export const dummyCodefetch = {
  root: {
    name: '.',
    path: '',
    type: 'directory',
    children: [
      {
        name: 'fp',
        path: 'fp',
        type: 'directory',
        children: [
          {
            name: '_baseConvert.js',
            path: 'fp/_baseConvert.js',
            type: 'file',
            content:
              "var mapping = require('./_mapping'),\n    fallbackHolder = require('./placeholder');\n\n/** Built-in value reference. */\nvar push = Array.prototype.push;\n\n/**\n * Creates a function, with an arity of `n`, that invokes `func` with the\n * arguments it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} n The arity of the new function.\n * @returns {Function} Returns the new function.\n */\nfunction baseArity(func, n) {\n  return n == 2\n    ? function(a, b) { return func.apply(undefined, arguments); }\n    : function(a) { return func.apply(undefined, arguments); };\n}\n\n/**\n * Creates a function that invokes `func`, with up to `n` arguments, ignoring\n * any additional arguments.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @param {number} n The arity cap.\n * @returns {Function} Returns the new function.\n */\nfunction baseAry(func, n) {\n  return n == 2\n    ? function(a, b) { return func(a, b); }\n    : function(a) { return func(a); };\n}\n\n/**\n * Creates a clone of `array`.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the cloned array.\n */\nfunction cloneArray(array) {\n  var length = array ? array.length : 0,\n      result = Array(length);\n\n  while (length--) {\n    result[length] = array[length];\n  }\n  return result;\n}\n\n/**\n * Creates a function that clones a given object using the assignment `func`.\n *\n * @private\n * @param {Function} func The assignment function.\n * @returns {Function} Returns the new cloner function.\n */\nfunction createCloner(func) {\n  return function(object) {\n    return func({}, object);\n  };\n}\n\n/**\n * A specialized version of `_.spread` which flattens the spread array into\n * the arguments of the invoked `func`.\n *\n * @private\n * @param {Function} func The function to spread arguments over.\n * @param {number} start The start position of the spread.\n * @returns {Function} Returns the new function.\n */\nfunction flatSpread(func, start) {\n  return function() {\n    var length = arguments.length,\n        lastIndex = length - 1,\n        args = Array(length);\n\n    while (length--) {\n      args[length] = arguments[length];\n    }\n    var array = args[start],\n        otherArgs = args.slice(0, start);\n\n    if (array) {\n      push.apply(otherArgs, array);\n    }\n    if (start != lastIndex) {\n      push.apply(otherArgs, args.slice(start + 1));\n    }\n    return func.apply(this, otherArgs);\n  };\n}\n\n/**\n * Creates a function that wraps `func` and uses `cloner` to clone the first\n * argument it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} cloner The function to clone arguments.\n * @returns {Function} Returns the new immutable function.\n */\nfunction wrapImmutable(func, cloner) {\n  return function() {\n    var length = arguments.length;\n    if (!length) {\n      return;\n    }\n    var args = Array(length);\n    while (length--) {\n      args[length] = arguments[length];\n    }\n    var result = args[0] = cloner.apply(undefined, args);\n    func.apply(undefined, args);\n    return result;\n  };\n}\n\n/**\n * The base implementation of `convert` which accepts a `util` object of methods\n * required to perform conversions.\n *\n * @param {Object} util The util object.\n * @param {string} name The name of the function to convert.\n * @param {Function} func The function to convert.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.cap=true] Specify capping iteratee arguments.\n * @param {boolean} [options.curry=true] Specify currying.\n * @param {boolean} [options.fixed=true] Specify fixed arity.\n * @param {boolean} [options.immutable=true] Specify immutable operations.\n * @param {boolean} [options.rearg=true] Specify rearranging arguments.\n * @returns {Function|Object} Returns the converted function or object.\n */\nfunction baseConvert(util, name, func, options) {\n  var isLib = typeof name == 'function',\n      isObj = name === Object(name);\n\n  if (isObj) {\n    options = func;\n    func = name;\n    name = undefined;\n  }\n  if (func == null) {\n    throw new TypeError;\n  }\n  options || (options = {});\n\n  var config = {\n    'cap': 'cap' in options ? options.cap : true,\n    'curry': 'curry' in options ? options.curry : true,\n    'fixed': 'fixed' in options ? options.fixed : true,\n    'immutable': 'immutable' in options ? options.immutable : true,\n    'rearg': 'rearg' in options ? options.rearg : true\n  };\n\n  var defaultHolder = isLib ? func : fallbackHolder,\n      forceCurry = ('curry' in options) && options.curry,\n      forceFixed = ('fixed' in options) && options.fixed,\n      forceRearg = ('rearg' in options) && options.rearg,\n      pristine = isLib ? func.runInContext() : undefined;\n\n  var helpers = isLib ? func : {\n    'ary': util.ary,\n    'assign': util.assign,\n    'clone': util.clone,\n    'curry': util.curry,\n    'forEach': util.forEach,\n    'isArray': util.isArray,\n    'isError': util.isError,\n    'isFunction': util.isFunction,\n    'isWeakMap': util.isWeakMap,\n    'iteratee': util.iteratee,\n    'keys': util.keys,\n    'rearg': util.rearg,\n    'toInteger': util.toInteger,\n    'toPath': util.toPath\n  };\n\n  var ary = helpers.ary,\n      assign = helpers.assign,\n      clone = helpers.clone,\n      curry = helpers.curry,\n      each = helpers.forEach,\n      isArray = helpers.isArray,\n      isError = helpers.isError,\n      isFunction = helpers.isFunction,\n      isWeakMap = helpers.isWeakMap,\n      keys = helpers.keys,\n      rearg = helpers.rearg,\n      toInteger = helpers.toInteger,\n      toPath = helpers.toPath;\n\n  var aryMethodKeys = keys(mapping.aryMethod);\n\n  var wrappers = {\n    'castArray': function(castArray) {\n      return function() {\n        var value = arguments[0];\n        return isArray(value)\n          ? castArray(cloneArray(value))\n          : castArray.apply(undefined, arguments);\n      };\n    },\n    'iteratee': function(iteratee) {\n      return function() {\n        var func = arguments[0],\n            arity = arguments[1],\n            result = iteratee(func, arity),\n            length = result.length;\n\n        if (config.cap && typeof arity == 'number') {\n          arity = arity > 2 ? (arity - 2) : 1;\n          return (length && length <= arity) ? result : baseAry(result, arity);\n        }\n        return result;\n      };\n    },\n    'mixin': function(mixin) {\n      return function(source) {\n        var func = this;\n        if (!isFunction(func)) {\n          return mixin(func, Object(source));\n        }\n        var pairs = [];\n        each(keys(source), function(key) {\n          if (isFunction(source[key])) {\n            pairs.push([key, func.prototype[key]]);\n          }\n        });\n\n        mixin(func, Object(source));\n\n        each(pairs, function(pair) {\n          var value = pair[1];\n          if (isFunction(value)) {\n            func.prototype[pair[0]] = value;\n          } else {\n            delete func.prototype[pair[0]];\n          }\n        });\n        return func;\n      };\n    },\n    'nthArg': function(nthArg) {\n      return function(n) {\n        var arity = n < 0 ? 1 : (toInteger(n) + 1);\n        return curry(nthArg(n), arity);\n      };\n    },\n    'rearg': function(rearg) {\n      return function(func, indexes) {\n        var arity = indexes ? indexes.length : 0;\n        return curry(rearg(func, indexes), arity);\n      };\n    },\n    'runInContext': function(runInContext) {\n      return function(context) {\n        return baseConvert(util, runInContext(context), options);\n      };\n    }\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Casts `func` to a function with an arity capped iteratee if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @returns {Function} Returns the cast function.\n   */\n  function castCap(name, func) {\n    if (config.cap) {\n      var indexes = mapping.iterateeRearg[name];\n      if (indexes) {\n        return iterateeRearg(func, indexes);\n      }\n      var n = !isLib && mapping.iterateeAry[name];\n      if (n) {\n        return iterateeAry(func, n);\n      }\n    }\n    return func;\n  }\n\n  /**\n   * Casts `func` to a curried function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity of `func`.\n   * @returns {Function} Returns the cast function.\n   */\n  function castCurry(name, func, n) {\n    return (forceCurry || (config.curry && n > 1))\n      ? curry(func, n)\n      : func;\n  }\n\n  /**\n   * Casts `func` to a fixed arity function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity cap.\n   * @returns {Function} Returns the cast function.\n   */\n  function castFixed(name, func, n) {\n    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {\n      var data = mapping.methodSpread[name],\n          start = data && data.start;\n\n      return start  === undefined ? ary(func, n) : flatSpread(func, start);\n    }\n    return func;\n  }\n\n  /**\n   * Casts `func` to an rearged function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity of `func`.\n   * @returns {Function} Returns the cast function.\n   */\n  function castRearg(name, func, n) {\n    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))\n      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])\n      : func;\n  }\n\n  /**\n   * Creates a clone of `object` by `path`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {Array|string} path The path to clone by.\n   * @returns {Object} Returns the cloned object.\n   */\n  function cloneByPath(object, path) {\n    path = toPath(path);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        result = clone(Object(object)),\n        nested = result;\n\n    while (nested != null && ++index < length) {\n      var key = path[index],\n          value = nested[key];\n\n      if (value != null &&\n          !(isFunction(value) || isError(value) || isWeakMap(value))) {\n        nested[key] = clone(index == lastIndex ? value : Object(value));\n      }\n      nested = nested[key];\n    }\n    return result;\n  }\n\n  /**\n   * Converts `lodash` to an immutable auto-curried iteratee-first data-last\n   * version with conversion `options` applied.\n   *\n   * @param {Object} [options] The options object. See `baseConvert` for more details.\n   * @returns {Function} Returns the converted `lodash`.\n   */\n  function convertLib(options) {\n    return _.runInContext.convert(options)(undefined);\n  }\n\n  /**\n   * Create a converter function for `func` of `name`.\n   *\n   * @param {string} name The name of the function to convert.\n   * @param {Function} func The function to convert.\n   * @returns {Function} Returns the new converter function.\n   */\n  function createConverter(name, func) {\n    var realName = mapping.aliasToReal[name] || name,\n        methodName = mapping.remap[realName] || realName,\n        oldOptions = options;\n\n    return function(options) {\n      var newUtil = isLib ? pristine : helpers,\n          newFunc = isLib ? pristine[methodName] : func,\n          newOptions = assign(assign({}, oldOptions), options);\n\n      return baseConvert(newUtil, realName, newFunc, newOptions);\n    };\n  }\n\n  /**\n   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`\n   * arguments, ignoring any additional arguments.\n   *\n   * @private\n   * @param {Function} func The function to cap iteratee arguments for.\n   * @param {number} n The arity cap.\n   * @returns {Function} Returns the new function.\n   */\n  function iterateeAry(func, n) {\n    return overArg(func, function(func) {\n      return typeof func == 'function' ? baseAry(func, n) : func;\n    });\n  }\n\n  /**\n   * Creates a function that wraps `func` to invoke its iteratee with arguments\n   * arranged according to the specified `indexes` where the argument value at\n   * the first index is provided as the first argument, the argument value at\n   * the second index is provided as the second argument, and so on.\n   *\n   * @private\n   * @param {Function} func The function to rearrange iteratee arguments for.\n   * @param {number[]} indexes The arranged argument indexes.\n   * @returns {Function} Returns the new function.\n   */\n  function iterateeRearg(func, indexes) {\n    return overArg(func, function(func) {\n      var n = indexes.length;\n      return baseArity(rearg(baseAry(func, n), indexes), n);\n    });\n  }\n\n  /**\n   * Creates a function that invokes `func` with its first argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function() {\n      var length = arguments.length;\n      if (!length) {\n        return func();\n      }\n      var args = Array(length);\n      while (length--) {\n        args[length] = arguments[length];\n      }\n      var index = config.rearg ? 0 : (length - 1);\n      args[index] = transform(args[index]);\n      return func.apply(undefined, args);\n    };\n  }\n\n  /**\n   * Creates a function that wraps `func` and applys the conversions\n   * rules by `name`.\n   *\n   * @private\n   * @param {string} name The name of the function to wrap.\n   * @param {Function} func The function to wrap.\n   * @returns {Function} Returns the converted function.\n   */\n  function wrap(name, func, placeholder) {\n    var result,\n        realName = mapping.aliasToReal[name] || name,\n        wrapped = func,\n        wrapper = wrappers[realName];\n\n    if (wrapper) {\n      wrapped = wrapper(func);\n    }\n    else if (config.immutable) {\n      if (mapping.mutate.array[realName]) {\n        wrapped = wrapImmutable(func, cloneArray);\n      }\n      else if (mapping.mutate.object[realName]) {\n        wrapped = wrapImmutable(func, createCloner(func));\n      }\n      else if (mapping.mutate.set[realName]) {\n        wrapped = wrapImmutable(func, cloneByPath);\n      }\n    }\n    each(aryMethodKeys, function(aryKey) {\n      each(mapping.aryMethod[aryKey], function(otherName) {\n        if (realName == otherName) {\n          var data = mapping.methodSpread[realName],\n              afterRearg = data && data.afterRearg;\n\n          result = afterRearg\n            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)\n            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);\n\n          result = castCap(realName, result);\n          result = castCurry(realName, result, aryKey);\n          return false;\n        }\n      });\n      return !result;\n    });\n\n    result || (result = wrapped);\n    if (result == func) {\n      result = forceCurry ? curry(result, 1) : function() {\n        return func.apply(this, arguments);\n      };\n    }\n    result.convert = createConverter(realName, func);\n    result.placeholder = func.placeholder = placeholder;\n\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  if (!isObj) {\n    return wrap(name, func, defaultHolder);\n  }\n  var _ = func;\n\n  // Convert methods by ary cap.\n  var pairs = [];\n  each(aryMethodKeys, function(aryKey) {\n    each(mapping.aryMethod[aryKey], function(key) {\n      var func = _[mapping.remap[key] || key];\n      if (func) {\n        pairs.push([key, wrap(key, func, _)]);\n      }\n    });\n  });\n\n  // Convert remaining methods.\n  each(keys(_), function(key) {\n    var func = _[key];\n    if (typeof func == 'function') {\n      var length = pairs.length;\n      while (length--) {\n        if (pairs[length][0] == key) {\n          return;\n        }\n      }\n      func.convert = createConverter(key, func);\n      pairs.push([key, func]);\n    }\n  });\n\n  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.\n  each(pairs, function(pair) {\n    _[pair[0]] = pair[1];\n  });\n\n  _.convert = convertLib;\n  _.placeholder = _;\n\n  // Assign aliases.\n  each(keys(_), function(key) {\n    each(mapping.realToAlias[key] || [], function(alias) {\n      _[alias] = _[key];\n    });\n  });\n\n  return _;\n}\n\nmodule.exports = baseConvert;\n",
            language: 'javascript',
            size: 16414,
            tokens: 1941,
            lastModified: '2025-07-02T12:28:22.829Z',
          },
          {
            name: '_convertBrowser.js',
            path: 'fp/_convertBrowser.js',
            type: 'file',
            content:
              "var baseConvert = require('./_baseConvert');\n\n/**\n * Converts `lodash` to an immutable auto-curried iteratee-first data-last\n * version with conversion `options` applied.\n *\n * @param {Function} lodash The lodash function to convert.\n * @param {Object} [options] The options object. See `baseConvert` for more details.\n * @returns {Function} Returns the converted `lodash`.\n */\nfunction browserConvert(lodash, options) {\n  return baseConvert(lodash, lodash, options);\n}\n\nif (typeof _ == 'function' && typeof _.runInContext == 'function') {\n  _ = browserConvert(_.runInContext());\n}\nmodule.exports = browserConvert;\n",
            language: 'javascript',
            size: 615,
            tokens: 70,
            lastModified: '2025-07-02T12:28:22.830Z',
          },
          {
            name: '_mapping.js',
            path: 'fp/_mapping.js',
            type: 'file',
            content:
              "/** Used to map aliases to their real names. */\nexports.aliasToReal = {\n\n  // Lodash aliases.\n  'each': 'forEach',\n  'eachRight': 'forEachRight',\n  'entries': 'toPairs',\n  'entriesIn': 'toPairsIn',\n  'extend': 'assignIn',\n  'extendAll': 'assignInAll',\n  'extendAllWith': 'assignInAllWith',\n  'extendWith': 'assignInWith',\n  'first': 'head',\n\n  // Methods that are curried variants of others.\n  'conforms': 'conformsTo',\n  'matches': 'isMatch',\n  'property': 'get',\n\n  // Ramda aliases.\n  '__': 'placeholder',\n  'F': 'stubFalse',\n  'T': 'stubTrue',\n  'all': 'every',\n  'allPass': 'overEvery',\n  'always': 'constant',\n  'any': 'some',\n  'anyPass': 'overSome',\n  'apply': 'spread',\n  'assoc': 'set',\n  'assocPath': 'set',\n  'complement': 'negate',\n  'compose': 'flowRight',\n  'contains': 'includes',\n  'dissoc': 'unset',\n  'dissocPath': 'unset',\n  'dropLast': 'dropRight',\n  'dropLastWhile': 'dropRightWhile',\n  'equals': 'isEqual',\n  'identical': 'eq',\n  'indexBy': 'keyBy',\n  'init': 'initial',\n  'invertObj': 'invert',\n  'juxt': 'over',\n  'omitAll': 'omit',\n  'nAry': 'ary',\n  'path': 'get',\n  'pathEq': 'matchesProperty',\n  'pathOr': 'getOr',\n  'paths': 'at',\n  'pickAll': 'pick',\n  'pipe': 'flow',\n  'pluck': 'map',\n  'prop': 'get',\n  'propEq': 'matchesProperty',\n  'propOr': 'getOr',\n  'props': 'at',\n  'symmetricDifference': 'xor',\n  'symmetricDifferenceBy': 'xorBy',\n  'symmetricDifferenceWith': 'xorWith',\n  'takeLast': 'takeRight',\n  'takeLastWhile': 'takeRightWhile',\n  'unapply': 'rest',\n  'unnest': 'flatten',\n  'useWith': 'overArgs',\n  'where': 'conformsTo',\n  'whereEq': 'isMatch',\n  'zipObj': 'zipObject'\n};\n\n/** Used to map ary to method names. */\nexports.aryMethod = {\n  '1': [\n    'assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create',\n    'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow',\n    'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll',\n    'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome','rest', 'reverse',\n    'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart',\n    'uniqueId', 'words', 'zipAll'\n  ],\n  '2': [\n    'add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith',\n    'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith',\n    'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN',\n    'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference',\n    'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq',\n    'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex',\n    'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach',\n    'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get',\n    'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection',\n    'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy',\n    'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty',\n    'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit',\n    'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial',\n    'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll',\n    'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove',\n    'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex',\n    'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy',\n    'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight',\n    'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars',\n    'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith',\n    'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject',\n    'zipObjectDeep'\n  ],\n  '3': [\n    'assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith',\n    'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr',\n    'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith',\n    'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth',\n    'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd',\n    'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight',\n    'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy',\n    'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy',\n    'xorWith', 'zipWith'\n  ],\n  '4': [\n    'fill', 'setWith', 'updateWith'\n  ]\n};\n\n/** Used to map ary to rearg configs. */\nexports.aryRearg = {\n  '2': [1, 0],\n  '3': [2, 0, 1],\n  '4': [3, 2, 0, 1]\n};\n\n/** Used to map method names to their iteratee ary. */\nexports.iterateeAry = {\n  'dropRightWhile': 1,\n  'dropWhile': 1,\n  'every': 1,\n  'filter': 1,\n  'find': 1,\n  'findFrom': 1,\n  'findIndex': 1,\n  'findIndexFrom': 1,\n  'findKey': 1,\n  'findLast': 1,\n  'findLastFrom': 1,\n  'findLastIndex': 1,\n  'findLastIndexFrom': 1,\n  'findLastKey': 1,\n  'flatMap': 1,\n  'flatMapDeep': 1,\n  'flatMapDepth': 1,\n  'forEach': 1,\n  'forEachRight': 1,\n  'forIn': 1,\n  'forInRight': 1,\n  'forOwn': 1,\n  'forOwnRight': 1,\n  'map': 1,\n  'mapKeys': 1,\n  'mapValues': 1,\n  'partition': 1,\n  'reduce': 2,\n  'reduceRight': 2,\n  'reject': 1,\n  'remove': 1,\n  'some': 1,\n  'takeRightWhile': 1,\n  'takeWhile': 1,\n  'times': 1,\n  'transform': 2\n};\n\n/** Used to map method names to iteratee rearg configs. */\nexports.iterateeRearg = {\n  'mapKeys': [1],\n  'reduceRight': [1, 0]\n};\n\n/** Used to map method names to rearg configs. */\nexports.methodRearg = {\n  'assignInAllWith': [1, 0],\n  'assignInWith': [1, 2, 0],\n  'assignAllWith': [1, 0],\n  'assignWith': [1, 2, 0],\n  'differenceBy': [1, 2, 0],\n  'differenceWith': [1, 2, 0],\n  'getOr': [2, 1, 0],\n  'intersectionBy': [1, 2, 0],\n  'intersectionWith': [1, 2, 0],\n  'isEqualWith': [1, 2, 0],\n  'isMatchWith': [2, 1, 0],\n  'mergeAllWith': [1, 0],\n  'mergeWith': [1, 2, 0],\n  'padChars': [2, 1, 0],\n  'padCharsEnd': [2, 1, 0],\n  'padCharsStart': [2, 1, 0],\n  'pullAllBy': [2, 1, 0],\n  'pullAllWith': [2, 1, 0],\n  'rangeStep': [1, 2, 0],\n  'rangeStepRight': [1, 2, 0],\n  'setWith': [3, 1, 2, 0],\n  'sortedIndexBy': [2, 1, 0],\n  'sortedLastIndexBy': [2, 1, 0],\n  'unionBy': [1, 2, 0],\n  'unionWith': [1, 2, 0],\n  'updateWith': [3, 1, 2, 0],\n  'xorBy': [1, 2, 0],\n  'xorWith': [1, 2, 0],\n  'zipWith': [1, 2, 0]\n};\n\n/** Used to map method names to spread configs. */\nexports.methodSpread = {\n  'assignAll': { 'start': 0 },\n  'assignAllWith': { 'start': 0 },\n  'assignInAll': { 'start': 0 },\n  'assignInAllWith': { 'start': 0 },\n  'defaultsAll': { 'start': 0 },\n  'defaultsDeepAll': { 'start': 0 },\n  'invokeArgs': { 'start': 2 },\n  'invokeArgsMap': { 'start': 2 },\n  'mergeAll': { 'start': 0 },\n  'mergeAllWith': { 'start': 0 },\n  'partial': { 'start': 1 },\n  'partialRight': { 'start': 1 },\n  'without': { 'start': 1 },\n  'zipAll': { 'start': 0 }\n};\n\n/** Used to identify methods which mutate arrays or objects. */\nexports.mutate = {\n  'array': {\n    'fill': true,\n    'pull': true,\n    'pullAll': true,\n    'pullAllBy': true,\n    'pullAllWith': true,\n    'pullAt': true,\n    'remove': true,\n    'reverse': true\n  },\n  'object': {\n    'assign': true,\n    'assignAll': true,\n    'assignAllWith': true,\n    'assignIn': true,\n    'assignInAll': true,\n    'assignInAllWith': true,\n    'assignInWith': true,\n    'assignWith': true,\n    'defaults': true,\n    'defaultsAll': true,\n    'defaultsDeep': true,\n    'defaultsDeepAll': true,\n    'merge': true,\n    'mergeAll': true,\n    'mergeAllWith': true,\n    'mergeWith': true,\n  },\n  'set': {\n    'set': true,\n    'setWith': true,\n    'unset': true,\n    'update': true,\n    'updateWith': true\n  }\n};\n\n/** Used to map real names to their aliases. */\nexports.realToAlias = (function() {\n  var hasOwnProperty = Object.prototype.hasOwnProperty,\n      object = exports.aliasToReal,\n      result = {};\n\n  for (var key in object) {\n    var value = object[key];\n    if (hasOwnProperty.call(result, value)) {\n      result[value].push(key);\n    } else {\n      result[value] = [key];\n    }\n  }\n  return result;\n}());\n\n/** Used to map method names to other names. */\nexports.remap = {\n  'assignAll': 'assign',\n  'assignAllWith': 'assignWith',\n  'assignInAll': 'assignIn',\n  'assignInAllWith': 'assignInWith',\n  'curryN': 'curry',\n  'curryRightN': 'curryRight',\n  'defaultsAll': 'defaults',\n  'defaultsDeepAll': 'defaultsDeep',\n  'findFrom': 'find',\n  'findIndexFrom': 'findIndex',\n  'findLastFrom': 'findLast',\n  'findLastIndexFrom': 'findLastIndex',\n  'getOr': 'get',\n  'includesFrom': 'includes',\n  'indexOfFrom': 'indexOf',\n  'invokeArgs': 'invoke',\n  'invokeArgsMap': 'invokeMap',\n  'lastIndexOfFrom': 'lastIndexOf',\n  'mergeAll': 'merge',\n  'mergeAllWith': 'mergeWith',\n  'padChars': 'pad',\n  'padCharsEnd': 'padEnd',\n  'padCharsStart': 'padStart',\n  'propertyOf': 'get',\n  'rangeStep': 'range',\n  'rangeStepRight': 'rangeRight',\n  'restFrom': 'rest',\n  'spreadFrom': 'spread',\n  'trimChars': 'trim',\n  'trimCharsEnd': 'trimEnd',\n  'trimCharsStart': 'trimStart',\n  'zipAll': 'zip'\n};\n\n/** Used to track methods that skip fixing their arity. */\nexports.skipFixed = {\n  'castArray': true,\n  'flow': true,\n  'flowRight': true,\n  'iteratee': true,\n  'mixin': true,\n  'rearg': true,\n  'runInContext': true\n};\n\n/** Used to track methods that skip rearranging arguments. */\nexports.skipRearg = {\n  'add': true,\n  'assign': true,\n  'assignIn': true,\n  'bind': true,\n  'bindKey': true,\n  'concat': true,\n  'difference': true,\n  'divide': true,\n  'eq': true,\n  'gt': true,\n  'gte': true,\n  'isEqual': true,\n  'lt': true,\n  'lte': true,\n  'matchesProperty': true,\n  'merge': true,\n  'multiply': true,\n  'overArgs': true,\n  'partial': true,\n  'partialRight': true,\n  'propertyOf': true,\n  'random': true,\n  'range': true,\n  'rangeRight': true,\n  'subtract': true,\n  'zip': true,\n  'zipObject': true,\n  'zipObjectDeep': true\n};\n",
            language: 'javascript',
            size: 9955,
            tokens: 973,
            lastModified: '2025-07-02T12:28:22.830Z',
          },
          {
            name: 'placeholder.js',
            path: 'fp/placeholder.js',
            type: 'file',
            content:
              '/**\n * The default argument placeholder value for methods.\n *\n * @type {Object}\n */\nmodule.exports = {};\n',
            language: 'javascript',
            size: 105,
            tokens: 12,
            lastModified: '2025-07-02T12:28:22.831Z',
          },
        ],
      },
      {
        name: 'lib',
        path: 'lib',
        type: 'directory',
        children: [
          {
            name: 'common',
            path: 'lib/common',
            type: 'directory',
            children: [
              {
                name: 'file.js',
                path: 'lib/common/file.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst fs = require('fs-extra');\nconst glob = require('glob');\nconst path = require('path');\n\nconst minify = require('../common/minify.js');\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates a [fs.copy](https://github.com/jprichardson/node-fs-extra#copy)\n * function with `srcPath` and `destPath` partially applied.\n *\n * @memberOf file\n * @param {string} srcPath The path of the file to copy.\n * @param {string} destPath The path to copy the file to.\n * @returns {Function} Returns the partially applied function.\n */\nfunction copy(srcPath, destPath) {\n  return _.partial(fs.copy, srcPath, destPath);\n}\n\n/**\n * Creates an object of base name and compiled template pairs that match `pattern`.\n *\n * @memberOf file\n * @param {string} pattern The glob pattern to be match.\n * @returns {Object} Returns the object of compiled templates.\n */\nfunction globTemplate(pattern) {\n  return _.transform(glob.sync(pattern), (result, filePath) => {\n    const key = path.basename(filePath, path.extname(filePath));\n    result[key] = _.template(fs.readFileSync(filePath, 'utf8'));\n  }, {});\n}\n\n/**\n * Creates a `minify` function with `srcPath` and `destPath` partially applied.\n *\n * @memberOf file\n * @param {string} srcPath The path of the file to minify.\n * @param {string} destPath The path to write the file to.\n * @returns {Function} Returns the partially applied function.\n */\nfunction min(srcPath, destPath) {\n  return _.partial(minify, srcPath, destPath);\n}\n\n/**\n * Creates a [fs.writeFile](https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback)\n * function with `filePath` and `data` partially applied.\n *\n * @memberOf file\n * @param {string} destPath The path to write the file to.\n * @param {string} data The data to write to the file.\n * @returns {Function} Returns the partially applied function.\n */\nfunction write(destPath, data) {\n  return _.partial(fs.writeFile, destPath, data);\n}\n\n/*----------------------------------------------------------------------------*/\n\nmodule.exports = {\n  copy,\n  globTemplate,\n  min,\n  write\n};\n",
                language: 'javascript',
                size: 2140,
                tokens: 265,
                lastModified: '2025-07-02T12:28:22.832Z',
              },
              {
                name: 'mapping.js',
                path: 'lib/common/mapping.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _mapping = require('../../fp/_mapping');\nconst util = require('./util');\nconst Hash = util.Hash;\n\n/*----------------------------------------------------------------------------*/\n\nmodule.exports = new Hash(_mapping);\n",
                language: 'javascript',
                size: 238,
                tokens: 24,
                lastModified: '2025-07-02T12:28:22.832Z',
              },
              {
                name: 'minify.js',
                path: 'lib/common/minify.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst fs = require('fs-extra');\nconst uglify = require('uglify-js');\n\nconst uglifyOptions = require('./uglify.options');\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Asynchronously minifies the file at `srcPath`, writes it to `destPath`, and\n * invokes `callback` upon completion. The callback is invoked with one argument:\n * (error).\n *\n * If unspecified, `destPath` is `srcPath` with an extension of `.min.js`.\n * (e.g. the `destPath` of `path/to/foo.js` would be `path/to/foo.min.js`)\n *\n * @param {string} srcPath The path of the file to minify.\n * @param {string} [destPath] The path to write the file to.\n * @param {Function} callback The function invoked upon completion.\n * @param {Object} [option] The UglifyJS options object.\n */\nfunction minify(srcPath, destPath, callback, options) {\n  if (_.isFunction(destPath)) {\n    if (_.isObject(callback)) {\n      options = callback;\n    }\n    callback = destPath;\n    destPath = undefined;\n  }\n  if (!destPath) {\n    destPath = srcPath.replace(/(?=\\.js$)/, '.min');\n  }\n  const output = uglify.minify(srcPath, _.defaults(options || {}, uglifyOptions));\n  fs.writeFile(destPath, output.code, 'utf-8', callback);\n}\n\nmodule.exports = minify;\n",
                language: 'javascript',
                size: 1282,
                tokens: 162,
                lastModified: '2025-07-02T12:28:22.832Z',
              },
              {
                name: 'uglify.options.js',
                path: 'lib/common/uglify.options.js',
                type: 'file',
                content:
                  "'use strict';\n\n/**\n * The UglifyJS options object for\n * [compress](https://github.com/mishoo/UglifyJS2#compressor-options),\n * [mangle](https://github.com/mishoo/UglifyJS2#mangler-options), and\n * [output](https://github.com/mishoo/UglifyJS2#beautifier-options) options.\n */\nmodule.exports = {\n  'compress': {\n    'collapse_vars': true,\n    'negate_iife': false,\n    'pure_getters': true,\n    'unsafe': true,\n    'warnings': false\n  },\n  'output': {\n    'ascii_only': true,\n    'comments': /@license/,\n    'max_line_len': 500\n  }\n};\n",
                language: 'javascript',
                size: 534,
                tokens: 60,
                lastModified: '2025-07-02T12:28:22.833Z',
              },
              {
                name: 'util.js',
                path: 'lib/common/util.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates a hash object. If a `properties` object is provided, its own\n * enumerable properties are assigned to the created hash.\n *\n * @memberOf util\n * @param {Object} [properties] The properties to assign to the hash.\n * @returns {Object} Returns the new hash object.\n */\nfunction Hash(properties) {\n  return _.transform(properties, (result, value, key) => {\n    result[key] = (_.isPlainObject(value) && !(value instanceof Hash))\n      ? new Hash(value)\n      : value;\n  }, this);\n}\n\nHash.prototype = Object.create(null);\n\n/**\n * This method throws any error it receives.\n *\n * @memberOf util\n * @param {Object} [error] The error object.\n */\nfunction pitch(error) {\n  if (error != null) {\n    throw error;\n  }\n}\n\nmodule.exports = {\n  Hash,\n  pitch\n};\n",
                language: 'javascript',
                size: 886,
                tokens: 103,
                lastModified: '2025-07-02T12:28:22.833Z',
              },
            ],
          },
          {
            name: 'fp',
            path: 'lib/fp',
            type: 'directory',
            children: [
              {
                name: 'template',
                path: 'lib/fp/template',
                type: 'directory',
                children: [
                  {
                    name: 'doc',
                    path: 'lib/fp/template/doc',
                    type: 'directory',
                    children: [
                      {
                        name: 'wiki.jst',
                        path: 'lib/fp/template/doc/wiki.jst',
                        type: 'file',
                        content:
                          "## lodash/fp\n\nThe `lodash/fp` module promotes a more\n[functional programming](https://en.wikipedia.org/wiki/Functional_programming)\n(FP) friendly style by exporting an instance of `lodash` with its methods wrapped\nto produce immutable auto-curried iteratee-first data-last methods.\n\n## Installation\n\nIn a browser:\n```html\n<script src='https://cdn.jsdelivr.net/g/lodash@4(lodash.min.js+lodash.fp.min.js)'></script>\n<script>\n// Loading `lodash.fp.js` converts `_` to its fp variant.\n_.defaults({ 'a': 2, 'b': 2 })({ 'a': 1 });\n// ➜ { 'a': 1, 'b': 2 }\n\n// Use `noConflict` to restore the pre-fp variant.\nvar fp = _.noConflict();\n\n_.defaults({ 'a': 1 }, { 'a': 2, 'b': 2 });\n// ➜ { 'a': 1, 'b': 2 }\nfp.defaults({ 'a': 2, 'b': 2 })({ 'a': 1 });\n// ➜ { 'a': 1, 'b': 2 }\n</script>\n```\n\nIn Node.js:\n```js\n// Load the fp build.\nvar fp = require('lodash/fp');\n\n// Load a method category.\nvar object = require('lodash/fp/object');\n\n// Load a single method for smaller builds with browserify/rollup/webpack.\nvar extend = require('lodash/fp/extend');\n```\n\n## Mapping\n\nImmutable auto-curried iteratee-first data-last methods sound great, but what\ndoes that really mean for each method? Below is a breakdown of the mapping used\nto convert each method.\n\n#### Capped Iteratee Arguments\n\nIteratee arguments are capped to avoid gotchas with variadic iteratees.\n```js\n// The `lodash/map` iteratee receives three arguments:\n// (value, index|key, collection)\n_.map(['6', '8', '10'], parseInt);\n// ➜ [6, NaN, 2]\n\n// The `lodash/fp/map` iteratee is capped at one argument:\n// (value)\nfp.map(parseInt)(['6', '8', '10']);\n// ➜ [6, 8, 10]\n```\n\nMethods that cap iteratees to one argument:<br>\n<%= toFuncList(_.keys(_.pickBy(mapping.iterateeAry, _.partial(_.eq, _, 1)))) %>\n\nMethods that cap iteratees to two arguments:<br>\n<%= toFuncList(_.keys(_.pickBy(mapping.iterateeAry, _.partial(_.eq, _, 2)))) %>\n\nThe iteratee of `mapKeys` is capped to one argument: `(key)`\n\n#### Fixed Arity\n\nMethods have fixed arities to support auto-currying.\n```js\n// `lodash/padStart` accepts an optional `chars` param.\n_.padStart('a', 3, '-')\n// ➜ '--a'\n\n// `lodash/fp/padStart` does not.\nfp.padStart(3)('a');\n// ➜ '  a'\nfp.padCharsStart('-')(3)('a');\n// ➜ '--a'\n```\n\nMethods with a fixed arity of one:<br>\n<%= toFuncList(_.difference(mapping.aryMethod[1], _.keys(mapping.skipFixed))) %>\n\nMethods with a fixed arity of two:<br>\n<%= toFuncList(_.difference(mapping.aryMethod[2], _.keys(mapping.skipFixed))) %>\n\nMethods with a fixed arity of three:<br>\n<%= toFuncList(_.difference(mapping.aryMethod[3], _.keys(mapping.skipFixed))) %>\n\nMethods with a fixed arity of four:<br>\n<%= toFuncList(_.difference(mapping.aryMethod[4], _.keys(mapping.skipFixed))) %>\n\n#### Rearranged Arguments\n\nMethod arguments are rearranged to make composition easier.\n```js\n// `lodash/filter` is data-first iteratee-last:\n// (collection, iteratee)\nvar compact = _.partial(_.filter, _, Boolean);\ncompact(['a', null, 'c']);\n// ➜ ['a', 'c']\n\n// `lodash/fp/filter` is iteratee-first data-last:\n// (iteratee, collection)\nvar compact = fp.filter(Boolean);\ncompact(['a', null, 'c']);\n// ➜ ['a', 'c']\n```\n\n##### Most methods follow these rules\n\nA fixed arity of two has an argument order of:<br>\n<%= toArgOrder(mapping.aryRearg[2]) %>\n\nA fixed arity of three has an argument order of:<br>\n<%= toArgOrder(mapping.aryRearg[3]) %>\n\nA fixed arity of four has an argument order of:<br>\n<%= toArgOrder(mapping.aryRearg[4]) %>\n\n##### Exceptions to the rules\n\nMethods that accept an array as their last, second to last, or only argument:<br>\n<%= toFuncList(_.keys(mapping.methodSpread)) %>\n\nMethods with unchanged argument orders:<br>\n<%= toFuncList(_.keys(mapping.skipRearg)) %>\n\nMethods with custom argument orders:<br>\n<%= _.map(_.keys(mapping.methodRearg), methodName => {\n  const orders = mapping.methodRearg[methodName];\n  return ' * `_.' + methodName + '` has an order of ' + toArgOrder(orders);\n}).join('\\n') %>\n\nThe iteratee of `reduceRight` has an argument order of: `(b, a)`\n\n#### New Methods\n\nNot all variadic methods have corresponding new method variants. Feel free to\n[request](https://github.com/lodash/lodash/blob/master/.github/CONTRIBUTING.md#feature-requests)\nany additions.\n\nMethods created to accommodate Lodash’s variadic methods:<br>\n<%= toFuncList(_.keys(mapping.remap)) %>\n\n#### Aliases\n\nThere are <%= _.size(mapping.aliasToReal) %> method aliases:<br>\n<%= _.map(_.keys(mapping.aliasToReal).sort(), alias => {\n  const realName = mapping.aliasToReal[alias];\n  return ' * `_.' + alias + '` is an alias of `_.' + realName + '`';\n}).join('\\n') %>\n\n## Placeholders\n\nThe placeholder argument, which defaults to `_`, may be used to fill in method\narguments in a different order. Placeholders are filled by the first available\narguments of the curried returned function.\n```js\n// The equivalent of `2 > 5`.\n_.gt(2)(5);\n// ➜ false\n\n// The equivalent of `_.gt(5, 2)` or `5 > 2`.\n_.gt(_, 2)(5);\n// ➜ true\n```\n\n## Chaining\n\nThe `lodash/fp` module **does not** convert chain sequence methods. See\n[Izaak Schroeder’s article](https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba)\non using functional composition as an alternative to method chaining.\n\n## Convert\n\nAlthough `lodash/fp` & its method modules come pre-converted, there are times\nwhen you may want to customize the conversion. That’s when the `convert` method\ncomes in handy.\n```js\n// Every option is `true` by default.\nvar _fp = fp.convert({\n  // Specify capping iteratee arguments.\n  'cap': true,\n  // Specify currying.\n  'curry': true,\n  // Specify fixed arity.\n  'fixed': true,\n  // Specify immutable operations.\n  'immutable': true,\n  // Specify rearranging arguments.\n  'rearg': true\n});\n\n// The `convert` method is available on each method too.\nvar mapValuesWithKey = fp.mapValues.convert({ 'cap': false });\n\n// Here’s an example of disabling iteratee argument caps to access the `key` param.\nmapValuesWithKey(function(value, key) {\n  return key == 'a' ? -1 : value;\n})({ 'a': 1, 'b': 1 });\n// => { 'a': -1, 'b': 1 }\n```\n\nManual conversions are also possible with the `convert` module.\n```js\nvar convert = require('lodash/fp/convert');\n\n// Convert by name.\nvar assign = convert('assign', require('lodash.assign'));\n\n// Convert by object.\nvar fp = convert({\n  'assign': require('lodash.assign'),\n  'chunk': require('lodash.chunk')\n});\n\n// Convert by `lodash` instance.\nvar fp = convert(lodash.runInContext());\n```\n\n## Tooling\n\nUse [eslint-plugin-lodash-fp](https://www.npmjs.com/package/eslint-plugin-lodash-fp)\nto help use `lodash/fp` more efficiently.\n",
                        language: 'text',
                        size: 6600,
                        tokens: 1015,
                        lastModified: '2025-07-02T12:28:22.836Z',
                      },
                    ],
                  },
                  {
                    name: 'modules',
                    path: 'lib/fp/template/modules',
                    type: 'directory',
                    children: [
                      {
                        name: '_falseOptions.jst',
                        path: 'lib/fp/template/modules/_falseOptions.jst',
                        type: 'file',
                        content:
                          "module.exports = {\n  'cap': false,\n  'curry': false,\n  'fixed': false,\n  'immutable': false,\n  'rearg': false\n};\n",
                        language: 'text',
                        size: 113,
                        tokens: 13,
                        lastModified: '2025-07-02T12:28:22.836Z',
                      },
                      {
                        name: '_util.jst',
                        path: 'lib/fp/template/modules/_util.jst',
                        type: 'file',
                        content:
                          "module.exports = {\n  'ary': require('../ary'),\n  'assign': require('../_baseAssign'),\n  'clone': require('../clone'),\n  'curry': require('../curry'),\n  'forEach': require('../_arrayEach'),\n  'isArray': require('../isArray'),\n  'isError': require('../isError'),\n  'isFunction': require('../isFunction'),\n  'isWeakMap': require('../isWeakMap'),\n  'iteratee': require('../iteratee'),\n  'keys': require('../_baseKeys'),\n  'rearg': require('../rearg'),\n  'toInteger': require('../toInteger'),\n  'toPath': require('../toPath')\n};\n",
                        language: 'text',
                        size: 524,
                        tokens: 45,
                        lastModified: '2025-07-02T12:28:22.837Z',
                      },
                      {
                        name: 'alias.jst',
                        path: 'lib/fp/template/modules/alias.jst',
                        type: 'file',
                        content: "module.exports = require('./<%= name %>');\n",
                        language: 'text',
                        size: 43,
                        tokens: 8,
                        lastModified: '2025-07-02T12:28:22.837Z',
                      },
                      {
                        name: 'category.jst',
                        path: 'lib/fp/template/modules/category.jst',
                        type: 'file',
                        content:
                          "var convert = require('./convert');\nmodule.exports = convert(require('../<%= name %>'));\n",
                        language: 'text',
                        size: 89,
                        tokens: 14,
                        lastModified: '2025-07-02T12:28:22.837Z',
                      },
                      {
                        name: 'convert.jst',
                        path: 'lib/fp/template/modules/convert.jst',
                        type: 'file',
                        content:
                          "var baseConvert = require('./_baseConvert'),\n    util = require('./_util');\n\n/**\n * Converts `func` of `name` to an immutable auto-curried iteratee-first data-last\n * version with conversion `options` applied. If `name` is an object its methods\n * will be converted.\n *\n * @param {string} name The name of the function to wrap.\n * @param {Function} [func] The function to wrap.\n * @param {Object} [options] The options object. See `baseConvert` for more details.\n * @returns {Function|Object} Returns the converted function or object.\n */\nfunction convert(name, func, options) {\n  return baseConvert(util, name, func, options);\n}\n\nmodule.exports = convert;\n",
                        language: 'text',
                        size: 657,
                        tokens: 88,
                        lastModified: '2025-07-02T12:28:22.838Z',
                      },
                      {
                        name: 'fp.jst',
                        path: 'lib/fp/template/modules/fp.jst',
                        type: 'file',
                        content:
                          "var _ = require('./lodash.min').runInContext();\nmodule.exports = require('./fp/_baseConvert')(_, _);\n",
                        language: 'text',
                        size: 101,
                        tokens: 12,
                        lastModified: '2025-07-02T12:28:22.838Z',
                      },
                      {
                        name: 'module.jst',
                        path: 'lib/fp/template/modules/module.jst',
                        type: 'file',
                        content:
                          "var convert = require('./convert'),\n    func = convert('<%= name %>', require('../<%= _.get(mapping.remap, name, name) %>'));\n\nfunc.placeholder = require('./placeholder');\nmodule.exports = func;\n",
                        language: 'text',
                        size: 195,
                        tokens: 30,
                        lastModified: '2025-07-02T12:28:22.838Z',
                      },
                      {
                        name: 'thru.jst',
                        path: 'lib/fp/template/modules/thru.jst',
                        type: 'file',
                        content:
                          "var convert = require('./convert'),\n    func = convert('<%= name %>', require('../<%= _.get(mapping.remap, name, name) %>'), require('./_falseOptions'));\n\nfunc.placeholder = require('./placeholder');\nmodule.exports = func;\n",
                        language: 'text',
                        size: 223,
                        tokens: 32,
                        lastModified: '2025-07-02T12:28:22.838Z',
                      },
                    ],
                  },
                ],
              },
              {
                name: 'build-dist.js',
                path: 'lib/fp/build-dist.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst async = require('async');\nconst path = require('path');\nconst webpack = require('webpack');\n\nconst file = require('../common/file');\nconst util = require('../common/util');\n\nconst basePath = path.join(__dirname, '..', '..');\nconst distPath = path.join(basePath, 'dist');\nconst fpPath = path.join(basePath, 'fp');\nconst filename = 'lodash.fp.js';\n\nconst fpConfig = {\n  'entry': path.join(fpPath, '_convertBrowser.js'),\n  'output': {\n    'path': distPath,\n    'filename': filename,\n    'library': 'fp',\n    'libraryTarget': 'umd'\n  },\n  'plugins': [\n    new webpack.optimize.OccurenceOrderPlugin,\n    new webpack.optimize.DedupePlugin\n  ]\n};\n\nconst mappingConfig = {\n  'entry': path.join(fpPath, '_mapping.js'),\n  'output': {\n    'path': distPath,\n    'filename': 'mapping.fp.js',\n    'library': 'mapping',\n    'libraryTarget': 'umd'\n  }\n};\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates browser builds of the FP converter and mappings at the `target` path.\n *\n * @private\n * @param {string} target The output directory path.\n */\nfunction build() {\n  async.series([\n    _.partial(webpack, mappingConfig),\n    _.partial(webpack, fpConfig),\n    file.min(path.join(distPath, filename))\n  ], util.pitch);\n}\n\nbuild();\n",
                language: 'javascript',
                size: 1312,
                tokens: 146,
                lastModified: '2025-07-02T12:28:22.833Z',
              },
              {
                name: 'build-doc.js',
                path: 'lib/fp/build-doc.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst fs = require('fs-extra');\nconst path = require('path');\n\nconst file = require('../common/file');\nconst mapping = require('../common/mapping');\nconst util = require('../common/util');\n\nconst templatePath = path.join(__dirname, 'template/doc');\nconst template = file.globTemplate(path.join(templatePath, '*.jst'));\n\nconst argNames = ['a', 'b', 'c', 'd'];\n\nconst templateData = {\n  mapping,\n  toArgOrder,\n  toFuncList\n};\n\n/**\n * Converts arranged argument `indexes` into a named argument string\n * representation of their order.\n *\n * @private\n * @param {number[]} indexes The arranged argument indexes.\n * @returns {string} Returns the named argument string.\n */\nfunction toArgOrder(indexes) {\n  const reordered = [];\n  _.each(indexes, (newIndex, index) => {\n    reordered[newIndex] = argNames[index];\n  });\n  return '`(' + reordered.join(', ') + ')`';\n}\n\n/**\n * Converts `funcNames` into a chunked list string representation.\n *\n * @private\n * @param {string[]} funcNames The function names.\n * @returns {string} Returns the function list string.\n */\nfunction toFuncList(funcNames) {\n  let chunks = _.chunk(funcNames.slice().sort(), 5);\n  let lastChunk = _.last(chunks);\n  const lastName = lastChunk ? lastChunk.pop() : undefined;\n\n  chunks = _.reject(chunks, _.isEmpty);\n  lastChunk = _.last(chunks);\n\n  let result = '`' + _.map(chunks, chunk => chunk.join('`, `') + '`').join(',\\n`');\n  if (lastName == null) {\n    return result;\n  }\n  if (_.size(chunks) > 1 || _.size(lastChunk) > 1) {\n    result += ',';\n  }\n  result += ' &';\n  result += _.size(lastChunk) < 5 ? ' ' : '\\n';\n  return result + '`' + lastName + '`';\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates the FP-Guide wiki at the `target` path.\n *\n * @private\n * @param {string} target The output file path.\n */\nfunction build(target) {\n  target = path.resolve(target);\n  fs.writeFile(target, template.wiki(templateData), util.pitch);\n}\n\nbuild(_.last(process.argv));\n",
                language: 'javascript',
                size: 2029,
                tokens: 259,
                lastModified: '2025-07-02T12:28:22.834Z',
              },
              {
                name: 'build-modules.js',
                path: 'lib/fp/build-modules.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst async = require('async');\nconst glob = require('glob');\nconst path = require('path');\n\nconst file = require('../common/file');\nconst mapping = require('../common/mapping');\nconst util = require('../common/util');\n\nconst templatePath = path.join(__dirname, 'template/modules');\nconst template = file.globTemplate(path.join(templatePath, '*.jst'));\n\nconst aryMethods = _.union(\n  mapping.aryMethod[1],\n  mapping.aryMethod[2],\n  mapping.aryMethod[3],\n  mapping.aryMethod[4]\n);\n\nconst categories = [\n  'array',\n  'collection',\n  'date',\n  'function',\n  'lang',\n  'math',\n  'number',\n  'object',\n  'seq',\n  'string',\n  'util'\n];\n\nconst ignored = [\n  '_*.js',\n  'core.js',\n  'core.min.js',\n  'fp.js',\n  'index.js',\n  'lodash.js',\n  'lodash.min.js'\n];\n\n/**\n * Checks if `name` is a method alias.\n *\n * @private\n * @param {string} name The name to check.\n * @returns {boolean} Returns `true` if `name` is a method alias, else `false`.\n */\nfunction isAlias(name) {\n  return _.has(mapping.aliasToReal, name);\n}\n\n/**\n * Checks if `name` is a category name.\n *\n * @private\n * @param {string} name The name to check.\n * @returns {boolean} Returns `true` if `name` is a category name, else `false`.\n */\nfunction isCategory(name) {\n  return _.includes(categories, name);\n}\n\n/**\n * Checks if `name` belongs to a method that's passed thru and not wrapped.\n *\n * @private\n * @param {string} name The name to check.\n * @returns {boolean} Returns `true` if `name` is of a pass thru method,\n *  else `false`.\n */\nfunction isThru(name) {\n  return !_.includes(aryMethods, name);\n}\n\n/**\n * Gets metadata for `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {*} Returns the metadata for `func`.\n */\nfunction getTemplate(moduleName) {\n  const data = {\n    'name': _.get(mapping.aliasToReal, moduleName, moduleName),\n    'mapping': mapping\n  };\n\n  if (isAlias(moduleName)) {\n    return template.alias(data);\n  }\n  if (isCategory(moduleName)) {\n    return template.category(data);\n  }\n  if (isThru(moduleName)) {\n    return template.thru(data);\n  }\n  return template.module(data);\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates FP modules at the `target` path.\n *\n * @private\n * @param {string} target The output directory path.\n */\nfunction build(target) {\n  target = path.resolve(target);\n\n  const fpPath = path.join(target, 'fp');\n\n  // Glob existing lodash module paths.\n  const modulePaths = glob.sync(path.join(target, '*.js'), {\n    'nodir': true,\n    'ignore': ignored.map(filename => {\n      return path.join(target, filename);\n    })\n  });\n\n  // Add FP alias and remapped module paths.\n  _.each([mapping.aliasToReal, mapping.remap], data => {\n    _.forOwn(data, (realName, alias) => {\n      const modulePath = path.join(target, alias + '.js');\n      if (!_.includes(modulePaths, modulePath)) {\n        modulePaths.push(modulePath);\n      }\n    });\n  });\n\n  const actions = modulePaths.map(modulePath => {\n    const moduleName = path.basename(modulePath, '.js');\n    return file.write(path.join(fpPath, moduleName + '.js'), getTemplate(moduleName));\n  });\n\n  actions.unshift(file.copy(path.join(__dirname, '../../fp'), fpPath));\n  actions.push(file.write(path.join(fpPath, '_falseOptions.js'), template._falseOptions()));\n  actions.push(file.write(path.join(fpPath, '_util.js'), template._util()));\n  actions.push(file.write(path.join(target, 'fp.js'), template.fp()));\n  actions.push(file.write(path.join(fpPath, 'convert.js'), template.convert()));\n\n  async.series(actions, util.pitch);\n}\n\nbuild(_.last(process.argv));\n",
                language: 'javascript',
                size: 3640,
                tokens: 451,
                lastModified: '2025-07-02T12:28:22.835Z',
              },
            ],
          },
          {
            name: 'main',
            path: 'lib/main',
            type: 'directory',
            children: [
              {
                name: 'build-dist.js',
                path: 'lib/main/build-dist.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst async = require('async');\nconst path = require('path');\n\nconst file = require('../common/file');\nconst util = require('../common/util');\n\nconst basePath = path.join(__dirname, '..', '..');\nconst distPath = path.join(basePath, 'dist');\nconst filename = 'lodash.js';\n\nconst baseLodash = path.join(basePath, filename);\nconst distLodash = path.join(distPath, filename);\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates browser builds of Lodash at the `target` path.\n *\n * @private\n * @param {string} target The output directory path.\n */\nfunction build() {\n  async.series([\n    file.copy(baseLodash, distLodash),\n    file.min(distLodash)\n  ], util.pitch);\n}\n\nbuild();\n",
                language: 'javascript',
                size: 734,
                tokens: 87,
                lastModified: '2025-07-02T12:28:22.839Z',
              },
              {
                name: 'build-doc.js',
                path: 'lib/main/build-doc.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst docdown = require('docdown');\nconst fs = require('fs-extra');\nconst path = require('path');\n\nconst util = require('../common/util');\n\nconst basePath = path.join(__dirname, '..', '..');\nconst docPath = path.join(basePath, 'doc');\nconst readmePath = path.join(docPath, 'README.md');\n\nconst pkg = require('../../package.json');\nconst version = pkg.version;\n\nconst config = {\n  'base': {\n    'path': path.join(basePath, 'lodash.js'),\n    'title': `<a href=\"https://lodash.com/\">lodash</a> <span>v${ version }</span>`,\n    'toc': 'categories',\n    'url': `https://github.com/lodash/lodash/blob/${ version }/lodash.js`\n  },\n  'github': {\n    'style': 'github',\n    'sublinks': [npmLink('&#x24C3;', 'See the npm package')]\n  },\n  'site': {\n    'entryLink': '<a href=\"${entryHref}\" class=\"fa fa-link\"></a>',\n    'sourceLink': '[source](${sourceHref})',\n    'tocHref': '',\n    'tocLink': '',\n    'sublinks': [npmLink('npm package')]\n  }\n};\n\n/**\n * Composes a npm link from `text` and optional `title`.\n *\n * @private\n * @param {string} text The link text.\n * @param {string} [title] The link title.\n * @returns {string} Returns the composed npm link.\n */\nfunction npmLink(text, title) {\n  return (\n    '<% if (name == \"templateSettings\" || !/^(?:methods|properties|seq)$/i.test(category)) {' +\n      'print(' +\n        '\"[' + text + '](https://www.npmjs.com/package/lodash.\" + name.toLowerCase() + ' +\n        '\"' + (title == null ? '' : ' \\\\\"' + title + '\\\\\"') + ')\"' +\n      ');' +\n    '} %>'\n  );\n}\n\n/**\n * Post-process `markdown` to make adjustments.\n *\n * @private\n * @param {string} markdown The markdown to process.\n * @returns {string} Returns the processed markdown.\n */\nfunction postprocess(markdown) {\n  // Wrap symbol property identifiers in brackets.\n  return markdown.replace(/\\.(Symbol\\.(?:[a-z]+[A-Z]?)+)/g, '[$1]');\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates the documentation markdown formatted for 'github' or 'site'.\n *\n * @private\n * @param {string} type The format type.\n */\nfunction build(type) {\n  const options = _.defaults({}, config.base, config[type]);\n  const markdown = docdown(options);\n\n  fs.writeFile(readmePath, postprocess(markdown), util.pitch);\n}\n\nbuild(_.last(process.argv));\n",
                language: 'javascript',
                size: 2312,
                tokens: 285,
                lastModified: '2025-07-02T12:28:22.839Z',
              },
              {
                name: 'build-modules.js',
                path: 'lib/main/build-modules.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst async = require('async');\nconst path = require('path');\n\nconst file = require('../common/file');\nconst util = require('../common/util');\n\nconst basePath = path.join(__dirname, '..', '..');\nconst distPath = path.join(basePath, 'dist');\n\nconst filePairs = [\n  [path.join(distPath, 'lodash.core.js'), 'core.js'],\n  [path.join(distPath, 'lodash.core.min.js'), 'core.min.js'],\n  [path.join(distPath, 'lodash.min.js'), 'lodash.min.js']\n];\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates supplementary Lodash modules at the `target` path.\n *\n * @private\n * @param {string} target The output directory path.\n */\nfunction build(target) {\n  const actions = _.map(filePairs, pair =>\n    file.copy(pair[0], path.join(target, pair[1])));\n\n  async.series(actions, util.pitch);\n}\n\nbuild(_.last(process.argv));\n",
                language: 'javascript',
                size: 895,
                tokens: 115,
                lastModified: '2025-07-02T12:28:22.839Z',
              },
              {
                name: 'build-site.js',
                path: 'lib/main/build-site.js',
                type: 'file',
                content:
                  "'use strict';\n\nconst _ = require('lodash');\nconst cheerio = require('cheerio');\nconst fs = require('fs');\nconst marky = require('marky-markdown');\nconst path = require('path');\nconst util = require('../common/util');\n\nconst basePath = path.join(__dirname, '..', '..');\nconst docPath = path.join(basePath, 'doc');\nconst readmePath = path.join(docPath, 'README.md');\n\nconst highlights = {\n  'html': [\n    'string'\n  ],\n  'js': [\n    'comment',\n    'console',\n    'delimiter',\n    'method',\n    'modifier',\n    'name',\n    'numeric',\n    'string',\n    'support',\n    'type'\n  ]\n};\n\nconst exts = _.keys(highlights);\n\n/**\n * Converts Lodash method references into documentation links.\n *\n * @private\n * @param {Object} $ The Cheerio object.\n */\nfunction autoLink($) {\n  $('.doc-container code').each(function() {\n    const $code = $(this);\n    const html = $code.html();\n    if (/^_\\.\\w+$/.test(html)) {\n      const id = html.split('.')[1];\n      $code.replaceWith(`<a href=\"#${ id }\"><code>_.${ id }</code></a>`);\n    }\n  });\n}\n\n/**\n * Removes horizontal rules from the document.\n *\n * @private\n * @param {Object} $ The Cheerio object.\n */\nfunction removeHorizontalRules($) {\n  $('hr').remove();\n}\n\n/**\n * Removes marky-markdown specific ids and class names.\n *\n * @private\n * @param {Object} $ The Cheerio object.\n */\nfunction removeMarkyAttributes($) {\n  $('[id^=\"user-content-\"]')\n    .attr('class', null)\n    .attr('id', null);\n\n  $(':header:not(h3) > a').each(function() {\n    const $a = $(this);\n    $a.replaceWith($a.html());\n  });\n}\n\n/**\n * Renames \"_\" id and anchor references to \"lodash\".\n *\n * @private\n * @param {Object} $ The Cheerio object.\n */\nfunction renameLodashId($) {\n  $('#_').attr('id', 'lodash');\n  $('[href=\"#_\"]').attr('href', '#lodash');\n}\n\n/**\n * Repairs broken marky-markdown headers.\n * See https://github.com/npm/marky-markdown/issues/217 for more details.\n *\n * @private\n * @param {Object} $ The Cheerio object.\n */\nfunction repairMarkyHeaders($) {\n  $('p:empty + h3').prev().remove();\n\n  $('h3 ~ p:empty').each(function() {\n    const $p = $(this);\n    let node = this.prev;\n    while ((node = node.prev) && node.name != 'h3' && node.name != 'p') {\n      $p.prepend(node.next);\n    }\n  });\n\n  $('h3 code em').parent().each(function() {\n    const $code = $(this);\n    $code.html($code.html().replace(/<\\/?em>/g, '_'));\n  });\n}\n\n/**\n * Cleans up highlights blocks by removing extraneous class names and elements.\n *\n * @private\n * @param {Object} $ The Cheerio object.\n */\nfunction tidyHighlights($) {\n  $('.highlight').each(function() {\n    let $spans;\n    const $parent = $(this);\n    const classes = $parent.find('.source,.text').first().attr('class').split(' ');\n    const ext = _(classes).intersection(exts).last();\n\n    $parent.addClass(ext);\n\n    // Remove line indicators for single line snippets.\n    $parent.children('pre').each(function() {\n      const $divs = $(this).children('div');\n      if ($divs.length == 1) {\n        $divs.replaceWith($divs.html());\n      }\n    });\n    // Remove extraneous class names.\n    $parent.find('[class]').each(function() {\n      const $element = $(this);\n      const classes = $element.attr('class').split(' ');\n      const attr = _(classes).intersection(highlights[ext]).join(' ');\n      $element.attr('class', attr || null);\n    });\n    // Collapse nested comment highlights.\n    $parent.find(`[class~=\"comment\"]`).each(function() {\n      const $element = $(this);\n      $element.text($element.text().trim());\n    });\n    // Collapse nested string highlights.\n    $parent.find(`[class~=\"string\"]`).each(function() {\n      const $element = $(this);\n      $element.text($element.text());\n    });\n    // Collapse nested spans.\n    while (($spans = $parent.find('span:not([class])')).length) {\n      $spans.each(function() {\n        let $span = $(this);\n        while ($span[0] && $span[0].name == 'span' && !$span.attr('class')) {\n          const $parent = $span.parent();\n          $span.replaceWith($span.html());\n          $span = $parent;\n        }\n      });\n    }\n  });\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Creates the documentation HTML.\n *\n * @private\n */\nfunction build() {\n  const markdown = fs\n    // Load markdown.\n    .readFileSync(readmePath, 'utf8')\n    // Uncomment docdown HTML hints.\n    .replace(/(<)!--\\s*|\\s*--(>)/g, '$1$2')\n    // Convert source and npm package links to anchors.\n    .replace(/\\[source\\]\\(([^)]+)\\) \\[npm package\\]\\(([^)]+)\\)/g, (match, href1, href2) =>\n      `<p><a href=\"${ href1 }\">source</a> <a href=\"${ href2 }\">npm package</a></p>`\n    );\n\n  const $ = cheerio.load(marky(markdown, {\n    'enableHeadingLinkIcons': false,\n    'sanitize': false\n  }));\n\n  const $header = $('h1').first().remove();\n  const version = $header.find('span').first().text().trim().slice(1);\n\n  // Auto-link Lodash method references.\n  autoLink($);\n  // Rename \"_\" id references to \"lodash\".\n  renameLodashId($);\n  // Remove docdown horizontal rules.\n  removeHorizontalRules($);\n  // Remove marky-markdown attribute additions.\n  removeMarkyAttributes($);\n  // Repair marky-markdown wrapping around headers.\n  repairMarkyHeaders($);\n  // Cleanup highlights.\n  tidyHighlights($);\n\n  const html = [\n    // Append YAML front matter.\n    '---',\n    'id: docs',\n    'layout: docs',\n    'title: Lodash Documentation',\n    'version: ' + (version || null),\n    '---',\n    '',\n    // Wrap in raw tags to avoid Liquid template tag processing.\n    '{% raw %}',\n    $.html().trim(),\n    '{% endraw %}',\n    ''\n  ].join('\\n');\n\n  fs.writeFile(path.join(docPath, version + '.html'), html, util.pitch);\n}\n\nbuild();\n",
                language: 'javascript',
                size: 5641,
                tokens: 690,
                lastModified: '2025-07-02T12:28:22.839Z',
              },
            ],
          },
        ],
      },
      {
        name: 'perf',
        path: 'perf',
        type: 'directory',
        children: [
          {
            name: 'asset',
            path: 'perf/asset',
            type: 'directory',
            children: [
              {
                name: 'perf-ui.js',
                path: 'perf/asset/perf-ui.js',
                type: 'file',
                content:
                  ";(function(window) {\n  'use strict';\n\n  /** The base path of the lodash builds. */\n  var basePath = '../';\n\n  /** The lodash build to load. */\n  var build = (build = /build=([^&]+)/.exec(location.search)) && decodeURIComponent(build[1]);\n\n  /** The other library to load. */\n  var other = (other = /other=([^&]+)/.exec(location.search)) && decodeURIComponent(other[1]);\n\n  /** The `ui` object. */\n  var ui = {};\n\n  /*--------------------------------------------------------------------------*/\n\n  // Initialize controls.\n  addEventListener('load', function() {\n    function eventHandler(event) {\n      var buildIndex = buildList.selectedIndex,\n          otherIndex = otherList.selectedIndex,\n          search = location.search.replace(/^\\?|&?(?:build|other)=[^&]*&?/g, '');\n\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      } else {\n        event.cancelBubble = true;\n      }\n      location.href =\n        location.href.split('?')[0] + '?' +\n        (search ? search + '&' : '') +\n        'build=' + (buildIndex < 0 ? build : buildList[buildIndex].value) + '&' +\n        'other=' + (otherIndex < 0 ? other : otherList[otherIndex].value);\n    }\n\n    var span1 = document.createElement('span');\n    span1.style.cssText = 'float:right';\n    span1.innerHTML =\n      '<label for=\"perf-build\">Build: </label>' +\n      '<select id=\"perf-build\">' +\n      '<option value=\"lodash\">lodash (production)</option>' +\n      '</select>';\n\n    var span2 = document.createElement('span');\n    span2.style.cssText = 'float:right';\n    span2.innerHTML =\n      '<label for=\"perf-other\">Other Library: </label>' +\n      '<select id=\"perf-other\">' +\n      '<option value=\"underscore-dev\">Underscore (development)</option>' +\n      '<option value=\"underscore\">Underscore (production)</option>' +\n      '<option value=\"lodash\">lodash</option>' +\n      '</select>';\n\n    var buildList = span1.lastChild,\n        otherList = span2.lastChild,\n        toolbar = document.getElementById('perf-toolbar');\n\n    toolbar.appendChild(span2);\n    toolbar.appendChild(span1);\n\n    buildList.selectedIndex = (function() {\n      switch (build) {\n        case 'lodash':\n        case null:                return 0;\n      }\n      return -1;\n    }());\n\n    otherList.selectedIndex = (function() {\n      switch (other) {\n        case 'underscore-dev':    return 0;\n        case 'lodash':            return 2;\n        case 'underscore':\n        case null:                return 1;\n      }\n      return -1;\n    }());\n\n    buildList.addEventListener('change', eventHandler);\n    otherList.addEventListener('change', eventHandler);\n  });\n\n  // The lodash build file path.\n  ui.buildPath = (function() {\n    var result;\n    switch (build) {\n      case null:                build  = 'lodash';\n      case 'lodash':            result = 'dist/lodash.min.js'; break;\n      default:                  return build;\n    }\n    return basePath + result;\n  }());\n\n  // The other library file path.\n  ui.otherPath = (function() {\n    var result;\n    switch (other) {\n      case 'lodash':            result = 'dist/lodash.min.js'; break;\n      case 'underscore-dev':    result = 'vendor/underscore/underscore.js'; break;\n      case null:                other  = 'underscore';\n      case 'underscore':        result = 'vendor/underscore/underscore-min.js'; break;\n      default:                  return other;\n    }\n    return basePath + result;\n  }());\n\n  ui.urlParams = { 'build': build, 'other': other };\n\n  window.ui = ui;\n\n}(this));\n",
                language: 'javascript',
                size: 3500,
                tokens: 389,
                lastModified: '2025-07-02T12:28:22.846Z',
              },
            ],
          },
          {
            name: 'index.html',
            path: 'perf/index.html',
            type: 'file',
            content:
              '<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <title>lodash Performance Suite</title>\n    <style>\n      html, body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n      }\n      #FirebugUI {\n        top: 2.5em;\n      }\n      #perf-toolbar {\n        background-color: #EEE;\n        color: #5E740B;\n        font-family: "Helvetica Neue Light", "HelveticaNeue-Light", "Helvetica Neue", Calibri, Helvetica, Arial, sans-serif;\n        font-size: small;\n        padding: 0.5em 1em 0.5em 1em;\n        overflow: hidden;\n      }\n      #perf-toolbar label {\n        display: inline-block;\n        margin-right: 0.5em;\n      }\n      #perf-toolbar span {\n        display: inline-block;\n        float: right;\n        line-height: 2.1em;\n        margin-left: 1em;\n        margin-top: 0;\n      }\n    </style>\n  </head>\n  <body>\n    <div id="perf-toolbar"></div>\n    <script src="../lodash.js"></script>\n    <script src="../node_modules/platform/platform.js"></script>\n    <script src="../node_modules/benchmark/benchmark.js"></script>\n    <script src="../vendor/firebug-lite/src/firebug-lite-debug.js"></script>\n    <script src="./asset/perf-ui.js"></script>\n    <script>\n      document.write(\'<script src="\' + ui.buildPath + \'"><\\/script>\');\n    </script>\n    <script>\n      var lodash = _.noConflict();\n    </script>\n    <script>\n      document.write(\'<script src="\' + ui.otherPath + \'"><\\/script>\');\n    </script>\n    <script src="perf.js"></script>\n    <script>\n      (function() {\n        var measured,\n            perfNow,\n            begin = new Date;\n\n        function init() {\n          var fbUI = document.getElementById(\'FirebugUI\'),\n              fbDoc = fbUI && (fbDoc = fbUI.contentWindow || fbUI.contentDocument).document || fbDoc,\n              fbCommandLine = fbDoc && fbDoc.getElementById(\'fbCommandLine\');\n\n          if (!fbCommandLine) {\n            return setTimeout(init, 15);\n          }\n          fbUI.style.height = (\n            Math.max(document.documentElement.clientHeight, document.body.clientHeight) -\n            document.getElementById(\'perf-toolbar\').clientHeight\n          ) + \'px\';\n\n          fbDoc.body.style.height = fbDoc.documentElement.style.height = \'100%\';\n          setTimeout(run, 15);\n        }\n\n        window.onload = init;\n      }());\n    </script>\n  </body>\n</html>\n',
            language: 'html',
            size: 2342,
            tokens: 270,
            lastModified: '2025-07-02T12:28:22.846Z',
          },
          {
            name: 'perf.js',
            path: 'perf/perf.js',
            type: 'file',
            content:
              ";(function() {\n  'use strict';\n\n  /** Used to access the Firebug Lite panel (set by `run`). */\n  var fbPanel;\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments. */\n  var undefined;\n\n  /** Used as a reference to the global object. */\n  var root = typeof global == 'object' && global || this;\n\n  /** Method and object shortcuts. */\n  var phantom = root.phantom,\n      amd = root.define && define.amd,\n      argv = root.process && process.argv,\n      document = !phantom && root.document,\n      noop = function() {},\n      params = root.arguments,\n      system = root.system;\n\n  /** Add `console.log()` support for Rhino and RingoJS. */\n  var console = root.console || (root.console = { 'log': root.print });\n\n  /** The file path of the lodash file to test. */\n  var filePath = (function() {\n    var min = 0,\n        result = [];\n\n    if (phantom) {\n      result = params = phantom.args;\n    } else if (system) {\n      min = 1;\n      result = params = system.args;\n    } else if (argv) {\n      min = 2;\n      result = params = argv;\n    } else if (params) {\n      result = params;\n    }\n    var last = result[result.length - 1];\n    result = (result.length > min && !/perf(?:\\.js)?$/.test(last)) ? last : '../lodash.js';\n\n    if (!amd) {\n      try {\n        result = require('fs').realpathSync(result);\n      } catch (e) {}\n\n      try {\n        result = require.resolve(result);\n      } catch (e) {}\n    }\n    return result;\n  }());\n\n  /** Used to match path separators. */\n  var rePathSeparator = /[\\/\\\\]/;\n\n  /** Used to detect primitive types. */\n  var rePrimitive = /^(?:boolean|number|string|undefined)$/;\n\n  /** Used to match RegExp special characters. */\n  var reSpecialChars = /[.*+?^=!:${}()|[\\]\\/\\\\]/g;\n\n  /** The `ui` object. */\n  var ui = root.ui || (root.ui = {\n    'buildPath': basename(filePath, '.js'),\n    'otherPath': 'underscore'\n  });\n\n  /** The lodash build basename. */\n  var buildName = root.buildName = basename(ui.buildPath, '.js');\n\n  /** The other library basename. */\n  var otherName = root.otherName = (function() {\n    var result = basename(ui.otherPath, '.js');\n    return result + (result == buildName ? ' (2)' : '');\n  }());\n\n  /** Used to score performance. */\n  var score = { 'a': [], 'b': [] };\n\n  /** Used to queue benchmark suites. */\n  var suites = [];\n\n  /** Use a single \"load\" function. */\n  var load = (typeof require == 'function' && !amd)\n    ? require\n    : noop;\n\n  /** Load lodash. */\n  var lodash = root.lodash || (root.lodash = (\n    lodash = load(filePath) || root._,\n    lodash = lodash._ || lodash,\n    (lodash.runInContext ? lodash.runInContext(root) : lodash),\n    lodash.noConflict()\n  ));\n\n  /** Load Underscore. */\n  var _ = root.underscore || (root.underscore = (\n    _ = load('../vendor/underscore/underscore.js') || root._,\n    _._ || _\n  ));\n\n  /** Load Benchmark.js. */\n  var Benchmark = root.Benchmark || (root.Benchmark = (\n    Benchmark = load('../node_modules/benchmark/benchmark.js') || root.Benchmark,\n    Benchmark = Benchmark.Benchmark || Benchmark,\n    Benchmark.runInContext(lodash.extend({}, root, { '_': lodash }))\n  ));\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Gets the basename of the given `filePath`. If the file `extension` is passed,\n   * it will be removed from the basename.\n   *\n   * @private\n   * @param {string} path The file path to inspect.\n   * @param {string} extension The extension to remove.\n   * @returns {string} Returns the basename.\n   */\n  function basename(filePath, extension) {\n    var result = (filePath || '').split(rePathSeparator).pop();\n    return (arguments.length < 2)\n      ? result\n      : result.replace(RegExp(extension.replace(reSpecialChars, '\\\\$&') + '$'), '');\n  }\n\n  /**\n   * Computes the geometric mean (log-average) of an array of values.\n   * See http://en.wikipedia.org/wiki/Geometric_mean#Relationship_with_arithmetic_mean_of_logarithms.\n   *\n   * @private\n   * @param {Array} array The array of values.\n   * @returns {number} The geometric mean.\n   */\n  function getGeometricMean(array) {\n    return Math.pow(Math.E, lodash.reduce(array, function(sum, x) {\n      return sum + Math.log(x);\n    }, 0) / array.length) || 0;\n  }\n\n  /**\n   * Gets the Hz, i.e. operations per second, of `bench` adjusted for the\n   * margin of error.\n   *\n   * @private\n   * @param {Object} bench The benchmark object.\n   * @returns {number} Returns the adjusted Hz.\n   */\n  function getHz(bench) {\n    var result = 1 / (bench.stats.mean + bench.stats.moe);\n    return isFinite(result) ? result : 0;\n  }\n\n  /**\n   * Host objects can return type values that are different from their actual\n   * data type. The objects we are concerned with usually return non-primitive\n   * types of \"object\", \"function\", or \"unknown\".\n   *\n   * @private\n   * @param {*} object The owner of the property.\n   * @param {string} property The property to check.\n   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.\n   */\n  function isHostType(object, property) {\n    if (object == null) {\n      return false;\n    }\n    var type = typeof object[property];\n    return !rePrimitive.test(type) && (type != 'object' || !!object[property]);\n  }\n\n  /**\n   * Logs text to the console.\n   *\n   * @private\n   * @param {string} text The text to log.\n   */\n  function log(text) {\n    console.log(text + '');\n    if (fbPanel) {\n      // Scroll the Firebug Lite panel down.\n      fbPanel.scrollTop = fbPanel.scrollHeight;\n    }\n  }\n\n  /**\n   * Runs all benchmark suites.\n   *\n   * @private (@public in the browser)\n   */\n  function run() {\n    fbPanel = (fbPanel = root.document && document.getElementById('FirebugUI')) &&\n      (fbPanel = (fbPanel = fbPanel.contentWindow || fbPanel.contentDocument).document || fbPanel) &&\n      fbPanel.getElementById('fbPanel1');\n\n    log('\\nSit back and relax, this may take a while.');\n    suites[0].run({ 'async': true });\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  lodash.extend(Benchmark.Suite.options, {\n    'onStart': function() {\n      log('\\n' + this.name + ':');\n    },\n    'onCycle': function(event) {\n      log(event.target);\n    },\n    'onComplete': function() {\n      for (var index = 0, length = this.length; index < length; index++) {\n        var bench = this[index];\n        if (bench.error) {\n          var errored = true;\n        }\n      }\n      if (errored) {\n        log('There was a problem, skipping...');\n      }\n      else {\n        var formatNumber = Benchmark.formatNumber,\n            fastest = this.filter('fastest'),\n            fastestHz = getHz(fastest[0]),\n            slowest = this.filter('slowest'),\n            slowestHz = getHz(slowest[0]),\n            aHz = getHz(this[0]),\n            bHz = getHz(this[1]);\n\n        if (fastest.length > 1) {\n          log('It\\'s too close to call.');\n          aHz = bHz = slowestHz;\n        }\n        else {\n          var percent = ((fastestHz / slowestHz) - 1) * 100;\n\n          log(\n            fastest[0].name + ' is ' +\n            formatNumber(percent < 1 ? percent.toFixed(2) : Math.round(percent)) +\n            '% faster.'\n          );\n        }\n        // Add score adjusted for margin of error.\n        score.a.push(aHz);\n        score.b.push(bHz);\n      }\n      // Remove current suite from queue.\n      suites.shift();\n\n      if (suites.length) {\n        // Run next suite.\n        suites[0].run({ 'async': true });\n      }\n      else {\n        var aMeanHz = getGeometricMean(score.a),\n            bMeanHz = getGeometricMean(score.b),\n            fastestMeanHz = Math.max(aMeanHz, bMeanHz),\n            slowestMeanHz = Math.min(aMeanHz, bMeanHz),\n            xFaster = fastestMeanHz / slowestMeanHz,\n            percentFaster = formatNumber(Math.round((xFaster - 1) * 100)),\n            message = 'is ' + percentFaster + '% ' + (xFaster == 1 ? '' : '(' + formatNumber(xFaster.toFixed(2)) + 'x) ') + 'faster than';\n\n        // Report results.\n        if (aMeanHz >= bMeanHz) {\n          log('\\n' + buildName + ' ' + message + ' ' + otherName + '.');\n        } else {\n          log('\\n' + otherName + ' ' + message + ' ' + buildName + '.');\n        }\n      }\n    }\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  lodash.extend(Benchmark.options, {\n    'async': true,\n    'setup': '\\\n      var _ = global.underscore,\\\n          lodash = global.lodash,\\\n          belt = this.name == buildName ? lodash : _;\\\n      \\\n      var date = new Date,\\\n          limit = 50,\\\n          regexp = /x/,\\\n          object = {},\\\n          objects = Array(limit),\\\n          numbers = Array(limit),\\\n          fourNumbers = [5, 25, 10, 30],\\\n          nestedNumbers = [1, [2], [3, [[4]]]],\\\n          nestedObjects = [{}, [{}], [{}, [[{}]]]],\\\n          twoNumbers = [12, 23];\\\n      \\\n      for (var index = 0; index < limit; index++) {\\\n        numbers[index] = index;\\\n        object[\"key\" + index] = index;\\\n        objects[index] = { \"num\": index };\\\n      }\\\n      var strNumbers = numbers + \"\";\\\n      \\\n      if (typeof assign != \"undefined\") {\\\n        var _assign = _.assign || _.extend,\\\n            lodashAssign = lodash.assign;\\\n      }\\\n      if (typeof bind != \"undefined\") {\\\n        var thisArg = { \"name\": \"fred\" };\\\n        \\\n        var func = function(greeting, punctuation) {\\\n          return (greeting || \"hi\") + \" \" + this.name + (punctuation || \".\");\\\n        };\\\n        \\\n        var _boundNormal = _.bind(func, thisArg),\\\n            _boundMultiple = _boundNormal,\\\n            _boundPartial = _.bind(func, thisArg, \"hi\");\\\n        \\\n        var lodashBoundNormal = lodash.bind(func, thisArg),\\\n            lodashBoundMultiple = lodashBoundNormal,\\\n            lodashBoundPartial = lodash.bind(func, thisArg, \"hi\");\\\n        \\\n        for (index = 0; index < 10; index++) {\\\n          _boundMultiple = _.bind(_boundMultiple, { \"name\": \"fred\" + index });\\\n          lodashBoundMultiple = lodash.bind(lodashBoundMultiple, { \"name\": \"fred\" + index });\\\n        }\\\n      }\\\n      if (typeof bindAll != \"undefined\") {\\\n        var bindAllCount = -1,\\\n            bindAllObjects = Array(this.count);\\\n        \\\n        var funcNames = belt.reject(belt.functions(belt).slice(0, 40), function(funcName) {\\\n          return /^_/.test(funcName);\\\n        });\\\n        \\\n        // Potentially expensive.\\n\\\n        for (index = 0; index < this.count; index++) {\\\n          bindAllObjects[index] = belt.reduce(funcNames, function(object, funcName) {\\\n            object[funcName] = belt[funcName];\\\n            return object;\\\n          }, {});\\\n        }\\\n      }\\\n      if (typeof chaining != \"undefined\") {\\\n        var even = function(v) { return v % 2 == 0; },\\\n            square = function(v) { return v * v; };\\\n        \\\n        var largeArray = belt.range(10000),\\\n            _chaining = _(largeArray).chain(),\\\n            lodashChaining = lodash(largeArray).chain();\\\n      }\\\n      if (typeof compact != \"undefined\") {\\\n        var uncompacted = numbers.slice();\\\n        uncompacted[2] = false;\\\n        uncompacted[6] = null;\\\n        uncompacted[18] = \"\";\\\n      }\\\n      if (typeof flowRight != \"undefined\") {\\\n        var compAddOne = function(n) { return n + 1; },\\\n            compAddTwo = function(n) { return n + 2; },\\\n            compAddThree = function(n) { return n + 3; };\\\n        \\\n        var _composed = _.flowRight && _.flowRight(compAddThree, compAddTwo, compAddOne),\\\n            lodashComposed = lodash.flowRight && lodash.flowRight(compAddThree, compAddTwo, compAddOne);\\\n      }\\\n      if (typeof countBy != \"undefined\" || typeof omit != \"undefined\") {\\\n        var wordToNumber = {\\\n          \"one\": 1,\\\n          \"two\": 2,\\\n          \"three\": 3,\\\n          \"four\": 4,\\\n          \"five\": 5,\\\n          \"six\": 6,\\\n          \"seven\": 7,\\\n          \"eight\": 8,\\\n          \"nine\": 9,\\\n          \"ten\": 10,\\\n          \"eleven\": 11,\\\n          \"twelve\": 12,\\\n          \"thirteen\": 13,\\\n          \"fourteen\": 14,\\\n          \"fifteen\": 15,\\\n          \"sixteen\": 16,\\\n          \"seventeen\": 17,\\\n          \"eighteen\": 18,\\\n          \"nineteen\": 19,\\\n          \"twenty\": 20,\\\n          \"twenty-one\": 21,\\\n          \"twenty-two\": 22,\\\n          \"twenty-three\": 23,\\\n          \"twenty-four\": 24,\\\n          \"twenty-five\": 25,\\\n          \"twenty-six\": 26,\\\n          \"twenty-seven\": 27,\\\n          \"twenty-eight\": 28,\\\n          \"twenty-nine\": 29,\\\n          \"thirty\": 30,\\\n          \"thirty-one\": 31,\\\n          \"thirty-two\": 32,\\\n          \"thirty-three\": 33,\\\n          \"thirty-four\": 34,\\\n          \"thirty-five\": 35,\\\n          \"thirty-six\": 36,\\\n          \"thirty-seven\": 37,\\\n          \"thirty-eight\": 38,\\\n          \"thirty-nine\": 39,\\\n          \"forty\": 40\\\n        };\\\n        \\\n        var words = belt.keys(wordToNumber).slice(0, limit);\\\n      }\\\n      if (typeof flatten != \"undefined\") {\\\n        var _flattenDeep = _.flatten([[1]])[0] !== 1,\\\n            lodashFlattenDeep = lodash.flatten([[1]])[0] !== 1;\\\n      }\\\n      if (typeof isEqual != \"undefined\") {\\\n        var objectOfPrimitives = {\\\n          \"boolean\": true,\\\n          \"number\": 1,\\\n          \"string\": \"a\"\\\n        };\\\n        \\\n        var objectOfObjects = {\\\n          \"boolean\": new Boolean(true),\\\n          \"number\": new Number(1),\\\n          \"string\": new String(\"a\")\\\n        };\\\n        \\\n        var objectOfObjects2 = {\\\n          \"boolean\": new Boolean(true),\\\n          \"number\": new Number(1),\\\n          \"string\": new String(\"A\")\\\n        };\\\n        \\\n        var object2 = {},\\\n            object3 = {},\\\n            objects2 = Array(limit),\\\n            objects3 = Array(limit),\\\n            numbers2 = Array(limit),\\\n            numbers3 = Array(limit),\\\n            nestedNumbers2 = [1, [2], [3, [[4]]]],\\\n            nestedNumbers3 = [1, [2], [3, [[6]]]];\\\n        \\\n        for (index = 0; index < limit; index++) {\\\n          object2[\"key\" + index] = index;\\\n          object3[\"key\" + index] = index;\\\n          objects2[index] = { \"num\": index };\\\n          objects3[index] = { \"num\": index };\\\n          numbers2[index] = index;\\\n          numbers3[index] = index;\\\n        }\\\n        object3[\"key\" + (limit - 1)] = -1;\\\n        objects3[limit - 1].num = -1;\\\n        numbers3[limit - 1] = -1;\\\n      }\\\n      if (typeof matches != \"undefined\") {\\\n        var source = { \"num\": 9 };\\\n        \\\n        var _matcher = (_.matches || _.noop)(source),\\\n            lodashMatcher = (lodash.matches || lodash.noop)(source);\\\n      }\\\n      if (typeof multiArrays != \"undefined\") {\\\n        var twentyValues = belt.shuffle(belt.range(20)),\\\n            fortyValues = belt.shuffle(belt.range(40)),\\\n            hundredSortedValues = belt.range(100),\\\n            hundredValues = belt.shuffle(hundredSortedValues),\\\n            hundredValues2 = belt.shuffle(hundredValues),\\\n            hundredTwentyValues = belt.shuffle(belt.range(120)),\\\n            hundredTwentyValues2 = belt.shuffle(hundredTwentyValues),\\\n            twoHundredValues = belt.shuffle(belt.range(200)),\\\n            twoHundredValues2 = belt.shuffle(twoHundredValues);\\\n      }\\\n      if (typeof partial != \"undefined\") {\\\n        var func = function(greeting, punctuation) {\\\n          return greeting + \" fred\" + (punctuation || \".\");\\\n        };\\\n        \\\n        var _partial = _.partial(func, \"hi\"),\\\n            lodashPartial = lodash.partial(func, \"hi\");\\\n      }\\\n      if (typeof template != \"undefined\") {\\\n        var tplData = {\\\n          \"header1\": \"Header1\",\\\n          \"header2\": \"Header2\",\\\n          \"header3\": \"Header3\",\\\n          \"header4\": \"Header4\",\\\n          \"header5\": \"Header5\",\\\n          \"header6\": \"Header6\",\\\n          \"list\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"]\\\n        };\\\n        \\\n        var tpl =\\\n          \"<div>\" +\\\n          \"<h1 class=\\'header1\\'><%= header1 %></h1>\" +\\\n          \"<h2 class=\\'header2\\'><%= header2 %></h2>\" +\\\n          \"<h3 class=\\'header3\\'><%= header3 %></h3>\" +\\\n          \"<h4 class=\\'header4\\'><%= header4 %></h4>\" +\\\n          \"<h5 class=\\'header5\\'><%= header5 %></h5>\" +\\\n          \"<h6 class=\\'header6\\'><%= header6 %></h6>\" +\\\n          \"<ul class=\\'list\\'>\" +\\\n          \"<% for (var index = 0, length = list.length; index < length; index++) { %>\" +\\\n          \"<li class=\\'item\\'><%= list[index] %></li>\" +\\\n          \"<% } %>\" +\\\n          \"</ul>\" +\\\n          \"</div>\";\\\n        \\\n        var tplVerbose =\\\n          \"<div>\" +\\\n          \"<h1 class=\\'header1\\'><%= data.header1 %></h1>\" +\\\n          \"<h2 class=\\'header2\\'><%= data.header2 %></h2>\" +\\\n          \"<h3 class=\\'header3\\'><%= data.header3 %></h3>\" +\\\n          \"<h4 class=\\'header4\\'><%= data.header4 %></h4>\" +\\\n          \"<h5 class=\\'header5\\'><%= data.header5 %></h5>\" +\\\n          \"<h6 class=\\'header6\\'><%= data.header6 %></h6>\" +\\\n          \"<ul class=\\'list\\'>\" +\\\n          \"<% for (var index = 0, length = data.list.length; index < length; index++) { %>\" +\\\n          \"<li class=\\'item\\'><%= data.list[index] %></li>\" +\\\n          \"<% } %>\" +\\\n          \"</ul>\" +\\\n          \"</div>\";\\\n        \\\n        var settingsObject = { \"variable\": \"data\" };\\\n        \\\n        var _tpl = _.template(tpl),\\\n            _tplVerbose = _.template(tplVerbose, null, settingsObject);\\\n        \\\n        var lodashTpl = lodash.template(tpl),\\\n            lodashTplVerbose = lodash.template(tplVerbose, null, settingsObject);\\\n      }\\\n      if (typeof wrap != \"undefined\") {\\\n        var add = function(a, b) {\\\n          return a + b;\\\n        };\\\n        \\\n        var average = function(func, a, b) {\\\n          return (func(a, b) / 2).toFixed(2);\\\n        };\\\n        \\\n        var _wrapped = _.wrap(add, average);\\\n            lodashWrapped = lodash.wrap(add, average);\\\n      }\\\n      if (typeof zip != \"undefined\") {\\\n        var unzipped = [[\"a\", \"b\", \"c\"], [1, 2, 3], [true, false, true]];\\\n      }'\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_(...).map(...).filter(...).take(...).value()`')\n      .add(buildName, {\n        'fn': 'lodashChaining.map(square).filter(even).take(100).value()',\n        'teardown': 'function chaining(){}'\n      })\n      .add(otherName, {\n        'fn': '_chaining.map(square).filter(even).take(100).value()',\n        'teardown': 'function chaining(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.assign`')\n      .add(buildName, {\n        'fn': 'lodashAssign({}, { \"a\": 1, \"b\": 2, \"c\": 3 })',\n        'teardown': 'function assign(){}'\n      })\n      .add(otherName, {\n        'fn': '_assign({}, { \"a\": 1, \"b\": 2, \"c\": 3 })',\n        'teardown': 'function assign(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.assign` with multiple sources')\n      .add(buildName, {\n        'fn': 'lodashAssign({}, { \"a\": 1, \"b\": 2 }, { \"c\": 3, \"d\": 4 })',\n        'teardown': 'function assign(){}'\n      })\n      .add(otherName, {\n        'fn': '_assign({}, { \"a\": 1, \"b\": 2 }, { \"c\": 3, \"d\": 4 })',\n        'teardown': 'function assign(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.bind` (slow path)')\n      .add(buildName, {\n        'fn': 'lodash.bind(function() { return this.name; }, { \"name\": \"fred\" })',\n        'teardown': 'function bind(){}'\n      })\n      .add(otherName, {\n        'fn': '_.bind(function() { return this.name; }, { \"name\": \"fred\" })',\n        'teardown': 'function bind(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('bound call with arguments')\n      .add(buildName, {\n        'fn': 'lodashBoundNormal(\"hi\", \"!\")',\n        'teardown': 'function bind(){}'\n      })\n      .add(otherName, {\n        'fn': '_boundNormal(\"hi\", \"!\")',\n        'teardown': 'function bind(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('bound and partially applied call with arguments')\n      .add(buildName, {\n        'fn': 'lodashBoundPartial(\"!\")',\n        'teardown': 'function bind(){}'\n      })\n      .add(otherName, {\n        'fn': '_boundPartial(\"!\")',\n        'teardown': 'function bind(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('bound multiple times')\n      .add(buildName, {\n        'fn': 'lodashBoundMultiple()',\n        'teardown': 'function bind(){}'\n      })\n      .add(otherName, {\n        'fn': '_boundMultiple()',\n        'teardown': 'function bind(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.bindAll`')\n      .add(buildName, {\n        'fn': 'lodash.bindAll(bindAllObjects[++bindAllCount], funcNames)',\n        'teardown': 'function bindAll(){}'\n      })\n      .add(otherName, {\n        'fn': '_.bindAll(bindAllObjects[++bindAllCount], funcNames)',\n        'teardown': 'function bindAll(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.clone` with an array')\n      .add(buildName, '\\\n        lodash.clone(numbers)'\n      )\n      .add(otherName, '\\\n        _.clone(numbers)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.clone` with an object')\n      .add(buildName, '\\\n        lodash.clone(object)'\n      )\n      .add(otherName, '\\\n        _.clone(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.compact`')\n      .add(buildName, {\n        'fn': 'lodash.compact(uncompacted)',\n        'teardown': 'function compact(){}'\n      })\n      .add(otherName, {\n        'fn': '_.compact(uncompacted)',\n        'teardown': 'function compact(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.countBy` with `callback` iterating an array')\n      .add(buildName, '\\\n        lodash.countBy(numbers, function(num) { return num >> 1; })'\n      )\n      .add(otherName, '\\\n        _.countBy(numbers, function(num) { return num >> 1; })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.countBy` with `property` name iterating an array')\n      .add(buildName, {\n        'fn': 'lodash.countBy(words, \"length\")',\n        'teardown': 'function countBy(){}'\n      })\n      .add(otherName, {\n        'fn': '_.countBy(words, \"length\")',\n        'teardown': 'function countBy(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.countBy` with `callback` iterating an object')\n      .add(buildName, {\n        'fn': 'lodash.countBy(wordToNumber, function(num) { return num >> 1; })',\n        'teardown': 'function countBy(){}'\n      })\n      .add(otherName, {\n        'fn': '_.countBy(wordToNumber, function(num) { return num >> 1; })',\n        'teardown': 'function countBy(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.defaults`')\n      .add(buildName, '\\\n        lodash.defaults({ \"key2\": 2, \"key6\": 6, \"key18\": 18 }, object)'\n      )\n      .add(otherName, '\\\n        _.defaults({ \"key2\": 2, \"key6\": 6, \"key18\": 18 }, object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.difference`')\n      .add(buildName, '\\\n        lodash.difference(numbers, twoNumbers, fourNumbers)'\n      )\n      .add(otherName, '\\\n        _.difference(numbers, twoNumbers, fourNumbers)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.difference` iterating 20 and 40 elements')\n      .add(buildName, {\n        'fn': 'lodash.difference(twentyValues, fortyValues)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.difference(twentyValues, fortyValues)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.difference` iterating 200 elements')\n      .add(buildName, {\n        'fn': 'lodash.difference(twoHundredValues, twoHundredValues2)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.difference(twoHundredValues, twoHundredValues2)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.each` iterating an array')\n      .add(buildName, '\\\n        var result = [];\\\n        lodash.each(numbers, function(num) {\\\n          result.push(num * 2);\\\n        })'\n      )\n      .add(otherName, '\\\n        var result = [];\\\n        _.each(numbers, function(num) {\\\n          result.push(num * 2);\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.each` iterating an object')\n      .add(buildName, '\\\n        var result = [];\\\n        lodash.each(object, function(num) {\\\n          result.push(num * 2);\\\n        })'\n      )\n      .add(otherName, '\\\n        var result = [];\\\n        _.each(object, function(num) {\\\n          result.push(num * 2);\\\n        })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.every` iterating an array')\n      .add(buildName, '\\\n        lodash.every(numbers, function(num) {\\\n          return num < limit;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.every(numbers, function(num) {\\\n          return num < limit;\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.every` iterating an object')\n      .add(buildName, '\\\n        lodash.every(object, function(num) {\\\n          return num < limit;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.every(object, function(num) {\\\n          return num < limit;\\\n        })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.filter` iterating an array')\n      .add(buildName, '\\\n        lodash.filter(numbers, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.filter(numbers, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.filter` iterating an object')\n      .add(buildName, '\\\n        lodash.filter(object, function(num) {\\\n          return num % 2\\\n        })'\n      )\n      .add(otherName, '\\\n        _.filter(object, function(num) {\\\n          return num % 2\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.filter` with `_.matches` shorthand')\n      .add(buildName, {\n        'fn': 'lodash.filter(objects, source)',\n        'teardown': 'function matches(){}'\n      })\n      .add(otherName, {\n        'fn': '_.filter(objects, source)',\n        'teardown': 'function matches(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.filter` with `_.matches` predicate')\n      .add(buildName, {\n        'fn': 'lodash.filter(objects, lodashMatcher)',\n        'teardown': 'function matches(){}'\n      })\n      .add(otherName, {\n        'fn': '_.filter(objects, _matcher)',\n        'teardown': 'function matches(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.find` iterating an array')\n      .add(buildName, '\\\n        lodash.find(numbers, function(num) {\\\n          return num === (limit - 1);\\\n        })'\n      )\n      .add(otherName, '\\\n        _.find(numbers, function(num) {\\\n          return num === (limit - 1);\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.find` iterating an object')\n      .add(buildName, '\\\n        lodash.find(object, function(value, key) {\\\n          return /\\D9$/.test(key);\\\n        })'\n      )\n      .add(otherName, '\\\n        _.find(object, function(value, key) {\\\n          return /\\D9$/.test(key);\\\n        })'\n      )\n  );\n\n  // Avoid Underscore induced `OutOfMemoryError` in Rhino and Ringo.\n  suites.push(\n    Benchmark.Suite('`_.find` with `_.matches` shorthand')\n      .add(buildName, {\n        'fn': 'lodash.find(objects, source)',\n        'teardown': 'function matches(){}'\n      })\n      .add(otherName, {\n        'fn': '_.find(objects, source)',\n        'teardown': 'function matches(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.flatten`')\n      .add(buildName, {\n        'fn': 'lodash.flatten(nestedNumbers, !lodashFlattenDeep)',\n        'teardown': 'function flatten(){}'\n      })\n      .add(otherName, {\n        'fn': '_.flatten(nestedNumbers, !_flattenDeep)',\n        'teardown': 'function flatten(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.flattenDeep` nested arrays of numbers')\n      .add(buildName, {\n        'fn': 'lodash.flattenDeep(nestedNumbers)',\n        'teardown': 'function flatten(){}'\n      })\n      .add(otherName, {\n        'fn': '_.flattenDeep(nestedNumbers)',\n        'teardown': 'function flatten(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.flattenDeep` nest arrays of objects')\n      .add(buildName, {\n        'fn': 'lodash.flattenDeep(nestedObjects)',\n        'teardown': 'function flatten(){}'\n      })\n      .add(otherName, {\n        'fn': '_.flattenDeep(nestedObjects)',\n        'teardown': 'function flatten(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.flowRight`')\n      .add(buildName, {\n        'fn': 'lodash.flowRight(compAddThree, compAddTwo, compAddOne)',\n        'teardown': 'function flowRight(){}'\n      })\n      .add(otherName, {\n        'fn': '_.flowRight(compAddThree, compAddTwo, compAddOne)',\n        'teardown': 'function flowRight(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('composed call')\n      .add(buildName, {\n        'fn': 'lodashComposed(0)',\n        'teardown': 'function flowRight(){}'\n      })\n      .add(otherName, {\n        'fn': '_composed(0)',\n        'teardown': 'function flowRight(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.functions`')\n      .add(buildName, '\\\n        lodash.functions(lodash)'\n      )\n      .add(otherName, '\\\n        _.functions(lodash)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.groupBy` with `callback` iterating an array')\n      .add(buildName, '\\\n        lodash.groupBy(numbers, function(num) { return num >> 1; })'\n      )\n      .add(otherName, '\\\n        _.groupBy(numbers, function(num) { return num >> 1; })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.groupBy` with `property` name iterating an array')\n      .add(buildName, {\n        'fn': 'lodash.groupBy(words, \"length\")',\n        'teardown': 'function countBy(){}'\n      })\n      .add(otherName, {\n        'fn': '_.groupBy(words, \"length\")',\n        'teardown': 'function countBy(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.groupBy` with `callback` iterating an object')\n      .add(buildName, {\n        'fn': 'lodash.groupBy(wordToNumber, function(num) { return num >> 1; })',\n        'teardown': 'function countBy(){}'\n      })\n      .add(otherName, {\n        'fn': '_.groupBy(wordToNumber, function(num) { return num >> 1; })',\n        'teardown': 'function countBy(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.includes` searching an array')\n      .add(buildName, '\\\n        lodash.includes(numbers, limit - 1)'\n      )\n      .add(otherName, '\\\n        _.includes(numbers, limit - 1)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.includes` searching an object')\n      .add(buildName, '\\\n        lodash.includes(object, limit - 1)'\n      )\n      .add(otherName, '\\\n        _.includes(object, limit - 1)'\n      )\n  );\n\n  if (lodash.includes('ab', 'ab') && _.includes('ab', 'ab')) {\n    suites.push(\n      Benchmark.Suite('`_.includes` searching a string')\n        .add(buildName, '\\\n          lodash.includes(strNumbers, \",\" + (limit - 1))'\n        )\n        .add(otherName, '\\\n          _.includes(strNumbers, \",\" + (limit - 1))'\n        )\n    );\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.indexOf`')\n      .add(buildName, {\n        'fn': 'lodash.indexOf(hundredSortedValues, 99)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.indexOf(hundredSortedValues, 99)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.intersection`')\n      .add(buildName, '\\\n        lodash.intersection(numbers, twoNumbers, fourNumbers)'\n      )\n      .add(otherName, '\\\n        _.intersection(numbers, twoNumbers, fourNumbers)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.intersection` iterating 120 elements')\n      .add(buildName, {\n        'fn': 'lodash.intersection(hundredTwentyValues, hundredTwentyValues2)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.intersection(hundredTwentyValues, hundredTwentyValues2)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.invert`')\n      .add(buildName, '\\\n        lodash.invert(object)'\n      )\n      .add(otherName, '\\\n        _.invert(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.invokeMap` iterating an array')\n      .add(buildName, '\\\n        lodash.invokeMap(numbers, \"toFixed\")'\n      )\n      .add(otherName, '\\\n        _.invokeMap(numbers, \"toFixed\")'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.invokeMap` with arguments iterating an array')\n      .add(buildName, '\\\n        lodash.invokeMap(numbers, \"toFixed\", 1)'\n      )\n      .add(otherName, '\\\n        _.invokeMap(numbers, \"toFixed\", 1)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.invokeMap` with a function for `path` iterating an array')\n      .add(buildName, '\\\n        lodash.invokeMap(numbers, Number.prototype.toFixed, 1)'\n      )\n      .add(otherName, '\\\n        _.invokeMap(numbers, Number.prototype.toFixed, 1)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.invokeMap` iterating an object')\n      .add(buildName, '\\\n        lodash.invokeMap(object, \"toFixed\", 1)'\n      )\n      .add(otherName, '\\\n        _.invokeMap(object, \"toFixed\", 1)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.isEqual` comparing primitives')\n      .add(buildName, {\n        'fn': '\\\n          lodash.isEqual(1, \"1\");\\\n          lodash.isEqual(1, 1)',\n        'teardown': 'function isEqual(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.isEqual(1, \"1\");\\\n          _.isEqual(1, 1);',\n        'teardown': 'function isEqual(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.isEqual` comparing primitives and their object counterparts (edge case)')\n      .add(buildName, {\n        'fn': '\\\n          lodash.isEqual(objectOfPrimitives, objectOfObjects);\\\n          lodash.isEqual(objectOfPrimitives, objectOfObjects2)',\n        'teardown': 'function isEqual(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.isEqual(objectOfPrimitives, objectOfObjects);\\\n          _.isEqual(objectOfPrimitives, objectOfObjects2)',\n        'teardown': 'function isEqual(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.isEqual` comparing arrays')\n      .add(buildName, {\n        'fn': '\\\n          lodash.isEqual(numbers, numbers2);\\\n          lodash.isEqual(numbers2, numbers3)',\n        'teardown': 'function isEqual(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.isEqual(numbers, numbers2);\\\n          _.isEqual(numbers2, numbers3)',\n        'teardown': 'function isEqual(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.isEqual` comparing nested arrays')\n      .add(buildName, {\n        'fn': '\\\n          lodash.isEqual(nestedNumbers, nestedNumbers2);\\\n          lodash.isEqual(nestedNumbers2, nestedNumbers3)',\n        'teardown': 'function isEqual(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.isEqual(nestedNumbers, nestedNumbers2);\\\n          _.isEqual(nestedNumbers2, nestedNumbers3)',\n        'teardown': 'function isEqual(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.isEqual` comparing arrays of objects')\n      .add(buildName, {\n        'fn': '\\\n          lodash.isEqual(objects, objects2);\\\n          lodash.isEqual(objects2, objects3)',\n        'teardown': 'function isEqual(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.isEqual(objects, objects2);\\\n          _.isEqual(objects2, objects3)',\n        'teardown': 'function isEqual(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.isEqual` comparing objects')\n      .add(buildName, {\n        'fn': '\\\n          lodash.isEqual(object, object2);\\\n          lodash.isEqual(object2, object3)',\n        'teardown': 'function isEqual(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.isEqual(object, object2);\\\n          _.isEqual(object2, object3)',\n        'teardown': 'function isEqual(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.isArguments`, `_.isDate`, `_.isFunction`, `_.isNumber`, `_.isObject`, `_.isRegExp`')\n      .add(buildName, '\\\n        lodash.isArguments(arguments);\\\n        lodash.isArguments(object);\\\n        lodash.isDate(date);\\\n        lodash.isDate(object);\\\n        lodash.isFunction(lodash);\\\n        lodash.isFunction(object);\\\n        lodash.isNumber(1);\\\n        lodash.isNumber(object);\\\n        lodash.isObject(object);\\\n        lodash.isObject(1);\\\n        lodash.isRegExp(regexp);\\\n        lodash.isRegExp(object)'\n      )\n      .add(otherName, '\\\n        _.isArguments(arguments);\\\n        _.isArguments(object);\\\n        _.isDate(date);\\\n        _.isDate(object);\\\n        _.isFunction(_);\\\n        _.isFunction(object);\\\n        _.isNumber(1);\\\n        _.isNumber(object);\\\n        _.isObject(object);\\\n        _.isObject(1);\\\n        _.isRegExp(regexp);\\\n        _.isRegExp(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.keys` (uses native `Object.keys` if available)')\n      .add(buildName, '\\\n        lodash.keys(object)'\n      )\n      .add(otherName, '\\\n        _.keys(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.lastIndexOf`')\n      .add(buildName, {\n        'fn': 'lodash.lastIndexOf(hundredSortedValues, 0)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.lastIndexOf(hundredSortedValues, 0)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.map` iterating an array')\n      .add(buildName, '\\\n        lodash.map(objects, function(value) {\\\n          return value.num;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.map(objects, function(value) {\\\n          return value.num;\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.map` iterating an object')\n      .add(buildName, '\\\n        lodash.map(object, function(value) {\\\n          return value;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.map(object, function(value) {\\\n          return value;\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.map` with `_.property` shorthand')\n      .add(buildName, '\\\n        lodash.map(objects, \"num\")'\n      )\n      .add(otherName, '\\\n        _.map(objects, \"num\")'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.max`')\n      .add(buildName, '\\\n        lodash.max(numbers)'\n      )\n      .add(otherName, '\\\n        _.max(numbers)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.min`')\n      .add(buildName, '\\\n        lodash.min(numbers)'\n      )\n      .add(otherName, '\\\n        _.min(numbers)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.omit` iterating 20 properties, omitting 2 keys')\n      .add(buildName, '\\\n        lodash.omit(object, \"key6\", \"key13\")'\n      )\n      .add(otherName, '\\\n        _.omit(object, \"key6\", \"key13\")'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.omit` iterating 40 properties, omitting 20 keys')\n      .add(buildName, {\n        'fn': 'lodash.omit(wordToNumber, words)',\n        'teardown': 'function omit(){}'\n      })\n      .add(otherName, {\n        'fn': '_.omit(wordToNumber, words)',\n        'teardown': 'function omit(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.partial` (slow path)')\n      .add(buildName, {\n        'fn': 'lodash.partial(function(greeting) { return greeting + \" \" + this.name; }, \"hi\")',\n        'teardown': 'function partial(){}'\n      })\n      .add(otherName, {\n        'fn': '_.partial(function(greeting) { return greeting + \" \" + this.name; }, \"hi\")',\n        'teardown': 'function partial(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('partially applied call with arguments')\n      .add(buildName, {\n        'fn': 'lodashPartial(\"!\")',\n        'teardown': 'function partial(){}'\n      })\n      .add(otherName, {\n        'fn': '_partial(\"!\")',\n        'teardown': 'function partial(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.partition` iterating an array')\n      .add(buildName, '\\\n        lodash.partition(numbers, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.partition(numbers, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.partition` iterating an object')\n      .add(buildName, '\\\n        lodash.partition(object, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.partition(object, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.pick`')\n      .add(buildName, '\\\n        lodash.pick(object, \"key6\", \"key13\")'\n      )\n      .add(otherName, '\\\n        _.pick(object, \"key6\", \"key13\")'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.reduce` iterating an array')\n      .add(buildName, '\\\n        lodash.reduce(numbers, function(result, value, index) {\\\n          result[index] = value;\\\n          return result;\\\n        }, {})'\n      )\n      .add(otherName, '\\\n        _.reduce(numbers, function(result, value, index) {\\\n          result[index] = value;\\\n          return result;\\\n        }, {})'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.reduce` iterating an object')\n      .add(buildName, '\\\n        lodash.reduce(object, function(result, value, key) {\\\n          result.push(key, value);\\\n          return result;\\\n        }, [])'\n      )\n      .add(otherName, '\\\n        _.reduce(object, function(result, value, key) {\\\n          result.push(key, value);\\\n          return result;\\\n        }, [])'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.reduceRight` iterating an array')\n      .add(buildName, '\\\n        lodash.reduceRight(numbers, function(result, value, index) {\\\n          result[index] = value;\\\n          return result;\\\n        }, {})'\n      )\n      .add(otherName, '\\\n        _.reduceRight(numbers, function(result, value, index) {\\\n          result[index] = value;\\\n          return result;\\\n        }, {})'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.reduceRight` iterating an object')\n      .add(buildName, '\\\n        lodash.reduceRight(object, function(result, value, key) {\\\n          result.push(key, value);\\\n          return result;\\\n        }, [])'\n      )\n      .add(otherName, '\\\n        _.reduceRight(object, function(result, value, key) {\\\n          result.push(key, value);\\\n          return result;\\\n        }, [])'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.reject` iterating an array')\n      .add(buildName, '\\\n        lodash.reject(numbers, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.reject(numbers, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.reject` iterating an object')\n      .add(buildName, '\\\n        lodash.reject(object, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.reject(object, function(num) {\\\n          return num % 2;\\\n        })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sampleSize`')\n      .add(buildName, '\\\n        lodash.sampleSize(numbers, limit / 2)'\n      )\n      .add(otherName, '\\\n        _.sampleSize(numbers, limit / 2)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.shuffle`')\n      .add(buildName, '\\\n        lodash.shuffle(numbers)'\n      )\n      .add(otherName, '\\\n        _.shuffle(numbers)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.size` with an object')\n      .add(buildName, '\\\n        lodash.size(object)'\n      )\n      .add(otherName, '\\\n        _.size(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.some` iterating an array')\n      .add(buildName, '\\\n        lodash.some(numbers, function(num) {\\\n          return num == (limit - 1);\\\n        })'\n      )\n      .add(otherName, '\\\n        _.some(numbers, function(num) {\\\n          return num == (limit - 1);\\\n        })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.some` iterating an object')\n      .add(buildName, '\\\n        lodash.some(object, function(num) {\\\n          return num == (limit - 1);\\\n        })'\n      )\n      .add(otherName, '\\\n        _.some(object, function(num) {\\\n          return num == (limit - 1);\\\n        })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sortBy` with `callback`')\n      .add(buildName, '\\\n        lodash.sortBy(numbers, function(num) { return Math.sin(num); })'\n      )\n      .add(otherName, '\\\n        _.sortBy(numbers, function(num) { return Math.sin(num); })'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.sortBy` with `property` name')\n      .add(buildName, {\n        'fn': 'lodash.sortBy(words, \"length\")',\n        'teardown': 'function countBy(){}'\n      })\n      .add(otherName, {\n        'fn': '_.sortBy(words, \"length\")',\n        'teardown': 'function countBy(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sortedIndex`')\n      .add(buildName, '\\\n        lodash.sortedIndex(numbers, limit)'\n      )\n      .add(otherName, '\\\n        _.sortedIndex(numbers, limit)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sortedIndexBy`')\n      .add(buildName, {\n        'fn': '\\\n          lodash.sortedIndexBy(words, \"twenty-five\", function(value) {\\\n            return wordToNumber[value];\\\n          })',\n        'teardown': 'function countBy(){}'\n      })\n      .add(otherName, {\n        'fn': '\\\n          _.sortedIndexBy(words, \"twenty-five\", function(value) {\\\n            return wordToNumber[value];\\\n          })',\n        'teardown': 'function countBy(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sortedIndexOf`')\n      .add(buildName, {\n        'fn': 'lodash.sortedIndexOf(hundredSortedValues, 99)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.sortedIndexOf(hundredSortedValues, 99)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sortedLastIndexOf`')\n      .add(buildName, {\n        'fn': 'lodash.sortedLastIndexOf(hundredSortedValues, 0)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.sortedLastIndexOf(hundredSortedValues, 0)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.sum`')\n      .add(buildName, '\\\n        lodash.sum(numbers)'\n      )\n      .add(otherName, '\\\n        _.sum(numbers)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.template` (slow path)')\n      .add(buildName, {\n        'fn': 'lodash.template(tpl)(tplData)',\n        'teardown': 'function template(){}'\n      })\n      .add(otherName, {\n        'fn': '_.template(tpl)(tplData)',\n        'teardown': 'function template(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('compiled template')\n      .add(buildName, {\n        'fn': 'lodashTpl(tplData)',\n        'teardown': 'function template(){}'\n      })\n      .add(otherName, {\n        'fn': '_tpl(tplData)',\n        'teardown': 'function template(){}'\n      })\n  );\n\n  suites.push(\n    Benchmark.Suite('compiled template without a with-statement')\n      .add(buildName, {\n        'fn': 'lodashTplVerbose(tplData)',\n        'teardown': 'function template(){}'\n      })\n      .add(otherName, {\n        'fn': '_tplVerbose(tplData)',\n        'teardown': 'function template(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.times`')\n      .add(buildName, '\\\n        var result = [];\\\n        lodash.times(limit, function(n) { result.push(n); })'\n      )\n      .add(otherName, '\\\n        var result = [];\\\n        _.times(limit, function(n) { result.push(n); })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.toArray` with an array (edge case)')\n      .add(buildName, '\\\n        lodash.toArray(numbers)'\n      )\n      .add(otherName, '\\\n        _.toArray(numbers)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.toArray` with an object')\n      .add(buildName, '\\\n        lodash.toArray(object)'\n      )\n      .add(otherName, '\\\n        _.toArray(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.toPairs`')\n      .add(buildName, '\\\n        lodash.toPairs(object)'\n      )\n      .add(otherName, '\\\n        _.toPairs(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.unescape` string without html entities')\n      .add(buildName, '\\\n        lodash.unescape(\"`&`, `<`, `>`, `\\\\\"`, and `\\'`\")'\n      )\n      .add(otherName, '\\\n        _.unescape(\"`&`, `<`, `>`, `\\\\\"`, and `\\'`\")'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.unescape` string with html entities')\n      .add(buildName, '\\\n        lodash.unescape(\"`&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;`\")'\n      )\n      .add(otherName, '\\\n        _.unescape(\"`&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;`\")'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.union`')\n      .add(buildName, '\\\n        lodash.union(numbers, twoNumbers, fourNumbers)'\n      )\n      .add(otherName, '\\\n        _.union(numbers, twoNumbers, fourNumbers)'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.union` iterating an array of 200 elements')\n      .add(buildName, {\n        'fn': 'lodash.union(hundredValues, hundredValues2)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.union(hundredValues, hundredValues2)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.uniq`')\n      .add(buildName, '\\\n        lodash.uniq(numbers.concat(twoNumbers, fourNumbers))'\n      )\n      .add(otherName, '\\\n        _.uniq(numbers.concat(twoNumbers, fourNumbers))'\n      )\n  );\n\n  suites.push(\n    Benchmark.Suite('`_.uniq` iterating an array of 200 elements')\n      .add(buildName, {\n        'fn': 'lodash.uniq(twoHundredValues)',\n        'teardown': 'function multiArrays(){}'\n      })\n      .add(otherName, {\n        'fn': '_.uniq(twoHundredValues)',\n        'teardown': 'function multiArrays(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.uniqBy`')\n      .add(buildName, '\\\n        lodash.uniqBy(numbers.concat(twoNumbers, fourNumbers), function(num) {\\\n          return num % 2;\\\n        })'\n      )\n      .add(otherName, '\\\n        _.uniqBy(numbers.concat(twoNumbers, fourNumbers), function(num) {\\\n          return num % 2;\\\n        })'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.values`')\n      .add(buildName, '\\\n        lodash.values(object)'\n      )\n      .add(otherName, '\\\n        _.values(object)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.without`')\n      .add(buildName, '\\\n        lodash.without(numbers, 9, 12, 14, 15)'\n      )\n      .add(otherName, '\\\n        _.without(numbers, 9, 12, 14, 15)'\n      )\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.wrap` result called')\n      .add(buildName, {\n        'fn': 'lodashWrapped(2, 5)',\n        'teardown': 'function wrap(){}'\n      })\n      .add(otherName, {\n        'fn': '_wrapped(2, 5)',\n        'teardown': 'function wrap(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  suites.push(\n    Benchmark.Suite('`_.zip`')\n      .add(buildName, {\n        'fn': 'lodash.zip.apply(lodash, unzipped)',\n        'teardown': 'function zip(){}'\n      })\n      .add(otherName, {\n        'fn': '_.zip.apply(_, unzipped)',\n        'teardown': 'function zip(){}'\n      })\n  );\n\n  /*--------------------------------------------------------------------------*/\n\n  if (Benchmark.platform + '') {\n    log(Benchmark.platform);\n  }\n  // Expose `run` to be called later when executing in a browser.\n  if (document) {\n    root.run = run;\n  } else {\n    run();\n  }\n}.call(this));\n",
            language: 'javascript',
            size: 56316,
            tokens: 5060,
            lastModified: '2025-07-02T12:28:22.847Z',
          },
        ],
      },
      {
        name: 'test',
        path: 'test',
        type: 'directory',
        children: [
          {
            name: 'asset',
            path: 'test/asset',
            type: 'directory',
            children: [
              {
                name: 'test-ui.js',
                path: 'test/asset/test-ui.js',
                type: 'file',
                content:
                  ";(function(window) {\n  'use strict';\n\n  /** The base path of the lodash builds. */\n  var basePath = '../';\n\n  /** The lodash build to load. */\n  var build = (build = /build=([^&]+)/.exec(location.search)) && decodeURIComponent(build[1]);\n\n  /** The module loader to use. */\n  var loader = (loader = /loader=([^&]+)/.exec(location.search)) && decodeURIComponent(loader[1]);\n\n  /** The `ui` object. */\n  var ui = {};\n\n  /*--------------------------------------------------------------------------*/\n\n  // Initialize controls.\n  addEventListener('load', function() {\n    function eventHandler(event) {\n      var buildIndex = buildList.selectedIndex,\n          loaderIndex = loaderList.selectedIndex,\n          search = location.search.replace(/^\\?|&?(?:build|loader)=[^&]*&?/g, '');\n\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      } else {\n        event.cancelBubble = true;\n      }\n      location.href =\n        location.href.split('?')[0] + '?' +\n        (search ? search + '&' : '') +\n        'build=' + (buildIndex < 0 ? build : buildList[buildIndex].value) + '&' +\n        'loader=' + (loaderIndex < 0 ? loader : loaderList[loaderIndex].value);\n    }\n\n    function init() {\n      var toolbar = document.getElementById('qunit-testrunner-toolbar');\n      if (!toolbar) {\n        setTimeout(init, 15);\n        return;\n      }\n      toolbar.insertBefore(span2, toolbar.lastChild);\n      toolbar.insertBefore(span1, span2);\n\n      buildList.selectedIndex = (function() {\n        switch (build) {\n          case 'lodash':            return 1;\n          case 'lodash-core-dev':   return 2;\n          case 'lodash-core':       return 3;\n          case 'lodash-dev':\n          case null:                return 0;\n        }\n        return -1;\n      }());\n\n      loaderList.selectedIndex = (function() {\n        switch (loader) {\n          case 'curl':      return 1;\n          case 'dojo':      return 2;\n          case 'requirejs': return 3;\n          case 'none':\n          case null:        return 0;\n        }\n        return -1;\n      }());\n\n      buildList.addEventListener('change', eventHandler);\n      loaderList.addEventListener('change', eventHandler);\n    }\n\n    var span1 = document.createElement('span');\n    span1.innerHTML =\n      '<label for=\"qunit-build\">Build: </label>' +\n      '<select id=\"qunit-build\">' +\n      '<option value=\"lodash-dev\">lodash (development)</option>' +\n      '<option value=\"lodash\">lodash (production)</option>' +\n      '<option value=\"lodash-core-dev\">lodash-core (development)</option>' +\n      '<option value=\"lodash-core\">lodash-core (production)</option>' +\n      '</select>';\n\n    var span2 = document.createElement('span');\n    span2.innerHTML =\n      '<label for=\"qunit-loader\">Loader: </label>' +\n      '<select id=\"qunit-loader\">' +\n      '<option value=\"none\">None</option>' +\n      '<option value=\"curl\">Curl</option>' +\n      '<option value=\"dojo\">Dojo</option>' +\n      '<option value=\"requirejs\">RequireJS</option>' +\n      '</select>';\n\n    span1.style.cssText =\n    span2.style.cssText = 'display:inline-block;float:right;line-height:2.1em;margin-left:1em;margin-top:0;';\n\n    span1.firstChild.style.cssText =\n    span2.firstChild.style.cssText = 'display:inline-block;margin-right:.5em;';\n\n    var buildList = span1.lastChild,\n        loaderList = span2.lastChild;\n\n    setTimeout(function() {\n      ui.timing.loadEventEnd = +new Date;\n    }, 1);\n\n    init();\n  });\n\n  // The lodash build file path.\n  ui.buildPath = (function() {\n    var result;\n    switch (build) {\n      case 'lodash':            result = 'dist/lodash.min.js'; break;\n      case 'lodash-core-dev':   result = 'dist/lodash.core.js'; break;\n      case 'lodash-core':       result = 'dist/lodash.core.min.js'; break;\n      case null:                build  = 'lodash-dev';\n      case 'lodash-dev':        result = 'lodash.js'; break;\n      default:                  return build;\n    }\n    return basePath + result;\n  }());\n\n  // The module loader file path.\n  ui.loaderPath = (function() {\n    var result;\n    switch (loader) {\n      case 'curl':      result = 'node_modules/curl-amd/dist/curl-kitchen-sink/curl.js'; break;\n      case 'dojo':      result = 'node_modules/dojo/dojo.js'; break;\n      case 'requirejs': result = 'node_modules/requirejs/require.js'; break;\n      case null:        loader = 'none'; return '';\n      default:          return loader;\n    }\n    return basePath + result;\n  }());\n\n  // Used to indicate testing a core build.\n  ui.isCore = /\\bcore(\\.min)?\\.js\\b/.test(ui.buildPath);\n\n  // Used to indicate testing a foreign file.\n  ui.isForeign = RegExp('^(\\\\w+:)?//').test(build);\n\n  // Used to indicate testing a modularized build.\n  ui.isModularize = /\\b(?:amd|commonjs|es|node|npm|(index|main)\\.js)\\b/.test([location.pathname, location.search]);\n\n  // Used to indicate testing in Sauce Labs' automated test cloud.\n  ui.isSauceLabs = location.port == '9001';\n\n  // Used to indicate that lodash is in strict mode.\n  ui.isStrict = /\\bes\\b/.test([location.pathname, location.search]);\n\n  ui.urlParams = { 'build': build, 'loader': loader };\n  ui.timing = { 'loadEventEnd': 0 };\n\n  window.ui = ui;\n\n}(this));\n",
                language: 'javascript',
                size: 5178,
                tokens: 619,
                lastModified: '2025-07-02T12:28:22.847Z',
              },
              {
                name: 'worker.js',
                path: 'test/asset/worker.js',
                type: 'file',
                content:
                  "'use strict';\n\nself.console || (self.console = { 'log': function() {} });\n\naddEventListener('message', function(e) {\n  if (e.data) {\n    try {\n      importScripts('../' + e.data);\n    } catch (e) {\n      var lineNumber = e.lineNumber,\n          message = (lineNumber == null ? '' : (lineNumber + ': ')) + e.message;\n\n      self._ = { 'VERSION': message };\n    }\n    postMessage(_.VERSION);\n  }\n});\n",
                language: 'javascript',
                size: 398,
                tokens: 45,
                lastModified: '2025-07-02T12:28:22.847Z',
              },
            ],
          },
          {
            name: 'backbone.html',
            path: 'test/backbone.html',
            type: 'file',
            content:
              "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Backbone Test Suite</title>\n    <link rel=\"stylesheet\" href=\"../node_modules/qunitjs/qunit/qunit.css\">\n  </head>\n  <body>\n    <script>\n      // Avoid reporting tests to Sauce Labs when script errors occur.\n      if (location.port == '9001') {\n        window.onerror = function(message) {\n          if (window.QUnit) {\n            QUnit.config.done.length = 0;\n          }\n          global_test_results = { 'message': message };\n        };\n      }\n    </script>\n    <script src=\"../node_modules/qunitjs/qunit/qunit.js\"></script>\n    <script src=\"../node_modules/qunit-extras/qunit-extras.js\"></script>\n    <script src=\"../vendor/json-js/json2.js\"></script>\n    <script src=\"../node_modules/platform/platform.js\"></script>\n    <script src=\"./asset/test-ui.js\"></script>\n    <script src=\"../lodash.js\"></script>\n    <script>\n      QUnit.config.asyncRetries = 10;\n      QUnit.config.hidepassed = true;\n\n      var mixinPrereqs = (function() {\n        var aliasToReal = {\n          'indexBy': 'keyBy',\n          'invoke': 'invokeMap'\n        };\n\n        var keyMap = {\n          'rest': 'tail'\n        };\n\n        var lodash = _.noConflict();\n\n        return function(_) {\n          lodash(_)\n            .defaultsDeep({ 'templateSettings': lodash.templateSettings })\n            .mixin(lodash.pick(lodash, lodash.difference([\n              'countBy',\n              'debounce',\n              'difference',\n              'find',\n              'findIndex',\n              'findLastIndex',\n              'groupBy',\n              'includes',\n              'invert',\n              'invokeMap',\n              'keyBy',\n              'omit',\n              'partition',\n              'reduceRight',\n              'reject',\n              'sample',\n              'without'\n            ], lodash.functions(_))))\n            .value();\n\n          lodash.forOwn(keyMap, function(realName, otherName) {\n            _[otherName] = lodash[realName];\n            _.prototype[otherName] = lodash.prototype[realName];\n          });\n          lodash.forOwn(aliasToReal, function(realName, alias) {\n            _[alias] = _[realName];\n            _.prototype[alias] = _.prototype[realName];\n          });\n          return _;\n        };\n      }());\n\n      // Load prerequisite scripts.\n      document.write(ui.urlParams.loader == 'none'\n        ? '<script src=\"' + ui.buildPath + '\"><\\/script>'\n        : '<script data-dojo-config=\"async:1\" src=\"' + ui.loaderPath + '\"><\\/script>'\n      );\n    </script>\n    <script>\n      if (ui.urlParams.loader == 'none') {\n        mixinPrereqs(_);\n        document.write([\n          '<script src=\"../node_modules/jquery/dist/jquery.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/backbone.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/setup/dom-setup.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/setup/environment.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/noconflict.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/events.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/model.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/collection.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/router.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/view.js\"><\\/script>',\n          '<script src=\"../vendor/backbone/test/sync.js\"><\\/script>'\n        ].join('\\n'));\n      }\n    </script>\n    <script>\n      (function() {\n        if (window.curl) {\n          curl.config({ 'apiName': 'require' });\n        }\n        if (!window.require) {\n          return;\n        }\n        var reBasename = /[\\w.-]+$/,\n            basePath = ('//' + location.host + location.pathname.replace(reBasename, '')).replace(/\\btest\\/$/, ''),\n            modulePath = ui.buildPath.replace(/\\.js$/, ''),\n            locationPath = modulePath.replace(reBasename, '').replace(/^\\/|\\/$/g, ''),\n            moduleMain = modulePath.match(reBasename)[0],\n            uid = +new Date;\n\n        function getConfig() {\n          var result = {\n            'baseUrl': './',\n            'urlArgs': 't=' + uid++,\n            'waitSeconds': 0,\n            'paths': {\n              'backbone': '../vendor/backbone/backbone',\n              'jquery': '../node_modules/jquery/dist/jquery'\n            },\n            'packages': [{\n              'name': 'test',\n              'location': '../vendor/backbone/test',\n              'config': {\n                // Work around no global being exported.\n                'exports': 'QUnit',\n                'loader': 'curl/loader/legacy'\n              }\n            }]\n          };\n\n          if (ui.isModularize) {\n            result.packages.push({\n              'name': 'underscore',\n              'location': locationPath,\n              'main': moduleMain\n            });\n          } else {\n            result.paths.underscore = modulePath;\n          }\n          return result;\n        }\n\n        QUnit.config.autostart = false;\n\n        require(getConfig(), ['underscore'], function(lodash) {\n          _ = mixinPrereqs(lodash);\n          require(getConfig(), ['backbone'], function() {\n            require(getConfig(), [\n              'test/setup/dom-setup',\n              'test/setup/environment',\n              'test/noconflict',\n              'test/events',\n              'test/model',\n              'test/collection',\n              'test/router',\n              'test/view',\n              'test/sync'\n            ], QUnit.start);\n          });\n        });\n      }());\n    </script>\n  </body>\n</html>\n",
            language: 'html',
            size: 5640,
            tokens: 534,
            lastModified: '2025-07-02T12:28:22.848Z',
          },
          {
            name: 'fp.html',
            path: 'test/fp.html',
            type: 'file',
            content:
              '<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <title>lodash-fp Test Suite</title>\n    <link rel="stylesheet" href="../node_modules/qunitjs/qunit/qunit.css">\n  </head>\n  <body>\n    <script>\n      // Avoid reporting tests to Sauce Labs when script errors occur.\n      if (location.port == \'9001\') {\n        window.onerror = function(message) {\n          if (window.QUnit) {\n            QUnit.config.done.length = 0;\n          }\n          global_test_results = { \'message\': message };\n        };\n      }\n    </script>\n    <script src="../lodash.js"></script>\n    <script src="../dist/lodash.fp.js"></script>\n    <script src="../dist/mapping.fp.js"></script>\n    <script src="../node_modules/qunitjs/qunit/qunit.js"></script>\n    <script src="../node_modules/qunit-extras/qunit-extras.js"></script>\n    <script src="../node_modules/platform/platform.js"></script>\n    <script src="./test-fp.js"></script>\n    <div id="qunit"></div>\n    <script>\n      // Set a more readable browser name.\n      window.onload = function() {\n        var timeoutId = setInterval(function() {\n          var ua = document.getElementById(\'qunit-userAgent\');\n          if (ua) {\n            ua.innerHTML = platform;\n            clearInterval(timeoutId);\n          }\n        }, 16);\n      };\n    </script>\n  </body>\n</html>\n',
            language: 'html',
            size: 1322,
            tokens: 172,
            lastModified: '2025-07-02T12:28:22.848Z',
          },
          {
            name: 'index.html',
            path: 'test/index.html',
            type: 'file',
            content:
              "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>lodash Test Suite</title>\n    <link rel=\"stylesheet\" href=\"../node_modules/qunitjs/qunit/qunit.css\">\n    <style>\n      #exports, #module {\n        display: none;\n      }\n    </style>\n  </head>\n  <body>\n    <script>\n      // Avoid reporting tests to Sauce Labs when script errors occur.\n      if (location.port == '9001') {\n        window.onerror = function(message) {\n          if (window.QUnit) {\n            QUnit.config.done.length = 0;\n          }\n          global_test_results = { 'message': message };\n        };\n      }\n    </script>\n    <script src=\"../node_modules/lodash/lodash.js\"></script>\n    <script>var lodashStable = _.noConflict();</script>\n    <script src=\"../node_modules/qunitjs/qunit/qunit.js\"></script>\n    <script src=\"../node_modules/qunit-extras/qunit-extras.js\"></script>\n    <script src=\"../node_modules/platform/platform.js\"></script>\n    <script src=\"./asset/test-ui.js\"></script>\n    <div id=\"qunit\"></div>\n    <div id=\"exports\"></div>\n    <div id=\"module\"></div>\n    <script>\n      function setProperty(object, key, value) {\n        try {\n          Object.defineProperty(object, key, {\n            'configurable': true,\n            'enumerable': false,\n            'writable': true,\n            'value': value\n          });\n        } catch (e) {\n          object[key] = value;\n        }\n        return object;\n      }\n\n      function addBizarroMethods() {\n        var funcProto = Function.prototype,\n            objectProto = Object.prototype;\n\n        var hasOwnProperty = objectProto.hasOwnProperty,\n            fnToString = funcProto.toString,\n            nativeString = fnToString.call(objectProto.toString),\n            noop = function() {},\n            propertyIsEnumerable = objectProto.propertyIsEnumerable,\n            reToString = /toString/g;\n\n        function constant(value) {\n          return function() {\n            return value;\n          };\n        }\n\n        function createToString(funcName) {\n          return constant(nativeString.replace(reToString, funcName));\n        }\n\n        // Allow bypassing native checks.\n        setProperty(funcProto, 'toString', (function() {\n          function wrapper() {\n            setProperty(funcProto, 'toString', fnToString);\n            var result = hasOwnProperty.call(this, 'toString') ? this.toString() : fnToString.call(this);\n            setProperty(funcProto, 'toString', wrapper);\n            return result;\n          }\n          return wrapper;\n        }()));\n\n        // Add prototype extensions.\n        funcProto._method = noop;\n\n        // Set bad shims.\n        setProperty(Object, '_create', Object.create);\n        setProperty(Object, 'create', undefined);\n\n        setProperty(Object, '_getOwnPropertySymbols', Object.getOwnPropertySymbols);\n        setProperty(Object, 'getOwnPropertySymbols', undefined);\n\n        setProperty(objectProto, '_propertyIsEnumerable', propertyIsEnumerable);\n        setProperty(objectProto, 'propertyIsEnumerable', function(key) {\n          return !(key == 'valueOf' && this && this.valueOf === 1) && _propertyIsEnumerable.call(this, key);\n        });\n\n        setProperty(window, '_Map', window.Map);\n        if (_Map) {\n          setProperty(window, 'Map', (function(Map) {\n            var count = 0;\n            return function() {\n              if (count++) {\n                return new Map;\n              }\n              var result = {};\n              setProperty(window, 'Map', Map);\n              return result;\n            };\n          }(_Map)));\n\n          setProperty(Map, 'toString', createToString('Map'));\n        }\n        setProperty(window, '_Promise', window.Promise);\n        setProperty(window, 'Promise', noop);\n\n        setProperty(window, '_Set', window.Set);\n        setProperty(window, 'Set', noop);\n\n        setProperty(window, '_Symbol', window.Symbol);\n        setProperty(window, 'Symbol', undefined);\n\n        setProperty(window, '_WeakMap', window.WeakMap);\n        setProperty(window, 'WeakMap', noop);\n\n        // Fake `WinRTError`.\n        setProperty(window, 'WinRTError', Error);\n\n        // Fake free variable `global`.\n        setProperty(window, 'exports', window);\n        setProperty(window, 'global', window);\n        setProperty(window, 'module', {});\n      }\n\n      function removeBizarroMethods() {\n        var funcProto = Function.prototype,\n            objectProto = Object.prototype;\n\n        setProperty(objectProto, 'propertyIsEnumerable', objectProto._propertyIsEnumerable);\n\n        if (Object._create) {\n          Object.create = Object._create;\n        } else {\n          delete Object.create;\n        }\n        if (Object._getOwnPropertySymbols) {\n          Object.getOwnPropertySymbols = Object._getOwnPropertySymbols;\n        } else {\n          delete Object.getOwnPropertySymbols;\n        }\n        if (_Map) {\n          Map = _Map;\n        } else {\n          setProperty(window, 'Map', undefined);\n        }\n        if (_Promise) {\n          Promise = _Promise;\n        } else {\n          setProperty(window, 'Promise', undefined);\n        }\n        if (_Set) {\n          Set = _Set;\n        } else {\n          setProperty(window, 'Set', undefined);\n        }\n        if (_Symbol) {\n          Symbol = _Symbol;\n        }\n        if (_WeakMap) {\n          WeakMap = _WeakMap;\n        } else {\n          setProperty(window, 'WeakMap', undefined);\n        }\n        setProperty(window, '_Map', undefined);\n        setProperty(window, '_Promise', undefined);\n        setProperty(window, '_Set', undefined);\n        setProperty(window, '_Symbol', undefined);\n        setProperty(window, '_WeakMap', undefined);\n\n        setProperty(window, 'WinRTError', undefined);\n\n        setProperty(window, 'exports', document.getElementById('exports'));\n        setProperty(window, 'global', undefined);\n        setProperty(window, 'module', document.getElementById('module'));\n\n        delete funcProto._method;\n        delete Object._create;\n        delete Object._getOwnPropertySymbols;\n        delete objectProto._propertyIsEnumerable;\n      }\n\n      // Load lodash to expose it to the bad extensions/shims.\n      if (!ui.isModularize) {\n        addBizarroMethods();\n        document.write('<script src=\"' + ui.buildPath + '\"><\\/script>');\n      }\n    </script>\n    <script>\n      // Store lodash to test for bad extensions/shims.\n      if (!ui.isModularize) {\n        var lodashBizarro = window._;\n        window._ = undefined;\n        removeBizarroMethods();\n      }\n      // Load test scripts.\n      document.write((ui.isForeign || ui.urlParams.loader == 'none')\n        ? '<script src=\"' + ui.buildPath + '\"><\\/script><script src=\"test.js\"><\\/script>'\n        : '<script data-dojo-config=\"async:1\" src=\"' + ui.loaderPath + '\"><\\/script>'\n      );\n    </script>\n    <script>\n      var lodashModule,\n          shimmedModule,\n          underscoreModule;\n\n      (function() {\n        if (window.curl) {\n          curl.config({ 'apiName': 'require' });\n        }\n        if (ui.isForeign || !window.require) {\n          return;\n        }\n        var reBasename = /[\\w.-]+$/,\n            basePath = ('//' + location.host + location.pathname.replace(reBasename, '')).replace(/\\btest\\/$/, ''),\n            modulePath = ui.buildPath.replace(/\\.js$/, ''),\n            moduleMain = modulePath.match(reBasename)[0],\n            locationPath = modulePath.replace(reBasename, '').replace(/^\\/|\\/$/g, ''),\n            shimmedLocationPath = './abc/../' + locationPath,\n            underscoreLocationPath = './xyz/../' + locationPath,\n            uid = +new Date;\n\n        function getConfig() {\n          var result = {\n            'baseUrl': './',\n            'urlArgs': 't=' + uid++,\n            'waitSeconds': 0,\n            'paths': {},\n            'packages': [{\n              'name': 'test',\n              'location': basePath + 'test',\n              'main': 'test',\n              'config': {\n                // Work around no global being exported.\n                'exports': 'QUnit',\n                'loader': 'curl/loader/legacy'\n              }\n            }],\n            'shim': {\n              'shimmed': {\n                'exports': '_'\n              }\n            }\n          };\n\n          if (ui.isModularize) {\n            result.packages.push({\n              'name': 'lodash',\n              'location': locationPath,\n              'main': moduleMain\n            }, {\n              'name': 'shimmed',\n              'location': shimmedLocationPath,\n              'main': moduleMain\n            }, {\n              'name': 'underscore',\n              'location': underscoreLocationPath,\n              'main': moduleMain\n            });\n          } else {\n            result.paths.lodash = modulePath;\n            result.paths.shimmed = shimmedLocationPath + '/' + moduleMain;\n            result.paths.underscore = underscoreLocationPath + '/' + moduleMain;\n          }\n          return result;\n        }\n\n        function loadTests() {\n          require(getConfig(), ['test'], function() {\n            QUnit.start();\n          });\n        }\n\n        function loadModulesAndTests() {\n          require(getConfig(), ['lodash', 'shimmed', 'underscore'], function(lodash, shimmed, underscore) {\n            lodashModule = lodash;\n            lodashModule.moduleName = 'lodash';\n\n            if (shimmed) {\n              shimmedModule = shimmed.result(shimmed, 'noConflict') || shimmed;\n              shimmedModule.moduleName = 'shimmed';\n            }\n            if (underscore) {\n              underscoreModule = underscore.result(underscore, 'noConflict') || underscore;\n              underscoreModule.moduleName = 'underscore';\n            }\n            window._ = lodash;\n\n            if (ui.isModularize) {\n              require(getConfig(), [\n                'lodash/_baseEach',\n                'lodash/_isIndex',\n                'lodash/_isIterateeCall'\n              ], function(baseEach, isIndex, isIterateeCall) {\n                lodash._baseEach = baseEach;\n                lodash._isIndex = isIndex;\n                lodash._isIterateeCall = isIterateeCall;\n                loadTests();\n              });\n            } else {\n              loadTests();\n            }\n          });\n        }\n\n        QUnit.config.autostart = false;\n\n        if (window.requirejs) {\n          addBizarroMethods();\n          require(getConfig(), ['lodash'], function(lodash) {\n            lodashBizarro = lodash.result(lodash, 'noConflict') || lodash;\n            delete requirejs.s.contexts._;\n\n            removeBizarroMethods();\n            loadModulesAndTests();\n          });\n        } else {\n          loadModulesAndTests();\n        }\n      }());\n\n      // Set a more readable browser name.\n      window.onload = function() {\n        var timeoutId = setInterval(function() {\n          var ua = document.getElementById('qunit-userAgent');\n          if (ua) {\n            ua.innerHTML = platform;\n            clearInterval(timeoutId);\n          }\n        }, 16);\n      };\n    </script>\n  </body>\n</html>\n",
            language: 'html',
            size: 11064,
            tokens: 941,
            lastModified: '2025-07-02T12:28:22.848Z',
          },
          {
            name: 'remove.js',
            path: 'test/remove.js',
            type: 'file',
            content:
              "#!/usr/bin/env node\n'use strict';\n\nvar _ = require('../lodash'),\n    fs = require('fs'),\n    path = require('path');\n\nvar args = (args = process.argv)\n  .slice((args[0] === process.execPath || args[0] === 'node') ? 2 : 0);\n\nvar filePath = path.resolve(args[1]),\n    reLine = /.*/gm;\n\nvar pattern = (function() {\n  var result = args[0],\n      delimiter = result.charAt(0),\n      lastIndex = result.lastIndexOf(delimiter);\n\n  return RegExp(result.slice(1, lastIndex), result.slice(lastIndex + 1));\n}());\n\n/*----------------------------------------------------------------------------*/\n\nfs.writeFileSync(filePath, fs.readFileSync(filePath, 'utf8').replace(pattern, function(match) {\n  var snippet = _.slice(arguments, -3, -2)[0];\n  return match.replace(snippet, snippet.replace(reLine, ''));\n}));\n",
            language: 'javascript',
            size: 795,
            tokens: 104,
            lastModified: '2025-07-02T12:28:22.848Z',
          },
          {
            name: 'saucelabs.js',
            path: 'test/saucelabs.js',
            type: 'file',
            content:
              "#!/usr/bin/env node\n'use strict';\n\n/** Environment shortcut. */\nvar env = process.env;\n\n/** Load Node.js modules. */\nvar EventEmitter = require('events').EventEmitter,\n    http = require('http'),\n    path = require('path'),\n    url = require('url'),\n    util = require('util');\n\n/** Load other modules. */\nvar _ = require('../lodash.js'),\n    chalk = require('chalk'),\n    ecstatic = require('ecstatic'),\n    request = require('request'),\n    SauceTunnel = require('sauce-tunnel');\n\n/** Used for Sauce Labs credentials. */\nvar accessKey = env.SAUCE_ACCESS_KEY,\n    username = env.SAUCE_USERNAME;\n\n/** Used as the default maximum number of times to retry a job and tunnel. */\nvar maxJobRetries = 3,\n    maxTunnelRetries = 3;\n\n/** Used as the static file server middleware. */\nvar mount = ecstatic({\n  'cache': 'no-cache',\n  'root': process.cwd()\n});\n\n/** Used as the list of ports supported by Sauce Connect. */\nvar ports = [\n  80, 443, 888, 2000, 2001, 2020, 2109, 2222, 2310, 3000, 3001, 3030, 3210,\n  3333, 4000, 4001, 4040, 4321, 4502, 4503, 4567, 5000, 5001, 5050, 5555, 5432,\n  6000, 6001, 6060, 6666, 6543, 7000, 7070, 7774, 7777, 8000, 8001, 8003, 8031,\n  8080, 8081, 8765, 8777, 8888, 9000, 9001, 9080, 9090, 9876, 9877, 9999, 49221,\n  55001\n];\n\n/** Used by `logInline` to clear previously logged messages. */\nvar prevLine = '';\n\n/** Method shortcut. */\nvar push = Array.prototype.push;\n\n/** Used to detect error messages. */\nvar reError = /(?:\\be|E)rror\\b/;\n\n/** Used to detect valid job ids. */\nvar reJobId = /^[a-z0-9]{32}$/;\n\n/** Used to display the wait throbber. */\nvar throbberDelay = 500,\n    waitCount = -1;\n\n/**\n * Used as Sauce Labs config values.\n * See the [Sauce Labs documentation](https://docs.saucelabs.com/reference/test-configuration/)\n * for more details.\n */\nvar advisor = getOption('advisor', false),\n    build = getOption('build', (env.TRAVIS_COMMIT || '').slice(0, 10)),\n    commandTimeout = getOption('commandTimeout', 90),\n    compatMode = getOption('compatMode', null),\n    customData = Function('return {' + getOption('customData', '').replace(/^\\{|}$/g, '') + '}')(),\n    deviceOrientation = getOption('deviceOrientation', 'portrait'),\n    framework = getOption('framework', 'qunit'),\n    idleTimeout = getOption('idleTimeout', 60),\n    jobName = getOption('name', 'unit tests'),\n    maxDuration = getOption('maxDuration', 180),\n    port = ports[Math.min(_.sortedIndex(ports, getOption('port', 9001)), ports.length - 1)],\n    publicAccess = getOption('public', true),\n    queueTimeout = getOption('queueTimeout', 240),\n    recordVideo = getOption('recordVideo', true),\n    recordScreenshots = getOption('recordScreenshots', false),\n    runner = getOption('runner', 'test/index.html').replace(/^\\W+/, ''),\n    runnerUrl = getOption('runnerUrl', 'http://localhost:' + port + '/' + runner),\n    statusInterval = getOption('statusInterval', 5),\n    tags = getOption('tags', []),\n    throttled = getOption('throttled', 10),\n    tunneled = getOption('tunneled', true),\n    tunnelId = getOption('tunnelId', 'tunnel_' + (env.TRAVIS_JOB_ID || 0)),\n    tunnelTimeout = getOption('tunnelTimeout', 120),\n    videoUploadOnPass = getOption('videoUploadOnPass', false);\n\n/** Used to convert Sauce Labs browser identifiers to their formal names. */\nvar browserNameMap = {\n  'googlechrome': 'Chrome',\n  'iehta': 'Internet Explorer',\n  'ipad': 'iPad',\n  'iphone': 'iPhone',\n  'microsoftedge': 'Edge'\n};\n\n/** List of platforms to load the runner on. */\nvar platforms = [\n  ['Linux', 'android', '5.1'],\n  ['Windows 10', 'chrome', '54'],\n  ['Windows 10', 'chrome', '53'],\n  ['Windows 10', 'firefox', '50'],\n  ['Windows 10', 'firefox', '49'],\n  ['Windows 10', 'microsoftedge', '14'],\n  ['Windows 10', 'internet explorer', '11'],\n  ['Windows 8', 'internet explorer', '10'],\n  ['Windows 7', 'internet explorer', '9'],\n  ['macOS 10.12', 'safari', '10'],\n  ['OS X 10.11', 'safari', '9']\n];\n\n/** Used to tailor the `platforms` array. */\nvar isAMD = _.includes(tags, 'amd'),\n    isBackbone = _.includes(tags, 'backbone'),\n    isModern = _.includes(tags, 'modern');\n\n// The platforms to test IE compatibility modes.\nif (compatMode) {\n  platforms = [\n    ['Windows 10', 'internet explorer', '11'],\n    ['Windows 8', 'internet explorer', '10'],\n    ['Windows 7', 'internet explorer', '9'],\n    ['Windows 7', 'internet explorer', '8']\n  ];\n}\n// The platforms for AMD tests.\nif (isAMD) {\n  platforms = _.filter(platforms, function(platform) {\n    var browser = browserName(platform[1]),\n        version = +platform[2];\n\n    switch (browser) {\n      case 'Android': return version >= 4.4;\n      case 'Opera': return version >= 10;\n    }\n    return true;\n  });\n}\n// The platforms for Backbone tests.\nif (isBackbone) {\n  platforms = _.filter(platforms, function(platform) {\n    var browser = browserName(platform[1]),\n        version = +platform[2];\n\n    switch (browser) {\n      case 'Firefox': return version >= 4;\n      case 'Internet Explorer': return version >= 7;\n      case 'iPad': return version >= 5;\n      case 'Opera': return version >= 12;\n    }\n    return true;\n  });\n}\n// The platforms for modern builds.\nif (isModern) {\n  platforms = _.filter(platforms, function(platform) {\n    var browser = browserName(platform[1]),\n        version = +platform[2];\n\n    switch (browser) {\n      case 'Android': return version >= 4.1;\n      case 'Firefox': return version >= 10;\n      case 'Internet Explorer': return version >= 9;\n      case 'iPad': return version >= 6;\n      case 'Opera': return version >= 12;\n      case 'Safari': return version >= 6;\n    }\n    return true;\n  });\n}\n\n/** Used as the default `Job` options object. */\nvar jobOptions = {\n  'build': build,\n  'command-timeout': commandTimeout,\n  'custom-data': customData,\n  'device-orientation': deviceOrientation,\n  'framework': framework,\n  'idle-timeout': idleTimeout,\n  'max-duration': maxDuration,\n  'name': jobName,\n  'public': publicAccess,\n  'platforms': platforms,\n  'record-screenshots': recordScreenshots,\n  'record-video': recordVideo,\n  'sauce-advisor': advisor,\n  'tags': tags,\n  'url': runnerUrl,\n  'video-upload-on-pass': videoUploadOnPass\n};\n\nif (publicAccess === true) {\n  jobOptions['public'] = 'public';\n}\nif (tunneled) {\n  jobOptions['tunnel-identifier'] = tunnelId;\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * Resolves the formal browser name for a given Sauce Labs browser identifier.\n *\n * @private\n * @param {string} identifier The browser identifier.\n * @returns {string} Returns the formal browser name.\n */\nfunction browserName(identifier) {\n  return browserNameMap[identifier] || _.startCase(identifier);\n}\n\n/**\n * Gets the value for the given option name. If no value is available the\n * `defaultValue` is returned.\n *\n * @private\n * @param {string} name The name of the option.\n * @param {*} defaultValue The default option value.\n * @returns {*} Returns the option value.\n */\nfunction getOption(name, defaultValue) {\n  var isArr = _.isArray(defaultValue);\n  return _.reduce(process.argv, function(result, value) {\n    if (isArr) {\n      value = optionToArray(name, value);\n      return _.isEmpty(value) ? result : value;\n    }\n    value = optionToValue(name, value);\n\n    return value == null ? result : value;\n  }, defaultValue);\n}\n\n/**\n * Checks if `value` is a job ID.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a job ID, else `false`.\n */\nfunction isJobId(value) {\n  return reJobId.test(value);\n}\n\n/**\n * Writes an inline message to standard output.\n *\n * @private\n * @param {string} [text=''] The text to log.\n */\nfunction logInline(text) {\n  var blankLine = _.repeat(' ', _.size(prevLine));\n  prevLine = text = _.truncate(text, { 'length': 40 });\n  process.stdout.write(text + blankLine.slice(text.length) + '\\r');\n}\n\n/**\n * Writes the wait throbber to standard output.\n *\n * @private\n */\nfunction logThrobber() {\n  logInline('Please wait' + _.repeat('.', (++waitCount % 3) + 1));\n}\n\n/**\n * Converts a comma separated option value into an array.\n *\n * @private\n * @param {string} name The name of the option to inspect.\n * @param {string} string The options string.\n * @returns {Array} Returns the new converted array.\n */\nfunction optionToArray(name, string) {\n  return _.compact(_.invokeMap((optionToValue(name, string) || '').split(/, */), 'trim'));\n}\n\n/**\n * Extracts the option value from an option string.\n *\n * @private\n * @param {string} name The name of the option to inspect.\n * @param {string} string The options string.\n * @returns {string|undefined} Returns the option value, else `undefined`.\n */\nfunction optionToValue(name, string) {\n  var result = string.match(RegExp('^' + name + '(?:=([\\\\s\\\\S]+))?$'));\n  if (result) {\n    result = _.get(result, 1);\n    result = result ? _.trim(result) : true;\n  }\n  if (result === 'false') {\n    return false;\n  }\n  return result || undefined;\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * The `Job#remove` and `Tunnel#stop` callback used by `Jobs#restart`\n * and `Tunnel#restart` respectively.\n *\n * @private\n */\nfunction onGenericRestart() {\n  this.restarting = false;\n  this.emit('restart');\n  this.start();\n}\n\n/**\n * The `request.put` and `SauceTunnel#stop` callback used by `Jobs#stop`\n * and `Tunnel#stop` respectively.\n *\n * @private\n * @param {Object} [error] The error object.\n */\nfunction onGenericStop(error) {\n  this.running = this.stopping = false;\n  this.emit('stop', error);\n}\n\n/**\n * The `request.del` callback used by `Jobs#remove`.\n *\n * @private\n */\nfunction onJobRemove(error, res, body) {\n  this.id = this.taskId = this.url = null;\n  this.removing = false;\n  this.emit('remove');\n}\n\n/**\n * The `Job#remove` callback used by `Jobs#reset`.\n *\n * @private\n */\nfunction onJobReset() {\n  this.attempts = 0;\n  this.failed = this.resetting = false;\n  this._pollerId = this.id = this.result = this.taskId = this.url = null;\n  this.emit('reset');\n}\n\n/**\n * The `request.post` callback used by `Jobs#start`.\n *\n * @private\n * @param {Object} [error] The error object.\n * @param {Object} res The response data object.\n * @param {Object} body The response body JSON object.\n */\nfunction onJobStart(error, res, body) {\n  this.starting = false;\n\n  if (this.stopping) {\n    return;\n  }\n  var statusCode = _.get(res, 'statusCode'),\n      taskId = _.first(_.get(body, 'js tests'));\n\n  if (error || !taskId || statusCode != 200) {\n    if (this.attempts < this.retries) {\n      this.restart();\n      return;\n    }\n    var na = 'unavailable',\n        bodyStr = _.isObject(body) ? '\\n' + JSON.stringify(body) : na,\n        statusStr = _.isFinite(statusCode) ? statusCode : na;\n\n    logInline();\n    console.error('Failed to start job; status: %s, body: %s', statusStr, bodyStr);\n    if (error) {\n      console.error(error);\n    }\n    this.failed = true;\n    this.emit('complete');\n    return;\n  }\n  this.running = true;\n  this.taskId = taskId;\n  this.timestamp = _.now();\n  this.emit('start');\n  this.status();\n}\n\n/**\n * The `request.post` callback used by `Job#status`.\n *\n * @private\n * @param {Object} [error] The error object.\n * @param {Object} res The response data object.\n * @param {Object} body The response body JSON object.\n */\nfunction onJobStatus(error, res, body) {\n  this.checking = false;\n\n  if (!this.running || this.stopping) {\n    return;\n  }\n  var completed = _.get(body, 'completed', false),\n      data = _.first(_.get(body, 'js tests')),\n      elapsed = (_.now() - this.timestamp) / 1000,\n      jobId = _.get(data, 'job_id', null),\n      jobResult = _.get(data, 'result', null),\n      jobStatus = _.get(data, 'status', ''),\n      jobUrl = _.get(data, 'url', null),\n      expired = (elapsed >= queueTimeout && !_.includes(jobStatus, 'in progress')),\n      options = this.options,\n      platform = options.platforms[0];\n\n  if (_.isObject(jobResult)) {\n    var message = _.get(jobResult, 'message');\n  } else {\n    if (typeof jobResult == 'string') {\n      message = jobResult;\n    }\n    jobResult = null;\n  }\n  if (isJobId(jobId)) {\n    this.id = jobId;\n    this.result = jobResult;\n    this.url = jobUrl;\n  } else {\n    completed = false;\n  }\n  this.emit('status', jobStatus);\n\n  if (!completed && !expired) {\n    this._pollerId = _.delay(_.bind(this.status, this), this.statusInterval * 1000);\n    return;\n  }\n  var description = browserName(platform[1]) + ' ' + platform[2] + ' on ' + _.startCase(platform[0]),\n      errored = !jobResult || !jobResult.passed || reError.test(message) || reError.test(jobStatus),\n      failures = _.get(jobResult, 'failed'),\n      label = options.name + ':',\n      tunnel = this.tunnel;\n\n  if (errored || failures) {\n    if (errored && this.attempts < this.retries) {\n      this.restart();\n      return;\n    }\n    var details = 'See ' + jobUrl + ' for details.';\n    this.failed = true;\n\n    logInline();\n    if (failures) {\n      console.error(label + ' %s ' + chalk.red('failed') + ' %d test' + (failures > 1 ? 's' : '') + '. %s', description, failures, details);\n    }\n    else if (tunnel.attempts < tunnel.retries) {\n      tunnel.restart();\n      return;\n    }\n    else {\n      if (message === undefined) {\n        message = 'Results are unavailable. ' + details;\n      }\n      console.error(label, description, chalk.red('failed') + ';', message);\n    }\n  }\n  else {\n    logInline();\n    console.log(label, description, chalk.green('passed'));\n  }\n  this.running = false;\n  this.emit('complete');\n}\n\n/**\n * The `SauceTunnel#start` callback used by `Tunnel#start`.\n *\n * @private\n * @param {boolean} success The connection success indicator.\n */\nfunction onTunnelStart(success) {\n  this.starting = false;\n\n  if (this._timeoutId) {\n    clearTimeout(this._timeoutId);\n    this._timeoutId = null;\n  }\n  if (!success) {\n    if (this.attempts < this.retries) {\n      this.restart();\n      return;\n    }\n    logInline();\n    console.error('Failed to open Sauce Connect tunnel');\n    process.exit(2);\n  }\n  logInline();\n  console.log('Sauce Connect tunnel opened');\n\n  var jobs = this.jobs;\n  push.apply(jobs.queue, jobs.all);\n\n  this.running = true;\n  this.emit('start');\n\n  console.log('Starting jobs...');\n  this.dequeue();\n}\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * The Job constructor.\n *\n * @private\n * @param {Object} [properties] The properties to initialize a job with.\n */\nfunction Job(properties) {\n  EventEmitter.call(this);\n\n  this.options = {};\n  _.merge(this, properties);\n  _.defaults(this.options, _.cloneDeep(jobOptions));\n\n  this.attempts = 0;\n  this.checking = this.failed = this.removing = this.resetting = this.restarting = this.running = this.starting = this.stopping = false;\n  this._pollerId = this.id = this.result = this.taskId = this.url = null;\n}\n\nutil.inherits(Job, EventEmitter);\n\n/**\n * Removes the job.\n *\n * @memberOf Job\n * @param {Function} callback The function called once the job is removed.\n * @param {Object} Returns the job instance.\n */\nJob.prototype.remove = function(callback) {\n  this.once('remove', _.iteratee(callback));\n  if (this.removing) {\n    return this;\n  }\n  this.removing = true;\n  return this.stop(function() {\n    var onRemove = _.bind(onJobRemove, this);\n    if (!this.id) {\n      _.defer(onRemove);\n      return;\n    }\n    request.del(_.template('https://saucelabs.com/rest/v1/${user}/jobs/${id}')(this), {\n      'auth': { 'user': this.user, 'pass': this.pass }\n    }, onRemove);\n  });\n};\n\n/**\n * Resets the job.\n *\n * @memberOf Job\n * @param {Function} callback The function called once the job is reset.\n * @param {Object} Returns the job instance.\n */\nJob.prototype.reset = function(callback) {\n  this.once('reset', _.iteratee(callback));\n  if (this.resetting) {\n    return this;\n  }\n  this.resetting = true;\n  return this.remove(onJobReset);\n};\n\n/**\n * Restarts the job.\n *\n * @memberOf Job\n * @param {Function} callback The function called once the job is restarted.\n * @param {Object} Returns the job instance.\n */\nJob.prototype.restart = function(callback) {\n  this.once('restart', _.iteratee(callback));\n  if (this.restarting) {\n    return this;\n  }\n  this.restarting = true;\n\n  var options = this.options,\n      platform = options.platforms[0],\n      description = browserName(platform[1]) + ' ' + platform[2] + ' on ' + _.startCase(platform[0]),\n      label = options.name + ':';\n\n  logInline();\n  console.log('%s %s restart %d of %d', label, description, ++this.attempts, this.retries);\n\n  return this.remove(onGenericRestart);\n};\n\n/**\n * Starts the job.\n *\n * @memberOf Job\n * @param {Function} callback The function called once the job is started.\n * @param {Object} Returns the job instance.\n */\nJob.prototype.start = function(callback) {\n  this.once('start', _.iteratee(callback));\n  if (this.starting || this.running) {\n    return this;\n  }\n  this.starting = true;\n  request.post(_.template('https://saucelabs.com/rest/v1/${user}/js-tests')(this), {\n    'auth': { 'user': this.user, 'pass': this.pass },\n    'json': this.options\n  }, _.bind(onJobStart, this));\n\n  return this;\n};\n\n/**\n * Checks the status of a job.\n *\n * @memberOf Job\n * @param {Function} callback The function called once the status is resolved.\n * @param {Object} Returns the job instance.\n */\nJob.prototype.status = function(callback) {\n  this.once('status', _.iteratee(callback));\n  if (this.checking || this.removing || this.resetting || this.restarting || this.starting || this.stopping) {\n    return this;\n  }\n  this._pollerId = null;\n  this.checking = true;\n  request.post(_.template('https://saucelabs.com/rest/v1/${user}/js-tests/status')(this), {\n    'auth': { 'user': this.user, 'pass': this.pass },\n    'json': { 'js tests': [this.taskId] }\n  }, _.bind(onJobStatus, this));\n\n  return this;\n};\n\n/**\n * Stops the job.\n *\n * @memberOf Job\n * @param {Function} callback The function called once the job is stopped.\n * @param {Object} Returns the job instance.\n */\nJob.prototype.stop = function(callback) {\n  this.once('stop', _.iteratee(callback));\n  if (this.stopping) {\n    return this;\n  }\n  this.stopping = true;\n  if (this._pollerId) {\n    clearTimeout(this._pollerId);\n    this._pollerId = null;\n    this.checking = false;\n  }\n  var onStop = _.bind(onGenericStop, this);\n  if (!this.running || !this.id) {\n    _.defer(onStop);\n    return this;\n  }\n  request.put(_.template('https://saucelabs.com/rest/v1/${user}/jobs/${id}/stop')(this), {\n    'auth': { 'user': this.user, 'pass': this.pass }\n  }, onStop);\n\n  return this;\n};\n\n/*----------------------------------------------------------------------------*/\n\n/**\n * The Tunnel constructor.\n *\n * @private\n * @param {Object} [properties] The properties to initialize the tunnel with.\n */\nfunction Tunnel(properties) {\n  EventEmitter.call(this);\n\n  _.merge(this, properties);\n\n  var active = [],\n      queue = [];\n\n  var all = _.map(this.platforms, _.bind(function(platform) {\n    return new Job(_.merge({\n      'user': this.user,\n      'pass': this.pass,\n      'tunnel': this,\n      'options': { 'platforms': [platform] }\n    }, this.job));\n  }, this));\n\n  var completed = 0,\n      restarted = [],\n      success = true,\n      total = all.length,\n      tunnel = this;\n\n  _.invokeMap(all, 'on', 'complete', function() {\n    _.pull(active, this);\n    if (success) {\n      success = !this.failed;\n    }\n    if (++completed == total) {\n      tunnel.stop(_.partial(tunnel.emit, 'complete', success));\n      return;\n    }\n    tunnel.dequeue();\n  });\n\n  _.invokeMap(all, 'on', 'restart', function() {\n    if (!_.includes(restarted, this)) {\n      restarted.push(this);\n    }\n    // Restart tunnel if all active jobs have restarted.\n    var threshold = Math.min(all.length, _.isFinite(throttled) ? throttled : 3);\n    if (tunnel.attempts < tunnel.retries &&\n        active.length >= threshold && _.isEmpty(_.difference(active, restarted))) {\n      tunnel.restart();\n    }\n  });\n\n  this.on('restart', function() {\n    completed = 0;\n    success = true;\n    restarted.length = 0;\n  });\n\n  this._timeoutId = null;\n  this.attempts = 0;\n  this.restarting = this.running = this.starting = this.stopping = false;\n  this.jobs = { 'active': active, 'all': all, 'queue': queue };\n  this.connection = new SauceTunnel(this.user, this.pass, this.id, this.tunneled, ['-P', '0']);\n}\n\nutil.inherits(Tunnel, EventEmitter);\n\n/**\n * Restarts the tunnel.\n *\n * @memberOf Tunnel\n * @param {Function} callback The function called once the tunnel is restarted.\n */\nTunnel.prototype.restart = function(callback) {\n  this.once('restart', _.iteratee(callback));\n  if (this.restarting) {\n    return this;\n  }\n  this.restarting = true;\n\n  logInline();\n  console.log('Tunnel %s: restart %d of %d', this.id, ++this.attempts, this.retries);\n\n  var jobs = this.jobs,\n      active = jobs.active,\n      all = jobs.all;\n\n  var reset = _.after(all.length, _.bind(this.stop, this, onGenericRestart)),\n      stop = _.after(active.length, _.partial(_.invokeMap, all, 'reset', reset));\n\n  if (_.isEmpty(active)) {\n    _.defer(stop);\n  }\n  if (_.isEmpty(all)) {\n    _.defer(reset);\n  }\n  _.invokeMap(active, 'stop', function() {\n    _.pull(active, this);\n    stop();\n  });\n\n  if (this._timeoutId) {\n    clearTimeout(this._timeoutId);\n    this._timeoutId = null;\n  }\n  return this;\n};\n\n/**\n * Starts the tunnel.\n *\n * @memberOf Tunnel\n * @param {Function} callback The function called once the tunnel is started.\n * @param {Object} Returns the tunnel instance.\n */\nTunnel.prototype.start = function(callback) {\n  this.once('start', _.iteratee(callback));\n  if (this.starting || this.running) {\n    return this;\n  }\n  this.starting = true;\n\n  logInline();\n  console.log('Opening Sauce Connect tunnel...');\n\n  var onStart = _.bind(onTunnelStart, this);\n  if (this.timeout) {\n    this._timeoutId = _.delay(onStart, this.timeout * 1000, false);\n  }\n  this.connection.start(onStart);\n  return this;\n};\n\n/**\n * Removes jobs from the queue and starts them.\n *\n * @memberOf Tunnel\n * @param {Object} Returns the tunnel instance.\n */\nTunnel.prototype.dequeue = function() {\n  var count = 0,\n      jobs = this.jobs,\n      active = jobs.active,\n      queue = jobs.queue,\n      throttled = this.throttled;\n\n  while (queue.length && (active.length < throttled)) {\n    var job = queue.shift();\n    active.push(job);\n    _.delay(_.bind(job.start, job), ++count * 1000);\n  }\n  return this;\n};\n\n/**\n * Stops the tunnel.\n *\n * @memberOf Tunnel\n * @param {Function} callback The function called once the tunnel is stopped.\n * @param {Object} Returns the tunnel instance.\n */\nTunnel.prototype.stop = function(callback) {\n  this.once('stop', _.iteratee(callback));\n  if (this.stopping) {\n    return this;\n  }\n  this.stopping = true;\n\n  logInline();\n  console.log('Shutting down Sauce Connect tunnel...');\n\n  var jobs = this.jobs,\n      active = jobs.active;\n\n  var stop = _.after(active.length, _.bind(function() {\n    var onStop = _.bind(onGenericStop, this);\n    if (this.running) {\n      this.connection.stop(onStop);\n    } else {\n      onStop();\n    }\n  }, this));\n\n  jobs.queue.length = 0;\n  if (_.isEmpty(active)) {\n    _.defer(stop);\n  }\n  _.invokeMap(active, 'stop', function() {\n    _.pull(active, this);\n    stop();\n  });\n\n  if (this._timeoutId) {\n    clearTimeout(this._timeoutId);\n    this._timeoutId = null;\n  }\n  return this;\n};\n\n/*----------------------------------------------------------------------------*/\n\n// Cleanup any inline logs when exited via `ctrl+c`.\nprocess.on('SIGINT', function() {\n  logInline();\n  process.exit();\n});\n\n// Create a web server for the current working directory.\nhttp.createServer(function(req, res) {\n  // See http://msdn.microsoft.com/en-us/library/ff955275(v=vs.85).aspx.\n  if (compatMode && path.extname(url.parse(req.url).pathname) == '.html') {\n    res.setHeader('X-UA-Compatible', 'IE=' + compatMode);\n  }\n  mount(req, res);\n}).listen(port);\n\n// Setup Sauce Connect so we can use this server from Sauce Labs.\nvar tunnel = new Tunnel({\n  'user': username,\n  'pass': accessKey,\n  'id': tunnelId,\n  'job': { 'retries': maxJobRetries, 'statusInterval': statusInterval },\n  'platforms': platforms,\n  'retries': maxTunnelRetries,\n  'throttled': throttled,\n  'tunneled': tunneled,\n  'timeout': tunnelTimeout\n});\n\ntunnel.on('complete', function(success) {\n  process.exit(success ? 0 : 1);\n});\n\ntunnel.start();\n\nsetInterval(logThrobber, throbberDelay);\n",
            language: 'javascript',
            size: 24352,
            tokens: 3043,
            lastModified: '2025-07-02T12:28:22.849Z',
          },
          {
            name: 'test-fp.js',
            path: 'test/test-fp.js',
            type: 'file',
            content:
              ";(function() {\n  'use strict';\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the size to cover large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used as a reference to the global object. */\n  var root = (typeof global == 'object' && global) || this;\n\n  /** Used for native method references. */\n  var arrayProto = Array.prototype;\n\n  /** Method and object shortcuts. */\n  var phantom = root.phantom,\n      argv = root.process && process.argv,\n      document = !phantom && root.document,\n      slice = arrayProto.slice,\n      WeakMap = root.WeakMap;\n\n  /** Math helpers. */\n  var add = function(x, y) { return x + y; },\n      isEven = function(n) { return n % 2 == 0; },\n      isEvenIndex = function(n, index) { return isEven(index); },\n      square = function(n) { return n * n; };\n\n  // Leak to avoid sporadic `noglobals` fails on Edge in Sauce Labs.\n  root.msWDfn = undefined;\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Load QUnit and extras. */\n  var QUnit = root.QUnit || require('qunit-extras');\n\n  /** Load stable Lodash. */\n  var _ = root._ || require('../lodash.js');\n\n  var convert = (function() {\n    var baseConvert = root.fp || require('../fp/_baseConvert.js');\n    if (!root.fp) {\n      return function(name, func, options) {\n        return baseConvert(_, name, func, options);\n      };\n    }\n    return function(name, func, options) {\n      if (typeof name == 'function') {\n        options = func;\n        func = name;\n        name = undefined;\n      }\n      return name === undefined\n        ? baseConvert(func, options)\n        : baseConvert(_.runInContext(), options)[name];\n    };\n  }());\n\n  var allFalseOptions = {\n    'cap': false,\n    'curry': false,\n    'fixed': false,\n    'immutable': false,\n    'rearg': false\n  };\n\n  var fp = root.fp\n    ? (fp = _.noConflict(), _ = root._, fp)\n    : convert(_.runInContext());\n\n  var mapping = root.mapping || require('../fp/_mapping.js');\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Skips a given number of tests with a passing result.\n   *\n   * @private\n   * @param {Object} assert The QUnit assert object.\n   * @param {number} [count=1] The number of tests to skip.\n   */\n  function skipAssert(assert, count) {\n    count || (count = 1);\n    while (count--) {\n      assert.ok(true, 'test skipped');\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  if (argv) {\n    console.log('Running lodash/fp tests.');\n  }\n\n  QUnit.module('convert module');\n\n  (function() {\n    QUnit.test('should work with `name` and `func`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4],\n          remove = convert('remove', _.remove),\n          actual = remove(isEven)(array);\n\n      assert.deepEqual(array, [1, 2, 3, 4]);\n      assert.deepEqual(actual, [1, 3]);\n    });\n\n    QUnit.test('should work with `name`, `func`, and `options`', function(assert) {\n      assert.expect(3);\n\n      var array = [1, 2, 3, 4],\n          remove = convert('remove', _.remove, allFalseOptions);\n\n      var actual = remove(array, function(n, index) {\n        return isEven(index);\n      });\n\n      assert.deepEqual(array, [2, 4]);\n      assert.deepEqual(actual, [1, 3]);\n      assert.deepEqual(remove(), []);\n    });\n\n    QUnit.test('should work with an object', function(assert) {\n      assert.expect(2);\n\n      if (!document) {\n        var array = [1, 2, 3, 4],\n            lodash = convert({ 'remove': _.remove }),\n            actual = lodash.remove(isEven)(array);\n\n        assert.deepEqual(array, [1, 2, 3, 4]);\n        assert.deepEqual(actual, [1, 3]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should work with an object and `options`', function(assert) {\n      assert.expect(3);\n\n      if (!document) {\n        var array = [1, 2, 3, 4],\n            lodash = convert({ 'remove': _.remove }, allFalseOptions),\n            actual = lodash.remove(array, isEvenIndex);\n\n        assert.deepEqual(array, [2, 4]);\n        assert.deepEqual(actual, [1, 3]);\n        assert.deepEqual(lodash.remove(), []);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should work with lodash and `options`', function(assert) {\n      assert.expect(3);\n\n      var array = [1, 2, 3, 4],\n          lodash = convert(_.runInContext(), allFalseOptions),\n          actual = lodash.remove(array, isEvenIndex);\n\n      assert.deepEqual(array, [2, 4]);\n      assert.deepEqual(actual, [1, 3]);\n      assert.deepEqual(lodash.remove(), []);\n    });\n\n    QUnit.test('should work with `runInContext` and `options`', function(assert) {\n      assert.expect(3);\n\n      var array = [1, 2, 3, 4],\n          runInContext = convert('runInContext', _.runInContext, allFalseOptions),\n          lodash = runInContext(),\n          actual = lodash.remove(array, isEvenIndex);\n\n      assert.deepEqual(array, [2, 4]);\n      assert.deepEqual(actual, [1, 3]);\n      assert.deepEqual(lodash.remove(), []);\n    });\n\n    QUnit.test('should accept a variety of options', function(assert) {\n      assert.expect(8);\n\n      var array = [1, 2, 3, 4],\n          value = _.clone(array),\n          remove = convert('remove', _.remove, { 'cap': false }),\n          actual = remove(isEvenIndex)(value);\n\n      assert.deepEqual(value, [1, 2, 3, 4]);\n      assert.deepEqual(actual, [2, 4]);\n\n      remove = convert('remove', _.remove, { 'curry': false });\n      actual = remove(isEven);\n\n      assert.deepEqual(actual, []);\n\n      var trim = convert('trim', _.trim, { 'fixed': false });\n      assert.strictEqual(trim('_-abc-_', '_-'), 'abc');\n\n      value = _.clone(array);\n      remove = convert('remove', _.remove, { 'immutable': false });\n      actual = remove(isEven)(value);\n\n      assert.deepEqual(value, [1, 3]);\n      assert.deepEqual(actual, [2, 4]);\n\n      value = _.clone(array);\n      remove = convert('remove', _.remove, { 'rearg': false });\n      actual = remove(value)(isEven);\n\n      assert.deepEqual(value, [1, 2, 3, 4]);\n      assert.deepEqual(actual, [1, 3]);\n    });\n\n    QUnit.test('should respect the `cap` option', function(assert) {\n      assert.expect(1);\n\n      var iteratee = convert('iteratee', _.iteratee, { 'cap': false });\n\n      var func = iteratee(function(a, b, c) {\n        return [a, b, c];\n      }, 3);\n\n      assert.deepEqual(func(1, 2, 3), [1, 2, 3]);\n    });\n\n    QUnit.test('should respect the `rearg` option', function(assert) {\n      assert.expect(1);\n\n      var add = convert('add', _.add, { 'rearg': true });\n\n      assert.strictEqual(add('2')('1'), '12');\n    });\n\n    QUnit.test('should add a `placeholder` property', function(assert) {\n      assert.expect(2);\n\n      if (!document) {\n        var lodash = convert({ 'add': _.add });\n\n        assert.strictEqual(lodash.placeholder, lodash);\n        assert.strictEqual(lodash.add.placeholder, lodash);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('method.convert');\n\n  (function() {\n    QUnit.test('should exist on unconverted methods', function(assert) {\n      assert.expect(2);\n\n      var array = [],\n          isArray = fp.isArray.convert({ 'curry': true });\n\n      assert.strictEqual(fp.isArray(array), true);\n      assert.strictEqual(isArray()(array), true);\n    });\n\n    QUnit.test('should convert method aliases', function(assert) {\n      assert.expect(1);\n\n      var all = fp.all.convert({ 'rearg': false }),\n          actual = all([0])(_.identity);\n\n      assert.strictEqual(actual, false);\n    });\n\n    QUnit.test('should convert remapped methods', function(assert) {\n      assert.expect(1);\n\n      var extendAll = fp.extendAll.convert({ 'immutable': false }),\n          object = {};\n\n      extendAll([object, { 'a': 1 }, { 'b': 2 }]);\n      assert.deepEqual(object, { 'a': 1, 'b': 2 });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('convert methods');\n\n  _.each(['fp.convert', 'method.convert'], function(methodName) {\n    var isFp = methodName == 'fp.convert',\n        func = isFp ? fp.convert : fp.remove.convert;\n\n    QUnit.test('`' + methodName + '` should work with an object', function(assert) {\n      assert.expect(3);\n\n      var array = [1, 2, 3, 4],\n          lodash = func(allFalseOptions),\n          remove = isFp ? lodash.remove : lodash,\n          actual = remove(array, isEvenIndex);\n\n      assert.deepEqual(array, [2, 4]);\n      assert.deepEqual(actual, [1, 3]);\n      assert.deepEqual(remove(), []);\n    });\n\n    QUnit.test('`' + methodName + '` should extend existing configs', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4],\n          lodash = func({ 'cap': false }),\n          remove = (isFp ? lodash.remove : lodash).convert({ 'rearg': false }),\n          actual = remove(array)(isEvenIndex);\n\n      assert.deepEqual(array, [1, 2, 3, 4]);\n      assert.deepEqual(actual, [2, 4]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('method arity checks');\n\n  (function() {\n    QUnit.test('should wrap methods with an arity > `1`', function(assert) {\n      assert.expect(1);\n\n      var methodNames = _.filter(_.functions(fp), function(methodName) {\n        return fp[methodName].length > 1;\n      });\n\n      assert.deepEqual(methodNames, []);\n    });\n\n    QUnit.test('should have >= arity of `aryMethod` designation', function(assert) {\n      assert.expect(4);\n\n      _.times(4, function(index) {\n        var aryCap = index + 1;\n\n        var methodNames = _.filter(mapping.aryMethod[aryCap], function(methodName) {\n          var key = _.get(mapping.remap, methodName, methodName),\n              arity = _[key].length;\n\n          return arity != 0 && arity < aryCap;\n        });\n\n        assert.deepEqual(methodNames, [], '`aryMethod[' + aryCap + ']`');\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('method aliases');\n\n  (function() {\n    QUnit.test('should have correct aliases', function(assert) {\n      assert.expect(1);\n\n      var actual = _.transform(mapping.aliasToReal, function(result, realName, alias) {\n        result.push([alias, fp[alias] === fp[realName]]);\n      }, []);\n\n      assert.deepEqual(_.reject(actual, 1), []);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('method ary caps');\n\n  (function() {\n    QUnit.test('should have a cap of 1', function(assert) {\n      assert.expect(1);\n\n      var funcMethods = [\n        'curry', 'iteratee', 'memoize', 'over', 'overEvery', 'overSome',\n        'method', 'methodOf', 'rest', 'runInContext'\n      ];\n\n      var exceptions = funcMethods.concat('mixin', 'nthArg', 'template'),\n          expected = _.map(mapping.aryMethod[1], _.constant(true));\n\n      var actual = _.map(mapping.aryMethod[1], function(methodName) {\n        var arg = _.includes(funcMethods, methodName) ? _.noop : 1,\n            result = _.attempt(function() { return fp[methodName](arg); });\n\n        if (_.includes(exceptions, methodName)\n              ? typeof result == 'function'\n              : typeof result != 'function'\n            ) {\n          return true;\n        }\n        console.log(methodName, result);\n        return false;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should have a cap of 2', function(assert) {\n      assert.expect(1);\n\n      var funcMethods = [\n        'after', 'ary', 'before', 'bind', 'bindKey', 'curryN', 'debounce',\n        'delay', 'overArgs', 'partial', 'partialRight', 'rearg', 'throttle',\n        'wrap'\n      ];\n\n      var exceptions = _.without(funcMethods.concat('matchesProperty'), 'delay'),\n          expected = _.map(mapping.aryMethod[2], _.constant(true));\n\n      var actual = _.map(mapping.aryMethod[2], function(methodName) {\n        var args = _.includes(funcMethods, methodName) ? [methodName == 'curryN' ? 1 : _.noop, _.noop] : [1, []],\n            result = _.attempt(function() { return fp[methodName](args[0])(args[1]); });\n\n        if (_.includes(exceptions, methodName)\n              ? typeof result == 'function'\n              : typeof result != 'function'\n            ) {\n          return true;\n        }\n        console.log(methodName, result);\n        return false;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should have a cap of 3', function(assert) {\n      assert.expect(1);\n\n      var funcMethods = [\n        'assignWith', 'extendWith', 'isEqualWith', 'isMatchWith', 'reduce',\n        'reduceRight', 'transform', 'zipWith'\n      ];\n\n      var expected = _.map(mapping.aryMethod[3], _.constant(true));\n\n      var actual = _.map(mapping.aryMethod[3], function(methodName) {\n        var args = _.includes(funcMethods, methodName) ? [_.noop, 0, 1] : [0, 1, []],\n            result = _.attempt(function() { return fp[methodName](args[0])(args[1])(args[2]); });\n\n        if (typeof result != 'function') {\n          return true;\n        }\n        console.log(methodName, result);\n        return false;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('methods that use `indexOf`');\n\n  (function() {\n    QUnit.test('should work with `fp.indexOf`', function(assert) {\n      assert.expect(10);\n\n      var array = ['a', 'b', 'c'],\n          other = ['b', 'd', 'b'],\n          object = { 'a': 1, 'b': 2, 'c': 2 },\n          actual = fp.difference(array)(other);\n\n      assert.deepEqual(actual, ['a', 'c'], 'fp.difference');\n\n      actual = fp.includes('b')(array);\n      assert.strictEqual(actual, true, 'fp.includes');\n\n      actual = fp.intersection(other)(array);\n      assert.deepEqual(actual, ['b'], 'fp.intersection');\n\n      actual = fp.omit(other)(object);\n      assert.deepEqual(actual, { 'a': 1, 'c': 2 }, 'fp.omit');\n\n      actual = fp.union(other)(array);\n      assert.deepEqual(actual, ['a', 'b', 'c', 'd'], 'fp.union');\n\n      actual = fp.uniq(other);\n      assert.deepEqual(actual, ['b', 'd'], 'fp.uniq');\n\n      actual = fp.uniqBy(_.identity, other);\n      assert.deepEqual(actual, ['b', 'd'], 'fp.uniqBy');\n\n      actual = fp.without(other)(array);\n      assert.deepEqual(actual, ['a', 'c'], 'fp.without');\n\n      actual = fp.xor(other)(array);\n      assert.deepEqual(actual, ['a', 'c', 'd'], 'fp.xor');\n\n      actual = fp.pull('b')(array);\n      assert.deepEqual(actual, ['a', 'c'], 'fp.pull');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('cherry-picked methods');\n\n  (function() {\n    QUnit.test('should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(4);\n\n      var args,\n          array = [1, 2, 3],\n          object = { 'a': 1, 'b': 2 },\n          isFIFO = _.keys(object)[0] == 'a',\n          map = convert('map', _.map),\n          reduce = convert('reduce', _.reduce);\n\n      map(function() {\n        args || (args = slice.call(arguments));\n      })(array);\n\n      assert.deepEqual(args, [1]);\n\n      args = undefined;\n      map(function() {\n        args || (args = slice.call(arguments));\n      })(object);\n\n      assert.deepEqual(args, isFIFO ? [1] : [2]);\n\n      args = undefined;\n      reduce(function() {\n        args || (args = slice.call(arguments));\n      })(0)(array);\n\n      assert.deepEqual(args, [0, 1]);\n\n      args = undefined;\n      reduce(function() {\n        args || (args = slice.call(arguments));\n      })(0)(object);\n\n      assert.deepEqual(args, isFIFO ? [0, 1] : [0, 2]);\n    });\n\n    QUnit.test('should not support shortcut fusion', function(assert) {\n      assert.expect(3);\n\n      var array = fp.range(0, LARGE_ARRAY_SIZE),\n          filterCount = 0,\n          mapCount = 0;\n\n      var iteratee = function(value) {\n        mapCount++;\n        return value * value;\n      };\n\n      var predicate = function(value) {\n        filterCount++;\n        return isEven(value);\n      };\n\n      var map1 = convert('map', _.map),\n          filter1 = convert('filter', _.filter),\n          take1 = convert('take', _.take);\n\n      var filter2 = filter1(predicate),\n          map2 = map1(iteratee),\n          take2 = take1(2);\n\n      var combined = fp.flow(map2, filter2, fp.compact, take2);\n\n      assert.deepEqual(combined(array), [4, 16]);\n      assert.strictEqual(filterCount, 200, 'filterCount');\n      assert.strictEqual(mapCount, 200, 'mapCount');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('iteratee shorthands');\n\n  (function() {\n    var objects = [{ 'a': 1, 'b': 2 }, { 'a': 3, 'b': 4 }];\n\n    QUnit.test('should work with \"_.matches\" shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(fp.filter({ 'a': 3 })(objects), [objects[1]]);\n    });\n\n    QUnit.test('should work with \"_.matchesProperty\" shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(fp.filter(['a', 3])(objects), [objects[1]]);\n    });\n\n    QUnit.test('should work with \"_.property\" shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(fp.map('a')(objects), [1, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('placeholder methods');\n\n  (function() {\n    QUnit.test('should use `fp` as the default placeholder', function(assert) {\n      assert.expect(3);\n\n      var actual = fp.add(fp, 'b')('a');\n      assert.strictEqual(actual, 'ab');\n\n      actual = fp.fill(fp, 2)(1, '*')([1, 2, 3]);\n      assert.deepEqual(actual, [1, '*', 3]);\n\n      actual = fp.slice(fp, 2)(1)(['a', 'b', 'c']);\n      assert.deepEqual(actual, ['b']);\n    });\n\n    QUnit.test('should support `fp.placeholder`', function(assert) {\n      assert.expect(6);\n\n      _.each([[], fp.__], function(ph) {\n        fp.placeholder = ph;\n\n        var actual = fp.add(ph, 'b')('a');\n        assert.strictEqual(actual, 'ab');\n\n        actual = fp.fill(ph, 2)(1, '*')([1, 2, 3]);\n        assert.deepEqual(actual, [1, '*', 3]);\n\n        actual = fp.slice(ph, 2)(1)(['a', 'b', 'c']);\n        assert.deepEqual(actual, ['b']);\n      });\n    });\n\n    var methodNames = [\n      'bind',\n      'bindKey',\n      'curry',\n      'curryRight',\n      'partial',\n      'partialRight'\n    ];\n\n    _.each(methodNames, function(methodName) {\n      var func = fp[methodName];\n\n      QUnit.test('fp.' + methodName + '` should have a `placeholder` property', function(assert) {\n        assert.expect(2);\n\n        assert.ok(_.isObject(func.placeholder));\n        assert.strictEqual(func.placeholder, fp.__);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('setter methods');\n\n  (function() {\n    QUnit.test('should only clone objects in `path`', function(assert) {\n      assert.expect(11);\n\n      var object = { 'a': { 'b': 2, 'c': 3 }, 'd': { 'e': 4 } },\n          value = _.cloneDeep(object),\n          actual = fp.set('a.b.c.d', 5, value);\n\n      assert.ok(_.isObject(actual.a.b), 'fp.set');\n      assert.ok(_.isNumber(actual.a.b), 'fp.set');\n\n      assert.strictEqual(actual.a.b.c.d, 5, 'fp.set');\n      assert.strictEqual(actual.d, value.d, 'fp.set');\n\n      value = _.cloneDeep(object);\n      actual = fp.setWith(Object)('[0][1]')('a')(value);\n\n      assert.deepEqual(actual[0], { '1': 'a' }, 'fp.setWith');\n\n      value = _.cloneDeep(object);\n      actual = fp.unset('a.b')(value);\n\n      assert.notOk('b' in actual.a, 'fp.unset');\n      assert.strictEqual(actual.a.c, value.a.c, 'fp.unset');\n\n      value = _.cloneDeep(object);\n      actual = fp.update('a.b')(square)(value);\n\n      assert.strictEqual(actual.a.b, 4, 'fp.update');\n      assert.strictEqual(actual.d, value.d, 'fp.update');\n\n      value = _.cloneDeep(object);\n      actual = fp.updateWith(Object)('[0][1]')(_.constant('a'))(value);\n\n      assert.deepEqual(actual[0], { '1': 'a' }, 'fp.updateWith');\n      assert.strictEqual(actual.d, value.d, 'fp.updateWith');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.add and fp.subtract');\n\n  _.each(['add', 'subtract'], function(methodName) {\n    var func = fp[methodName],\n        isAdd = methodName == 'add';\n\n    QUnit.test('`fp.' + methodName + '` should not have `rearg` applied', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func('1')('2'), isAdd ? '12' : -1);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('object assignments');\n\n  _.each(['assign', 'assignIn', 'defaults', 'defaultsDeep', 'merge'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1 },\n          actual = func(object)({ 'b': 2 });\n\n      assert.deepEqual(object, { 'a': 1 });\n      assert.deepEqual(actual, { 'a': 1, 'b': 2 });\n    });\n  });\n\n  _.each(['assignAll', 'assignInAll', 'defaultsAll', 'defaultsDeepAll', 'mergeAll'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 1 }, { 'b': 2 }],\n          actual = func(objects);\n\n      assert.deepEqual(objects[0], { 'a': 1 });\n      assert.deepEqual(actual, { 'a': 1, 'b': 2 });\n    });\n  });\n\n  _.each(['assignWith', 'assignInWith', 'extendWith'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should provide the correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(function() {\n        args || (args = _.map(arguments, _.cloneDeep));\n      })({ 'a': 1 })({ 'b': 2 });\n\n      assert.deepEqual(args, [undefined, 2, 'b', { 'a': 1 }, { 'b': 2 }]);\n    });\n  });\n\n  _.each(['assignAllWith', 'assignInAllWith', 'extendAllWith', 'mergeAllWith'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 1 }, { 'b': 2 }],\n          actual = func(_.noop)(objects);\n\n      assert.deepEqual(objects[0], { 'a': 1 });\n      assert.deepEqual(actual, { 'a': 1, 'b': 2 });\n    });\n\n    QUnit.test('`fp.' + methodName + '` should work with more than two sources', function(assert) {\n      assert.expect(2);\n\n      var pass = false,\n          objects = [{ 'a': 1 }, { 'b': 2 }, { 'c': 3 }],\n          actual = func(function() { pass = true; })(objects);\n\n      assert.ok(pass);\n      assert.deepEqual(actual, { 'a': 1, 'b': 2, 'c': 3 });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.castArray');\n\n  (function() {\n    QUnit.test('should shallow clone array values', function(assert) {\n      assert.expect(2);\n\n      var array = [1],\n          actual = fp.castArray(array);\n\n      assert.deepEqual(actual, array);\n      assert.notStrictEqual(actual, array);\n    });\n\n    QUnit.test('should not shallow clone non-array values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1 },\n          actual = fp.castArray(object);\n\n      assert.deepEqual(actual, [object]);\n      assert.strictEqual(actual[0], object);\n    });\n\n    QUnit.test('should convert by name', function(assert) {\n      assert.expect(4);\n\n      var array = [1],\n          object = { 'a': 1 },\n          castArray = convert('castArray', _.castArray),\n          actual = castArray(array);\n\n      assert.deepEqual(actual, array);\n      assert.notStrictEqual(actual, array);\n\n      actual = castArray(object);\n      assert.deepEqual(actual, [object]);\n      assert.strictEqual(actual[0], object);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('curry methods');\n\n  _.each(['curry', 'curryRight'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('fp.' + methodName + '` should only accept a `func` param', function(assert) {\n      assert.expect(1);\n\n      assert.raises(function() { func(1, _.noop); }, TypeError);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('curryN methods');\n\n  _.each(['curryN', 'curryRightN'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('fp.' + methodName + '` should accept an `arity` param', function(assert) {\n      assert.expect(1);\n\n      var actual = func(1)(function(a, b) { return [a, b]; })('a');\n      assert.deepEqual(actual, ['a', undefined]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.defaultTo');\n\n  (function() {\n    QUnit.test('should have an argument order of `defaultValue` then `value`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(fp.defaultTo(1)(0), 0);\n      assert.strictEqual(fp.defaultTo(1)(undefined), 1);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.difference');\n\n  (function() {\n    QUnit.test('should return the elements of the first array not included in the second array', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.difference([2, 1], [2, 3]);\n      assert.deepEqual(actual, [1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.differenceBy');\n\n  (function() {\n    QUnit.test('should have an argument order of `iteratee`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.differenceBy(Math.floor, [2.1, 1.2], [2.3, 3.4]);\n      assert.deepEqual(actual, [1.2]);\n    });\n\n    QUnit.test('should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.differenceBy(function() {\n        args || (args = slice.call(arguments));\n      })([2.1, 1.2], [2.3, 3.4]);\n\n      assert.deepEqual(args, [2.3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.differenceWith');\n\n  (function() {\n    QUnit.test('should have an argument order of `comparator`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.differenceWith(fp.eq)([2, 1])([2, 3]);\n      assert.deepEqual(actual, [1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.divide and fp.multiply');\n\n  _.each(['divide', 'multiply'], function(methodName) {\n    var func = fp[methodName],\n        isDivide = methodName == 'divide';\n\n    QUnit.test('`fp.' + methodName + '` should not have `rearg` applied', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func('2')('4'), isDivide ? 0.5 : 8);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.extend');\n\n  (function() {\n    QUnit.test('should convert by name', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype = { 'b': 2 };\n\n      var object = { 'a': 1 },\n          extend = convert('extend', _.extend),\n          actual = extend(object)(new Foo);\n\n      assert.deepEqual(object, { 'a': 1 });\n      assert.deepEqual(actual, { 'a': 1, 'b': 2 });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.fill');\n\n  (function() {\n    QUnit.test('should have an argument order of `start`, `end`, then `value`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(fp.fill(1)(2)('*')(array), [1, '*', 3]);\n    });\n\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = fp.fill(1)(2)('*')(array);\n\n      assert.deepEqual(array, [1, 2, 3]);\n      assert.deepEqual(actual, [1, '*', 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.findFrom methods');\n\n  _.each(['findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('fp.' + methodName + '` should provide the correct `predicate` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })(1)([1, 2, 3]);\n\n      assert.deepEqual(args, [2]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.findFrom');\n\n  (function() {\n    function resolve(value) {\n      return fp.flow(fp.property('a'), fp.eq(value));\n    }\n\n    QUnit.test('should have an argument order of `value`, `fromIndex`, then `array`', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 1 }, { 'a': 2 }, { 'a': 1 }, { 'a': 2 }];\n\n      assert.strictEqual(fp.findFrom(resolve(1))(1)(objects), objects[2]);\n      assert.strictEqual(fp.findFrom(resolve(2))(-2)(objects), objects[3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.findLastFrom');\n\n  (function() {\n    function resolve(value) {\n      return fp.flow(fp.property('a'), fp.eq(value));\n    }\n\n    QUnit.test('should have an argument order of `value`, `fromIndex`, then `array`', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 1 }, { 'a': 2 }, { 'a': 1 }, { 'a': 2 }];\n\n      assert.strictEqual(fp.findLastFrom(resolve(1))(1)(objects), objects[0]);\n      assert.strictEqual(fp.findLastFrom(resolve(2))(-2)(objects), objects[1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.findIndexFrom and fp.indexOfFrom');\n\n  _.each(['findIndexFrom', 'indexOfFrom'], function(methodName) {\n    var func = fp[methodName],\n        resolve = methodName == 'findIndexFrom' ? fp.eq : _.identity;\n\n    QUnit.test('fp.' + methodName + '` should have an argument order of `value`, `fromIndex`, then `array`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 1, 2, 3];\n\n      assert.strictEqual(func(resolve(1))(2)(array), 3);\n      assert.strictEqual(func(resolve(2))(-3)(array), 4);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.findLastIndexFrom and fp.lastIndexOfFrom');\n\n  _.each(['findLastIndexFrom', 'lastIndexOfFrom'], function(methodName) {\n    var func = fp[methodName],\n        resolve = methodName == 'findLastIndexFrom' ? fp.eq : _.identity;\n\n    QUnit.test('fp.' + methodName + '` should have an argument order of `value`, `fromIndex`, then `array`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 1, 2, 3];\n\n      assert.strictEqual(func(resolve(2))(3)(array), 1);\n      assert.strictEqual(func(resolve(3))(-3)(array), 2);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.flatMapDepth');\n\n  (function() {\n    QUnit.test('should have an argument order of `iteratee`, `depth`, then `collection`', function(assert) {\n      assert.expect(2);\n\n      function duplicate(n) {\n        return [[[n, n]]];\n      }\n\n      var array = [1, 2],\n          object = { 'a': 1, 'b': 2 },\n          expected = [[1, 1], [2, 2]];\n\n      assert.deepEqual(fp.flatMapDepth(duplicate)(2)(array), expected);\n      assert.deepEqual(fp.flatMapDepth(duplicate)(2)(object), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('flow methods');\n\n  _.each(['flow', 'flowRight'], function(methodName) {\n    var func = fp[methodName],\n        isFlow = methodName == 'flow';\n\n    QUnit.test('`fp.' + methodName + '` should support shortcut fusion', function(assert) {\n      assert.expect(6);\n\n      var filterCount,\n          mapCount,\n          array = fp.range(0, LARGE_ARRAY_SIZE);\n\n      var iteratee = function(value) {\n        mapCount++;\n        return square(value);\n      };\n\n      var predicate = function(value) {\n        filterCount++;\n        return isEven(value);\n      };\n\n      var filter = fp.filter(predicate),\n          map = fp.map(iteratee),\n          take = fp.take(2);\n\n      _.times(2, function(index) {\n        var combined = isFlow\n          ? func(map, filter, fp.compact, take)\n          : func(take, fp.compact, filter, map);\n\n        filterCount = mapCount = 0;\n\n        if (WeakMap && WeakMap.name) {\n          assert.deepEqual(combined(array), [4, 16]);\n          assert.strictEqual(filterCount, 5, 'filterCount');\n          assert.strictEqual(mapCount, 5, 'mapCount');\n        }\n        else {\n          skipAssert(assert, 3);\n        }\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('forEach methods');\n\n  _.each(['forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should provide `value` to `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var args;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })(['a']);\n\n      assert.deepEqual(args, ['a']);\n\n      args = undefined;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })({ 'a': 1 });\n\n      assert.deepEqual(args, [1]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.getOr');\n\n  (function() {\n    QUnit.test('should accept a `defaultValue` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.getOr('default')('path')({});\n      assert.strictEqual(actual, 'default');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.gt and fp.gte');\n\n  _.each(['gt', 'gte'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should have `rearg` applied', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(2)(1), true);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.inRange');\n\n  (function() {\n    QUnit.test('should have an argument order of `start`, `end`, then `value`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(fp.inRange(2)(4)(3), true);\n      assert.strictEqual(fp.inRange(-2)(-6)(-3), true);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.intersectionBy');\n\n  (function() {\n    QUnit.test('should have an argument order of `iteratee`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.intersectionBy(Math.floor, [2.1, 1.2], [2.3, 3.4]);\n      assert.deepEqual(actual, [2.1]);\n    });\n\n    QUnit.test('should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.intersectionBy(function() {\n        args || (args = slice.call(arguments));\n      })([2.1, 1.2], [2.3, 3.4]);\n\n      assert.deepEqual(args, [2.3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.intersectionWith');\n\n  (function() {\n    QUnit.test('should have an argument order of `comparator`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.intersectionWith(fp.eq)([2, 1])([2, 3]);\n      assert.deepEqual(actual, [2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.invoke');\n\n  (function() {\n    QUnit.test('should not accept an `args` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.invoke('toUpperCase')('a');\n      assert.strictEqual(actual, 'A');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.invokeMap');\n\n  (function() {\n    QUnit.test('should not accept an `args` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.invokeMap('toUpperCase')(['a', 'b']);\n      assert.deepEqual(actual, ['A', 'B']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.invokeArgs');\n\n  (function() {\n    QUnit.test('should accept an `args` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.invokeArgs('concat')(['b', 'c'])('a');\n      assert.strictEqual(actual, 'abc');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.invokeArgsMap');\n\n  (function() {\n    QUnit.test('should accept an `args` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.invokeArgsMap('concat')(['b', 'c'])(['a', 'A']);\n      assert.deepEqual(actual, ['abc', 'Abc']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.isEqualWith');\n\n  (function() {\n    QUnit.test('should provide the correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var args,\n          iteration = 0,\n          objects = [{ 'a': 1 }, { 'a': 2 }],\n          stack = { '__data__': { '__data__': [objects, objects.slice().reverse()], 'size': 2 }, 'size': 2 },\n          expected = [1, 2, 'a', objects[0], objects[1], stack];\n\n      fp.isEqualWith(function() {\n        if (++iteration == 2) {\n          args = _.map(arguments, _.cloneDeep);\n        }\n      })(objects[0])(objects[1]);\n\n      args[5] = _.omitBy(args[5], _.isFunction);\n      args[5].__data__ = _.omitBy(args[5].__data__, _.isFunction);\n\n      assert.deepEqual(args, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.isMatchWith');\n\n  (function() {\n    QUnit.test('should provide the correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var args,\n          objects = [{ 'a': 1 }, { 'a': 2 }],\n          stack = { '__data__': { '__data__': [], 'size': 0 }, 'size': 0 },\n          expected = [2, 1, 'a', objects[1], objects[0], stack];\n\n      fp.isMatchWith(function() {\n        args || (args = _.map(arguments, _.cloneDeep));\n      })(objects[0])(objects[1]);\n\n      args[5] = _.omitBy(args[5], _.isFunction);\n      args[5].__data__ = _.omitBy(args[5].__data__, _.isFunction);\n\n      assert.deepEqual(args, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.iteratee');\n\n  (function() {\n    QUnit.test('should return a iteratee with capped params', function(assert) {\n      assert.expect(1);\n\n      var func = fp.iteratee(function(a, b, c) { return [a, b, c]; }, 3);\n      assert.deepEqual(func(1, 2, 3), [1, undefined, undefined]);\n    });\n\n    QUnit.test('should convert by name', function(assert) {\n      assert.expect(1);\n\n      var iteratee = convert('iteratee', _.iteratee),\n          func = iteratee(function(a, b, c) { return [a, b, c]; }, 3);\n\n      assert.deepEqual(func(1, 2, 3), [1, undefined, undefined]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.lt and fp.lte');\n\n  _.each(['lt', 'lte'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should have `rearg` applied', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(1)(2), true);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.mapKeys');\n\n  (function() {\n    QUnit.test('should only provide `key` to `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.mapKeys(function() {\n        args || (args = slice.call(arguments));\n      }, { 'a': 1 });\n\n      assert.deepEqual(args, ['a']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.maxBy and fp.minBy');\n\n  _.each(['maxBy', 'minBy'], function(methodName) {\n    var array = [1, 2, 3],\n        func = fp[methodName],\n        isMax = methodName == 'maxBy';\n\n    QUnit.test('`fp.' + methodName + '` should work with an `iteratee` argument', function(assert) {\n      assert.expect(1);\n\n      var actual = func(function(num) {\n        return -num;\n      })(array);\n\n      assert.strictEqual(actual, isMax ? 1 : 3);\n    });\n\n    QUnit.test('`fp.' + methodName + '` should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })(array);\n\n      assert.deepEqual(args, [1]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.mergeWith');\n\n  (function() {\n    QUnit.test('should provide the correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var args,\n          stack = { '__data__': { '__data__': [], 'size': 0 }, 'size': 0 },\n          expected = [[1, 2], [3], 'a', { 'a': [1, 2] }, { 'a': [3] }, stack];\n\n      fp.mergeWith(function() {\n        args || (args = _.map(arguments, _.cloneDeep));\n      })({ 'a': [1, 2] })({ 'a': [3] });\n\n      args[5] = _.omitBy(args[5], _.isFunction);\n      args[5].__data__ = _.omitBy(args[5].__data__, _.isFunction);\n\n      assert.deepEqual(args, expected);\n    });\n\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': [1, 2] }, { 'a': [3] }],\n          actual = fp.mergeWith(_.noop, objects[0], objects[1]);\n\n      assert.deepEqual(objects[0], { 'a': [1, 2] });\n      assert.deepEqual(actual, { 'a': [3, 2] });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.mergeAllWith');\n\n  (function() {\n    QUnit.test('should provide the correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var args,\n          objects = [{ 'a': [1, 2] }, { 'a': [3] }],\n          stack = { '__data__': { '__data__': [], 'size': 0 }, 'size': 0 },\n          expected = [[1, 2], [3], 'a', { 'a': [1, 2] }, { 'a': [3] }, stack];\n\n      fp.mergeAllWith(function() {\n        args || (args = _.map(arguments, _.cloneDeep));\n      })(objects);\n\n      args[5] = _.omitBy(args[5], _.isFunction);\n      args[5].__data__ = _.omitBy(args[5].__data__, _.isFunction);\n\n      assert.deepEqual(args, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.mixin');\n\n  (function() {\n    var source = { 'a': _.noop };\n\n    QUnit.test('should mixin static methods but not prototype methods', function(assert) {\n      assert.expect(2);\n\n      fp.mixin(source);\n\n      assert.strictEqual(typeof fp.a, 'function');\n      assert.notOk('a' in fp.prototype);\n\n      delete fp.a;\n      delete fp.prototype.a;\n    });\n\n    QUnit.test('should not assign inherited `source` methods', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.a = _.noop;\n      fp.mixin(new Foo);\n\n      assert.notOk('a' in fp);\n      assert.notOk('a' in fp.prototype);\n\n      delete fp.a;\n      delete fp.prototype.a;\n    });\n\n    QUnit.test('should not remove existing prototype methods', function(assert) {\n      assert.expect(2);\n\n      var each1 = fp.each,\n          each2 = fp.prototype.each;\n\n      fp.mixin({ 'each': source.a });\n\n      assert.strictEqual(fp.each, source.a);\n      assert.strictEqual(fp.prototype.each, each2);\n\n      fp.each = each1;\n      fp.prototype.each = each2;\n    });\n\n    QUnit.test('should not export to the global when `source` is not an object', function(assert) {\n      assert.expect(2);\n\n      var props = _.without(_.keys(_), '_');\n\n      _.times(2, function(index) {\n        fp.mixin.apply(fp, index ? [1] : []);\n\n        assert.ok(_.every(props, function(key) {\n          return root[key] !== fp[key];\n        }));\n\n        _.each(props, function(key) {\n          if (root[key] === fp[key]) {\n            delete root[key];\n          }\n        });\n      });\n    });\n\n    QUnit.test('should convert by name', function(assert) {\n      assert.expect(3);\n\n      var object = { 'mixin': convert('mixin', _.mixin) };\n\n      function Foo() {}\n      Foo.mixin = object.mixin;\n      Foo.mixin(source);\n\n      assert.ok('a' in Foo);\n      assert.notOk('a' in Foo.prototype);\n\n      object.mixin(source);\n      assert.ok('a' in object);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.nthArg');\n\n  (function() {\n    QUnit.test('should return a curried function', function(assert) {\n      assert.expect(2);\n\n      var func = fp.nthArg(1);\n      assert.strictEqual(func(1)(2), 2);\n\n      func = fp.nthArg(-1);\n      assert.strictEqual(func(1), 1);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.over');\n\n  (function() {\n    QUnit.test('should not cap iteratee args', function(assert) {\n      assert.expect(2);\n\n      _.each([fp.over, convert('over', _.over)], function(func) {\n        var over = func([Math.max, Math.min]);\n        assert.deepEqual(over(1, 2, 3, 4), [4, 1]);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.omitBy and fp.pickBy');\n\n  _.each(['omitBy', 'pickBy'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should provide `value` and `key` to `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })({ 'a': 1 });\n\n      assert.deepEqual(args, [1, 'a']);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('padChars methods');\n\n  _.each(['padChars', 'padCharsStart', 'padCharsEnd'], function(methodName) {\n    var func = fp[methodName],\n        isPad = methodName == 'padChars',\n        isStart = methodName == 'padCharsStart';\n\n    QUnit.test('fp.' + methodName + '` should truncate pad characters to fit the pad length', function(assert) {\n      assert.expect(1);\n\n      if (isPad) {\n        assert.strictEqual(func('_-')(8)('abc'), '_-abc_-_');\n      } else {\n        assert.strictEqual(func('_-')(6)('abc'), isStart ? '_-_abc' : 'abc_-_');\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('partial methods');\n\n  _.each(['partial', 'partialRight'], function(methodName) {\n    var func = fp[methodName],\n        isPartial = methodName == 'partial';\n\n    QUnit.test('fp.' + methodName + '` should accept an `args` param', function(assert) {\n      assert.expect(1);\n\n      var expected = isPartial ? [1, 2, 3] : [0, 1, 2];\n\n      var actual = func(function(a, b, c) {\n        return [a, b, c];\n      })([1, 2])(isPartial ? 3 : 0);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('fp.' + methodName + '` should convert by name', function(assert) {\n      assert.expect(2);\n\n      var expected = isPartial ? [1, 2, 3] : [0, 1, 2],\n          par = convert(methodName, _[methodName]),\n          ph = par.placeholder;\n\n      var actual = par(function(a, b, c) {\n        return [a, b, c];\n      })([1, 2])(isPartial ? 3 : 0);\n\n      assert.deepEqual(actual, expected);\n\n      actual = par(function(a, b, c) {\n        return [a, b, c];\n      })([ph, 2])(isPartial ? 1 : 0, isPartial ? 3 : 1);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.propertyOf');\n\n  (function() {\n    QUnit.test('should be curried', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1 };\n\n      assert.strictEqual(fp.propertyOf(object, 'a'), 1);\n      assert.strictEqual(fp.propertyOf(object)('a'), 1);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.pull');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = fp.pull(2)(array);\n\n      assert.deepEqual(array, [1, 2, 3]);\n      assert.deepEqual(actual, [1, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.pullAll');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = fp.pullAll([1, 3])(array);\n\n      assert.deepEqual(array, [1, 2, 3]);\n      assert.deepEqual(actual, [2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.pullAt');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = fp.pullAt([0, 2])(array);\n\n      assert.deepEqual(array, [1, 2, 3]);\n      assert.deepEqual(actual, [2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.random');\n\n  (function() {\n    var array = Array(1000);\n\n    QUnit.test('should support a `min` and `max` argument', function(assert) {\n      assert.expect(1);\n\n      var min = 5,\n          max = 10;\n\n      assert.ok(_.some(array, function() {\n        var result = fp.random(min)(max);\n        return result >= min && result <= max;\n      }));\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('range methods');\n\n  _.each(['range', 'rangeRight'], function(methodName) {\n    var func = fp[methodName],\n        isRange = methodName == 'range';\n\n    QUnit.test('fp.' + methodName + '` should have an argument order of `start` then `end`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(1)(4), isRange ? [1, 2, 3] : [3, 2, 1]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('rangeStep methods');\n\n  _.each(['rangeStep', 'rangeStepRight'], function(methodName) {\n    var func = fp[methodName],\n        isRange = methodName == 'rangeStep';\n\n    QUnit.test('fp.' + methodName + '` should have an argument order of `step`, `start`, then `end`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(2)(1)(4), isRange ? [1, 3] : [3, 1]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.rearg');\n\n  (function() {\n    function fn(a, b, c) {\n      return [a, b, c];\n    }\n\n    QUnit.test('should be curried', function(assert) {\n      assert.expect(1);\n\n      var rearged = fp.rearg([1, 2, 0])(fn);\n      assert.deepEqual(rearged('c', 'a', 'b'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should return a curried function', function(assert) {\n      assert.expect(1);\n\n      var rearged = fp.rearg([1, 2, 0], fn);\n      assert.deepEqual(rearged('c')('a')('b'), ['a', 'b', 'c']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('reduce methods');\n\n  _.each(['reduce', 'reduceRight'], function(methodName) {\n    var func = fp[methodName],\n        isReduce = methodName == 'reduce';\n\n    QUnit.test('`fp.' + methodName + '` should provide the correct `iteratee` arguments when iterating an array', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })(0)([1, 2, 3]);\n\n      assert.deepEqual(args, isReduce ? [0, 1] : [3, 0]);\n    });\n\n    QUnit.test('`fp.' + methodName + '` should provide the correct `iteratee` arguments when iterating an object', function(assert) {\n      assert.expect(1);\n\n      var args,\n          object = { 'a': 1, 'b': 2 },\n          isFIFO = _.keys(object)[0] == 'a';\n\n      var expected = isFIFO\n        ? (isReduce ? [0, 1] : [2, 0])\n        : (isReduce ? [0, 2] : [1, 0]);\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })(0)(object);\n\n      assert.deepEqual(args, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.remove');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = fp.remove(fp.eq(2))(array);\n\n      assert.deepEqual(array, [1, 2, 3]);\n      assert.deepEqual(actual, [1, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.restFrom');\n\n  (function() {\n    QUnit.test('should accept a `start` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.restFrom(2)(function() {\n        return slice.call(arguments);\n      })('a', 'b', 'c', 'd');\n\n      assert.deepEqual(actual, ['a', 'b', ['c', 'd']]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.reverse');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = fp.reverse(array);\n\n      assert.deepEqual(array, [1, 2, 3]);\n      assert.deepEqual(actual, [3, 2, 1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.runInContext');\n\n  (function() {\n    QUnit.test('should return a converted lodash instance', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(typeof fp.runInContext({}).curryN, 'function');\n    });\n\n    QUnit.test('should convert by name', function(assert) {\n      assert.expect(1);\n\n      var runInContext = convert('runInContext', _.runInContext);\n      assert.strictEqual(typeof runInContext({}).curryN, 'function');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.set');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2, 'c': 3 } },\n          actual = fp.set('a.b')(3)(object);\n\n      assert.deepEqual(object, { 'a': { 'b': 2, 'c': 3 } });\n      assert.deepEqual(actual, { 'a': { 'b': 3, 'c': 3 } });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.setWith');\n\n  (function() {\n    QUnit.test('should provide the correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.setWith(function() {\n        args || (args = _.map(arguments, _.cloneDeep));\n      })('b.c')(2)({ 'a': 1 });\n\n      assert.deepEqual(args, [undefined, 'b', { 'a': 1 }]);\n    });\n\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2, 'c': 3 } },\n          actual = fp.setWith(Object)('d.e')(4)(object);\n\n      assert.deepEqual(object, { 'a': { 'b': 2, 'c': 3 } });\n      assert.deepEqual(actual, { 'a': { 'b': 2, 'c': 3 }, 'd': { 'e': 4 } });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.spreadFrom');\n\n  (function() {\n    QUnit.test('should accept a `start` param', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.spreadFrom(2)(function() {\n        return slice.call(arguments);\n      })('a', 'b', ['c', 'd']);\n\n      assert.deepEqual(actual, ['a', 'b', 'c', 'd']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('trimChars methods');\n\n  _.each(['trimChars', 'trimCharsStart', 'trimCharsEnd'], function(methodName, index) {\n    var func = fp[methodName],\n        parts = [];\n\n    if (index != 2) {\n      parts.push('leading');\n    }\n    if (index != 1) {\n      parts.push('trailing');\n    }\n    parts = parts.join(' and ');\n\n    QUnit.test('`fp.' + methodName + '` should remove ' + parts + ' `chars`', function(assert) {\n      assert.expect(1);\n\n      var string = '-_-a-b-c-_-',\n          expected = (index == 2 ? '-_-' : '') + 'a-b-c' + (index == 1 ? '-_-' : '');\n\n      assert.strictEqual(func('_-')(string), expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.unionBy');\n\n  (function() {\n    QUnit.test('should have an argument order of `iteratee`, `array`, then `other`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.unionBy(Math.floor, [2.1], [1.2, 2.3]);\n      assert.deepEqual(actual, [2.1, 1.2]);\n    });\n\n    QUnit.test('should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.unionBy(function() {\n        args || (args = slice.call(arguments));\n      })([2.1], [1.2, 2.3]);\n\n      assert.deepEqual(args, [2.1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.unionWith');\n\n  (function() {\n    QUnit.test('should have an argument order of `comparator`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.unionWith(fp.eq)([2, 1])([2, 3]);\n      assert.deepEqual(actual, [2, 1, 3]);\n    });\n\n    QUnit.test('should provide the correct `comparator` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.unionWith(function() {\n        args || (args = slice.call(arguments));\n      })([2, 1])([2, 3]);\n\n      assert.deepEqual(args, [1, 2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.uniqBy');\n\n  (function() {\n    var objects = [{ 'a': 2 }, { 'a': 3 }, { 'a': 1 }, { 'a': 2 }, { 'a': 3 }, { 'a': 1 }];\n\n    QUnit.test('should work with an `iteratee` argument', function(assert) {\n      assert.expect(1);\n\n      var expected = objects.slice(0, 3),\n          actual = fp.uniqBy(_.property('a'))(objects);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.uniqBy(function() {\n        args || (args = slice.call(arguments));\n      })(objects);\n\n      assert.deepEqual(args, [objects[0]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.uniqWith');\n\n  (function() {\n    QUnit.test('should have an argument order of `comparator`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.uniqWith(fp.eq)([2, 1, 2]);\n      assert.deepEqual(actual, [2, 1]);\n    });\n\n    QUnit.test('should provide the correct `comparator` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.uniqWith(function() {\n        args || (args = slice.call(arguments));\n      })([2, 1, 2]);\n\n      assert.deepEqual(args, [1, 2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.update');\n\n  (function() {\n    QUnit.test('should not convert end of `path` to an object', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.update('a.b')(_.identity)({ 'a': { 'b': 1 } });\n      assert.strictEqual(typeof actual.a.b, 'number');\n    });\n\n    QUnit.test('should not convert uncloneables to objects', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': _.constant(true) } },\n          actual = fp.update('a.b')(_.identity)(object);\n\n      assert.strictEqual(typeof object.a.b, 'function');\n      assert.strictEqual(object.a.b, actual.a.b);\n    });\n\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2, 'c': 3 } },\n          actual = fp.update('a.b')(square)(object);\n\n      assert.deepEqual(object, { 'a': { 'b': 2, 'c': 3 } });\n      assert.deepEqual(actual, { 'a': { 'b': 4, 'c': 3 } });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.updateWith');\n\n  (function() {\n    QUnit.test('should provide the correct `customizer` arguments', function(assert) {\n      var args;\n\n      fp.updateWith(function() {\n        args || (args = _.map(arguments, _.cloneDeep));\n      })('b.c')(_.constant(2))({ 'a': 1 });\n\n      assert.deepEqual(args, [undefined, 'b', { 'a': 1 }]);\n    });\n\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2, 'c': 3 } },\n          actual = fp.updateWith(Object)('d.e')(_.constant(4))(object);\n\n      assert.deepEqual(object, { 'a': { 'b': 2, 'c': 3 } });\n      assert.deepEqual(actual, { 'a': { 'b': 2, 'c': 3 }, 'd': { 'e': 4 } });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.unset');\n\n  (function() {\n    QUnit.test('should not mutate values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2, 'c': 3 } },\n          actual = fp.unset('a.b')(object);\n\n      assert.deepEqual(object, { 'a': { 'b': 2, 'c': 3 } });\n      assert.deepEqual(actual, { 'a': { 'c': 3 } });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.xorBy');\n\n  (function() {\n    QUnit.test('should have an argument order of `iteratee`, `array`, then `other`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.xorBy(Math.floor, [2.1, 1.2], [2.3, 3.4]);\n      assert.deepEqual(actual, [1.2, 3.4]);\n    });\n\n    QUnit.test('should provide the correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      fp.xorBy(function() {\n        args || (args = slice.call(arguments));\n      })([2.1, 1.2], [2.3, 3.4]);\n\n      assert.deepEqual(args, [2.3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.xorWith');\n\n  (function() {\n    QUnit.test('should have an argument order of `comparator`, `array`, then `values`', function(assert) {\n      assert.expect(1);\n\n      var actual = fp.xorWith(fp.eq)([2, 1])([2, 3]);\n      assert.deepEqual(actual, [1, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('with methods');\n\n  _.each(['differenceWith', 'intersectionWith', 'xorWith'], function(methodName) {\n    var func = fp[methodName];\n\n    QUnit.test('`fp.' + methodName + '` should provide the correct `comparator` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(function() {\n        args || (args = slice.call(arguments));\n      })([2, 1])([2, 3]);\n\n      assert.deepEqual(args, [2, 2]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.zip');\n\n  (function() {\n    QUnit.test('should zip together two arrays', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(fp.zip([1, 2])([3, 4]), [[1, 3], [2, 4]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.zipAll');\n\n  (function() {\n    QUnit.test('should zip together an array of arrays', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(fp.zipAll([[1, 2], [3, 4], [5, 6]]), [[1, 3, 5], [2, 4, 6]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.zipObject');\n\n  (function() {\n    QUnit.test('should zip together key/value arrays into an object', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(fp.zipObject(['a', 'b'])([1, 2]), { 'a': 1, 'b': 2 });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('fp.zipWith');\n\n  (function() {\n    QUnit.test('should zip arrays combining grouped elements with `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var array1 = [1, 2, 3],\n          array2 = [4, 5, 6],\n          actual = fp.zipWith(add)(array1)(array2);\n\n      assert.deepEqual(actual, [5, 7, 9]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.config.asyncRetries = 10;\n  QUnit.config.hidepassed = true;\n\n  if (!document) {\n    QUnit.config.noglobals = true;\n    QUnit.load();\n    QUnit.start();\n  }\n}.call(this));\n",
            language: 'javascript',
            size: 65357,
            tokens: 7136,
            lastModified: '2025-07-02T12:28:22.850Z',
          },
          {
            name: 'test.js',
            path: 'test/test.js',
            type: 'file',
            content:
              ";(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used to detect when a function becomes hot. */\n  var HOT_COUNT = 150;\n\n  /** Used as the size to cover large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n  /** `Object#toString` result references. */\n  var funcTag = '[object Function]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]';\n\n  /** Used as a reference to the global object. */\n  var root = (typeof global == 'object' && global) || this;\n\n  /** Used to store lodash to test for bad extensions/shims. */\n  var lodashBizarro = root.lodashBizarro;\n\n  /** Used for native method references. */\n  var arrayProto = Array.prototype,\n      funcProto = Function.prototype,\n      objectProto = Object.prototype,\n      numberProto = Number.prototype,\n      stringProto = String.prototype;\n\n  /** Method and object shortcuts. */\n  var phantom = root.phantom,\n      process = root.process,\n      amd = root.define ? define.amd : undefined,\n      args = toArgs([1, 2, 3]),\n      argv = process ? process.argv : undefined,\n      defineProperty = Object.defineProperty,\n      document = phantom ? undefined : root.document,\n      body = root.document ? root.document.body : undefined,\n      create = Object.create,\n      fnToString = funcProto.toString,\n      freeze = Object.freeze,\n      getSymbols = Object.getOwnPropertySymbols,\n      identity = function(value) { return value; },\n      noop = function() {},\n      objToString = objectProto.toString,\n      params = argv,\n      push = arrayProto.push,\n      realm = {},\n      slice = arrayProto.slice,\n      strictArgs = (function() { 'use strict'; return arguments; }(1, 2, 3));\n\n  var ArrayBuffer = root.ArrayBuffer,\n      Buffer = root.Buffer,\n      Map = root.Map,\n      Promise = root.Promise,\n      Proxy = root.Proxy,\n      Set = root.Set,\n      Symbol = root.Symbol,\n      Uint8Array = root.Uint8Array,\n      WeakMap = root.WeakMap,\n      WeakSet = root.WeakSet;\n\n  var arrayBuffer = ArrayBuffer ? new ArrayBuffer(2) : undefined,\n      map = Map ? new Map : undefined,\n      promise = Promise ? Promise.resolve(1) : undefined,\n      set = Set ? new Set : undefined,\n      symbol = Symbol ? Symbol('a') : undefined,\n      weakMap = WeakMap ? new WeakMap : undefined,\n      weakSet = WeakSet ? new WeakSet : undefined;\n\n  /** Math helpers. */\n  var add = function(x, y) { return x + y; },\n      doubled = function(n) { return n * 2; },\n      isEven = function(n) { return n % 2 == 0; },\n      square = function(n) { return n * n; };\n\n  /** Stub functions. */\n  var stubA = function() { return 'a'; },\n      stubB = function() { return 'b'; },\n      stubC = function() { return 'c'; };\n\n  var stubTrue = function() { return true; },\n      stubFalse = function() { return false; };\n\n  var stubNaN = function() { return NaN; },\n      stubNull = function() { return null; };\n\n  var stubZero = function() { return 0; },\n      stubOne = function() { return 1; },\n      stubTwo = function() { return 2; },\n      stubThree = function() { return 3; },\n      stubFour = function() { return 4; };\n\n  var stubArray = function() { return []; },\n      stubObject = function() { return {}; },\n      stubString = function() { return ''; };\n\n  /** List of Latin Unicode letters. */\n  var burredLetters = [\n    // Latin-1 Supplement letters.\n    '\\xc0', '\\xc1', '\\xc2', '\\xc3', '\\xc4', '\\xc5', '\\xc6', '\\xc7', '\\xc8', '\\xc9', '\\xca', '\\xcb', '\\xcc', '\\xcd', '\\xce', '\\xcf',\n    '\\xd0', '\\xd1', '\\xd2', '\\xd3', '\\xd4', '\\xd5', '\\xd6',         '\\xd8', '\\xd9', '\\xda', '\\xdb', '\\xdc', '\\xdd', '\\xde', '\\xdf',\n    '\\xe0', '\\xe1', '\\xe2', '\\xe3', '\\xe4', '\\xe5', '\\xe6', '\\xe7', '\\xe8', '\\xe9', '\\xea', '\\xeb', '\\xec', '\\xed', '\\xee', '\\xef',\n    '\\xf0', '\\xf1', '\\xf2', '\\xf3', '\\xf4', '\\xf5', '\\xf6',         '\\xf8', '\\xf9', '\\xfa', '\\xfb', '\\xfc', '\\xfd', '\\xfe', '\\xff',\n    // Latin Extended-A letters.\n    '\\u0100', '\\u0101', '\\u0102', '\\u0103', '\\u0104', '\\u0105', '\\u0106', '\\u0107', '\\u0108', '\\u0109', '\\u010a', '\\u010b', '\\u010c', '\\u010d', '\\u010e', '\\u010f',\n    '\\u0110', '\\u0111', '\\u0112', '\\u0113', '\\u0114', '\\u0115', '\\u0116', '\\u0117', '\\u0118', '\\u0119', '\\u011a', '\\u011b', '\\u011c', '\\u011d', '\\u011e', '\\u011f',\n    '\\u0120', '\\u0121', '\\u0122', '\\u0123', '\\u0124', '\\u0125', '\\u0126', '\\u0127', '\\u0128', '\\u0129', '\\u012a', '\\u012b', '\\u012c', '\\u012d', '\\u012e', '\\u012f',\n    '\\u0130', '\\u0131', '\\u0132', '\\u0133', '\\u0134', '\\u0135', '\\u0136', '\\u0137', '\\u0138', '\\u0139', '\\u013a', '\\u013b', '\\u013c', '\\u013d', '\\u013e', '\\u013f',\n    '\\u0140', '\\u0141', '\\u0142', '\\u0143', '\\u0144', '\\u0145', '\\u0146', '\\u0147', '\\u0148', '\\u0149', '\\u014a', '\\u014b', '\\u014c', '\\u014d', '\\u014e', '\\u014f',\n    '\\u0150', '\\u0151', '\\u0152', '\\u0153', '\\u0154', '\\u0155', '\\u0156', '\\u0157', '\\u0158', '\\u0159', '\\u015a', '\\u015b', '\\u015c', '\\u015d', '\\u015e', '\\u015f',\n    '\\u0160', '\\u0161', '\\u0162', '\\u0163', '\\u0164', '\\u0165', '\\u0166', '\\u0167', '\\u0168', '\\u0169', '\\u016a', '\\u016b', '\\u016c', '\\u016d', '\\u016e', '\\u016f',\n    '\\u0170', '\\u0171', '\\u0172', '\\u0173', '\\u0174', '\\u0175', '\\u0176', '\\u0177', '\\u0178', '\\u0179', '\\u017a', '\\u017b', '\\u017c', '\\u017d', '\\u017e', '\\u017f'\n  ];\n\n  /** List of combining diacritical marks. */\n  var comboMarks = [\n    '\\u0300', '\\u0301', '\\u0302', '\\u0303', '\\u0304', '\\u0305', '\\u0306', '\\u0307', '\\u0308', '\\u0309', '\\u030a', '\\u030b', '\\u030c', '\\u030d', '\\u030e', '\\u030f',\n    '\\u0310', '\\u0311', '\\u0312', '\\u0313', '\\u0314', '\\u0315', '\\u0316', '\\u0317', '\\u0318', '\\u0319', '\\u031a', '\\u031b', '\\u031c', '\\u031d', '\\u031e', '\\u031f',\n    '\\u0320', '\\u0321', '\\u0322', '\\u0323', '\\u0324', '\\u0325', '\\u0326', '\\u0327', '\\u0328', '\\u0329', '\\u032a', '\\u032b', '\\u032c', '\\u032d', '\\u032e', '\\u032f',\n    '\\u0330', '\\u0331', '\\u0332', '\\u0333', '\\u0334', '\\u0335', '\\u0336', '\\u0337', '\\u0338', '\\u0339', '\\u033a', '\\u033b', '\\u033c', '\\u033d', '\\u033e', '\\u033f',\n    '\\u0340', '\\u0341', '\\u0342', '\\u0343', '\\u0344', '\\u0345', '\\u0346', '\\u0347', '\\u0348', '\\u0349', '\\u034a', '\\u034b', '\\u034c', '\\u034d', '\\u034e', '\\u034f',\n    '\\u0350', '\\u0351', '\\u0352', '\\u0353', '\\u0354', '\\u0355', '\\u0356', '\\u0357', '\\u0358', '\\u0359', '\\u035a', '\\u035b', '\\u035c', '\\u035d', '\\u035e', '\\u035f',\n    '\\u0360', '\\u0361', '\\u0362', '\\u0363', '\\u0364', '\\u0365', '\\u0366', '\\u0367', '\\u0368', '\\u0369', '\\u036a', '\\u036b', '\\u036c', '\\u036d', '\\u036e', '\\u036f',\n    '\\ufe20', '\\ufe21', '\\ufe22', '\\ufe23'\n  ];\n\n  /** List of converted Latin Unicode letters. */\n  var deburredLetters = [\n    // Converted Latin-1 Supplement letters.\n    'A',  'A', 'A', 'A', 'A', 'A', 'Ae', 'C',  'E', 'E', 'E', 'E', 'I', 'I', 'I',\n    'I',  'D', 'N', 'O', 'O', 'O', 'O',  'O',  'O', 'U', 'U', 'U', 'U', 'Y', 'Th',\n    'ss', 'a', 'a', 'a', 'a', 'a', 'a',  'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i',  'i',\n    'i',  'd', 'n', 'o', 'o', 'o', 'o',  'o',  'o', 'u', 'u', 'u', 'u', 'y', 'th', 'y',\n    // Converted Latin Extended-A letters.\n    'A', 'a', 'A', 'a', 'A', 'a', 'C', 'c', 'C', 'c', 'C', 'c', 'C', 'c',\n    'D', 'd', 'D', 'd', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e', 'E', 'e',\n    'G', 'g', 'G', 'g', 'G', 'g', 'G', 'g', 'H', 'h', 'H', 'h',\n    'I', 'i', 'I', 'i', 'I', 'i', 'I', 'i', 'I', 'i', 'IJ', 'ij', 'J', 'j',\n    'K', 'k', 'k', 'L', 'l', 'L', 'l', 'L', 'l', 'L', 'l', 'L', 'l',\n    'N', 'n', 'N', 'n', 'N', 'n', \"'n\", 'N', 'n',\n    'O', 'o', 'O', 'o', 'O', 'o', 'Oe', 'oe',\n    'R', 'r', 'R', 'r', 'R', 'r', 'S', 's', 'S', 's', 'S', 's', 'S', 's',\n    'T', 't', 'T', 't', 'T', 't',\n    'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u', 'U', 'u',\n    'W', 'w', 'Y', 'y', 'Y', 'Z', 'z', 'Z', 'z', 'Z', 'z', 's'\n  ];\n\n  /** Used to provide falsey values to methods. */\n  var falsey = [, null, undefined, false, 0, NaN, ''];\n\n  /** Used to specify the emoji style glyph variant of characters. */\n  var emojiVar = '\\ufe0f';\n\n  /** Used to provide empty values to methods. */\n  var empties = [[], {}].concat(falsey.slice(1));\n\n  /** Used to test error objects. */\n  var errors = [\n    new Error,\n    new EvalError,\n    new RangeError,\n    new ReferenceError,\n    new SyntaxError,\n    new TypeError,\n    new URIError\n  ];\n\n  /** List of fitzpatrick modifiers. */\n  var fitzModifiers = [\n    '\\ud83c\\udffb',\n    '\\ud83c\\udffc',\n    '\\ud83c\\udffd',\n    '\\ud83c\\udffe',\n    '\\ud83c\\udfff'\n  ];\n\n  /** Used to provide primitive values to methods. */\n  var primitives = [null, undefined, false, true, 1, NaN, 'a'];\n\n  /** Used to check whether methods support typed arrays. */\n  var typedArrays = [\n    'Float32Array',\n    'Float64Array',\n    'Int8Array',\n    'Int16Array',\n    'Int32Array',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'Uint16Array',\n    'Uint32Array'\n  ];\n\n  /** Used to check whether methods support array views. */\n  var arrayViews = typedArrays.concat('DataView');\n\n  /** The file path of the lodash file to test. */\n  var filePath = (function() {\n    var min = 2,\n        result = params || [];\n\n    if (phantom) {\n      min = 0;\n      result = params = phantom.args || require('system').args;\n    }\n    var last = result[result.length - 1];\n    result = (result.length > min && !/test(?:\\.js)?$/.test(last)) ? last : '../lodash.js';\n\n    if (!amd) {\n      try {\n        result = require('fs').realpathSync(result);\n      } catch (e) {}\n\n      try {\n        result = require.resolve(result);\n      } catch (e) {}\n    }\n    return result;\n  }());\n\n  /** The `ui` object. */\n  var ui = root.ui || (root.ui = {\n    'buildPath': filePath,\n    'loaderPath': '',\n    'isModularize': /\\b(?:amd|commonjs|es|node|npm|(index|main)\\.js)\\b/.test(filePath),\n    'isStrict': /\\bes\\b/.test(filePath) || 'default' in require(filePath),\n    'urlParams': {}\n  });\n\n  /** The basename of the lodash file to test. */\n  var basename = /[\\w.-]+$/.exec(filePath)[0];\n\n  /** Used to indicate testing a modularized build. */\n  var isModularize = ui.isModularize;\n\n  /** Detect if testing `npm` modules. */\n  var isNpm = isModularize && /\\bnpm\\b/.test([ui.buildPath, ui.urlParams.build]);\n\n  /** Detect if running in PhantomJS. */\n  var isPhantom = phantom || (typeof callPhantom == 'function');\n\n  /** Detect if lodash is in strict mode. */\n  var isStrict = ui.isStrict;\n\n  /*--------------------------------------------------------------------------*/\n\n  // Leak to avoid sporadic `noglobals` fails on Edge in Sauce Labs.\n  root.msWDfn = undefined;\n\n  // Assign `setTimeout` to itself to avoid being flagged as a leak.\n  setProperty(root, 'setTimeout', setTimeout);\n\n  // Exit early if going to run tests in a PhantomJS web page.\n  if (phantom && isModularize) {\n    var page = require('webpage').create();\n\n    page.onCallback = function(details) {\n      var coverage = details.coverage;\n      if (coverage) {\n        var fs = require('fs'),\n            cwd = fs.workingDirectory,\n            sep = fs.separator;\n\n        fs.write([cwd, 'coverage', 'coverage.json'].join(sep), JSON.stringify(coverage));\n      }\n      phantom.exit(details.failed ? 1 : 0);\n    };\n\n    page.onConsoleMessage = function(message) {\n      console.log(message);\n    };\n\n    page.onInitialized = function() {\n      page.evaluate(function() {\n        document.addEventListener('DOMContentLoaded', function() {\n          QUnit.done(function(details) {\n            details.coverage = window.__coverage__;\n            callPhantom(details);\n          });\n        });\n      });\n    };\n\n    page.open(filePath, function(status) {\n      if (status != 'success') {\n        console.log('PhantomJS failed to load page: ' + filePath);\n        phantom.exit(1);\n      }\n    });\n\n    console.log('test.js invoked with arguments: ' + JSON.stringify(slice.call(params)));\n    return;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Used to test Web Workers. */\n  var Worker = !(ui.isForeign || ui.isSauceLabs || isModularize) &&\n    (document && document.origin != 'null') && root.Worker;\n\n  /** Used to test host objects in IE. */\n  try {\n    var xml = new ActiveXObject('Microsoft.XMLDOM');\n  } catch (e) {}\n\n  /** Poison the free variable `root` in Node.js */\n  try {\n    defineProperty(global.root, 'root', {\n      'configurable': false,\n      'enumerable': false,\n      'get': function() { throw new ReferenceError; }\n    });\n  } catch (e) {}\n\n  /** Load QUnit and extras. */\n  var QUnit = root.QUnit || require('qunit-extras');\n\n  /** Load stable Lodash. */\n  var lodashStable = root.lodashStable;\n  if (!lodashStable) {\n    try {\n      lodashStable = interopRequire('../node_modules/lodash/lodash.js');\n    } catch (e) {\n      console.log('Error: The stable lodash dev dependency should be at least a version behind master branch.');\n      return;\n    }\n    lodashStable = lodashStable.noConflict();\n  }\n\n  /** The `lodash` function to test. */\n  var _ = root._ || (root._ = interopRequire(filePath));\n\n  /** Used to test pseudo private map caches. */\n  var mapCaches = (function() {\n    var MapCache = (_.memoize || lodashStable.memoize).Cache;\n    var result = {\n      'Hash': new MapCache().__data__.hash.constructor,\n      'MapCache': MapCache\n    };\n    (_.isMatchWith || lodashStable.isMatchWith)({ 'a': 1 }, { 'a': 1 }, function() {\n      var stack = lodashStable.last(arguments);\n      result.ListCache = stack.__data__.constructor;\n      result.Stack = stack.constructor;\n    });\n    return result;\n  }());\n\n  /** Used to detect instrumented istanbul code coverage runs. */\n  var coverage = root.__coverage__ || root[lodashStable.find(lodashStable.keys(root), function(key) {\n    return /^(?:\\$\\$cov_\\d+\\$\\$)$/.test(key);\n  })];\n\n  /** Used to test async functions. */\n  var asyncFunc = lodashStable.attempt(function() {\n    return Function('return async () => {}');\n  });\n\n  /** Used to test generator functions. */\n  var genFunc = lodashStable.attempt(function() {\n    return Function('return function*(){}');\n  });\n\n  /** Used to restore the `_` reference. */\n  var oldDash = root._;\n\n  /**\n   * Used to check for problems removing whitespace. For a whitespace reference,\n   * see [V8's unit test](https://code.google.com/p/v8/source/browse/branches/bleeding_edge/test/mjsunit/whitespaces.js).\n   */\n  var whitespace = lodashStable.filter([\n    // Basic whitespace characters.\n    ' ', '\\t', '\\x0b', '\\f', '\\xa0', '\\ufeff',\n\n    // Line terminators.\n    '\\n', '\\r', '\\u2028', '\\u2029',\n\n    // Unicode category \"Zs\" space separators.\n    '\\u1680', '\\u180e', '\\u2000', '\\u2001', '\\u2002', '\\u2003', '\\u2004', '\\u2005',\n    '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200a', '\\u202f', '\\u205f', '\\u3000'\n  ],\n  function(chr) { return /\\s/.exec(chr); })\n  .join('');\n\n  /**\n   * Creates a custom error object.\n   *\n   * @private\n   * @constructor\n   * @param {string} message The error message.\n   */\n  function CustomError(message) {\n    this.name = 'CustomError';\n    this.message = message;\n  }\n\n  CustomError.prototype = lodashStable.create(Error.prototype, {\n    'constructor': CustomError\n  });\n\n  /**\n   * Removes all own enumerable string keyed properties from a given object.\n   *\n   * @private\n   * @param {Object} object The object to empty.\n   */\n  function emptyObject(object) {\n    lodashStable.forOwn(object, function(value, key, object) {\n      delete object[key];\n    });\n  }\n\n  /**\n   * Extracts the unwrapped value from its wrapper.\n   *\n   * @private\n   * @param {Object} wrapper The wrapper to unwrap.\n   * @returns {*} Returns the unwrapped value.\n   */\n  function getUnwrappedValue(wrapper) {\n    var index = -1,\n        actions = wrapper.__actions__,\n        length = actions.length,\n        result = wrapper.__wrapped__;\n\n    while (++index < length) {\n      var args = [result],\n          action = actions[index];\n\n      push.apply(args, action.args);\n      result = action.func.apply(action.thisArg, args);\n    }\n    return result;\n  }\n\n  /**\n   * Loads the module of `id`. If the module has an `exports.default`, the\n   * exported default value is returned as the resolved module.\n   *\n   * @private\n   * @param {string} id The identifier of the module to resolve.\n   * @returns {*} Returns the resolved module.\n   */\n  function interopRequire(id) {\n    var result = require(id);\n    return 'default' in result ? result['default'] : result;\n  }\n\n  /**\n   * Sets a non-enumerable property value on `object`.\n   *\n   * Note: This function is used to avoid a bug in older versions of V8 where\n   * overwriting non-enumerable built-ins makes them enumerable.\n   * See https://code.google.com/p/v8/issues/detail?id=1623\n   *\n   * @private\n   * @param {Object} object The object modify.\n   * @param {string} key The name of the property to set.\n   * @param {*} value The property value.\n   */\n  function setProperty(object, key, value) {\n    try {\n      defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': false,\n        'writable': true,\n        'value': value\n      });\n    } catch (e) {\n      object[key] = value;\n    }\n    return object;\n  }\n\n  /**\n   * Skips a given number of tests with a passing result.\n   *\n   * @private\n   * @param {Object} assert The QUnit assert object.\n   * @param {number} [count=1] The number of tests to skip.\n   */\n  function skipAssert(assert, count) {\n    count || (count = 1);\n    while (count--) {\n      assert.ok(true, 'test skipped');\n    }\n  }\n\n  /**\n   * Converts `array` to an `arguments` object.\n   *\n   * @private\n   * @param {Array} array The array to convert.\n   * @returns {Object} Returns the converted `arguments` object.\n   */\n  function toArgs(array) {\n    return (function() { return arguments; }.apply(undefined, array));\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Add bizarro values.\n  (function() {\n    if (document || (typeof require != 'function')) {\n      return;\n    }\n    var nativeString = fnToString.call(toString),\n        reToString = /toString/g;\n\n    function createToString(funcName) {\n      return lodashStable.constant(nativeString.replace(reToString, funcName));\n    }\n\n    // Allow bypassing native checks.\n    setProperty(funcProto, 'toString', function wrapper() {\n      setProperty(funcProto, 'toString', fnToString);\n      var result = lodashStable.has(this, 'toString') ? this.toString() : fnToString.call(this);\n      setProperty(funcProto, 'toString', wrapper);\n      return result;\n    });\n\n    // Add prototype extensions.\n    funcProto._method = noop;\n\n    // Set bad shims.\n    setProperty(Object, 'create', undefined);\n    setProperty(Object, 'getOwnPropertySymbols', undefined);\n\n    var _propertyIsEnumerable = objectProto.propertyIsEnumerable;\n    setProperty(objectProto, 'propertyIsEnumerable', function(key) {\n      return !(key == 'valueOf' && this && this.valueOf === 1) && _propertyIsEnumerable.call(this, key);\n    });\n\n    if (Buffer) {\n      defineProperty(root, 'Buffer', {\n        'configurable': true,\n        'enumerable': true,\n        'get': function get() {\n          var caller = get.caller,\n              name = caller ? caller.name : '';\n\n          if (!(name == 'runInContext' || name.length == 1 || /\\b_\\.isBuffer\\b/.test(caller))) {\n            return Buffer;\n          }\n        }\n      });\n    }\n    if (Map) {\n      setProperty(root, 'Map', (function() {\n        var count = 0;\n        return function() {\n          if (count++) {\n            return new Map;\n          }\n          setProperty(root, 'Map', Map);\n          return {};\n        };\n      }()));\n\n      setProperty(root.Map, 'toString', createToString('Map'));\n    }\n    setProperty(root, 'Promise', noop);\n    setProperty(root, 'Set', noop);\n    setProperty(root, 'Symbol', undefined);\n    setProperty(root, 'WeakMap', noop);\n\n    // Fake `WinRTError`.\n    setProperty(root, 'WinRTError', Error);\n\n    // Clear cache so lodash can be reloaded.\n    emptyObject(require.cache);\n\n    // Load lodash and expose it to the bad extensions/shims.\n    lodashBizarro = interopRequire(filePath);\n    root._ = oldDash;\n\n    // Restore built-in methods.\n    setProperty(Object, 'create', create);\n    setProperty(objectProto, 'propertyIsEnumerable', _propertyIsEnumerable);\n    setProperty(root, 'Buffer', Buffer);\n\n    if (getSymbols) {\n      Object.getOwnPropertySymbols = getSymbols;\n    } else {\n      delete Object.getOwnPropertySymbols;\n    }\n    if (Map) {\n      setProperty(root, 'Map', Map);\n    } else {\n      delete root.Map;\n    }\n    if (Promise) {\n      setProperty(root, 'Promise', Promise);\n    } else {\n      delete root.Promise;\n    }\n    if (Set) {\n      setProperty(root, 'Set', Set);\n    } else {\n      delete root.Set;\n    }\n    if (Symbol) {\n      setProperty(root, 'Symbol', Symbol);\n    } else {\n      delete root.Symbol;\n    }\n    if (WeakMap) {\n      setProperty(root, 'WeakMap', WeakMap);\n    } else {\n      delete root.WeakMap;\n    }\n    delete root.WinRTError;\n    delete funcProto._method;\n  }());\n\n  // Add other realm values from the `vm` module.\n  lodashStable.attempt(function() {\n    lodashStable.assign(realm, require('vm').runInNewContext([\n      '(function() {',\n      '  var noop = function() {},',\n      '      root = this;',\n      '',\n      '  var object = {',\n      \"    'ArrayBuffer': root.ArrayBuffer,\",\n      \"    'arguments': (function() { return arguments; }(1, 2, 3)),\",\n      \"    'array': [1],\",\n      \"    'arrayBuffer': root.ArrayBuffer ? new root.ArrayBuffer : undefined,\",\n      \"    'boolean': Object(false),\",\n      \"    'date': new Date,\",\n      \"    'errors': [new Error, new EvalError, new RangeError, new ReferenceError, new SyntaxError, new TypeError, new URIError],\",\n      \"    'function': noop,\",\n      \"    'map': root.Map ? new root.Map : undefined,\",\n      \"    'nan': NaN,\",\n      \"    'null': null,\",\n      \"    'number': Object(0),\",\n      \"    'object': { 'a': 1 },\",\n      \"    'promise': root.Promise ? Promise.resolve(1) : undefined,\",\n      \"    'regexp': /x/,\",\n      \"    'set': root.Set ? new root.Set : undefined,\",\n      \"    'string': Object('a'),\",\n      \"    'symbol': root.Symbol ? root.Symbol() : undefined,\",\n      \"    'undefined': undefined,\",\n      \"    'weakMap': root.WeakMap ? new root.WeakMap : undefined,\",\n      \"    'weakSet': root.WeakSet ? new root.WeakSet : undefined\",\n      '  };',\n      '',\n      \"  ['\" + arrayViews.join(\"', '\") + \"'].forEach(function(type) {\",\n      '    var Ctor = root[type]',\n      '    object[type] = Ctor;',\n      '    object[type.toLowerCase()] = Ctor ? new Ctor(new ArrayBuffer(24)) : undefined;',\n      '  });',\n      '',\n      '  return object;',\n      '}());'\n    ].join('\\n')));\n  });\n\n  // Add other realm values from an iframe.\n  lodashStable.attempt(function() {\n    _._realm = realm;\n\n    var iframe = document.createElement('iframe');\n    iframe.frameBorder = iframe.height = iframe.width = 0;\n    body.appendChild(iframe);\n\n    var idoc = (idoc = iframe.contentDocument || iframe.contentWindow).document || idoc;\n    idoc.write([\n      '<html>',\n      '<body>',\n      '<script>',\n      'var _ = parent._,',\n      '    noop = function() {},',\n      '    root = this;',\n      '',\n      'var object = {',\n      \"  'ArrayBuffer': root.ArrayBuffer,\",\n      \"  'arguments': (function() { return arguments; }(1, 2, 3)),\",\n      \"  'array': [1],\",\n      \"  'arrayBuffer': root.ArrayBuffer ? new root.ArrayBuffer : undefined,\",\n      \"  'boolean': Object(false),\",\n      \"  'date': new Date,\",\n      \"  'element': document.body,\",\n      \"  'errors': [new Error, new EvalError, new RangeError, new ReferenceError, new SyntaxError, new TypeError, new URIError],\",\n      \"  'function': noop,\",\n      \"  'map': root.Map ? new root.Map : undefined,\",\n      \"  'nan': NaN,\",\n      \"  'null': null,\",\n      \"  'number': Object(0),\",\n      \"  'object': { 'a': 1 },\",\n      \"  'promise': root.Promise ? Promise.resolve(1) : undefined,\",\n      \"  'regexp': /x/,\",\n      \"  'set': root.Set ? new root.Set : undefined,\",\n      \"  'string': Object('a'),\",\n      \"  'symbol': root.Symbol ? root.Symbol() : undefined,\",\n      \"  'undefined': undefined,\",\n      \"  'weakMap': root.WeakMap ? new root.WeakMap : undefined,\",\n      \"  'weakSet': root.WeakSet ? new root.WeakSet : undefined\",\n      '};',\n      '',\n      \"_.each(['\" + arrayViews.join(\"', '\") + \"'], function(type) {\",\n      '  var Ctor = root[type];',\n      '  object[type] = Ctor;',\n      '  object[type.toLowerCase()] = Ctor ? new Ctor(new ArrayBuffer(24)) : undefined;',\n      '});',\n      '',\n      '_.assign(_._realm, object);',\n      '</script>',\n      '</body>',\n      '</html>'\n    ].join('\\n'));\n\n    idoc.close();\n    delete _._realm;\n  });\n\n  // Add a web worker.\n  lodashStable.attempt(function() {\n    var worker = new Worker('./asset/worker.js?t=' + (+new Date));\n    worker.addEventListener('message', function(e) {\n      _._VERSION = e.data || '';\n    }, false);\n\n    worker.postMessage(ui.buildPath);\n  });\n\n  // Expose internal modules for better code coverage.\n  lodashStable.attempt(function() {\n    var path = require('path'),\n        basePath = path.dirname(filePath);\n\n    if (isModularize && !(amd || isNpm)) {\n      lodashStable.each([\n        'baseEach',\n        'isIndex',\n        'isIterateeCall',\n        'memoizeCapped'\n      ], function(funcName) {\n        _['_' + funcName] = interopRequire(path.join(basePath, '_' + funcName));\n      });\n    }\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  if (params) {\n    console.log('Running lodash tests.');\n    console.log('test.js invoked with arguments: ' + JSON.stringify(slice.call(params)));\n  }\n\n  QUnit.module(basename);\n\n  (function() {\n    QUnit.test('should support loading ' + basename + ' as the \"lodash\" module', function(assert) {\n      assert.expect(1);\n\n      if (amd) {\n        assert.strictEqual((lodashModule || {}).moduleName, 'lodash');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should support loading ' + basename + ' with the Require.js \"shim\" configuration option', function(assert) {\n      assert.expect(1);\n\n      if (amd && lodashStable.includes(ui.loaderPath, 'requirejs')) {\n        assert.strictEqual((shimmedModule || {}).moduleName, 'shimmed');\n      } else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should support loading ' + basename + ' as the \"underscore\" module', function(assert) {\n      assert.expect(1);\n\n      if (amd) {\n        assert.strictEqual((underscoreModule || {}).moduleName, 'underscore');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should support loading ' + basename + ' in a web worker', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      if (Worker) {\n        var limit = 30000 / QUnit.config.asyncRetries,\n            start = +new Date;\n\n        var attempt = function() {\n          var actual = _._VERSION;\n          if ((new Date - start) < limit && typeof actual != 'string') {\n            setTimeout(attempt, 16);\n            return;\n          }\n          assert.strictEqual(actual, _.VERSION);\n          done();\n        };\n\n        attempt();\n      }\n      else {\n        skipAssert(assert);\n        done();\n      }\n    });\n\n    QUnit.test('should not add `Function.prototype` extensions to lodash', function(assert) {\n      assert.expect(1);\n\n      if (lodashBizarro) {\n        assert.notOk('_method' in lodashBizarro);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should avoid non-native built-ins', function(assert) {\n      assert.expect(6);\n\n      function message(lodashMethod, nativeMethod) {\n        return '`' + lodashMethod + '` should avoid overwritten native `' + nativeMethod + '`';\n      }\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var object = { 'a': 1 },\n          otherObject = { 'b': 2 },\n          largeArray = lodashStable.times(LARGE_ARRAY_SIZE, lodashStable.constant(object));\n\n      if (lodashBizarro) {\n        try {\n          var actual = lodashBizarro.create(Foo.prototype);\n        } catch (e) {\n          actual = null;\n        }\n        var label = message('_.create', 'Object.create');\n        assert.ok(actual instanceof Foo, label);\n\n        try {\n          actual = [\n            lodashBizarro.difference([object, otherObject], largeArray),\n            lodashBizarro.intersection(largeArray, [object]),\n            lodashBizarro.uniq(largeArray)\n          ];\n        } catch (e) {\n          actual = null;\n        }\n        label = message('_.difference`, `_.intersection`, and `_.uniq', 'Map');\n        assert.deepEqual(actual, [[otherObject], [object], [object]], label);\n\n        try {\n          if (Symbol) {\n            object[symbol] = {};\n          }\n          actual = [\n            lodashBizarro.clone(object),\n            lodashBizarro.cloneDeep(object)\n          ];\n        } catch (e) {\n          actual = null;\n        }\n        label = message('_.clone` and `_.cloneDeep', 'Object.getOwnPropertySymbols');\n        assert.deepEqual(actual, [object, object], label);\n\n        try {\n          // Avoid buggy symbol detection in Babel's `_typeof` helper.\n          var symObject = setProperty(Object(symbol), 'constructor', Object);\n          actual = [\n            Symbol ? lodashBizarro.clone(symObject) : {},\n            Symbol ? lodashBizarro.isEqual(symObject, Object(symbol)) : false,\n            Symbol ? lodashBizarro.toString(symObject) : ''\n          ];\n        } catch (e) {\n          actual = null;\n        }\n        label = message('_.clone`, `_.isEqual`, and `_.toString', 'Symbol');\n        assert.deepEqual(actual, [{}, false, ''], label);\n\n        try {\n          var map = new lodashBizarro.memoize.Cache;\n          actual = map.set('a', 1).get('a');\n        } catch (e) {\n          actual = null;\n        }\n        label = message('_.memoize.Cache', 'Map');\n        assert.deepEqual(actual, 1, label);\n\n        try {\n          map = new (Map || Object);\n          if (Symbol && Symbol.iterator) {\n            map[Symbol.iterator] = null;\n          }\n          actual = lodashBizarro.toArray(map);\n        } catch (e) {\n          actual = null;\n        }\n        label = message('_.toArray', 'Map');\n        assert.deepEqual(actual, [], label);\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('isIndex');\n\n  (function() {\n    var func = _._isIndex;\n\n    QUnit.test('should return `true` for indexes', function(assert) {\n      assert.expect(1);\n\n      if (func) {\n        var values = [[0], ['0'], ['1'], [3, 4], [MAX_SAFE_INTEGER - 1]],\n            expected = lodashStable.map(values, stubTrue);\n\n        var actual = lodashStable.map(values, function(args) {\n          return func.apply(undefined, args);\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non-indexes', function(assert) {\n      assert.expect(1);\n\n      if (func) {\n        var values = [['1abc'], ['07'], ['0001'], [-1], [3, 3], [1.1], [MAX_SAFE_INTEGER]],\n            expected = lodashStable.map(values, stubFalse);\n\n        var actual = lodashStable.map(values, function(args) {\n          return func.apply(undefined, args);\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('isIterateeCall');\n\n  (function() {\n    var array = [1],\n        func = _._isIterateeCall,\n        object =  { 'a': 1 };\n\n    QUnit.test('should return `true` for iteratee calls', function(assert) {\n      assert.expect(3);\n\n      function Foo() {}\n      Foo.prototype.a = 1;\n\n      if (func) {\n        assert.strictEqual(func(1, 0, array), true);\n        assert.strictEqual(func(1, 'a', object), true);\n        assert.strictEqual(func(1, 'a', new Foo), true);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should return `false` for non-iteratee calls', function(assert) {\n      assert.expect(4);\n\n      if (func) {\n        assert.strictEqual(func(2, 0, array), false);\n        assert.strictEqual(func(1, 1.1, array), false);\n        assert.strictEqual(func(1, 0, { 'length': MAX_SAFE_INTEGER + 1 }), false);\n        assert.strictEqual(func(1, 'b', object), false);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should work with `NaN` values', function(assert) {\n      assert.expect(2);\n\n      if (func) {\n        assert.strictEqual(func(NaN, 0, [NaN]), true);\n        assert.strictEqual(func(NaN, 'a', { 'a': NaN }), true);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should not error when `index` is an object without a `toString` method', function(assert) {\n      assert.expect(1);\n\n      if (func) {\n        try {\n          var actual = func(1, { 'toString': null }, [1]);\n        } catch (e) {\n          var message = e.message;\n        }\n        assert.strictEqual(actual, false, message || '');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('map caches');\n\n  (function() {\n    var keys = [null, undefined, false, true, 1, -Infinity, NaN, {}, 'a', symbol || noop];\n\n    var pairs = lodashStable.map(keys, function(key, index) {\n      var lastIndex = keys.length - 1;\n      return [key, keys[lastIndex - index]];\n    });\n\n    function createCaches(pairs) {\n      var largeStack = new mapCaches.Stack(pairs),\n          length = pairs ? pairs.length : 0;\n\n      lodashStable.times(LARGE_ARRAY_SIZE - length, function() {\n        largeStack.set({}, {});\n      });\n\n      return {\n        'hashes': new mapCaches.Hash(pairs),\n        'list caches': new mapCaches.ListCache(pairs),\n        'map caches': new mapCaches.MapCache(pairs),\n        'stack caches': new mapCaches.Stack(pairs),\n        'large stacks': largeStack\n      };\n    }\n\n    lodashStable.forOwn(createCaches(pairs), function(cache, kind) {\n      var isLarge = /^large/.test(kind);\n\n      QUnit.test('should implement a `Map` interface for ' + kind, function(assert) {\n        assert.expect(83);\n\n        lodashStable.each(keys, function(key, index) {\n          var value = pairs[index][1];\n\n          assert.deepEqual(cache.get(key), value);\n          assert.strictEqual(cache.has(key), true);\n          assert.strictEqual(cache.delete(key), true);\n          assert.strictEqual(cache.has(key), false);\n          assert.strictEqual(cache.get(key), undefined);\n          assert.strictEqual(cache.delete(key), false);\n          assert.strictEqual(cache.set(key, value), cache);\n          assert.strictEqual(cache.has(key), true);\n        });\n\n        assert.strictEqual(cache.size, isLarge ? LARGE_ARRAY_SIZE : keys.length);\n        assert.strictEqual(cache.clear(), undefined);\n        assert.ok(lodashStable.every(keys, function(key) {\n          return !cache.has(key);\n        }));\n      });\n    });\n\n    lodashStable.forOwn(createCaches(), function(cache, kind) {\n      QUnit.test('should support changing values of ' + kind, function(assert) {\n        assert.expect(10);\n\n        lodashStable.each(keys, function(key) {\n          cache.set(key, 1).set(key, 2);\n          assert.strictEqual(cache.get(key), 2);\n        });\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash constructor');\n\n  (function() {\n    var values = empties.concat(true, 1, 'a'),\n        expected = lodashStable.map(values, stubTrue);\n\n    QUnit.test('should create a new instance when called without the `new` operator', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = lodashStable.map(values, function(value) {\n          return _(value) instanceof _;\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return the given `lodash` instances', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = lodashStable.map(values, function(value) {\n          var wrapped = _(value);\n          return _(wrapped) === wrapped;\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should convert foreign wrapped values to `lodash` instances', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm && lodashBizarro) {\n        var actual = lodashStable.map(values, function(value) {\n          var wrapped = _(lodashBizarro(value)),\n              unwrapped = wrapped.value();\n\n          return wrapped instanceof _ &&\n            ((unwrapped === value) || (unwrapped !== unwrapped && value !== value));\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.add');\n\n  (function() {\n    QUnit.test('should add two numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.add(6, 4), 10);\n      assert.strictEqual(_.add(-6, 4), -2);\n      assert.strictEqual(_.add(-6, -4), -10);\n    });\n\n    QUnit.test('should not coerce arguments to numbers', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.add('6', '4'), '64');\n      assert.strictEqual(_.add('x', 'y'), 'xy');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.after');\n\n  (function() {\n    function after(n, times) {\n      var count = 0;\n      lodashStable.times(times, _.after(n, function() { count++; }));\n      return count;\n    }\n\n    QUnit.test('should create a function that invokes `func` after `n` calls', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(after(5, 5), 1, 'after(n) should invoke `func` after being called `n` times');\n      assert.strictEqual(after(5, 4), 0, 'after(n) should not invoke `func` before being called `n` times');\n      assert.strictEqual(after(0, 0), 0, 'after(0) should not invoke `func` immediately');\n      assert.strictEqual(after(0, 1), 1, 'after(0) should invoke `func` when called once');\n    });\n\n    QUnit.test('should coerce `n` values of `NaN` to `0`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(after(NaN, 1), 1);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(2);\n\n      var after = _.after(1, function(assert) { return ++this.count; }),\n          object = { 'after': after, 'count': 0 };\n\n      object.after();\n      assert.strictEqual(object.after(), 2);\n      assert.strictEqual(object.count, 2);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.ary');\n\n  (function() {\n    function fn(a, b, c) {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should cap the number of arguments provided to `func`', function(assert) {\n      assert.expect(2);\n\n      var actual = lodashStable.map(['6', '8', '10'], _.ary(parseInt, 1));\n      assert.deepEqual(actual, [6, 8, 10]);\n\n      var capped = _.ary(fn, 2);\n      assert.deepEqual(capped('a', 'b', 'c', 'd'), ['a', 'b']);\n    });\n\n    QUnit.test('should use `func.length` if `n` is not given', function(assert) {\n      assert.expect(1);\n\n      var capped = _.ary(fn);\n      assert.deepEqual(capped('a', 'b', 'c', 'd'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should treat a negative `n` as `0`', function(assert) {\n      assert.expect(1);\n\n      var capped = _.ary(fn, -1);\n\n      try {\n        var actual = capped('a');\n      } catch (e) {}\n\n      assert.deepEqual(actual, []);\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(1);\n\n      var values = ['1', 1.6, 'xyz'],\n          expected = [['a'], ['a'], []];\n\n      var actual = lodashStable.map(values, function(n) {\n        var capped = _.ary(fn, n);\n        return capped('a', 'b');\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not force a minimum argument count', function(assert) {\n      assert.expect(1);\n\n      var args = ['a', 'b', 'c'],\n          capped = _.ary(fn, 3);\n\n      var expected = lodashStable.map(args, function(arg, index) {\n        return args.slice(0, index);\n      });\n\n      var actual = lodashStable.map(expected, function(array) {\n        return capped.apply(undefined, array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(1);\n\n      var capped = _.ary(function(a, b) { return this; }, 1),\n          object = { 'capped': capped };\n\n      assert.strictEqual(object.capped(), object);\n    });\n\n    QUnit.test('should use the existing `ary` if smaller', function(assert) {\n      assert.expect(1);\n\n      var capped = _.ary(_.ary(fn, 1), 2);\n      assert.deepEqual(capped('a', 'b', 'c'), ['a']);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var funcs = lodashStable.map([fn], _.ary),\n          actual = funcs[0]('a', 'b', 'c');\n\n      assert.deepEqual(actual, ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should work when combined with other methods that use metadata', function(assert) {\n      assert.expect(2);\n\n      var array = ['a', 'b', 'c'],\n          includes = _.curry(_.rearg(_.ary(_.includes, 2), 1, 0), 2);\n\n      assert.strictEqual(includes('b')(array, 2), true);\n\n      if (!isNpm) {\n        includes = _(_.includes).ary(2).rearg(1, 0).curry(2).value();\n        assert.strictEqual(includes('b')(array, 2), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.assignIn');\n\n  (function() {\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.extend, _.assignIn);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.assign and lodash.assignIn');\n\n  lodashStable.each(['assign', 'assignIn'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should assign source properties to `object`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func({ 'a': 1 }, { 'b': 2 }), { 'a': 1, 'b': 2 });\n    });\n\n    QUnit.test('`_.' + methodName + '` should accept multiple sources', function(assert) {\n      assert.expect(2);\n\n      var expected = { 'a': 1, 'b': 2, 'c': 3 };\n      assert.deepEqual(func({ 'a': 1 }, { 'b': 2 }, { 'c': 3 }), expected);\n      assert.deepEqual(func({ 'a': 1 }, { 'b': 2, 'c': 2 }, { 'c': 3 }), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should overwrite destination properties', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'a': 3, 'b': 2, 'c': 1 };\n      assert.deepEqual(func({ 'a': 1, 'b': 2 }, expected), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should assign source properties with nullish values', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'a': null, 'b': undefined, 'c': null };\n      assert.deepEqual(func({ 'a': 1, 'b': 2 }, expected), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should skip assignments if values are the same', function(assert) {\n      assert.expect(1);\n\n      var object = {};\n\n      var descriptor = {\n        'configurable': true,\n        'enumerable': true,\n        'set': function() { throw new Error; }\n      };\n\n      var source = {\n        'a': 1,\n        'b': undefined,\n        'c': NaN,\n        'd': undefined,\n        'constructor': Object,\n        'toString': lodashStable.constant('source')\n      };\n\n      defineProperty(object, 'a', lodashStable.assign({}, descriptor, {\n        'get': stubOne\n      }));\n\n      defineProperty(object, 'b', lodashStable.assign({}, descriptor, {\n        'get': noop\n      }));\n\n      defineProperty(object, 'c', lodashStable.assign({}, descriptor, {\n        'get': stubNaN\n      }));\n\n      defineProperty(object, 'constructor', lodashStable.assign({}, descriptor, {\n        'get': lodashStable.constant(Object)\n      }));\n\n      try {\n        var actual = func(object, source);\n      } catch (e) {}\n\n      assert.deepEqual(actual, source);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat sparse array sources as dense', function(assert) {\n      assert.expect(1);\n\n      var array = [1];\n      array[2] = 3;\n\n      assert.deepEqual(func({}, array), { '0': 1, '1': undefined, '2': 3 });\n    });\n\n    QUnit.test('`_.' + methodName + '` should assign values of prototype objects', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype.a = 1;\n\n      assert.deepEqual(func({}, Foo.prototype), { 'a': 1 });\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce string sources to objects', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func({}, 'a'), { '0': 'a' });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.assignInWith');\n\n  (function() {\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.extendWith, _.assignInWith);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.assignWith and lodash.assignInWith');\n\n  lodashStable.each(['assignWith', 'assignInWith'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should work with a `customizer` callback', function(assert) {\n      assert.expect(1);\n\n      var actual = func({ 'a': 1, 'b': 2 }, { 'a': 3, 'c': 3 }, function(a, b) {\n        return a === undefined ? b : a;\n      });\n\n      assert.deepEqual(actual, { 'a': 1, 'b': 2, 'c': 3 });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a `customizer` that returns `undefined`', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'a': 1 };\n      assert.deepEqual(func({}, expected, noop), expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.at');\n\n  (function() {\n    var array = ['a', 'b', 'c'],\n        object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\n    QUnit.test('should return the elements corresponding to the specified keys', function(assert) {\n      assert.expect(1);\n\n      var actual = _.at(array, [0, 2]);\n      assert.deepEqual(actual, ['a', 'c']);\n    });\n\n    QUnit.test('should return `undefined` for nonexistent keys', function(assert) {\n      assert.expect(1);\n\n      var actual = _.at(array, [2, 4, 0]);\n      assert.deepEqual(actual, ['c', undefined, 'a']);\n    });\n\n    QUnit.test('should work with non-index keys on array values', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.reject(empties, function(value) {\n        return (value === 0) || lodashStable.isArray(value);\n      }).concat(-1, 1.1);\n\n      var array = lodashStable.transform(values, function(result, value) {\n        result[value] = 1;\n      }, []);\n\n      var expected = lodashStable.map(values, stubOne),\n          actual = _.at(array, values);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an empty array when no keys are given', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.at(array), []);\n      assert.deepEqual(_.at(array, [], []), []);\n    });\n\n    QUnit.test('should accept multiple key arguments', function(assert) {\n      assert.expect(1);\n\n      var actual = _.at(['a', 'b', 'c', 'd'], 3, 0, 2);\n      assert.deepEqual(actual, ['d', 'a', 'c']);\n    });\n\n    QUnit.test('should work with a falsey `object` when keys are given', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, lodashStable.constant(Array(4)));\n\n      var actual = lodashStable.map(falsey, function(object) {\n        try {\n          return _.at(object, 0, 1, 'pop', 'push');\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with an `arguments` object for `object`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.at(args, [2, 0]);\n      assert.deepEqual(actual, [3, 1]);\n    });\n\n    QUnit.test('should work with `arguments` object as secondary arguments', function(assert) {\n      assert.expect(1);\n\n      var actual = _.at([1, 2, 3, 4, 5], args);\n      assert.deepEqual(actual, [2, 3, 4]);\n    });\n\n    QUnit.test('should work with an object for `object`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.at(object, ['a[0].b.c', 'a[1]']);\n      assert.deepEqual(actual, [3, 4]);\n    });\n\n    QUnit.test('should pluck inherited property values', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var actual = _.at(new Foo, 'b');\n      assert.deepEqual(actual, [2]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var largeArray = lodashStable.range(LARGE_ARRAY_SIZE),\n            smallArray = array;\n\n        lodashStable.each([[2], ['2'], [2, 1]], function(paths) {\n          lodashStable.times(2, function(index) {\n            var array = index ? largeArray : smallArray,\n                wrapped = _(array).map(identity).at(paths);\n\n            assert.deepEqual(wrapped.value(), _.at(_.map(array, identity), paths));\n          });\n        });\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n\n    QUnit.test('should support shortcut fusion', function(assert) {\n      assert.expect(8);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            count = 0,\n            iteratee = function(value) { count++; return square(value); },\n            lastIndex = LARGE_ARRAY_SIZE - 1;\n\n        lodashStable.each([lastIndex, lastIndex + '', LARGE_ARRAY_SIZE, []], function(n, index) {\n          count = 0;\n          var actual = _(array).map(iteratee).at(n).value(),\n              expected = index < 2 ? 1 : 0;\n\n          assert.strictEqual(count, expected);\n\n          expected = index == 3 ? [] : [index == 2 ? undefined : square(lastIndex)];\n          assert.deepEqual(actual, expected);\n        });\n      }\n      else {\n        skipAssert(assert, 8);\n      }\n    });\n\n    QUnit.test('work with an object for `object` when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var paths = ['a[0].b.c', 'a[1]'],\n            actual = _(object).map(identity).at(paths).value();\n\n        assert.deepEqual(actual, _.at(_.map(object, identity), paths));\n\n        var indexObject = { '0': 1 };\n        actual = _(indexObject).at(0).value();\n        assert.deepEqual(actual, _.at(indexObject, 0));\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.attempt');\n\n  (function() {\n    QUnit.test('should return the result of `func`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.attempt(lodashStable.constant('x')), 'x');\n    });\n\n    QUnit.test('should provide additional arguments to `func`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.attempt(function() { return slice.call(arguments); }, 1, 2);\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('should return the caught error', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(errors, stubTrue);\n\n      var actual = lodashStable.map(errors, function(error) {\n        return _.attempt(function() { throw error; }) === error;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should coerce errors to error objects', function(assert) {\n      assert.expect(1);\n\n      var actual = _.attempt(function() { throw 'x'; });\n      assert.ok(lodashStable.isEqual(actual, Error('x')));\n    });\n\n    QUnit.test('should preserve custom errors', function(assert) {\n      assert.expect(1);\n\n      var actual = _.attempt(function() { throw new CustomError('x'); });\n      assert.ok(actual instanceof CustomError);\n    });\n\n    QUnit.test('should work with an error object from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.errors) {\n        var expected = lodashStable.map(realm.errors, stubTrue);\n\n        var actual = lodashStable.map(realm.errors, function(error) {\n          return _.attempt(function() { throw error; }) === error;\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.strictEqual(_(lodashStable.constant('x')).attempt(), 'x');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(lodashStable.constant('x')).chain().attempt() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.before');\n\n  (function() {\n    function before(n, times) {\n      var count = 0;\n      lodashStable.times(times, _.before(n, function() { count++; }));\n      return count;\n    }\n\n    QUnit.test('should create a function that invokes `func` after `n` calls', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(before(5, 4), 4, 'before(n) should invoke `func` before being called `n` times');\n      assert.strictEqual(before(5, 6), 4, 'before(n) should not invoke `func` after being called `n - 1` times');\n      assert.strictEqual(before(0, 0), 0, 'before(0) should not invoke `func` immediately');\n      assert.strictEqual(before(0, 1), 0, 'before(0) should not invoke `func` when called');\n    });\n\n    QUnit.test('should coerce `n` values of `NaN` to `0`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(before(NaN, 1), 0);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(2);\n\n      var before = _.before(2, function(assert) { return ++this.count; }),\n          object = { 'before': before, 'count': 0 };\n\n      object.before();\n      assert.strictEqual(object.before(), 1);\n      assert.strictEqual(object.count, 1);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.bind');\n\n  (function() {\n    function fn() {\n      var result = [this];\n      push.apply(result, arguments);\n      return result;\n    }\n\n    QUnit.test('should bind a function to an object', function(assert) {\n      assert.expect(1);\n\n      var object = {},\n          bound = _.bind(fn, object);\n\n      assert.deepEqual(bound('a'), [object, 'a']);\n    });\n\n    QUnit.test('should accept a falsey `thisArg`', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.reject(falsey.slice(1), function(value) { return value == null; }),\n          expected = lodashStable.map(values, function(value) { return [value]; });\n\n      var actual = lodashStable.map(values, function(value) {\n        try {\n          var bound = _.bind(fn, value);\n          return bound();\n        } catch (e) {}\n      });\n\n      assert.ok(lodashStable.every(actual, function(value, index) {\n        return lodashStable.isEqual(value, expected[index]);\n      }));\n    });\n\n    QUnit.test('should bind a function to nullish values', function(assert) {\n      assert.expect(6);\n\n      var bound = _.bind(fn, null),\n          actual = bound('a');\n\n      assert.ok((actual[0] === null) || (actual[0] && actual[0].Array));\n      assert.strictEqual(actual[1], 'a');\n\n      lodashStable.times(2, function(index) {\n        bound = index ? _.bind(fn, undefined) : _.bind(fn);\n        actual = bound('b');\n\n        assert.ok((actual[0] === undefined) || (actual[0] && actual[0].Array));\n        assert.strictEqual(actual[1], 'b');\n      });\n    });\n\n    QUnit.test('should partially apply arguments ', function(assert) {\n      assert.expect(4);\n\n      var object = {},\n          bound = _.bind(fn, object, 'a');\n\n      assert.deepEqual(bound(), [object, 'a']);\n\n      bound = _.bind(fn, object, 'a');\n      assert.deepEqual(bound('b'), [object, 'a', 'b']);\n\n      bound = _.bind(fn, object, 'a', 'b');\n      assert.deepEqual(bound(), [object, 'a', 'b']);\n      assert.deepEqual(bound('c', 'd'), [object, 'a', 'b', 'c', 'd']);\n    });\n\n    QUnit.test('should support placeholders', function(assert) {\n      assert.expect(4);\n\n      var object = {},\n          ph = _.bind.placeholder,\n          bound = _.bind(fn, object, ph, 'b', ph);\n\n      assert.deepEqual(bound('a', 'c'), [object, 'a', 'b', 'c']);\n      assert.deepEqual(bound('a'), [object, 'a', 'b', undefined]);\n      assert.deepEqual(bound('a', 'c', 'd'), [object, 'a', 'b', 'c', 'd']);\n      assert.deepEqual(bound(), [object, undefined, 'b', undefined]);\n    });\n\n    QUnit.test('should use `_.placeholder` when set', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var _ph = _.placeholder = {},\n            ph = _.bind.placeholder,\n            object = {},\n            bound = _.bind(fn, object, _ph, 'b', ph);\n\n        assert.deepEqual(bound('a', 'c'), [object, 'a', 'b', ph, 'c']);\n        delete _.placeholder;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should create a function with a `length` of `0`', function(assert) {\n      assert.expect(2);\n\n      var fn = function(a, b, c) {},\n          bound = _.bind(fn, {});\n\n      assert.strictEqual(bound.length, 0);\n\n      bound = _.bind(fn, {}, 1);\n      assert.strictEqual(bound.length, 0);\n    });\n\n    QUnit.test('should ignore binding when called with the `new` operator', function(assert) {\n      assert.expect(3);\n\n      function Foo() {\n        return this;\n      }\n\n      var bound = _.bind(Foo, { 'a': 1 }),\n          newBound = new bound;\n\n      assert.strictEqual(bound().a, 1);\n      assert.strictEqual(newBound.a, undefined);\n      assert.ok(newBound instanceof Foo);\n    });\n\n    QUnit.test('should handle a number of arguments when called with the `new` operator', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        return this;\n      }\n\n      function Bar() {}\n\n      var thisArg = { 'a': 1 },\n          boundFoo = _.bind(Foo, thisArg),\n          boundBar = _.bind(Bar, thisArg),\n          count = 9,\n          expected = lodashStable.times(count, lodashStable.constant([undefined, undefined]));\n\n      var actual = lodashStable.times(count, function(index) {\n        try {\n          switch (index) {\n            case 0: return [new boundFoo().a, new boundBar().a];\n            case 1: return [new boundFoo(1).a, new boundBar(1).a];\n            case 2: return [new boundFoo(1, 2).a, new boundBar(1, 2).a];\n            case 3: return [new boundFoo(1, 2, 3).a, new boundBar(1, 2, 3).a];\n            case 4: return [new boundFoo(1, 2, 3, 4).a, new boundBar(1, 2, 3, 4).a];\n            case 5: return [new boundFoo(1, 2, 3, 4, 5).a, new boundBar(1, 2, 3, 4, 5).a];\n            case 6: return [new boundFoo(1, 2, 3, 4, 5, 6).a, new boundBar(1, 2, 3, 4, 5, 6).a];\n            case 7: return [new boundFoo(1, 2, 3, 4, 5, 6, 7).a, new boundBar(1, 2, 3, 4, 5, 6, 7).a];\n            case 8: return [new boundFoo(1, 2, 3, 4, 5, 6, 7, 8).a, new boundBar(1, 2, 3, 4, 5, 6, 7, 8).a];\n          }\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should ensure `new bound` is an instance of `func`', function(assert) {\n      assert.expect(2);\n\n      function Foo(value) {\n        return value && object;\n      }\n\n      var bound = _.bind(Foo),\n          object = {};\n\n      assert.ok(new bound instanceof Foo);\n      assert.strictEqual(new bound(true), object);\n    });\n\n    QUnit.test('should append array arguments to partially applied arguments', function(assert) {\n      assert.expect(1);\n\n      var object = {},\n          bound = _.bind(fn, object, 'a');\n\n      assert.deepEqual(bound(['b'], 'c'), [object, 'a', ['b'], 'c']);\n    });\n\n    QUnit.test('should not rebind functions', function(assert) {\n      assert.expect(3);\n\n      var object1 = {},\n          object2 = {},\n          object3 = {};\n\n      var bound1 = _.bind(fn, object1),\n          bound2 = _.bind(bound1, object2, 'a'),\n          bound3 = _.bind(bound1, object3, 'b');\n\n      assert.deepEqual(bound1(), [object1]);\n      assert.deepEqual(bound2(), [object1, 'a']);\n      assert.deepEqual(bound3(), [object1, 'b']);\n    });\n\n    QUnit.test('should not error when instantiating bound built-ins', function(assert) {\n      assert.expect(2);\n\n      var Ctor = _.bind(Date, null),\n          expected = new Date(2012, 4, 23, 0, 0, 0, 0);\n\n      try {\n        var actual = new Ctor(2012, 4, 23, 0, 0, 0, 0);\n      } catch (e) {}\n\n      assert.deepEqual(actual, expected);\n\n      Ctor = _.bind(Date, null, 2012, 4, 23);\n\n      try {\n        actual = new Ctor(0, 0, 0, 0);\n      } catch (e) {}\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not error when calling bound class constructors with the `new` operator', function(assert) {\n      assert.expect(1);\n\n      var createCtor = lodashStable.attempt(Function, '\"use strict\";return class A{}');\n\n      if (typeof createCtor == 'function') {\n        var bound = _.bind(createCtor()),\n            count = 8,\n            expected = lodashStable.times(count, stubTrue);\n\n        var actual = lodashStable.times(count, function(index) {\n          try {\n            switch (index) {\n              case 0: return !!(new bound);\n              case 1: return !!(new bound(1));\n              case 2: return !!(new bound(1, 2));\n              case 3: return !!(new bound(1, 2, 3));\n              case 4: return !!(new bound(1, 2, 3, 4));\n              case 5: return !!(new bound(1, 2, 3, 4, 5));\n              case 6: return !!(new bound(1, 2, 3, 4, 5, 6));\n              case 7: return !!(new bound(1, 2, 3, 4, 5, 6, 7));\n            }\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var object = {},\n            bound = _(fn).bind({}, 'a', 'b');\n\n        assert.ok(bound instanceof _);\n\n        var actual = bound.value()('c');\n        assert.deepEqual(actual, [object, 'a', 'b', 'c']);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.bindAll');\n\n  (function() {\n    var args = toArgs(['a']);\n\n    var source = {\n      '_n0': -2,\n      '_p0': -1,\n      '_a': 1,\n      '_b': 2,\n      '_c': 3,\n      '_d': 4,\n      '-0': function() { return this._n0; },\n      '0': function() { return this._p0; },\n      'a': function() { return this._a; },\n      'b': function() { return this._b; },\n      'c': function() { return this._c; },\n      'd': function() { return this._d; }\n    };\n\n    QUnit.test('should accept individual method names', function(assert) {\n      assert.expect(1);\n\n      var object = lodashStable.cloneDeep(source);\n      _.bindAll(object, 'a', 'b');\n\n      var actual = lodashStable.map(['a', 'b', 'c'], function(key) {\n        return object[key].call({});\n      });\n\n      assert.deepEqual(actual, [1, 2, undefined]);\n    });\n\n    QUnit.test('should accept arrays of method names', function(assert) {\n      assert.expect(1);\n\n      var object = lodashStable.cloneDeep(source);\n      _.bindAll(object, ['a', 'b'], ['c']);\n\n      var actual = lodashStable.map(['a', 'b', 'c', 'd'], function(key) {\n        return object[key].call({});\n      });\n\n      assert.deepEqual(actual, [1, 2, 3, undefined]);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var props = [-0, Object(-0), 0, Object(0)];\n\n      var actual = lodashStable.map(props, function(key) {\n        var object = lodashStable.cloneDeep(source);\n        _.bindAll(object, key);\n        return object[lodashStable.toString(key)].call({});\n      });\n\n      assert.deepEqual(actual, [-2, -2, -1, -1]);\n    });\n\n    QUnit.test('should work with an array `object`', function(assert) {\n      assert.expect(1);\n\n      var array = ['push', 'pop'];\n      _.bindAll(array);\n      assert.strictEqual(array.pop, arrayProto.pop);\n    });\n\n    QUnit.test('should work with `arguments` objects as secondary arguments', function(assert) {\n      assert.expect(1);\n\n      var object = lodashStable.cloneDeep(source);\n      _.bindAll(object, args);\n\n      var actual = lodashStable.map(args, function(key) {\n        return object[key].call({});\n      });\n\n      assert.deepEqual(actual, [1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.bindKey');\n\n  (function() {\n    QUnit.test('should work when the target function is overwritten', function(assert) {\n      assert.expect(2);\n\n      var object = {\n        'user': 'fred',\n        'greet': function(greeting) {\n          return this.user + ' says: ' + greeting;\n        }\n      };\n\n      var bound = _.bindKey(object, 'greet', 'hi');\n      assert.strictEqual(bound(), 'fred says: hi');\n\n      object.greet = function(greeting) {\n        return this.user + ' says: ' + greeting + '!';\n      };\n\n      assert.strictEqual(bound(), 'fred says: hi!');\n    });\n\n    QUnit.test('should support placeholders', function(assert) {\n      assert.expect(4);\n\n      var object = {\n        'fn': function() {\n          return slice.call(arguments);\n        }\n      };\n\n      var ph = _.bindKey.placeholder,\n          bound = _.bindKey(object, 'fn', ph, 'b', ph);\n\n      assert.deepEqual(bound('a', 'c'), ['a', 'b', 'c']);\n      assert.deepEqual(bound('a'), ['a', 'b', undefined]);\n      assert.deepEqual(bound('a', 'c', 'd'), ['a', 'b', 'c', 'd']);\n      assert.deepEqual(bound(), [undefined, 'b', undefined]);\n    });\n\n    QUnit.test('should use `_.placeholder` when set', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var object = {\n          'fn': function() {\n            return slice.call(arguments);\n          }\n        };\n\n        var _ph = _.placeholder = {},\n            ph = _.bindKey.placeholder,\n            bound = _.bindKey(object, 'fn', _ph, 'b', ph);\n\n        assert.deepEqual(bound('a', 'c'), ['a', 'b', ph, 'c']);\n        delete _.placeholder;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should ensure `new bound` is an instance of `object[key]`', function(assert) {\n      assert.expect(2);\n\n      function Foo(value) {\n        return value && object;\n      }\n\n      var object = { 'Foo': Foo },\n          bound = _.bindKey(object, 'Foo');\n\n      assert.ok(new bound instanceof Foo);\n      assert.strictEqual(new bound(true), object);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('case methods');\n\n  lodashStable.each(['camel', 'kebab', 'lower', 'snake', 'start', 'upper'], function(caseName) {\n    var methodName = caseName + 'Case',\n        func = _[methodName];\n\n    var strings = [\n      'foo bar', 'Foo bar', 'foo Bar', 'Foo Bar',\n      'FOO BAR', 'fooBar', '--foo-bar--', '__foo_bar__'\n    ];\n\n    var converted = (function() {\n      switch (caseName) {\n        case 'camel': return 'fooBar';\n        case 'kebab': return 'foo-bar';\n        case 'lower': return 'foo bar';\n        case 'snake': return 'foo_bar';\n        case 'start': return 'Foo Bar';\n        case 'upper': return 'FOO BAR';\n      }\n    }());\n\n    QUnit.test('`_.' + methodName + '` should convert `string` to ' + caseName + ' case', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(strings, function(string) {\n        var expected = (caseName == 'start' && string == 'FOO BAR') ? string : converted;\n        return func(string) === expected;\n      });\n\n      assert.deepEqual(actual, lodashStable.map(strings, stubTrue));\n    });\n\n    QUnit.test('`_.' + methodName + '` should handle double-converting strings', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(strings, function(string) {\n        var expected = (caseName == 'start' && string == 'FOO BAR') ? string : converted;\n        return func(func(string)) === expected;\n      });\n\n      assert.deepEqual(actual, lodashStable.map(strings, stubTrue));\n    });\n\n    QUnit.test('`_.' + methodName + '` should deburr letters', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(burredLetters, function(burred, index) {\n        var letter = deburredLetters[index].replace(/['\\u2019]/g, '');\n        if (caseName == 'start') {\n          letter = letter == 'IJ' ? letter : lodashStable.capitalize(letter);\n        } else if (caseName == 'upper') {\n          letter = letter.toUpperCase();\n        } else {\n          letter = letter.toLowerCase();\n        }\n        return func(burred) === letter;\n      });\n\n      assert.deepEqual(actual, lodashStable.map(burredLetters, stubTrue));\n    });\n\n    QUnit.test('`_.' + methodName + '` should remove contraction apostrophes', function(assert) {\n      assert.expect(2);\n\n      var postfixes = ['d', 'll', 'm', 're', 's', 't', 've'];\n\n      lodashStable.each([\"'\", '\\u2019'], function(apos) {\n        var actual = lodashStable.map(postfixes, function(postfix) {\n          return func('a b' + apos + postfix +  ' c');\n        });\n\n        var expected = lodashStable.map(postfixes, function(postfix) {\n          switch (caseName) {\n            case 'camel': return 'aB'  + postfix + 'C';\n            case 'kebab': return 'a-b' + postfix + '-c';\n            case 'lower': return 'a b' + postfix + ' c';\n            case 'snake': return 'a_b' + postfix + '_c';\n            case 'start': return 'A B' + postfix + ' C';\n            case 'upper': return 'A B' + postfix.toUpperCase() + ' C';\n          }\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should remove Latin mathematical operators', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(['\\xd7', '\\xf7'], func);\n      assert.deepEqual(actual, ['', '']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `string` to a string', function(assert) {\n      assert.expect(2);\n\n      var string = 'foo bar';\n      assert.strictEqual(func(Object(string)), converted);\n      assert.strictEqual(func({ 'toString': lodashStable.constant(string) }), converted);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an unwrapped value implicitly when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.strictEqual(_('foo bar')[methodName](), converted);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_('foo bar').chain()[methodName]() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  (function() {\n    QUnit.test('should get the original value after cycling through all case methods', function(assert) {\n      assert.expect(1);\n\n      var funcs = [_.camelCase, _.kebabCase, _.lowerCase, _.snakeCase, _.startCase, _.lowerCase, _.camelCase];\n\n      var actual = lodashStable.reduce(funcs, function(result, func) {\n        return func(result);\n      }, 'enable 6h format');\n\n      assert.strictEqual(actual, 'enable6HFormat');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.camelCase');\n\n  (function() {\n    QUnit.test('should work with numbers', function(assert) {\n      assert.expect(6);\n\n      assert.strictEqual(_.camelCase('12 feet'), '12Feet');\n      assert.strictEqual(_.camelCase('enable 6h format'), 'enable6HFormat');\n      assert.strictEqual(_.camelCase('enable 24H format'), 'enable24HFormat');\n      assert.strictEqual(_.camelCase('too legit 2 quit'), 'tooLegit2Quit');\n      assert.strictEqual(_.camelCase('walk 500 miles'), 'walk500Miles');\n      assert.strictEqual(_.camelCase('xhr2 request'), 'xhr2Request');\n    });\n\n    QUnit.test('should handle acronyms', function(assert) {\n      assert.expect(6);\n\n      lodashStable.each(['safe HTML', 'safeHTML'], function(string) {\n        assert.strictEqual(_.camelCase(string), 'safeHtml');\n      });\n\n      lodashStable.each(['escape HTML entities', 'escapeHTMLEntities'], function(string) {\n        assert.strictEqual(_.camelCase(string), 'escapeHtmlEntities');\n      });\n\n      lodashStable.each(['XMLHttpRequest', 'XmlHTTPRequest'], function(string) {\n        assert.strictEqual(_.camelCase(string), 'xmlHttpRequest');\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.capitalize');\n\n  (function() {\n    QUnit.test('should capitalize the first character of a string', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.capitalize('fred'), 'Fred');\n      assert.strictEqual(_.capitalize('Fred'), 'Fred');\n      assert.strictEqual(_.capitalize(' fred'), ' fred');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.castArray');\n\n  (function() {\n    QUnit.test('should wrap non-array items in an array', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat(true, 1, 'a', { 'a': 1 }),\n          expected = lodashStable.map(values, function(value) { return [value]; }),\n          actual = lodashStable.map(values, _.castArray);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return array values by reference', function(assert) {\n      assert.expect(1);\n\n      var array = [1];\n      assert.strictEqual(_.castArray(array), array);\n    });\n\n    QUnit.test('should return an empty array when no arguments are given', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.castArray(), []);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.chain');\n\n  (function() {\n    QUnit.test('should return a wrapped value', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = _.chain({ 'a': 0 });\n        assert.ok(actual instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return existing wrapped values', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _({ 'a': 0 });\n        assert.strictEqual(_.chain(wrapped), wrapped);\n        assert.strictEqual(wrapped.chain(), wrapped);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should enable chaining for methods that return unwrapped values', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var array = ['c', 'b', 'a'];\n\n        assert.ok(_.chain(array).head() instanceof _);\n        assert.ok(_(array).chain().head() instanceof _);\n\n        assert.ok(_.chain(array).isArray() instanceof _);\n        assert.ok(_(array).chain().isArray() instanceof _);\n\n        assert.ok(_.chain(array).sortBy().head() instanceof _);\n        assert.ok(_(array).chain().sortBy().head() instanceof _);\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n\n    QUnit.test('should chain multiple methods', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        lodashStable.times(2, function(index) {\n          var array = ['one two three four', 'five six seven eight', 'nine ten eleven twelve'],\n              expected = { ' ': 9, 'e': 14, 'f': 2, 'g': 1, 'h': 2, 'i': 4, 'l': 2, 'n': 6, 'o': 3, 'r': 2, 's': 2, 't': 5, 'u': 1, 'v': 4, 'w': 2, 'x': 1 },\n              wrapped = index ? _(array).chain() : _.chain(array);\n\n          var actual = wrapped\n            .chain()\n            .map(function(value) { return value.split(''); })\n            .flatten()\n            .reduce(function(object, chr) {\n              object[chr] || (object[chr] = 0);\n              object[chr]++;\n              return object;\n            }, {})\n            .value();\n\n          assert.deepEqual(actual, expected);\n\n          array = [1, 2, 3, 4, 5, 6];\n          wrapped = index ? _(array).chain() : _.chain(array);\n          actual = wrapped\n            .chain()\n            .filter(function(n) { return n % 2 != 0; })\n            .reject(function(n) { return n % 3 == 0; })\n            .sortBy(function(n) { return -n; })\n            .value();\n\n          assert.deepEqual(actual, [5, 1]);\n\n          array = [3, 4];\n          wrapped = index ? _(array).chain() : _.chain(array);\n          actual = wrapped\n            .reverse()\n            .concat([2, 1])\n            .unshift(5)\n            .tap(function(value) { value.pop(); })\n            .map(square)\n            .value();\n\n          assert.deepEqual(actual, [25, 16, 9, 4]);\n        });\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.chunk');\n\n  (function() {\n    var array = [0, 1, 2, 3, 4, 5];\n\n    QUnit.test('should return chunked arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = _.chunk(array, 3);\n      assert.deepEqual(actual, [[0, 1, 2], [3, 4, 5]]);\n    });\n\n    QUnit.test('should return the last chunk as remaining elements', function(assert) {\n      assert.expect(1);\n\n      var actual = _.chunk(array, 4);\n      assert.deepEqual(actual, [[0, 1, 2, 3], [4, 5]]);\n    });\n\n    QUnit.test('should treat falsey `size` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? [[0], [1], [2], [3], [4], [5]] : [];\n      });\n\n      var actual = lodashStable.map(falsey, function(size, index) {\n        return index ? _.chunk(array, size) : _.chunk(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should ensure the minimum `size` is `0`', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.reject(falsey, lodashStable.isUndefined).concat(-1, -Infinity),\n          expected = lodashStable.map(values, stubArray);\n\n      var actual = lodashStable.map(values, function(n) {\n        return _.chunk(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should coerce `size` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.chunk(array, array.length / 4), [[0], [1], [2], [3], [4], [5]]);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map([[1, 2], [3, 4]], _.chunk);\n      assert.deepEqual(actual, [[[1], [2]], [[3], [4]]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.clamp');\n\n  (function() {\n    QUnit.test('should work with a `max`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.clamp(5, 3), 3);\n      assert.strictEqual(_.clamp(1, 3), 1);\n    });\n\n    QUnit.test('should clamp negative numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.clamp(-10, -5, 5), -5);\n      assert.strictEqual(_.clamp(-10.2, -5.5, 5.5), -5.5);\n      assert.strictEqual(_.clamp(-Infinity, -5, 5), -5);\n    });\n\n    QUnit.test('should clamp positive numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.clamp(10, -5, 5), 5);\n      assert.strictEqual(_.clamp(10.6, -5.6, 5.4), 5.4);\n      assert.strictEqual(_.clamp(Infinity, -5, 5), 5);\n    });\n\n    QUnit.test('should not alter negative numbers in range', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.clamp(-4, -5, 5), -4);\n      assert.strictEqual(_.clamp(-5, -5, 5), -5);\n      assert.strictEqual(_.clamp(-5.5, -5.6, 5.6), -5.5);\n    });\n\n    QUnit.test('should not alter positive numbers in range', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.clamp(4, -5, 5), 4);\n      assert.strictEqual(_.clamp(5, -5, 5), 5);\n      assert.strictEqual(_.clamp(4.5, -5.1, 5.2), 4.5);\n    });\n\n    QUnit.test('should not alter `0` in range', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(1 / _.clamp(0, -5, 5), Infinity);\n    });\n\n    QUnit.test('should clamp to `0`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(1 / _.clamp(-10, 0, 5), Infinity);\n    });\n\n    QUnit.test('should not alter `-0` in range', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(1 / _.clamp(-0, -5, 5), -Infinity);\n    });\n\n    QUnit.test('should clamp to `-0`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(1 / _.clamp(-10, -0, 5), -Infinity);\n    });\n\n    QUnit.test('should return `NaN` when `number` is `NaN`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.clamp(NaN, -5, 5), NaN);\n    });\n\n    QUnit.test('should coerce `min` and `max` of `NaN` to `0`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.clamp(1, -5, NaN), 0);\n      assert.deepEqual(_.clamp(-1, NaN, 5), 0);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('clone methods');\n\n  (function() {\n    function Foo() {\n      this.a = 1;\n    }\n    Foo.prototype.b = 1;\n    Foo.c = function() {};\n\n    if (Map) {\n      var map = new Map;\n      map.set('a', 1);\n      map.set('b', 2);\n    }\n    if (Set) {\n      var set = new Set;\n      set.add(1);\n      set.add(2);\n    }\n    var objects = {\n      '`arguments` objects': arguments,\n      'arrays': ['a', ''],\n      'array-like objects': { '0': 'a', 'length': 1 },\n      'booleans': false,\n      'boolean objects': Object(false),\n      'date objects': new Date,\n      'Foo instances': new Foo,\n      'objects': { 'a': 0, 'b': 1, 'c': 2 },\n      'objects with object values': { 'a': /a/, 'b': ['B'], 'c': { 'C': 1 } },\n      'objects from another document': realm.object || {},\n      'maps': map,\n      'null values': null,\n      'numbers': 0,\n      'number objects': Object(0),\n      'regexes': /a/gim,\n      'sets': set,\n      'strings': 'a',\n      'string objects': Object('a'),\n      'undefined values': undefined\n    };\n\n    objects.arrays.length = 3;\n\n    var uncloneable = {\n      'DOM elements': body,\n      'functions': Foo,\n      'async functions': asyncFunc,\n      'generator functions': genFunc,\n      'the `Proxy` constructor': Proxy\n    };\n\n    lodashStable.each(errors, function(error) {\n      uncloneable[error.name + 's'] = error;\n    });\n\n    QUnit.test('`_.clone` should perform a shallow clone', function(assert) {\n      assert.expect(2);\n\n      var array = [{ 'a': 0 }, { 'b': 1 }],\n          actual = _.clone(array);\n\n      assert.deepEqual(actual, array);\n      assert.ok(actual !== array && actual[0] === array[0]);\n    });\n\n    QUnit.test('`_.cloneDeep` should deep clone objects with circular references', function(assert) {\n      assert.expect(1);\n\n      var object = {\n        'foo': { 'b': { 'c': { 'd': {} } } },\n        'bar': {}\n      };\n\n      object.foo.b.c.d = object;\n      object.bar.b = object.foo.b;\n\n      var actual = _.cloneDeep(object);\n      assert.ok(actual.bar.b === actual.foo.b && actual === actual.foo.b.c.d && actual !== object);\n    });\n\n    QUnit.test('`_.cloneDeep` should deep clone objects with lots of circular references', function(assert) {\n      assert.expect(2);\n\n      var cyclical = {};\n      lodashStable.times(LARGE_ARRAY_SIZE + 1, function(index) {\n        cyclical['v' + index] = [index ? cyclical['v' + (index - 1)] : cyclical];\n      });\n\n      var clone = _.cloneDeep(cyclical),\n          actual = clone['v' + LARGE_ARRAY_SIZE][0];\n\n      assert.strictEqual(actual, clone['v' + (LARGE_ARRAY_SIZE - 1)]);\n      assert.notStrictEqual(actual, cyclical['v' + (LARGE_ARRAY_SIZE - 1)]);\n    });\n\n    QUnit.test('`_.cloneDeepWith` should provide `stack` to `customizer`', function(assert) {\n      assert.expect(1);\n\n      var actual;\n\n      _.cloneDeepWith({ 'a': 1 }, function() {\n        actual = _.last(arguments);\n      });\n\n      assert.ok(isNpm\n        ? actual.constructor.name == 'Stack'\n        : actual instanceof mapCaches.Stack\n      );\n    });\n\n    lodashStable.each(['clone', 'cloneDeep'], function(methodName) {\n      var func = _[methodName],\n          isDeep = methodName == 'cloneDeep';\n\n      lodashStable.forOwn(objects, function(object, kind) {\n        QUnit.test('`_.' + methodName + '` should clone ' + kind, function(assert) {\n          assert.expect(2);\n\n          var actual = func(object);\n          assert.ok(lodashStable.isEqual(actual, object));\n\n          if (lodashStable.isObject(object)) {\n            assert.notStrictEqual(actual, object);\n          } else {\n            assert.strictEqual(actual, object);\n          }\n        });\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone array buffers', function(assert) {\n        assert.expect(2);\n\n        if (ArrayBuffer) {\n          var actual = func(arrayBuffer);\n          assert.strictEqual(actual.byteLength, arrayBuffer.byteLength);\n          assert.notStrictEqual(actual, arrayBuffer);\n        }\n        else {\n          skipAssert(assert, 2);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone buffers', function(assert) {\n        assert.expect(4);\n\n        if (Buffer) {\n          var buffer = new Buffer([1, 2]),\n              actual = func(buffer);\n\n          assert.strictEqual(actual.byteLength, buffer.byteLength);\n          assert.strictEqual(actual.inspect(), buffer.inspect());\n          assert.notStrictEqual(actual, buffer);\n\n          buffer[0] = 2;\n          assert.strictEqual(actual[0], isDeep ? 2 : 1);\n        }\n        else {\n          skipAssert(assert, 4);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone `index` and `input` array properties', function(assert) {\n        assert.expect(2);\n\n        var array = /c/.exec('abcde'),\n            actual = func(array);\n\n        assert.strictEqual(actual.index, 2);\n        assert.strictEqual(actual.input, 'abcde');\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone `lastIndex` regexp property', function(assert) {\n        assert.expect(1);\n\n        var regexp = /c/g;\n        regexp.exec('abcde');\n\n        assert.strictEqual(func(regexp).lastIndex, 3);\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone expando properties', function(assert) {\n        assert.expect(1);\n\n        var values = lodashStable.map([false, true, 1, 'a'], function(value) {\n          var object = Object(value);\n          object.a = 1;\n          return object;\n        });\n\n        var expected = lodashStable.map(values, stubTrue);\n\n        var actual = lodashStable.map(values, function(value) {\n          return func(value).a === 1;\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone prototype objects', function(assert) {\n        assert.expect(2);\n\n        var actual = func(Foo.prototype);\n\n        assert.notOk(actual instanceof Foo);\n        assert.deepEqual(actual, { 'b': 1 });\n      });\n\n      QUnit.test('`_.' + methodName + '` should set the `[[Prototype]]` of a clone', function(assert) {\n        assert.expect(1);\n\n        assert.ok(func(new Foo) instanceof Foo);\n      });\n\n      QUnit.test('`_.' + methodName + '` should set the `[[Prototype]]` of a clone even when the `constructor` is incorrect', function(assert) {\n        assert.expect(1);\n\n        Foo.prototype.constructor = Object;\n        assert.ok(func(new Foo) instanceof Foo);\n        Foo.prototype.constructor = Foo;\n      });\n\n      QUnit.test('`_.' + methodName + '` should ensure `value` constructor is a function before using its `[[Prototype]]`', function(assert) {\n        assert.expect(1);\n\n        Foo.prototype.constructor = null;\n        assert.notOk(func(new Foo) instanceof Foo);\n        Foo.prototype.constructor = Foo;\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone properties that shadow those on `Object.prototype`', function(assert) {\n        assert.expect(2);\n\n        var object = {\n          'constructor': objectProto.constructor,\n          'hasOwnProperty': objectProto.hasOwnProperty,\n          'isPrototypeOf': objectProto.isPrototypeOf,\n          'propertyIsEnumerable': objectProto.propertyIsEnumerable,\n          'toLocaleString': objectProto.toLocaleString,\n          'toString': objectProto.toString,\n          'valueOf': objectProto.valueOf\n        };\n\n        var actual = func(object);\n\n        assert.deepEqual(actual, object);\n        assert.notStrictEqual(actual, object);\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone symbol properties', function(assert) {\n        assert.expect(7);\n\n        function Foo() {\n          this[symbol] = { 'c': 1 };\n        }\n\n        if (Symbol) {\n          var symbol2 = Symbol('b');\n          Foo.prototype[symbol2] = 2;\n\n          var symbol3 = Symbol('c');\n          defineProperty(Foo.prototype, symbol3, {\n            'configurable': true,\n            'enumerable': false,\n            'writable': true,\n            'value': 3\n          });\n\n          var object = { 'a': { 'b': new Foo } };\n          object[symbol] = { 'b': 1 };\n\n          var actual = func(object);\n          if (isDeep) {\n            assert.notStrictEqual(actual[symbol], object[symbol]);\n            assert.notStrictEqual(actual.a, object.a);\n          } else {\n            assert.strictEqual(actual[symbol], object[symbol]);\n            assert.strictEqual(actual.a, object.a);\n          }\n          assert.deepEqual(actual[symbol], object[symbol]);\n          assert.deepEqual(getSymbols(actual.a.b), [symbol]);\n          assert.deepEqual(actual.a.b[symbol], object.a.b[symbol]);\n          assert.deepEqual(actual.a.b[symbol2], object.a.b[symbol2]);\n          assert.deepEqual(actual.a.b[symbol3], object.a.b[symbol3]);\n        }\n        else {\n          skipAssert(assert, 7);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should clone symbol objects', function(assert) {\n        assert.expect(4);\n\n        if (Symbol) {\n          assert.strictEqual(func(symbol), symbol);\n\n          var object = Object(symbol),\n              actual = func(object);\n\n          assert.strictEqual(typeof actual, 'object');\n          assert.strictEqual(typeof actual.valueOf(), 'symbol');\n          assert.notStrictEqual(actual, object);\n        }\n        else {\n          skipAssert(assert, 4);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should not clone symbol primitives', function(assert) {\n        assert.expect(1);\n\n        if (Symbol) {\n          assert.strictEqual(func(symbol), symbol);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should not error on DOM elements', function(assert) {\n        assert.expect(1);\n\n        if (document) {\n          var element = document.createElement('div');\n\n          try {\n            assert.deepEqual(func(element), {});\n          } catch (e) {\n            assert.ok(false, e.message);\n          }\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should create an object from the same realm as `value`', function(assert) {\n        assert.expect(1);\n\n        var props = [];\n\n        var objects = lodashStable.transform(_, function(result, value, key) {\n          if (lodashStable.startsWith(key, '_') && lodashStable.isObject(value) &&\n              !lodashStable.isArguments(value) && !lodashStable.isElement(value) &&\n              !lodashStable.isFunction(value)) {\n            props.push(lodashStable.capitalize(lodashStable.camelCase(key)));\n            result.push(value);\n          }\n        }, []);\n\n        var expected = lodashStable.map(objects, stubTrue);\n\n        var actual = lodashStable.map(objects, function(object) {\n          var Ctor = object.constructor,\n              result = func(object);\n\n          return result !== object && ((result instanceof Ctor) || !(new Ctor instanceof Ctor));\n        });\n\n        assert.deepEqual(actual, expected, props.join(', '));\n      });\n\n      QUnit.test('`_.' + methodName + '` should perform a ' + (isDeep ? 'deep' : 'shallow') + ' clone when used as an iteratee for methods like `_.map`', function(assert) {\n        assert.expect(2);\n\n        var expected = [{ 'a': [0] }, { 'b': [1] }],\n            actual = lodashStable.map(expected, func);\n\n        assert.deepEqual(actual, expected);\n\n        if (isDeep) {\n          assert.ok(actual[0] !== expected[0] && actual[0].a !== expected[0].a && actual[1].b !== expected[1].b);\n        } else {\n          assert.ok(actual[0] !== expected[0] && actual[0].a === expected[0].a && actual[1].b === expected[1].b);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should return a unwrapped value when chaining', function(assert) {\n        assert.expect(2);\n\n        if (!isNpm) {\n          var object = objects.objects,\n              actual = _(object)[methodName]();\n\n          assert.deepEqual(actual, object);\n          assert.notStrictEqual(actual, object);\n        }\n        else {\n          skipAssert(assert, 2);\n        }\n      });\n\n      lodashStable.each(arrayViews, function(type) {\n        QUnit.test('`_.' + methodName + '` should clone ' + type + ' values', function(assert) {\n          assert.expect(10);\n\n          var Ctor = root[type];\n\n          lodashStable.times(2, function(index) {\n            if (Ctor) {\n              var buffer = new ArrayBuffer(24),\n                  view = index ? new Ctor(buffer, 8, 1) : new Ctor(buffer),\n                  actual = func(view);\n\n              assert.deepEqual(actual, view);\n              assert.notStrictEqual(actual, view);\n              assert.strictEqual(actual.buffer === view.buffer, !isDeep);\n              assert.strictEqual(actual.byteOffset, view.byteOffset);\n              assert.strictEqual(actual.length, view.length);\n            }\n            else {\n              skipAssert(assert, 5);\n            }\n          });\n        });\n      });\n\n      lodashStable.forOwn(uncloneable, function(value, key) {\n        QUnit.test('`_.' + methodName + '` should not clone ' + key, function(assert) {\n          assert.expect(3);\n\n          if (value) {\n            var object = { 'a': value, 'b': { 'c': value } },\n                actual = func(object),\n                expected = value === Foo ? { 'c': Foo.c } : {};\n\n            assert.deepEqual(actual, object);\n            assert.notStrictEqual(actual, object);\n            assert.deepEqual(func(value), expected);\n          }\n          else {\n            skipAssert(assert, 3);\n          }\n        });\n      });\n    });\n\n    lodashStable.each(['cloneWith', 'cloneDeepWith'], function(methodName) {\n      var func = _[methodName],\n          isDeep = methodName == 'cloneDeepWith';\n\n      QUnit.test('`_.' + methodName + '` should provide correct `customizer` arguments', function(assert) {\n        assert.expect(1);\n\n        var argsList = [],\n            object = new Foo;\n\n        func(object, function() {\n          var length = arguments.length,\n              args = slice.call(arguments, 0, length - (length > 1 ? 1 : 0));\n\n          argsList.push(args);\n        });\n\n        assert.deepEqual(argsList, isDeep ? [[object], [1, 'a', object]] : [[object]]);\n      });\n\n      QUnit.test('`_.' + methodName + '` should handle cloning when `customizer` returns `undefined`', function(assert) {\n        assert.expect(1);\n\n        var actual = func({ 'a': { 'b': 'c' } }, noop);\n        assert.deepEqual(actual, { 'a': { 'b': 'c' } });\n      });\n\n      lodashStable.forOwn(uncloneable, function(value, key) {\n        QUnit.test('`_.' + methodName + '` should work with a `customizer` callback and ' + key, function(assert) {\n          assert.expect(3);\n\n          var customizer = function(value) {\n            return lodashStable.isPlainObject(value) ? undefined : value;\n          };\n\n          var actual = func(value, customizer);\n          assert.strictEqual(actual, value);\n\n          var object = { 'a': value, 'b': { 'c': value } };\n          actual = func(object, customizer);\n\n          assert.deepEqual(actual, object);\n          assert.notStrictEqual(actual, object);\n        });\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.compact');\n\n  (function() {\n    var largeArray = lodashStable.range(LARGE_ARRAY_SIZE).concat(null);\n\n    QUnit.test('should filter falsey values', function(assert) {\n      assert.expect(1);\n\n      var array = ['0', '1', '2'];\n      assert.deepEqual(_.compact(falsey.concat(array)), array);\n    });\n\n    QUnit.test('should work when in-between lazy operators', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var actual = _(falsey).thru(_.slice).compact().thru(_.slice).value();\n        assert.deepEqual(actual, []);\n\n        actual = _(falsey).thru(_.slice).push(true, 1).compact().push('a').value();\n        assert.deepEqual(actual, [true, 1, 'a']);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = _(largeArray).slice(1).compact().reverse().take().value();\n        assert.deepEqual(actual, _.take(_.compact(_.slice(largeArray, 1)).reverse()));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence with a custom `_.iteratee`', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var iteratee = _.iteratee,\n            pass = false;\n\n        _.iteratee = identity;\n\n        try {\n          var actual = _(largeArray).slice(1).compact().value();\n          pass = lodashStable.isEqual(actual, _.compact(_.slice(largeArray, 1)));\n        } catch (e) {console.log(e);}\n\n        assert.ok(pass);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.concat');\n\n  (function() {\n    QUnit.test('should shallow clone `array`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = _.concat(array);\n\n      assert.deepEqual(actual, array);\n      assert.notStrictEqual(actual, array);\n    });\n\n    QUnit.test('should concat arrays and values', function(assert) {\n      assert.expect(2);\n\n      var array = [1],\n          actual = _.concat(array, 2, [3], [[4]]);\n\n      assert.deepEqual(actual, [1, 2, 3, [4]]);\n      assert.deepEqual(array, [1]);\n    });\n\n    QUnit.test('should cast non-array `array` values to arrays', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined, false, true, 1, NaN, 'a'];\n\n      var expected = lodashStable.map(values, function(value, index) {\n        return index ? [value] : [];\n      });\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.concat(value) : _.concat();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(values, function(value) {\n        return [value, 2, [3]];\n      });\n\n      actual = lodashStable.map(values, function(value) {\n        return _.concat(value, [2], [[3]]);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should treat sparse arrays as dense', function(assert) {\n      assert.expect(3);\n\n      var expected = [],\n          actual = _.concat(Array(1), Array(1));\n\n      expected.push(undefined, undefined);\n\n      assert.ok('0'in actual);\n      assert.ok('1' in actual);\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return a new wrapped array', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array = [1],\n            wrapped = _(array).concat([2, 3]),\n            actual = wrapped.value();\n\n        assert.deepEqual(array, [1]);\n        assert.deepEqual(actual, [1, 2, 3]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.cond');\n\n  (function() {\n    QUnit.test('should create a conditional function', function(assert) {\n      assert.expect(3);\n\n      var cond = _.cond([\n        [lodashStable.matches({ 'a': 1 }),     stubA],\n        [lodashStable.matchesProperty('b', 1), stubB],\n        [lodashStable.property('c'),           stubC]\n      ]);\n\n      assert.strictEqual(cond({ 'a':  1, 'b': 2, 'c': 3 }), 'a');\n      assert.strictEqual(cond({ 'a':  0, 'b': 1, 'c': 2 }), 'b');\n      assert.strictEqual(cond({ 'a': -1, 'b': 0, 'c': 1 }), 'c');\n    });\n\n    QUnit.test('should provide arguments to functions', function(assert) {\n      assert.expect(2);\n\n      var args1,\n          args2,\n          expected = ['a', 'b', 'c'];\n\n      var cond = _.cond([[\n        function() { args1 || (args1 = slice.call(arguments)); return true; },\n        function() { args2 || (args2 = slice.call(arguments)); }\n      ]]);\n\n      cond('a', 'b', 'c');\n\n      assert.deepEqual(args1, expected);\n      assert.deepEqual(args2, expected);\n    });\n\n    QUnit.test('should work with predicate shorthands', function(assert) {\n      assert.expect(3);\n\n      var cond = _.cond([\n        [{ 'a': 1 }, stubA],\n        [['b', 1],   stubB],\n        ['c',        stubC]\n      ]);\n\n      assert.strictEqual(cond({ 'a':  1, 'b': 2, 'c': 3 }), 'a');\n      assert.strictEqual(cond({ 'a':  0, 'b': 1, 'c': 2 }), 'b');\n      assert.strictEqual(cond({ 'a': -1, 'b': 0, 'c': 1 }), 'c');\n    });\n\n    QUnit.test('should return `undefined` when no condition is met', function(assert) {\n      assert.expect(1);\n\n      var cond = _.cond([[stubFalse, stubA]]);\n      assert.strictEqual(cond({ 'a': 1 }), undefined);\n    });\n\n    QUnit.test('should throw a TypeError if `pairs` is not composed of functions', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([false, true], function(value) {\n        assert.raises(function() { _.cond([[stubTrue, value]])(); }, TypeError);\n      });\n    });\n\n    QUnit.test('should use `this` binding of function for `pairs`', function(assert) {\n      assert.expect(1);\n\n      var cond = _.cond([\n        [function(a) { return this[a]; }, function(a, b) { return this[b]; }]\n      ]);\n\n      var object = { 'cond': cond, 'a': 1, 'b': 2 };\n      assert.strictEqual(object.cond('a', 'b'), 2);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.conforms');\n\n  (function() {\n    QUnit.test('should not change behavior if `source` is modified', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 2 },\n          source = { 'a': function(value) { return value > 1; } },\n          par = _.conforms(source);\n\n      assert.strictEqual(par(object), true);\n\n      source.a = function(value) { return value < 2; };\n      assert.strictEqual(par(object), true);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('conforms methods');\n\n  lodashStable.each(['conforms', 'conformsTo'], function(methodName) {\n    var isConforms = methodName == 'conforms';\n\n    function conforms(source) {\n      return isConforms ? _.conforms(source) : function(object) {\n        return _.conformsTo(object, source);\n      };\n    }\n\n    QUnit.test('`_.' + methodName + '` should check if `object` conforms to `source`', function(assert) {\n      assert.expect(2);\n\n      var objects = [\n        { 'a': 1, 'b': 8 },\n        { 'a': 2, 'b': 4 },\n        { 'a': 3, 'b': 16 }\n      ];\n\n      var par = conforms({\n        'b': function(value) { return value > 4; }\n      });\n\n      var actual = lodashStable.filter(objects, par);\n      assert.deepEqual(actual, [objects[0], objects[2]]);\n\n      par = conforms({\n        'b': function(value) { return value > 8; },\n        'a': function(value) { return value > 1; }\n      });\n\n      actual = lodashStable.filter(objects, par);\n      assert.deepEqual(actual, [objects[2]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not match by inherited `source` properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = function(value) {\n          return value > 1;\n        };\n      }\n      Foo.prototype.b = function(value) {\n        return value > 8;\n      };\n\n      var objects = [\n        { 'a': 1, 'b': 8 },\n        { 'a': 2, 'b': 4 },\n        { 'a': 3, 'b': 16 }\n      ];\n\n      var par = conforms(new Foo),\n          actual = lodashStable.filter(objects, par);\n\n      assert.deepEqual(actual, [objects[1], objects[2]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not invoke `source` predicates for missing `object` properties', function(assert) {\n      assert.expect(2);\n\n      var count = 0;\n\n      var par = conforms({\n        'a': function() { count++; return true; }\n      });\n\n      assert.strictEqual(par({}), false);\n      assert.strictEqual(count, 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a function for `object`', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.a = 1;\n\n      function Bar() {}\n      Bar.a = 2;\n\n      var par = conforms({\n        'a': function(value) { return value > 1; }\n      });\n\n      assert.strictEqual(par(Foo), false);\n      assert.strictEqual(par(Bar), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a function for `source`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.a = function(value) { return value > 1; };\n\n      var objects = [{ 'a': 1 }, { 'a': 2 }],\n          actual = lodashStable.filter(objects, conforms(Foo));\n\n      assert.deepEqual(actual, [objects[1]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a non-plain `object`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var par = conforms({\n        'b': function(value) { return value > 1; }\n      });\n\n      assert.strictEqual(par(new Foo), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `false` when `object` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      var par = conforms({\n        'a': function(value) { return value > 1; }\n      });\n\n      var actual = lodashStable.map(values, function(value, index) {\n        try {\n          return index ? par(value) : par();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` when comparing an empty `source` to a nullish `object`', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubTrue),\n          par = conforms({});\n\n      var actual = lodashStable.map(values, function(value, index) {\n        try {\n          return index ? par(value) : par();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` when comparing an empty `source`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1 },\n          expected = lodashStable.map(empties, stubTrue);\n\n      var actual = lodashStable.map(empties, function(value) {\n        var par = conforms(value);\n        return par(object);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.constant');\n\n  (function() {\n    QUnit.test('should create a function that returns `value`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1 },\n          values = Array(2).concat(empties, true, 1, 'a'),\n          constant = _.constant(object);\n\n      var results = lodashStable.map(values, function(value, index) {\n        if (index < 2) {\n          return index ? constant.call({}) : constant();\n        }\n        return constant(value);\n      });\n\n      assert.ok(lodashStable.every(results, function(result) {\n        return result === object;\n      }));\n    });\n\n    QUnit.test('should work with falsey values', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubTrue);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        var constant = index ? _.constant(value) : _.constant(),\n            result = constant();\n\n        return (result === value) || (result !== result && value !== value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _(true).constant();\n        assert.ok(wrapped instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.countBy');\n\n  (function() {\n    var array = [6.1, 4.2, 6.3];\n\n    QUnit.test('should transform keys by `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.countBy(array, Math.floor);\n      assert.deepEqual(actual, { '4': 1, '6': 2 });\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var array = [4, 6, 6],\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant({ '4': 1, '6':  2 }));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.countBy(array, value) : _.countBy(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var actual = _.countBy(['one', 'two', 'three'], 'length');\n      assert.deepEqual(actual, { '3': 2, '5': 1 });\n    });\n\n    QUnit.test('should only add values to own, not inherited, properties', function(assert) {\n      assert.expect(2);\n\n      var actual = _.countBy(array, function(n) {\n        return Math.floor(n) > 4 ? 'hasOwnProperty' : 'constructor';\n      });\n\n      assert.deepEqual(actual.constructor, 1);\n      assert.deepEqual(actual.hasOwnProperty, 2);\n    });\n\n    QUnit.test('should work with a number for `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var array = [\n        [1, 'a'],\n        [2, 'a'],\n        [2, 'b']\n      ];\n\n      assert.deepEqual(_.countBy(array, 0), { '1': 1, '2': 2 });\n      assert.deepEqual(_.countBy(array, 1), { 'a': 2, 'b': 1 });\n    });\n\n    QUnit.test('should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.countBy({ 'a': 6.1, 'b': 4.2, 'c': 6.3 }, Math.floor);\n      assert.deepEqual(actual, { '4': 1, '6': 2 });\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE).concat(\n          lodashStable.range(Math.floor(LARGE_ARRAY_SIZE / 2), LARGE_ARRAY_SIZE),\n          lodashStable.range(Math.floor(LARGE_ARRAY_SIZE / 1.5), LARGE_ARRAY_SIZE)\n        );\n\n        var actual = _(array).countBy().map(square).filter(isEven).take().value();\n\n        assert.deepEqual(actual, _.take(_.filter(_.map(_.countBy(array), square), isEven)));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.create');\n\n  (function() {\n    function Shape() {\n      this.x = 0;\n      this.y = 0;\n    }\n\n    function Circle() {\n      Shape.call(this);\n    }\n\n    QUnit.test('should create an object that inherits from the given `prototype` object', function(assert) {\n      assert.expect(3);\n\n      Circle.prototype = _.create(Shape.prototype);\n      Circle.prototype.constructor = Circle;\n\n      var actual = new Circle;\n\n      assert.ok(actual instanceof Circle);\n      assert.ok(actual instanceof Shape);\n      assert.notStrictEqual(Circle.prototype, Shape.prototype);\n    });\n\n    QUnit.test('should assign `properties` to the created object', function(assert) {\n      assert.expect(3);\n\n      var expected = { 'constructor': Circle, 'radius': 0 };\n      Circle.prototype = _.create(Shape.prototype, expected);\n\n      var actual = new Circle;\n\n      assert.ok(actual instanceof Circle);\n      assert.ok(actual instanceof Shape);\n      assert.deepEqual(Circle.prototype, expected);\n    });\n\n    QUnit.test('should assign own properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n        this.c = 3;\n      }\n      Foo.prototype.b = 2;\n\n      assert.deepEqual(_.create({}, new Foo), { 'a': 1, 'c': 3 });\n    });\n\n    QUnit.test('should assign properties that shadow those of `prototype`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      var object = _.create(new Foo, { 'a': 1 });\n      assert.deepEqual(lodashStable.keys(object), ['a']);\n    });\n\n    QUnit.test('should accept a falsey `prototype`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubObject);\n\n      var actual = lodashStable.map(falsey, function(prototype, index) {\n        return index ? _.create(prototype) : _.create();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should ignore a primitive `prototype` and use an empty object instead', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(primitives, stubTrue);\n\n      var actual = lodashStable.map(primitives, function(value, index) {\n        return lodashStable.isPlainObject(index ? _.create(value) : _.create());\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [{ 'a': 1 }, { 'a': 1 }, { 'a': 1 }],\n          expected = lodashStable.map(array, stubTrue),\n          objects = lodashStable.map(array, _.create);\n\n      var actual = lodashStable.map(objects, function(object) {\n        return object.a === 1 && !_.keys(object).length;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.curry');\n\n  (function() {\n    function fn(a, b, c, d) {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should curry based on the number of arguments given', function(assert) {\n      assert.expect(3);\n\n      var curried = _.curry(fn),\n          expected = [1, 2, 3, 4];\n\n      assert.deepEqual(curried(1)(2)(3)(4), expected);\n      assert.deepEqual(curried(1, 2)(3, 4), expected);\n      assert.deepEqual(curried(1, 2, 3, 4), expected);\n    });\n\n    QUnit.test('should allow specifying `arity`', function(assert) {\n      assert.expect(3);\n\n      var curried = _.curry(fn, 3),\n          expected = [1, 2, 3];\n\n      assert.deepEqual(curried(1)(2, 3), expected);\n      assert.deepEqual(curried(1, 2)(3), expected);\n      assert.deepEqual(curried(1, 2, 3), expected);\n    });\n\n    QUnit.test('should coerce `arity` to an integer', function(assert) {\n      assert.expect(2);\n\n      var values = ['0', 0.6, 'xyz'],\n          expected = lodashStable.map(values, stubArray);\n\n      var actual = lodashStable.map(values, function(arity) {\n        return _.curry(fn, arity)();\n      });\n\n      assert.deepEqual(actual, expected);\n      assert.deepEqual(_.curry(fn, '2')(1)(2), [1, 2]);\n    });\n\n    QUnit.test('should support placeholders', function(assert) {\n      assert.expect(4);\n\n      var curried = _.curry(fn),\n          ph = curried.placeholder;\n\n      assert.deepEqual(curried(1)(ph, 3)(ph, 4)(2), [1, 2, 3, 4]);\n      assert.deepEqual(curried(ph, 2)(1)(ph, 4)(3), [1, 2, 3, 4]);\n      assert.deepEqual(curried(ph, ph, 3)(ph, 2)(ph, 4)(1), [1, 2, 3, 4]);\n      assert.deepEqual(curried(ph, ph, ph, 4)(ph, ph, 3)(ph, 2)(1), [1, 2, 3, 4]);\n    });\n\n    QUnit.test('should persist placeholders', function(assert) {\n      assert.expect(1);\n\n      var curried = _.curry(fn),\n          ph = curried.placeholder,\n          actual = curried(ph, ph, ph, 'd')('a')(ph)('b')('c');\n\n      assert.deepEqual(actual, ['a', 'b', 'c', 'd']);\n    });\n\n    QUnit.test('should use `_.placeholder` when set', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var curried = _.curry(fn),\n            _ph = _.placeholder = {},\n            ph = curried.placeholder;\n\n        assert.deepEqual(curried(1)(_ph, 3)(ph, 4), [1, ph, 3, 4]);\n        delete _.placeholder;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should provide additional arguments after reaching the target arity', function(assert) {\n      assert.expect(3);\n\n      var curried = _.curry(fn, 3);\n      assert.deepEqual(curried(1)(2, 3, 4), [1, 2, 3, 4]);\n      assert.deepEqual(curried(1, 2)(3, 4, 5), [1, 2, 3, 4, 5]);\n      assert.deepEqual(curried(1, 2, 3, 4, 5, 6), [1, 2, 3, 4, 5, 6]);\n    });\n\n    QUnit.test('should create a function with a `length` of `0`', function(assert) {\n      assert.expect(6);\n\n      lodashStable.times(2, function(index) {\n        var curried = index ? _.curry(fn, 4) : _.curry(fn);\n        assert.strictEqual(curried.length, 0);\n        assert.strictEqual(curried(1).length, 0);\n        assert.strictEqual(curried(1, 2).length, 0);\n      });\n    });\n\n    QUnit.test('should ensure `new curried` is an instance of `func`', function(assert) {\n      assert.expect(2);\n\n      function Foo(value) {\n        return value && object;\n      }\n\n      var curried = _.curry(Foo),\n          object = {};\n\n      assert.ok(new curried(false) instanceof Foo);\n      assert.strictEqual(new curried(true), object);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(9);\n\n      var fn = function(a, b, c) {\n        var value = this || {};\n        return [value[a], value[b], value[c]];\n      };\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          expected = [1, 2, 3];\n\n      assert.deepEqual(_.curry(_.bind(fn, object), 3)('a')('b')('c'), expected);\n      assert.deepEqual(_.curry(_.bind(fn, object), 3)('a', 'b')('c'), expected);\n      assert.deepEqual(_.curry(_.bind(fn, object), 3)('a', 'b', 'c'), expected);\n\n      assert.deepEqual(_.bind(_.curry(fn), object)('a')('b')('c'), Array(3));\n      assert.deepEqual(_.bind(_.curry(fn), object)('a', 'b')('c'), Array(3));\n      assert.deepEqual(_.bind(_.curry(fn), object)('a', 'b', 'c'), expected);\n\n      object.curried = _.curry(fn);\n      assert.deepEqual(object.curried('a')('b')('c'), Array(3));\n      assert.deepEqual(object.curried('a', 'b')('c'), Array(3));\n      assert.deepEqual(object.curried('a', 'b', 'c'), expected);\n    });\n\n    QUnit.test('should work with partialed methods', function(assert) {\n      assert.expect(2);\n\n      var curried = _.curry(fn),\n          expected = [1, 2, 3, 4];\n\n      var a = _.partial(curried, 1),\n          b = _.bind(a, null, 2),\n          c = _.partialRight(b, 4),\n          d = _.partialRight(b(3), 4);\n\n      assert.deepEqual(c(3), expected);\n      assert.deepEqual(d(), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.curryRight');\n\n  (function() {\n    function fn(a, b, c, d) {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should curry based on the number of arguments given', function(assert) {\n      assert.expect(3);\n\n      var curried = _.curryRight(fn),\n          expected = [1, 2, 3, 4];\n\n      assert.deepEqual(curried(4)(3)(2)(1), expected);\n      assert.deepEqual(curried(3, 4)(1, 2), expected);\n      assert.deepEqual(curried(1, 2, 3, 4), expected);\n    });\n\n    QUnit.test('should allow specifying `arity`', function(assert) {\n      assert.expect(3);\n\n      var curried = _.curryRight(fn, 3),\n          expected = [1, 2, 3];\n\n      assert.deepEqual(curried(3)(1, 2), expected);\n      assert.deepEqual(curried(2, 3)(1), expected);\n      assert.deepEqual(curried(1, 2, 3), expected);\n    });\n\n    QUnit.test('should coerce `arity` to an integer', function(assert) {\n      assert.expect(2);\n\n      var values = ['0', 0.6, 'xyz'],\n          expected = lodashStable.map(values, stubArray);\n\n      var actual = lodashStable.map(values, function(arity) {\n        return _.curryRight(fn, arity)();\n      });\n\n      assert.deepEqual(actual, expected);\n      assert.deepEqual(_.curryRight(fn, '2')(1)(2), [2, 1]);\n    });\n\n    QUnit.test('should support placeholders', function(assert) {\n      assert.expect(4);\n\n      var curried = _.curryRight(fn),\n          expected = [1, 2, 3, 4],\n          ph = curried.placeholder;\n\n      assert.deepEqual(curried(4)(2, ph)(1, ph)(3), expected);\n      assert.deepEqual(curried(3, ph)(4)(1, ph)(2), expected);\n      assert.deepEqual(curried(ph, ph, 4)(ph, 3)(ph, 2)(1), expected);\n      assert.deepEqual(curried(ph, ph, ph, 4)(ph, ph, 3)(ph, 2)(1), expected);\n    });\n\n    QUnit.test('should persist placeholders', function(assert) {\n      assert.expect(1);\n\n      var curried = _.curryRight(fn),\n          ph = curried.placeholder,\n          actual = curried('a', ph, ph, ph)('b')(ph)('c')('d');\n\n      assert.deepEqual(actual, ['a', 'b', 'c', 'd']);\n    });\n\n    QUnit.test('should use `_.placeholder` when set', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var curried = _.curryRight(fn),\n            _ph = _.placeholder = {},\n            ph = curried.placeholder;\n\n        assert.deepEqual(curried(4)(2, _ph)(1, ph), [1, 2, ph, 4]);\n        delete _.placeholder;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should provide additional arguments after reaching the target arity', function(assert) {\n      assert.expect(3);\n\n      var curried = _.curryRight(fn, 3);\n      assert.deepEqual(curried(4)(1, 2, 3), [1, 2, 3, 4]);\n      assert.deepEqual(curried(4, 5)(1, 2, 3), [1, 2, 3, 4, 5]);\n      assert.deepEqual(curried(1, 2, 3, 4, 5, 6), [1, 2, 3, 4, 5, 6]);\n    });\n\n    QUnit.test('should create a function with a `length` of `0`', function(assert) {\n      assert.expect(6);\n\n      lodashStable.times(2, function(index) {\n        var curried = index ? _.curryRight(fn, 4) : _.curryRight(fn);\n        assert.strictEqual(curried.length, 0);\n        assert.strictEqual(curried(4).length, 0);\n        assert.strictEqual(curried(3, 4).length, 0);\n      });\n    });\n\n    QUnit.test('should ensure `new curried` is an instance of `func`', function(assert) {\n      assert.expect(2);\n\n      function Foo(value) {\n        return value && object;\n      }\n\n      var curried = _.curryRight(Foo),\n          object = {};\n\n      assert.ok(new curried(false) instanceof Foo);\n      assert.strictEqual(new curried(true), object);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(9);\n\n      var fn = function(a, b, c) {\n        var value = this || {};\n        return [value[a], value[b], value[c]];\n      };\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          expected = [1, 2, 3];\n\n      assert.deepEqual(_.curryRight(_.bind(fn, object), 3)('c')('b')('a'), expected);\n      assert.deepEqual(_.curryRight(_.bind(fn, object), 3)('b', 'c')('a'), expected);\n      assert.deepEqual(_.curryRight(_.bind(fn, object), 3)('a', 'b', 'c'), expected);\n\n      assert.deepEqual(_.bind(_.curryRight(fn), object)('c')('b')('a'), Array(3));\n      assert.deepEqual(_.bind(_.curryRight(fn), object)('b', 'c')('a'), Array(3));\n      assert.deepEqual(_.bind(_.curryRight(fn), object)('a', 'b', 'c'), expected);\n\n      object.curried = _.curryRight(fn);\n      assert.deepEqual(object.curried('c')('b')('a'), Array(3));\n      assert.deepEqual(object.curried('b', 'c')('a'), Array(3));\n      assert.deepEqual(object.curried('a', 'b', 'c'), expected);\n    });\n\n    QUnit.test('should work with partialed methods', function(assert) {\n      assert.expect(2);\n\n      var curried = _.curryRight(fn),\n          expected = [1, 2, 3, 4];\n\n      var a = _.partialRight(curried, 4),\n          b = _.partialRight(a, 3),\n          c = _.bind(b, null, 1),\n          d = _.partial(b(2), 1);\n\n      assert.deepEqual(c(2), expected);\n      assert.deepEqual(d(), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('curry methods');\n\n  lodashStable.each(['curry', 'curryRight'], function(methodName) {\n    var func = _[methodName],\n        fn = function(a, b) { return slice.call(arguments); },\n        isCurry = methodName == 'curry';\n\n    QUnit.test('`_.' + methodName + '` should not error on functions with the same name as lodash methods', function(assert) {\n      assert.expect(1);\n\n      function run(a, b) {\n        return a + b;\n      }\n\n      var curried = func(run);\n\n      try {\n        var actual = curried(1)(2);\n      } catch (e) {}\n\n      assert.strictEqual(actual, 3);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work for function names that shadow those on `Object.prototype`', function(assert) {\n      assert.expect(1);\n\n      var curried = _.curry(function hasOwnProperty(a, b, c) {\n        return [a, b, c];\n      });\n\n      var expected = [1, 2, 3];\n\n      assert.deepEqual(curried(1)(2)(3), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(2);\n\n      var array = [fn, fn, fn],\n          object = { 'a': fn, 'b': fn, 'c': fn };\n\n      lodashStable.each([array, object], function(collection) {\n        var curries = lodashStable.map(collection, func),\n            expected = lodashStable.map(collection, lodashStable.constant(isCurry ? ['a', 'b'] : ['b', 'a']));\n\n        var actual = lodashStable.map(curries, function(curried) {\n          return curried('a')('b');\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.debounce');\n\n  (function() {\n    QUnit.test('should debounce a function', function(assert) {\n      assert.expect(6);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var debounced = _.debounce(function(value) {\n        ++callCount;\n        return value;\n      }, 32);\n\n      var results = [debounced('a'), debounced('b'), debounced('c')];\n      assert.deepEqual(results, [undefined, undefined, undefined]);\n      assert.strictEqual(callCount, 0);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n\n        var results = [debounced('d'), debounced('e'), debounced('f')];\n        assert.deepEqual(results, ['c', 'c', 'c']);\n        assert.strictEqual(callCount, 1);\n      }, 128);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        done();\n      }, 256);\n    });\n\n    QUnit.test('subsequent debounced calls return the last `func` result', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var debounced = _.debounce(identity, 32);\n      debounced('a');\n\n      setTimeout(function() {\n        assert.notEqual(debounced('b'), 'b');\n      }, 64);\n\n      setTimeout(function() {\n        assert.notEqual(debounced('c'), 'c');\n        done();\n      }, 128);\n    });\n\n    QUnit.test('should not immediately call `func` when `wait` is `0`', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          debounced = _.debounce(function() { ++callCount; }, 0);\n\n      debounced();\n      debounced();\n      assert.strictEqual(callCount, 0);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n        done();\n      }, 5);\n    });\n\n    QUnit.test('should apply default options', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          debounced = _.debounce(function() { callCount++; }, 32, {});\n\n      debounced();\n      assert.strictEqual(callCount, 0);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should support a `leading` option', function(assert) {\n      assert.expect(4);\n\n      var done = assert.async();\n\n      var callCounts = [0, 0];\n\n      var withLeading = _.debounce(function() {\n        callCounts[0]++;\n      }, 32, { 'leading': true });\n\n      var withLeadingAndTrailing = _.debounce(function() {\n        callCounts[1]++;\n      }, 32, { 'leading': true });\n\n      withLeading();\n      assert.strictEqual(callCounts[0], 1);\n\n      withLeadingAndTrailing();\n      withLeadingAndTrailing();\n      assert.strictEqual(callCounts[1], 1);\n\n      setTimeout(function() {\n        assert.deepEqual(callCounts, [1, 2]);\n\n        withLeading();\n        assert.strictEqual(callCounts[0], 2);\n\n        done();\n      }, 64);\n    });\n\n    QUnit.test('subsequent leading debounced calls return the last `func` result', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var debounced = _.debounce(identity, 32, { 'leading': true, 'trailing': false }),\n          results = [debounced('a'), debounced('b')];\n\n      assert.deepEqual(results, ['a', 'a']);\n\n      setTimeout(function() {\n        var results = [debounced('c'), debounced('d')];\n        assert.deepEqual(results, ['c', 'c']);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should support a `trailing` option', function(assert) {\n      assert.expect(4);\n\n      var done = assert.async();\n\n      var withCount = 0,\n          withoutCount = 0;\n\n      var withTrailing = _.debounce(function() {\n        withCount++;\n      }, 32, { 'trailing': true });\n\n      var withoutTrailing = _.debounce(function() {\n        withoutCount++;\n      }, 32, { 'trailing': false });\n\n      withTrailing();\n      assert.strictEqual(withCount, 0);\n\n      withoutTrailing();\n      assert.strictEqual(withoutCount, 0);\n\n      setTimeout(function() {\n        assert.strictEqual(withCount, 1);\n        assert.strictEqual(withoutCount, 0);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should support a `maxWait` option', function(assert) {\n      assert.expect(4);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var debounced = _.debounce(function(value) {\n        ++callCount;\n        return value;\n      }, 32, { 'maxWait': 64 });\n\n      debounced();\n      debounced();\n      assert.strictEqual(callCount, 0);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n        debounced();\n        debounced();\n        assert.strictEqual(callCount, 1);\n      }, 128);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        done();\n      }, 256);\n    });\n\n    QUnit.test('should support `maxWait` in a tight loop', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var limit = (argv || isPhantom) ? 1000 : 320,\n          withCount = 0,\n          withoutCount = 0;\n\n      var withMaxWait = _.debounce(function() {\n        withCount++;\n      }, 64, { 'maxWait': 128 });\n\n      var withoutMaxWait = _.debounce(function() {\n        withoutCount++;\n      }, 96);\n\n      var start = +new Date;\n      while ((new Date - start) < limit) {\n        withMaxWait();\n        withoutMaxWait();\n      }\n      var actual = [Boolean(withoutCount), Boolean(withCount)];\n      setTimeout(function() {\n        assert.deepEqual(actual, [false, true]);\n        done();\n      }, 1);\n    });\n\n    QUnit.test('should queue a trailing call for subsequent debounced calls after `maxWait`', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var debounced = _.debounce(function() {\n        ++callCount;\n      }, 200, { 'maxWait': 200 });\n\n      debounced();\n\n      setTimeout(debounced, 190);\n      setTimeout(debounced, 200);\n      setTimeout(debounced, 210);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        done();\n      }, 500);\n    });\n\n    QUnit.test('should cancel `maxDelayed` when `delayed` is invoked', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var debounced = _.debounce(function() {\n        callCount++;\n      }, 32, { 'maxWait': 64 });\n\n      debounced();\n\n      setTimeout(function() {\n        debounced();\n        assert.strictEqual(callCount, 1);\n      }, 128);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        done();\n      }, 192);\n    });\n\n    QUnit.test('should invoke the trailing call with the correct arguments and `this` binding', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var actual,\n          callCount = 0,\n          object = {};\n\n      var debounced = _.debounce(function(value) {\n        actual = [this];\n        push.apply(actual, arguments);\n        return ++callCount != 2;\n      }, 32, { 'leading': true, 'maxWait': 64 });\n\n      while (true) {\n        if (!debounced.call(object, 'a')) {\n          break;\n        }\n      }\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        assert.deepEqual(actual, [object, 'a']);\n        done();\n      }, 64);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.deburr');\n\n  (function() {\n    QUnit.test('should convert Latin Unicode letters to basic Latin', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(burredLetters, _.deburr);\n      assert.deepEqual(actual, deburredLetters);\n    });\n\n    QUnit.test('should not deburr Latin mathematical operators', function(assert) {\n      assert.expect(1);\n\n      var operators = ['\\xd7', '\\xf7'],\n          actual = lodashStable.map(operators, _.deburr);\n\n      assert.deepEqual(actual, operators);\n    });\n\n    QUnit.test('should deburr combining diacritical marks', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(comboMarks, lodashStable.constant('ei'));\n\n      var actual = lodashStable.map(comboMarks, function(chr) {\n        return _.deburr('e' + chr + 'i');\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.defaults');\n\n  (function() {\n    QUnit.test('should assign source properties if missing on `object`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.defaults({ 'a': 1 }, { 'a': 2, 'b': 2 });\n      assert.deepEqual(actual, { 'a': 1, 'b': 2 });\n    });\n\n    QUnit.test('should accept multiple sources', function(assert) {\n      assert.expect(2);\n\n      var expected = { 'a': 1, 'b': 2, 'c': 3 },\n          actual = _.defaults({ 'a': 1, 'b': 2 }, { 'b': 3 }, { 'c': 3 });\n\n      assert.deepEqual(actual, expected);\n\n      actual = _.defaults({ 'a': 1, 'b': 2 }, { 'b': 3, 'c': 3 }, { 'c': 2 });\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not overwrite `null` values', function(assert) {\n      assert.expect(1);\n\n      var actual = _.defaults({ 'a': null }, { 'a': 1 });\n      assert.strictEqual(actual.a, null);\n    });\n\n    QUnit.test('should overwrite `undefined` values', function(assert) {\n      assert.expect(1);\n\n      var actual = _.defaults({ 'a': undefined }, { 'a': 1 });\n      assert.strictEqual(actual.a, 1);\n    });\n\n    QUnit.test('should assign `undefined` values', function(assert) {\n      assert.expect(1);\n\n      var source = { 'a': undefined, 'b': 1 },\n          actual = _.defaults({}, source);\n\n      assert.deepEqual(actual, { 'a': undefined, 'b': 1 });\n    });\n\n    QUnit.test('should assign properties that shadow those on `Object.prototype`', function(assert) {\n      assert.expect(2);\n\n      var object = {\n        'constructor': objectProto.constructor,\n        'hasOwnProperty': objectProto.hasOwnProperty,\n        'isPrototypeOf': objectProto.isPrototypeOf,\n        'propertyIsEnumerable': objectProto.propertyIsEnumerable,\n        'toLocaleString': objectProto.toLocaleString,\n        'toString': objectProto.toString,\n        'valueOf': objectProto.valueOf\n      };\n\n      var source = {\n        'constructor': 1,\n        'hasOwnProperty': 2,\n        'isPrototypeOf': 3,\n        'propertyIsEnumerable': 4,\n        'toLocaleString': 5,\n        'toString': 6,\n        'valueOf': 7\n      };\n\n      var expected = lodashStable.clone(source);\n      assert.deepEqual(_.defaults({}, source), expected);\n\n      expected = lodashStable.clone(object);\n      assert.deepEqual(_.defaults({}, object, source), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.defaultsDeep');\n\n  (function() {\n    QUnit.test('should deep assign source properties if missing on `object`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': 2 }, 'd': 4 },\n          source = { 'a': { 'b': 3, 'c': 3 }, 'e': 5 },\n          expected = { 'a': { 'b': 2, 'c': 3 }, 'd': 4, 'e': 5 };\n\n      assert.deepEqual(_.defaultsDeep(object, source), expected);\n    });\n\n    QUnit.test('should accept multiple sources', function(assert) {\n      assert.expect(2);\n\n      var source1 = { 'a': { 'b': 3 } },\n          source2 = { 'a': { 'c': 3 } },\n          source3 = { 'a': { 'b': 3, 'c': 3 } },\n          source4 = { 'a': { 'c': 4 } },\n          expected = { 'a': { 'b': 2, 'c': 3 } };\n\n      assert.deepEqual(_.defaultsDeep({ 'a': { 'b': 2 } }, source1, source2), expected);\n      assert.deepEqual(_.defaultsDeep({ 'a': { 'b': 2 } }, source3, source4), expected);\n    });\n\n    QUnit.test('should not overwrite `null` values', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': null } },\n          source = { 'a': { 'b': 2 } },\n          actual = _.defaultsDeep(object, source);\n\n      assert.strictEqual(actual.a.b, null);\n    });\n\n    QUnit.test('should not overwrite regexp values', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': /x/ } },\n          source = { 'a': { 'b': /y/ } },\n          actual = _.defaultsDeep(object, source);\n\n      assert.deepEqual(actual.a.b, /x/);\n    });\n\n    QUnit.test('should not convert function properties to objects', function(assert) {\n      assert.expect(2);\n\n      var actual = _.defaultsDeep({}, { 'a': noop });\n      assert.strictEqual(actual.a, noop);\n\n      actual = _.defaultsDeep({}, { 'a': { 'b': noop } });\n      assert.strictEqual(actual.a.b, noop);\n    });\n\n    QUnit.test('should overwrite `undefined` values', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': undefined } },\n          source = { 'a': { 'b': 2 } },\n          actual = _.defaultsDeep(object, source);\n\n      assert.strictEqual(actual.a.b, 2);\n    });\n\n    QUnit.test('should assign `undefined` values', function(assert) {\n      assert.expect(1);\n\n      var source = { 'a': undefined, 'b': { 'c': undefined, 'd': 1 } },\n          expected = lodashStable.cloneDeep(source),\n          actual = _.defaultsDeep({}, source);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should merge sources containing circular references', function(assert) {\n      assert.expect(2);\n\n      var object = {\n        'foo': { 'b': { 'c': { 'd': {} } } },\n        'bar': { 'a': 2 }\n      };\n\n      var source = {\n        'foo': { 'b': { 'c': { 'd': {} } } },\n        'bar': {}\n      };\n\n      object.foo.b.c.d = object;\n      source.foo.b.c.d = source;\n      source.bar.b = source.foo.b;\n\n      var actual = _.defaultsDeep(object, source);\n\n      assert.strictEqual(actual.bar.b, actual.foo.b);\n      assert.strictEqual(actual.foo.b.c.d, actual.foo.b.c.d.foo.b.c.d);\n    });\n\n    QUnit.test('should not modify sources', function(assert) {\n      assert.expect(3);\n\n      var source1 = { 'a': 1, 'b': { 'c': 2 } },\n          source2 = { 'b': { 'c': 3, 'd': 3 } },\n          actual = _.defaultsDeep({}, source1, source2);\n\n      assert.deepEqual(actual, { 'a': 1, 'b': { 'c': 2, 'd': 3 } });\n      assert.deepEqual(source1, { 'a': 1, 'b': { 'c': 2 } });\n      assert.deepEqual(source2, { 'b': { 'c': 3, 'd': 3 } });\n    });\n\n    QUnit.test('should not attempt a merge of a string into an array', function(assert) {\n      assert.expect(1);\n\n      var actual = _.defaultsDeep({ 'a': ['abc'] }, { 'a': 'abc' });\n      assert.deepEqual(actual.a, ['abc']);\n    });\n\n    QUnit.test('should not indirectly merge `Object` properties', function(assert) {\n      assert.expect(1);\n\n      _.defaultsDeep({}, { 'constructor': { 'a': 1 } });\n\n      var actual = 'a' in Object;\n      delete Object.a;\n\n      assert.notOk(actual);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.defaultTo');\n\n  (function() {\n    QUnit.test('should return a default value if `value` is `NaN` or nullish', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return (value == null || value !== value) ? 1 : value;\n      });\n\n      var actual = lodashStable.map(falsey, function(value) {\n        return _.defaultTo(value, 1);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.defer');\n\n  (function() {\n    QUnit.test('should defer `func` execution', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var pass = false;\n      _.defer(function() { pass = true; });\n\n      setTimeout(function() {\n        assert.ok(pass);\n        done();\n      }, 32);\n    });\n\n    QUnit.test('should provide additional arguments to `func`', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var args;\n\n      _.defer(function() {\n        args = slice.call(arguments);\n      }, 1, 2);\n\n      setTimeout(function() {\n        assert.deepEqual(args, [1, 2]);\n        done();\n      }, 32);\n    });\n\n    QUnit.test('should be cancelable', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var pass = true,\n          timerId = _.defer(function() { pass = false; });\n\n      clearTimeout(timerId);\n\n      setTimeout(function() {\n        assert.ok(pass);\n        done();\n      }, 32);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.delay');\n\n  (function() {\n    QUnit.test('should delay `func` execution', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var pass = false;\n      _.delay(function() { pass = true; }, 32);\n\n      setTimeout(function() {\n        assert.notOk(pass);\n      }, 1);\n\n      setTimeout(function() {\n        assert.ok(pass);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should provide additional arguments to `func`', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var args;\n\n      _.delay(function() {\n        args = slice.call(arguments);\n      }, 32, 1, 2);\n\n      setTimeout(function() {\n        assert.deepEqual(args, [1, 2]);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should use a default `wait` of `0`', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var pass = false;\n      _.delay(function() { pass = true; });\n\n      assert.notOk(pass);\n\n      setTimeout(function() {\n        assert.ok(pass);\n        done();\n      }, 0);\n    });\n\n    QUnit.test('should be cancelable', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var pass = true,\n          timerId = _.delay(function() { pass = false; }, 32);\n\n      clearTimeout(timerId);\n\n      setTimeout(function() {\n        assert.ok(pass);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should work with mocked `setTimeout`', function(assert) {\n      assert.expect(1);\n\n      if (!isPhantom) {\n        var pass = false,\n            setTimeout = root.setTimeout;\n\n        setProperty(root, 'setTimeout', function(func) { func(); });\n        _.delay(function() { pass = true; }, 32);\n        setProperty(root, 'setTimeout', setTimeout);\n\n        assert.ok(pass);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('difference methods');\n\n  lodashStable.each(['difference', 'differenceBy', 'differenceWith'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return the difference of two arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2, 1], [2, 3]);\n      assert.deepEqual(actual, [1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return the difference of multiple arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2, 1, 2, 3], [3, 4], [3, 2]);\n      assert.deepEqual(actual, [1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat `-0` as `0`', function(assert) {\n      assert.expect(2);\n\n      var array = [-0, 0];\n\n      var actual = lodashStable.map(array, function(value) {\n        return func(array, [value]);\n      });\n\n      assert.deepEqual(actual, [[], []]);\n\n      actual = lodashStable.map(func([-0, 1], [1]), lodashStable.toString);\n      assert.deepEqual(actual, ['0']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `NaN`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func([1, NaN, 3], [NaN, 5, NaN]), [1, 3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays', function(assert) {\n      assert.expect(1);\n\n      var array1 = lodashStable.range(LARGE_ARRAY_SIZE + 1),\n          array2 = lodashStable.range(LARGE_ARRAY_SIZE),\n          a = {},\n          b = {},\n          c = {};\n\n      array1.push(a, b, c);\n      array2.push(b, c, a);\n\n      assert.deepEqual(func(array1, array2), [LARGE_ARRAY_SIZE]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of `-0` as `0`', function(assert) {\n      assert.expect(2);\n\n      var array = [-0, 0];\n\n      var actual = lodashStable.map(array, function(value) {\n        var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, lodashStable.constant(value));\n        return func(array, largeArray);\n      });\n\n      assert.deepEqual(actual, [[], []]);\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, stubOne);\n      actual = lodashStable.map(func([-0, 1], largeArray), lodashStable.toString);\n      assert.deepEqual(actual, ['0']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of `NaN`', function(assert) {\n      assert.expect(1);\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, stubNaN);\n      assert.deepEqual(func([1, NaN, 3], largeArray), [1, 3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of objects', function(assert) {\n      assert.expect(1);\n\n      var object1 = {},\n          object2 = {},\n          largeArray = lodashStable.times(LARGE_ARRAY_SIZE, lodashStable.constant(object1));\n\n      assert.deepEqual(func([object1, object2], largeArray), [object2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ignore values that are not array-like', function(assert) {\n      assert.expect(3);\n\n      var array = [1, null, 3];\n\n      assert.deepEqual(func(args, 3, { '0': 1 }), [1, 2, 3]);\n      assert.deepEqual(func(null, array, 1), []);\n      assert.deepEqual(func(array, args, null), [null]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.differenceBy');\n\n  (function() {\n    QUnit.test('should accept an `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var actual = _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n      assert.deepEqual(actual, [1.2]);\n\n      actual = _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n      assert.deepEqual(actual, [{ 'x': 2 }]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.differenceBy([2.1, 1.2], [2.3, 3.4], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [2.3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.differenceWith');\n\n  (function() {\n    QUnit.test('should work with a `comparator`', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }],\n          actual = _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], lodashStable.isEqual);\n\n      assert.deepEqual(actual, [objects[1]]);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var array = [-0, 1],\n          largeArray = lodashStable.times(LARGE_ARRAY_SIZE, stubOne),\n          others = [[1], largeArray],\n          expected = lodashStable.map(others, lodashStable.constant(['-0']));\n\n      var actual = lodashStable.map(others, function(other) {\n        return lodashStable.map(_.differenceWith(array, other, lodashStable.eq), lodashStable.toString);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.divide');\n\n  (function() {\n    QUnit.test('should divide two numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.divide(6, 4), 1.5);\n      assert.strictEqual(_.divide(-6, 4), -1.5);\n      assert.strictEqual(_.divide(-6, -4), 1.5);\n    });\n\n    QUnit.test('should coerce arguments to numbers', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.divide('6', '4'), 1.5);\n      assert.deepEqual(_.divide('x', 'y'), NaN);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.drop');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should drop the first two elements', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.drop(array, 2), [3]);\n    });\n\n    QUnit.test('should treat falsey `n` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? [2, 3] : array;\n      });\n\n      var actual = lodashStable.map(falsey, function(n) {\n        return _.drop(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return all elements when `n` < `1`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([0, -1, -Infinity], function(n) {\n        assert.deepEqual(_.drop(array, n), array);\n      });\n    });\n\n    QUnit.test('should return an empty array when `n` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(n) {\n        assert.deepEqual(_.drop(array, n), []);\n      });\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.drop(array, 1.6), [2, 3]);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.drop);\n\n      assert.deepEqual(actual, [[2, 3], [5, 6], [8, 9]]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var array = lodashStable.range(1, LARGE_ARRAY_SIZE + 1),\n            predicate = function(value) { values.push(value); return isEven(value); },\n            values = [],\n            actual = _(array).drop(2).drop().value();\n\n        assert.deepEqual(actual, array.slice(3));\n\n        actual = _(array).filter(predicate).drop(2).drop().value();\n        assert.deepEqual(values, array);\n        assert.deepEqual(actual, _.drop(_.drop(_.filter(array, predicate), 2)));\n\n        actual = _(array).drop(2).dropRight().drop().dropRight(2).value();\n        assert.deepEqual(actual, _.dropRight(_.drop(_.dropRight(_.drop(array, 2))), 2));\n\n        values = [];\n\n        actual = _(array).drop().filter(predicate).drop(2).dropRight().drop().dropRight(2).value();\n        assert.deepEqual(values, array.slice(1));\n        assert.deepEqual(actual, _.dropRight(_.drop(_.dropRight(_.drop(_.filter(_.drop(array), predicate), 2))), 2));\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.dropRight');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should drop the last two elements', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropRight(array, 2), [1]);\n    });\n\n    QUnit.test('should treat falsey `n` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? [1, 2] : array;\n      });\n\n      var actual = lodashStable.map(falsey, function(n) {\n        return _.dropRight(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return all elements when `n` < `1`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([0, -1, -Infinity], function(n) {\n        assert.deepEqual(_.dropRight(array, n), array);\n      });\n    });\n\n    QUnit.test('should return an empty array when `n` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(n) {\n        assert.deepEqual(_.dropRight(array, n), []);\n      });\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropRight(array, 1.6), [1, 2]);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.dropRight);\n\n      assert.deepEqual(actual, [[1, 2], [4, 5], [7, 8]]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var array = lodashStable.range(1, LARGE_ARRAY_SIZE + 1),\n            predicate = function(value) { values.push(value); return isEven(value); },\n            values = [],\n            actual = _(array).dropRight(2).dropRight().value();\n\n        assert.deepEqual(actual, array.slice(0, -3));\n\n        actual = _(array).filter(predicate).dropRight(2).dropRight().value();\n        assert.deepEqual(values, array);\n        assert.deepEqual(actual, _.dropRight(_.dropRight(_.filter(array, predicate), 2)));\n\n        actual = _(array).dropRight(2).drop().dropRight().drop(2).value();\n        assert.deepEqual(actual, _.drop(_.dropRight(_.drop(_.dropRight(array, 2))), 2));\n\n        values = [];\n\n        actual = _(array).dropRight().filter(predicate).dropRight(2).drop().dropRight().drop(2).value();\n        assert.deepEqual(values, array.slice(0, -1));\n        assert.deepEqual(actual, _.drop(_.dropRight(_.drop(_.dropRight(_.filter(_.dropRight(array), predicate), 2))), 2));\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.dropRightWhile');\n\n  (function() {\n    var array = [1, 2, 3, 4];\n\n    var objects = [\n      { 'a': 0, 'b': 0 },\n      { 'a': 1, 'b': 1 },\n      { 'a': 2, 'b': 2 }\n    ];\n\n    QUnit.test('should drop elements while `predicate` returns truthy', function(assert) {\n      assert.expect(1);\n\n      var actual = _.dropRightWhile(array, function(n) {\n        return n > 2;\n      });\n\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('should provide correct `predicate` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.dropRightWhile(array, function() {\n        args = slice.call(arguments);\n      });\n\n      assert.deepEqual(args, [4, 3, array]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropRightWhile(objects, { 'b': 2 }), objects.slice(0, 2));\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropRightWhile(objects, ['b', 2]), objects.slice(0, 2));\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropRightWhile(objects, 'b'), objects.slice(0, 1));\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(array).dropRightWhile(function(n) {\n          return n > 2;\n        });\n\n        assert.ok(wrapped instanceof _);\n        assert.deepEqual(wrapped.value(), [1, 2]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.dropWhile');\n\n  (function() {\n    var array = [1, 2, 3, 4];\n\n    var objects = [\n      { 'a': 2, 'b': 2 },\n      { 'a': 1, 'b': 1 },\n      { 'a': 0, 'b': 0 }\n    ];\n\n    QUnit.test('should drop elements while `predicate` returns truthy', function(assert) {\n      assert.expect(1);\n\n      var actual = _.dropWhile(array, function(n) {\n        return n < 3;\n      });\n\n      assert.deepEqual(actual, [3, 4]);\n    });\n\n    QUnit.test('should provide correct `predicate` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.dropWhile(array, function() {\n        args = slice.call(arguments);\n      });\n\n      assert.deepEqual(args, [1, 0, array]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropWhile(objects, { 'b': 2 }), objects.slice(1));\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropWhile(objects, ['b', 2]), objects.slice(1));\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.dropWhile(objects, 'b'), objects.slice(2));\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var array = lodashStable.range(1, LARGE_ARRAY_SIZE + 3),\n            predicate = function(n) { return n < 3; },\n            expected = _.dropWhile(array, predicate),\n            wrapped = _(array).dropWhile(predicate);\n\n        assert.deepEqual(wrapped.value(), expected);\n        assert.deepEqual(wrapped.reverse().value(), expected.slice().reverse());\n        assert.strictEqual(wrapped.last(), _.last(expected));\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence with `drop`', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.range(1, LARGE_ARRAY_SIZE + 3);\n\n        var actual = _(array)\n          .dropWhile(function(n) { return n == 1; })\n          .drop()\n          .dropWhile(function(n) { return n == 3; })\n          .value();\n\n        assert.deepEqual(actual, array.slice(3));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.endsWith');\n\n  (function() {\n    var string = 'abc';\n\n    QUnit.test('should return `true` if a string ends with `target`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.endsWith(string, 'c'), true);\n    });\n\n    QUnit.test('should return `false` if a string does not end with `target`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.endsWith(string, 'b'), false);\n    });\n\n    QUnit.test('should work with a `position`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.endsWith(string, 'b', 2), true);\n    });\n\n    QUnit.test('should work with `position` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 5, MAX_SAFE_INTEGER, Infinity], function(position) {\n        assert.strictEqual(_.endsWith(string, 'c', position), true);\n      });\n    });\n\n    QUnit.test('should treat falsey `position` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubTrue);\n\n      var actual = lodashStable.map(falsey, function(position) {\n        return _.endsWith(string, position === undefined ? 'c' : '', position);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should treat a negative `position` as `0`', function(assert) {\n      assert.expect(6);\n\n      lodashStable.each([-1, -3, -Infinity], function(position) {\n        assert.ok(lodashStable.every(string, function(chr) {\n          return !_.endsWith(string, chr, position);\n        }));\n        assert.strictEqual(_.endsWith(string, '', position), true);\n      });\n    });\n\n    QUnit.test('should coerce `position` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.endsWith(string, 'ab', 2.2), true);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.eq');\n\n  (function() {\n    QUnit.test('should perform a `SameValueZero` comparison of two values', function(assert) {\n      assert.expect(11);\n\n      assert.strictEqual(_.eq(), true);\n      assert.strictEqual(_.eq(undefined), true);\n      assert.strictEqual(_.eq(0, -0), true);\n      assert.strictEqual(_.eq(NaN, NaN), true);\n      assert.strictEqual(_.eq(1, 1), true);\n\n      assert.strictEqual(_.eq(null, undefined), false);\n      assert.strictEqual(_.eq(1, Object(1)), false);\n      assert.strictEqual(_.eq(1, '1'), false);\n      assert.strictEqual(_.eq(1, '1'), false);\n\n      var object = { 'a': 1 };\n      assert.strictEqual(_.eq(object, object), true);\n      assert.strictEqual(_.eq(object, { 'a': 1 }), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.escape');\n\n  (function() {\n    var escaped = '&amp;&lt;&gt;&quot;&#39;/',\n        unescaped = '&<>\"\\'/';\n\n    escaped += escaped;\n    unescaped += unescaped;\n\n    QUnit.test('should escape values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.escape(unescaped), escaped);\n    });\n\n    QUnit.test('should handle strings with nothing to escape', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.escape('abc'), 'abc');\n    });\n\n    QUnit.test('should escape the same characters unescaped by `_.unescape`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.escape(_.unescape(escaped)), escaped);\n    });\n\n    lodashStable.each(['`', '/'], function(chr) {\n      QUnit.test('should not escape the \"' + chr + '\" character', function(assert) {\n        assert.expect(1);\n\n        assert.strictEqual(_.escape(chr), chr);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.escapeRegExp');\n\n  (function() {\n    var escaped = '\\\\^\\\\$\\\\.\\\\*\\\\+\\\\?\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}\\\\|\\\\\\\\',\n        unescaped = '^$.*+?()[]{}|\\\\';\n\n    QUnit.test('should escape values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.escapeRegExp(unescaped + unescaped), escaped + escaped);\n    });\n\n    QUnit.test('should handle strings with nothing to escape', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.escapeRegExp('abc'), 'abc');\n    });\n\n    QUnit.test('should return an empty string for empty values', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined, ''],\n          expected = lodashStable.map(values, stubString);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.escapeRegExp(value) : _.escapeRegExp();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.every');\n\n  (function() {\n    QUnit.test('should return `true` if `predicate` returns truthy for all elements', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(lodashStable.every([true, 1, 'a'], identity), true);\n    });\n\n    QUnit.test('should return `true` for empty collections', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, stubTrue);\n\n      var actual = lodashStable.map(empties, function(value) {\n        try {\n          return _.every(value, identity);\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` as soon as `predicate` returns falsey', function(assert) {\n      assert.expect(2);\n\n      var count = 0;\n\n      assert.strictEqual(_.every([true, null, true], function(value) {\n        count++;\n        return value;\n      }), false);\n\n      assert.strictEqual(count, 2);\n    });\n\n    QUnit.test('should work with collections of `undefined` values (test in IE < 9)', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.every([undefined, undefined, undefined], identity), false);\n    });\n\n    QUnit.test('should use `_.identity` when `predicate` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var array = [0];\n        return index ? _.every(array, value) : _.every(array);\n      });\n\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(values, stubTrue);\n      actual = lodashStable.map(values, function(value, index) {\n        var array = [1];\n        return index ? _.every(array, value) : _.every(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 0, 'b': 1 }, { 'a': 1, 'b': 2 }];\n      assert.strictEqual(_.every(objects, 'a'), false);\n      assert.strictEqual(_.every(objects, 'b'), true);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 0, 'b': 0 }, { 'a': 0, 'b': 1 }];\n      assert.strictEqual(_.every(objects, { 'a': 0 }), true);\n      assert.strictEqual(_.every(objects, { 'b': 1 }), false);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map([[1]], _.every);\n      assert.deepEqual(actual, [true]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('strict mode checks');\n\n  lodashStable.each(['assign', 'assignIn', 'bindAll', 'defaults', 'defaultsDeep', 'merge'], function(methodName) {\n    var func = _[methodName],\n        isBindAll = methodName == 'bindAll';\n\n    QUnit.test('`_.' + methodName + '` should ' + (isStrict ? '' : 'not ') + 'throw strict mode errors', function(assert) {\n      assert.expect(1);\n\n      var object = freeze({ 'a': undefined, 'b': function() {} }),\n          pass = !isStrict;\n\n      try {\n        func(object, isBindAll ? 'b' : { 'a': 1 });\n      } catch (e) {\n        pass = !pass;\n      }\n      assert.ok(pass);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.fill');\n\n  (function() {\n    QUnit.test('should use a default `start` of `0` and a default `end` of `length`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(_.fill(array, 'a'), ['a', 'a', 'a']);\n    });\n\n    QUnit.test('should use `undefined` for `value` if not given', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = _.fill(array);\n\n      assert.deepEqual(actual, Array(3));\n      assert.ok(lodashStable.every(actual, function(value, index) {\n        return index in actual;\n      }));\n    });\n\n    QUnit.test('should work with a positive `start`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(_.fill(array, 'a', 1), [1, 'a', 'a']);\n    });\n\n    QUnit.test('should work with a `start` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(start) {\n        var array = [1, 2, 3];\n        assert.deepEqual(_.fill(array, 'a', start), [1, 2, 3]);\n      });\n    });\n\n    QUnit.test('should treat falsey `start` values as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, lodashStable.constant(['a', 'a', 'a']));\n\n      var actual = lodashStable.map(falsey, function(start) {\n        var array = [1, 2, 3];\n        return _.fill(array, 'a', start);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with a negative `start`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(_.fill(array, 'a', -1), [1, 2, 'a']);\n    });\n\n    QUnit.test('should work with a negative `start` <= negative `length`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([-3, -4, -Infinity], function(start) {\n        var array = [1, 2, 3];\n        assert.deepEqual(_.fill(array, 'a', start), ['a', 'a', 'a']);\n      });\n    });\n\n    QUnit.test('should work with `start` >= `end`', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([2, 3], function(start) {\n        var array = [1, 2, 3];\n        assert.deepEqual(_.fill(array, 'a', start, 2), [1, 2, 3]);\n      });\n    });\n\n    QUnit.test('should work with a positive `end`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(_.fill(array, 'a', 0, 1), ['a', 2, 3]);\n    });\n\n    QUnit.test('should work with a `end` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(end) {\n        var array = [1, 2, 3];\n        assert.deepEqual(_.fill(array, 'a', 0, end), ['a', 'a', 'a']);\n      });\n    });\n\n    QUnit.test('should treat falsey `end` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? ['a', 'a', 'a'] : [1, 2, 3];\n      });\n\n      var actual = lodashStable.map(falsey, function(end) {\n        var array = [1, 2, 3];\n        return _.fill(array, 'a', 0, end);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with a negative `end`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(_.fill(array, 'a', 0, -1), ['a', 'a', 3]);\n    });\n\n    QUnit.test('should work with a negative `end` <= negative `length`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([-3, -4, -Infinity], function(end) {\n        var array = [1, 2, 3];\n        assert.deepEqual(_.fill(array, 'a', 0, end), [1, 2, 3]);\n      });\n    });\n\n    QUnit.test('should coerce `start` and `end` to integers', function(assert) {\n      assert.expect(1);\n\n      var positions = [[0.1, 1.6], ['0', 1], [0, '1'], ['1'], [NaN, 1], [1, NaN]];\n\n      var actual = lodashStable.map(positions, function(pos) {\n        var array = [1, 2, 3];\n        return _.fill.apply(_, [array, 'a'].concat(pos));\n      });\n\n      assert.deepEqual(actual, [['a', 2, 3], ['a', 2, 3], ['a', 2, 3], [1, 'a', 'a'], ['a', 2, 3], [1, 2, 3]]);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2], [3, 4]],\n          actual = lodashStable.map(array, _.fill);\n\n      assert.deepEqual(actual, [[0, 0], [1, 1]]);\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var array = [1, 2, 3],\n            wrapped = _(array).fill('a'),\n            actual = wrapped.value();\n\n        assert.ok(wrapped instanceof _);\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, ['a', 'a', 'a']);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.filter');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should return elements `predicate` returns truthy for', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.filter(array, isEven), [2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  lodashStable.each(['find', 'findIndex', 'findKey', 'findLast', 'findLastIndex', 'findLastKey'], function(methodName) {\n    QUnit.module('lodash.' + methodName);\n\n    var array = [1, 2, 3, 4],\n        func = _[methodName];\n\n    var objects = [\n      { 'a': 0, 'b': 0 },\n      { 'a': 1, 'b': 1 },\n      { 'a': 2, 'b': 2 }\n    ];\n\n    var expected = ({\n      'find': [objects[1], undefined, objects[2]],\n      'findIndex': [1, -1, 2],\n      'findKey': ['1', undefined, '2'],\n      'findLast': [objects[2], undefined, objects[2]],\n      'findLastIndex': [2, -1, 2],\n      'findLastKey': ['2', undefined, '2']\n    })[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return the found value', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(objects, function(object) { return object.a; }), expected[0]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `' + expected[1] + '` if value is not found', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(objects, function(object) { return object.a === 3; }), expected[1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(objects, { 'b': 2 }), expected[2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(objects, ['b', 2]), expected[2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(objects, 'b'), expected[0]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `' + expected[1] + '` for empty collections', function(assert) {\n      assert.expect(1);\n\n      var emptyValues = lodashStable.endsWith(methodName, 'Index') ? lodashStable.reject(empties, lodashStable.isPlainObject) : empties,\n          expecting = lodashStable.map(emptyValues, lodashStable.constant(expected[1]));\n\n      var actual = lodashStable.map(emptyValues, function(value) {\n        try {\n          return func(value, { 'a': 3 });\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expecting);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      var expected = ({\n        'find': 1,\n        'findIndex': 0,\n        'findKey': '0',\n        'findLast': 4,\n        'findLastIndex': 3,\n        'findLastKey': '3'\n      })[methodName];\n\n      if (!isNpm) {\n        assert.strictEqual(_(array)[methodName](), expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(array).chain()[methodName]() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should not execute immediately when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _(array).chain()[methodName]();\n        assert.strictEqual(wrapped.__wrapped__, array);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should work in a lazy sequence', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var largeArray = lodashStable.range(1, LARGE_ARRAY_SIZE + 1),\n            smallArray = array;\n\n        lodashStable.times(2, function(index) {\n          var array = index ? largeArray : smallArray,\n              wrapped = _(array).filter(isEven);\n\n          assert.strictEqual(wrapped[methodName](), func(lodashStable.filter(array, isEven)));\n        });\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  });\n\n  _.each(['find', 'findIndex', 'findLast', 'findLastIndex'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should provide correct `predicate` arguments for arrays', function(assert) {\n      assert.expect(1);\n\n      var args,\n          array = ['a'];\n\n      func(array, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, ['a', 0, array]);\n    });\n  });\n\n  _.each(['find', 'findKey', 'findLast', 'findLastKey'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var actual = func({ 'a': 1, 'b': 2, 'c': 3 }, function(n) {\n        return n < 3;\n      });\n\n      var expected = ({\n        'find': 1,\n        'findKey': 'a',\n        'findLast': 2,\n        'findLastKey': 'b'\n      })[methodName];\n\n      assert.strictEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should provide correct `predicate` arguments for objects', function(assert) {\n      assert.expect(1);\n\n      var args,\n          object = { 'a': 1 };\n\n      func(object, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [1, 'a', object]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.find and lodash.findLast');\n\n  lodashStable.each(['find', 'findLast'], function(methodName) {\n    var isFind = methodName == 'find';\n\n    QUnit.test('`_.' + methodName + '` should support shortcut fusion', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var findCount = 0,\n            mapCount = 0,\n            array = lodashStable.range(1, LARGE_ARRAY_SIZE + 1),\n            iteratee = function(value) { mapCount++; return square(value); },\n            predicate = function(value) { findCount++; return isEven(value); },\n            actual = _(array).map(iteratee)[methodName](predicate);\n\n        assert.strictEqual(findCount, isFind ? 2 : 1);\n        assert.strictEqual(mapCount, isFind ? 2 : 1);\n        assert.strictEqual(actual, isFind ? 4 : square(LARGE_ARRAY_SIZE));\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.find and lodash.includes');\n\n  lodashStable.each(['includes', 'find'], function(methodName) {\n    var func = _[methodName],\n        isIncludes = methodName == 'includes',\n        resolve = methodName == 'find' ? lodashStable.curry(lodashStable.eq) : identity;\n\n    lodashStable.each({\n      'an `arguments` object': args,\n      'an array': [1, 2, 3]\n    },\n    function(collection, key) {\n      var values = lodashStable.toArray(collection);\n\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' and a positive `fromIndex`', function(assert) {\n        assert.expect(1);\n\n        var expected = [\n          isIncludes || values[2],\n          isIncludes ? false : undefined\n        ];\n\n        var actual = [\n          func(collection, resolve(values[2]), 2),\n          func(collection, resolve(values[1]), 2)\n        ];\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' and a `fromIndex` >= `length`', function(assert) {\n        assert.expect(1);\n\n        var indexes = [4, 6, Math.pow(2, 32), Infinity];\n\n        var expected = lodashStable.map(indexes, function() {\n          var result = isIncludes ? false : undefined;\n          return [result, result, result];\n        });\n\n        var actual = lodashStable.map(indexes, function(fromIndex) {\n          return [\n            func(collection, resolve(1), fromIndex),\n            func(collection, resolve(undefined), fromIndex),\n            func(collection, resolve(''), fromIndex)\n          ];\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' and treat falsey `fromIndex` values as `0`', function(assert) {\n        assert.expect(1);\n\n        var expected = lodashStable.map(falsey, lodashStable.constant(isIncludes || values[0]));\n\n        var actual = lodashStable.map(falsey, function(fromIndex) {\n          return func(collection, resolve(values[0]), fromIndex);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' and coerce `fromIndex` to an integer', function(assert) {\n        assert.expect(1);\n\n        var expected = [\n          isIncludes || values[0],\n          isIncludes || values[0],\n          isIncludes ? false : undefined\n        ];\n\n        var actual = [\n          func(collection, resolve(values[0]), 0.1),\n          func(collection, resolve(values[0]), NaN),\n          func(collection, resolve(values[0]), '1')\n        ];\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' and a negative `fromIndex`', function(assert) {\n        assert.expect(1);\n\n        var expected = [\n          isIncludes || values[2],\n          isIncludes ? false : undefined\n        ];\n\n        var actual = [\n          func(collection, resolve(values[2]), -1),\n          func(collection, resolve(values[1]), -1)\n        ];\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' and a negative `fromIndex` <= `-length`', function(assert) {\n        assert.expect(1);\n\n        var indexes = [-4, -6, -Infinity],\n            expected = lodashStable.map(indexes, lodashStable.constant(isIncludes || values[0]));\n\n        var actual = lodashStable.map(indexes, function(fromIndex) {\n          return func(collection, resolve(values[0]), fromIndex);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.findIndex and lodash.indexOf');\n\n  lodashStable.each(['findIndex', 'indexOf'], function(methodName) {\n    var array = [1, 2, 3, 1, 2, 3],\n        func = _[methodName],\n        resolve = methodName == 'findIndex' ? lodashStable.curry(lodashStable.eq) : identity;\n\n    QUnit.test('`_.' + methodName + '` should return the index of the first matched value', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(3)), 2);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a positive `fromIndex`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(1), 2), 3);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a `fromIndex` >= `length`', function(assert) {\n      assert.expect(1);\n\n      var values = [6, 8, Math.pow(2, 32), Infinity],\n          expected = lodashStable.map(values, lodashStable.constant([-1, -1, -1]));\n\n      var actual = lodashStable.map(values, function(fromIndex) {\n        return [\n          func(array, resolve(undefined), fromIndex),\n          func(array, resolve(1), fromIndex),\n          func(array, resolve(''), fromIndex)\n        ];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a negative `fromIndex`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(2), -3), 4);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a negative `fromIndex` <= `-length`', function(assert) {\n      assert.expect(1);\n\n      var values = [-6, -8, -Infinity],\n          expected = lodashStable.map(values, stubZero);\n\n      var actual = lodashStable.map(values, function(fromIndex) {\n        return func(array, resolve(1), fromIndex);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat falsey `fromIndex` values as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubZero);\n\n      var actual = lodashStable.map(falsey, function(fromIndex) {\n        return func(array, resolve(1), fromIndex);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `fromIndex` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(2), 1.2), 1);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.findLast');\n\n  (function() {\n    var resolve = lodashStable.curry(lodashStable.eq);\n\n    lodashStable.each({\n      'an `arguments` object': args,\n      'an array': [1, 2, 3]\n    },\n    function(collection, key) {\n      var values = lodashStable.toArray(collection);\n\n      QUnit.test('should work with ' + key + ' and a positive `fromIndex`', function(assert) {\n        assert.expect(1);\n\n        var expected = [\n          values[1],\n          undefined\n        ];\n\n        var actual = [\n          _.findLast(collection, resolve(values[1]), 1),\n          _.findLast(collection, resolve(values[2]), 1)\n        ];\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('should work with ' + key + ' and a `fromIndex` >= `length`', function(assert) {\n        assert.expect(1);\n\n        var indexes = [4, 6, Math.pow(2, 32), Infinity];\n\n        var expected = lodashStable.map(indexes, lodashStable.constant([values[0], undefined, undefined]));\n\n        var actual = lodashStable.map(indexes, function(fromIndex) {\n          return [\n            _.findLast(collection, resolve(1), fromIndex),\n            _.findLast(collection, resolve(undefined), fromIndex),\n            _.findLast(collection, resolve(''), fromIndex)\n          ];\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('should work with ' + key + ' and treat falsey `fromIndex` values correctly', function(assert) {\n        assert.expect(1);\n\n        var expected = lodashStable.map(falsey, function(value) {\n          return value === undefined ? values[3] : undefined;\n        });\n\n        var actual = lodashStable.map(falsey, function(fromIndex) {\n          return _.findLast(collection, resolve(values[3]), fromIndex);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('should work with ' + key + ' and coerce `fromIndex` to an integer', function(assert) {\n        assert.expect(1);\n\n        var expected = [\n          values[0],\n          values[0],\n          undefined\n        ];\n\n        var actual = [\n          _.findLast(collection, resolve(values[0]), 0.1),\n          _.findLast(collection, resolve(values[0]), NaN),\n          _.findLast(collection, resolve(values[2]), '1')\n        ];\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('should work with ' + key + ' and a negative `fromIndex`', function(assert) {\n        assert.expect(1);\n\n        var expected = [\n          values[1],\n          undefined\n        ];\n\n        var actual = [\n          _.findLast(collection, resolve(values[1]), -2),\n          _.findLast(collection, resolve(values[2]), -2)\n        ];\n\n        assert.deepEqual(actual, expected);\n      });\n\n      QUnit.test('should work with ' + key + ' and a negative `fromIndex` <= `-length`', function(assert) {\n        assert.expect(1);\n\n        var indexes = [-4, -6, -Infinity],\n            expected = lodashStable.map(indexes, lodashStable.constant(values[0]));\n\n        var actual = lodashStable.map(indexes, function(fromIndex) {\n          return _.findLast(collection, resolve(values[0]), fromIndex);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.flip');\n\n  (function() {\n    function fn() {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should flip arguments provided to `func`', function(assert) {\n      assert.expect(1);\n\n      var flipped = _.flip(fn);\n      assert.deepEqual(flipped('a', 'b', 'c', 'd'), ['d', 'c', 'b', 'a']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.flatMapDepth');\n\n  (function() {\n    var array = [1, [2, [3, [4]], 5]];\n\n    QUnit.test('should use a default `depth` of `1`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.flatMapDepth(array, identity), [1, 2, [3, [4]], 5]);\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([1, 2, [3, [4]], 5]));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.flatMapDepth(array, value) : _.flatMapDepth(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should treat a `depth` of < `1` as a shallow clone', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([-1, 0], function(depth) {\n        assert.deepEqual(_.flatMapDepth(array, identity, depth), [1, [2, [3, [4]], 5]]);\n      });\n    });\n\n    QUnit.test('should coerce `depth` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.flatMapDepth(array, identity, 2.2), [1, 2, 3, [4], 5]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('flatMap methods');\n\n  lodashStable.each(['flatMap', 'flatMapDeep', 'flatMapDepth'], function(methodName) {\n    var func = _[methodName],\n        array = [1, 2, 3, 4];\n\n    function duplicate(n) {\n      return [n, n];\n    }\n\n    QUnit.test('`_.' + methodName + '` should map values in `array` to a new flattened array', function(assert) {\n      assert.expect(1);\n\n      var actual = func(array, duplicate),\n          expected = lodashStable.flatten(lodashStable.map(array, duplicate));\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': [1, 2] }, { 'a': [3, 4] }];\n      assert.deepEqual(func(objects, 'a'), array);\n    });\n\n    QUnit.test('`_.' + methodName + '` should iterate over own string keyed properties of objects', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = [1, 2];\n      }\n      Foo.prototype.b = [3, 4];\n\n      var actual = func(new Foo, identity);\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(2);\n\n      var array = [[1, 2], [3, 4]],\n          object = { 'a': [1, 2], 'b': [3, 4] },\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([1, 2, 3, 4]));\n\n      lodashStable.each([array, object], function(collection) {\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? func(collection, value) : func(collection);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should accept a falsey `collection`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubArray);\n\n      var actual = lodashStable.map(falsey, function(collection, index) {\n        try {\n          return index ? func(collection) : func();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat number values for `collection` as empty', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(1), []);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with objects with non-number length properties', function(assert) {\n      assert.expect(1);\n\n      var object = { 'length': [1, 2] };\n      assert.deepEqual(func(object, identity), [1, 2]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.flattenDepth');\n\n  (function() {\n    var array = [1, [2, [3, [4]], 5]];\n\n    QUnit.test('should use a default `depth` of `1`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.flattenDepth(array), [1, 2, [3, [4]], 5]);\n    });\n\n    QUnit.test('should treat a `depth` of < `1` as a shallow clone', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([-1, 0], function(depth) {\n        assert.deepEqual(_.flattenDepth(array, depth), [1, [2, [3, [4]], 5]]);\n      });\n    });\n\n    QUnit.test('should coerce `depth` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.flattenDepth(array, 2.2), [1, 2, 3, [4], 5]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('flatten methods');\n\n  (function() {\n    var array = [1, [2, [3, [4]], 5]],\n        methodNames = ['flatten', 'flattenDeep', 'flattenDepth'];\n\n    QUnit.test('should flatten `arguments` objects', function(assert) {\n      assert.expect(3);\n\n      var array = [args, [args]];\n\n      assert.deepEqual(_.flatten(array), [1, 2, 3, args]);\n      assert.deepEqual(_.flattenDeep(array), [1, 2, 3, 1, 2, 3]);\n      assert.deepEqual(_.flattenDepth(array, 2), [1, 2, 3, 1, 2, 3]);\n    });\n\n    QUnit.test('should treat sparse arrays as dense', function(assert) {\n      assert.expect(6);\n\n      var array = [[1, 2, 3], Array(3)],\n          expected = [1, 2, 3];\n\n      expected.push(undefined, undefined, undefined);\n\n      lodashStable.each(methodNames, function(methodName) {\n        var actual = _[methodName](array);\n        assert.deepEqual(actual, expected);\n        assert.ok('4' in actual);\n      });\n    });\n\n    QUnit.test('should flatten objects with a truthy `Symbol.isConcatSpreadable` value', function(assert) {\n      assert.expect(1);\n\n      if (Symbol && Symbol.isConcatSpreadable) {\n        var object = { '0': 'a', 'length': 1 },\n            array = [object],\n            expected = lodashStable.map(methodNames, lodashStable.constant(['a']));\n\n        object[Symbol.isConcatSpreadable] = true;\n\n        var actual = lodashStable.map(methodNames, function(methodName) {\n          return _[methodName](array);\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work with extremely large arrays', function(assert) {\n      assert.expect(3);\n\n      lodashStable.times(3, function(index) {\n        var expected = Array(5e5);\n        try {\n          var func = _.flatten;\n          if (index == 1) {\n            func = _.flattenDeep;\n          } else if (index == 2) {\n            func = _.flattenDepth;\n          }\n          assert.deepEqual(func([expected]), expected);\n        } catch (e) {\n          assert.ok(false, e.message);\n        }\n      });\n    });\n\n    QUnit.test('should work with empty arrays', function(assert) {\n      assert.expect(3);\n\n      var array = [[], [[]], [[], [[[]]]]];\n\n      assert.deepEqual(_.flatten(array), [[], [], [[[]]]]);\n      assert.deepEqual(_.flattenDeep(array), []);\n      assert.deepEqual(_.flattenDepth(array, 2), [[[]]]);\n    });\n\n    QUnit.test('should support flattening of nested arrays', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(_.flatten(array), [1, 2, [3, [4]], 5]);\n      assert.deepEqual(_.flattenDeep(array), [1, 2, 3, 4, 5]);\n      assert.deepEqual(_.flattenDepth(array, 2), [1, 2, 3, [4], 5]);\n    });\n\n    QUnit.test('should return an empty array for non array-like objects', function(assert) {\n      assert.expect(3);\n\n      var expected = [],\n          nonArray = { '0': 'a' };\n\n      assert.deepEqual(_.flatten(nonArray), expected);\n      assert.deepEqual(_.flattenDeep(nonArray), expected);\n      assert.deepEqual(_.flattenDepth(nonArray, 2), expected);\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var wrapped = _(array),\n            actual = wrapped.flatten();\n\n        assert.ok(actual instanceof _);\n        assert.deepEqual(actual.value(), [1, 2, [3, [4]], 5]);\n\n        actual = wrapped.flattenDeep();\n\n        assert.ok(actual instanceof _);\n        assert.deepEqual(actual.value(), [1, 2, 3, 4, 5]);\n\n        actual = wrapped.flattenDepth(2);\n\n        assert.ok(actual instanceof _);\n        assert.deepEqual(actual.value(), [1, 2, 3, [4], 5]);\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('flow methods');\n\n  lodashStable.each(['flow', 'flowRight'], function(methodName) {\n    var func = _[methodName],\n        isFlow = methodName == 'flow';\n\n    QUnit.test('`_.' + methodName + '` should supply each function with the return value of the previous', function(assert) {\n      assert.expect(1);\n\n      var fixed = function(n) { return n.toFixed(1); },\n          combined = isFlow ? func(add, square, fixed) : func(fixed, square, add);\n\n      assert.strictEqual(combined(1, 2), '9.0');\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a new function', function(assert) {\n      assert.expect(1);\n\n      assert.notStrictEqual(func(noop), noop);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an identity function when no arguments are given', function(assert) {\n      assert.expect(6);\n\n      _.times(2, function(index) {\n        try {\n          var combined = index ? func([]) : func();\n          assert.strictEqual(combined('a'), 'a');\n        } catch (e) {\n          assert.ok(false, e.message);\n        }\n        assert.strictEqual(combined.length, 0);\n        assert.notStrictEqual(combined, identity);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a curried function and `_.head`', function(assert) {\n      assert.expect(1);\n\n      var curried = _.curry(identity);\n\n      var combined = isFlow\n        ? func(_.head, curried)\n        : func(curried, _.head);\n\n      assert.strictEqual(combined([1]), 1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support shortcut fusion', function(assert) {\n      assert.expect(6);\n\n      var filterCount,\n          mapCount,\n          array = lodashStable.range(LARGE_ARRAY_SIZE),\n          iteratee = function(value) { mapCount++; return square(value); },\n          predicate = function(value) { filterCount++; return isEven(value); };\n\n      lodashStable.times(2, function(index) {\n        var filter1 = _.filter,\n            filter2 = _.curry(_.rearg(_.ary(_.filter, 2), 1, 0), 2),\n            filter3 = (_.filter = index ? filter2 : filter1, filter2(predicate));\n\n        var map1 = _.map,\n            map2 = _.curry(_.rearg(_.ary(_.map, 2), 1, 0), 2),\n            map3 = (_.map = index ? map2 : map1, map2(iteratee));\n\n        var take1 = _.take,\n            take2 = _.curry(_.rearg(_.ary(_.take, 2), 1, 0), 2),\n            take3 = (_.take = index ? take2 : take1, take2(2));\n\n        var combined = isFlow\n          ? func(map3, filter3, _.compact, take3)\n          : func(take3, _.compact, filter3, map3);\n\n        filterCount = mapCount = 0;\n        assert.deepEqual(combined(array), [4, 16]);\n\n        if (!isNpm && WeakMap && WeakMap.name) {\n          assert.strictEqual(filterCount, 5, 'filterCount');\n          assert.strictEqual(mapCount, 5, 'mapCount');\n        }\n        else {\n          skipAssert(assert, 2);\n        }\n        _.filter = filter1;\n        _.map = map1;\n        _.take = take1;\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with curried functions with placeholders', function(assert) {\n      assert.expect(1);\n\n      var curried = _.curry(_.ary(_.map, 2), 2),\n          getProp = curried(curried.placeholder, 'a'),\n          objects = [{ 'a': 1 }, { 'a': 2 }, { 'a': 1 }];\n\n      var combined = isFlow\n        ? func(getProp, _.uniq)\n        : func(_.uniq, getProp);\n\n      assert.deepEqual(combined(objects), [1, 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _(noop)[methodName]();\n        assert.ok(wrapped instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.forEach');\n\n  (function() {\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.each, _.forEach);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.forEachRight');\n\n  (function() {\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.eachRight, _.forEachRight);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('forIn methods');\n\n  lodashStable.each(['forIn', 'forInRight'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` iterates over inherited string keyed properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var keys = [];\n      func(new Foo, function(value, key) { keys.push(key); });\n      assert.deepEqual(keys.sort(), ['a', 'b']);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('forOwn methods');\n\n  lodashStable.each(['forOwn', 'forOwnRight'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should iterate over `length` properties', function(assert) {\n      assert.expect(1);\n\n      var object = { '0': 'zero', '1': 'one', 'length': 2 },\n          props = [];\n\n      func(object, function(value, prop) { props.push(prop); });\n      assert.deepEqual(props.sort(), ['0', '1', 'length']);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('iteration methods');\n\n  (function() {\n    var methods = [\n      '_baseEach',\n      'countBy',\n      'every',\n      'filter',\n      'find',\n      'findIndex',\n      'findKey',\n      'findLast',\n      'findLastIndex',\n      'findLastKey',\n      'forEach',\n      'forEachRight',\n      'forIn',\n      'forInRight',\n      'forOwn',\n      'forOwnRight',\n      'groupBy',\n      'keyBy',\n      'map',\n      'mapKeys',\n      'mapValues',\n      'maxBy',\n      'minBy',\n      'omitBy',\n      'partition',\n      'pickBy',\n      'reject',\n      'some'\n    ];\n\n    var arrayMethods = [\n      'findIndex',\n      'findLastIndex',\n      'maxBy',\n      'minBy'\n    ];\n\n    var collectionMethods = [\n      '_baseEach',\n      'countBy',\n      'every',\n      'filter',\n      'find',\n      'findLast',\n      'forEach',\n      'forEachRight',\n      'groupBy',\n      'keyBy',\n      'map',\n      'partition',\n      'reduce',\n      'reduceRight',\n      'reject',\n      'some'\n    ];\n\n    var forInMethods = [\n      'forIn',\n      'forInRight',\n      'omitBy',\n      'pickBy'\n    ];\n\n    var iterationMethods = [\n      '_baseEach',\n      'forEach',\n      'forEachRight',\n      'forIn',\n      'forInRight',\n      'forOwn',\n      'forOwnRight'\n    ];\n\n    var objectMethods = [\n      'findKey',\n      'findLastKey',\n      'forIn',\n      'forInRight',\n      'forOwn',\n      'forOwnRight',\n      'mapKeys',\n      'mapValues',\n      'omitBy',\n      'pickBy'\n    ];\n\n    var rightMethods = [\n      'findLast',\n      'findLastIndex',\n      'findLastKey',\n      'forEachRight',\n      'forInRight',\n      'forOwnRight'\n    ];\n\n    var unwrappedMethods = [\n      'each',\n      'eachRight',\n      'every',\n      'find',\n      'findIndex',\n      'findKey',\n      'findLast',\n      'findLastIndex',\n      'findLastKey',\n      'forEach',\n      'forEachRight',\n      'forIn',\n      'forInRight',\n      'forOwn',\n      'forOwnRight',\n      'max',\n      'maxBy',\n      'min',\n      'minBy',\n      'some'\n    ];\n\n    lodashStable.each(methods, function(methodName) {\n      var array = [1, 2, 3],\n          func = _[methodName],\n          isBy = /(^partition|By)$/.test(methodName),\n          isFind = /^find/.test(methodName),\n          isOmitPick = /^(?:omit|pick)By$/.test(methodName),\n          isSome = methodName == 'some';\n\n      QUnit.test('`_.' + methodName + '` should provide correct iteratee arguments', function(assert) {\n        assert.expect(1);\n\n        if (func) {\n          var args,\n              expected = [1, 0, array];\n\n          func(array, function() {\n            args || (args = slice.call(arguments));\n          });\n\n          if (lodashStable.includes(rightMethods, methodName)) {\n            expected[0] = 3;\n            expected[1] = 2;\n          }\n          if (lodashStable.includes(objectMethods, methodName)) {\n            expected[1] += '';\n          }\n          if (isBy) {\n            expected.length = isOmitPick ? 2 : 1;\n          }\n          assert.deepEqual(args, expected);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should treat sparse arrays as dense', function(assert) {\n        assert.expect(1);\n\n        if (func) {\n          var array = [1];\n          array[2] = 3;\n\n          var expected = lodashStable.includes(objectMethods, methodName)\n            ? [[1, '0', array], [undefined, '1', array], [3, '2', array]]\n            : [[1,  0, array],  [undefined,  1,  array], [3,  2,  array]];\n\n          if (isBy) {\n            expected = lodashStable.map(expected, function(args) {\n              return args.slice(0, isOmitPick ? 2 : 1);\n            });\n          }\n          else if (lodashStable.includes(objectMethods, methodName)) {\n            expected = lodashStable.map(expected, function(args) {\n              args[1] += '';\n              return args;\n            });\n          }\n          if (lodashStable.includes(rightMethods, methodName)) {\n            expected.reverse();\n          }\n          var argsList = [];\n          func(array, function() {\n            argsList.push(slice.call(arguments));\n            return !(isFind || isSome);\n          });\n\n          assert.deepEqual(argsList, expected);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each(lodashStable.difference(methods, objectMethods), function(methodName) {\n      var array = [1, 2, 3],\n          func = _[methodName],\n          isEvery = methodName == 'every';\n\n      array.a = 1;\n\n      QUnit.test('`_.' + methodName + '` should not iterate custom properties on arrays', function(assert) {\n        assert.expect(1);\n\n        if (func) {\n          var keys = [];\n          func(array, function(value, key) {\n            keys.push(key);\n            return isEvery;\n          });\n\n          assert.notOk(lodashStable.includes(keys, 'a'));\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each(lodashStable.difference(methods, unwrappedMethods), function(methodName) {\n      var array = [1, 2, 3],\n          isBaseEach = methodName == '_baseEach';\n\n      QUnit.test('`_.' + methodName + '` should return a wrapped value when implicitly chaining', function(assert) {\n        assert.expect(1);\n\n        if (!(isBaseEach || isNpm)) {\n          var wrapped = _(array)[methodName](noop);\n          assert.ok(wrapped instanceof _);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each(unwrappedMethods, function(methodName) {\n      var array = [1, 2, 3];\n\n      QUnit.test('`_.' + methodName + '` should return an unwrapped value when implicitly chaining', function(assert) {\n        assert.expect(1);\n\n        if (!isNpm) {\n          var actual = _(array)[methodName](noop);\n          assert.notOk(actual instanceof _);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n\n      QUnit.test('`_.' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n        assert.expect(2);\n\n        if (!isNpm) {\n          var wrapped = _(array).chain(),\n              actual = wrapped[methodName](noop);\n\n          assert.ok(actual instanceof _);\n          assert.notStrictEqual(actual, wrapped);\n        }\n        else {\n          skipAssert(assert, 2);\n        }\n      });\n    });\n\n    lodashStable.each(lodashStable.difference(methods, arrayMethods, forInMethods), function(methodName) {\n      var func = _[methodName];\n\n      QUnit.test('`_.' + methodName + '` iterates over own string keyed properties of objects', function(assert) {\n        assert.expect(1);\n\n        function Foo() {\n          this.a = 1;\n        }\n        Foo.prototype.b = 2;\n\n        if (func) {\n          var values = [];\n          func(new Foo, function(value) { values.push(value); });\n          assert.deepEqual(values, [1]);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each(iterationMethods, function(methodName) {\n      var array = [1, 2, 3],\n          func = _[methodName];\n\n      QUnit.test('`_.' + methodName + '` should return the collection', function(assert) {\n        assert.expect(1);\n\n        if (func) {\n          assert.strictEqual(func(array, Boolean), array);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each(collectionMethods, function(methodName) {\n      var func = _[methodName];\n\n      QUnit.test('`_.' + methodName + '` should use `isArrayLike` to determine whether a value is array-like', function(assert) {\n        assert.expect(3);\n\n        if (func) {\n          var isIteratedAsObject = function(object) {\n            var result = false;\n            func(object, function() { result = true; }, 0);\n            return result;\n          };\n\n          var values = [-1, '1', 1.1, Object(1), MAX_SAFE_INTEGER + 1],\n              expected = lodashStable.map(values, stubTrue);\n\n          var actual = lodashStable.map(values, function(length) {\n            return isIteratedAsObject({ 'length': length });\n          });\n\n          var Foo = function(a) {};\n          Foo.a = 1;\n\n          assert.deepEqual(actual, expected);\n          assert.ok(isIteratedAsObject(Foo));\n          assert.notOk(isIteratedAsObject({ 'length': 0 }));\n        }\n        else {\n          skipAssert(assert, 3);\n        }\n      });\n    });\n\n    lodashStable.each(methods, function(methodName) {\n      var func = _[methodName],\n          isFind = /^find/.test(methodName),\n          isSome = methodName == 'some',\n          isReduce = /^reduce/.test(methodName);\n\n      QUnit.test('`_.' + methodName + '` should ignore changes to `length`', function(assert) {\n        assert.expect(1);\n\n        if (func) {\n          var count = 0,\n              array = [1];\n\n          func(array, function() {\n            if (++count == 1) {\n              array.push(2);\n            }\n            return !(isFind || isSome);\n          }, isReduce ? array : null);\n\n          assert.strictEqual(count, 1);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each(lodashStable.difference(lodashStable.union(methods, collectionMethods), arrayMethods), function(methodName) {\n      var func = _[methodName],\n          isFind = /^find/.test(methodName),\n          isSome = methodName == 'some',\n          isReduce = /^reduce/.test(methodName);\n\n      QUnit.test('`_.' + methodName + '` should ignore added `object` properties', function(assert) {\n        assert.expect(1);\n\n        if (func) {\n          var count = 0,\n              object = { 'a': 1 };\n\n          func(object, function() {\n            if (++count == 1) {\n              object.b = 2;\n            }\n            return !(isFind || isSome);\n          }, isReduce ? object : null);\n\n          assert.strictEqual(count, 1);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('object assignments');\n\n  lodashStable.each(['assign', 'assignIn', 'defaults', 'defaultsDeep', 'merge'], function(methodName) {\n    var func = _[methodName],\n        isAssign = methodName == 'assign',\n        isDefaults = /^defaults/.test(methodName);\n\n    QUnit.test('`_.' + methodName + '` should coerce primitives to objects', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(primitives, function(value) {\n        var object = Object(value);\n        object.a = 1;\n        return object;\n      });\n\n      var actual = lodashStable.map(primitives, function(value) {\n        return func(value, { 'a': 1 });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should assign own ' + (isAssign ? '' : 'and inherited ') + 'string keyed source properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var expected = isAssign ? { 'a': 1 } : { 'a': 1, 'b': 2 };\n      assert.deepEqual(func({}, new Foo), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not skip a trailing function source', function(assert) {\n      assert.expect(1);\n\n      function fn() {}\n      fn.b = 2;\n\n      assert.deepEqual(func({}, { 'a': 1 }, fn), { 'a': 1, 'b': 2 });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not error on nullish sources', function(assert) {\n      assert.expect(1);\n\n      try {\n        assert.deepEqual(func({ 'a': 1 }, undefined, { 'b': 2 }, null), { 'a': 1, 'b': 2 });\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should create an object when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var source = { 'a': 1 },\n          values = [null, undefined],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        var object = func(value, source);\n        return object !== source && lodashStable.isEqual(object, source);\n      });\n\n      assert.deepEqual(actual, expected);\n\n      actual = lodashStable.map(values, function(value) {\n        return lodashStable.isEqual(func(value), {});\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work as an iteratee for methods like `_.reduce`', function(assert) {\n      assert.expect(2);\n\n      var array = [{ 'a': 1 }, { 'b': 2 }, { 'c': 3 }],\n          expected = { 'a': isDefaults ? 0 : 1, 'b': 2, 'c': 3 };\n\n      function fn() {};\n      fn.a = array[0];\n      fn.b = array[1];\n      fn.c = array[2];\n\n      assert.deepEqual(lodashStable.reduce(array, func, { 'a': 0 }), expected);\n      assert.deepEqual(lodashStable.reduce(fn, func, { 'a': 0 }), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not return the existing wrapped value when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _({ 'a': 1 }),\n            actual = wrapped[methodName]({ 'b': 2 });\n\n        assert.notStrictEqual(actual, wrapped);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  lodashStable.each(['assign', 'assignIn', 'merge'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should not treat `object` as `source`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype.a = 1;\n\n      var actual = func(new Foo, { 'b': 2 });\n      assert.notOk(_.has(actual, 'a'));\n    });\n  });\n\n  lodashStable.each(['assign', 'assignIn', 'assignInWith', 'assignWith', 'defaults', 'defaultsDeep', 'merge', 'mergeWith'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should not assign values that are the same as their destinations', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a', ['a'], { 'a': 1 }, NaN], function(value) {\n        var object = {},\n            pass = true;\n\n        defineProperty(object, 'a', {\n          'configurable': true,\n          'enumerable': true,\n          'get': lodashStable.constant(value),\n          'set': function() { pass = false; }\n        });\n\n        func(object, { 'a': value });\n        assert.ok(pass);\n      });\n    });\n  });\n\n  lodashStable.each(['assignWith', 'assignInWith', 'mergeWith'], function(methodName) {\n    var func = _[methodName],\n        isMergeWith = methodName == 'mergeWith';\n\n    QUnit.test('`_.' + methodName + '` should provide correct `customizer` arguments', function(assert) {\n      assert.expect(3);\n\n      var args,\n          object = { 'a': 1 },\n          source = { 'a': 2 },\n          expected = lodashStable.map([1, 2, 'a', object, source], lodashStable.cloneDeep);\n\n      func(object, source, function() {\n        args || (args = lodashStable.map(slice.call(arguments, 0, 5), lodashStable.cloneDeep));\n      });\n\n      assert.deepEqual(args, expected, 'primitive values');\n\n      var argsList = [],\n          objectValue = [1, 2],\n          sourceValue = { 'b': 2 };\n\n      object = { 'a': objectValue };\n      source = { 'a': sourceValue };\n      expected = [lodashStable.map([objectValue, sourceValue, 'a', object, source], lodashStable.cloneDeep)];\n\n      if (isMergeWith) {\n        expected.push(lodashStable.map([undefined, 2, 'b', objectValue, sourceValue], lodashStable.cloneDeep));\n      }\n      func(object, source, function() {\n        argsList.push(lodashStable.map(slice.call(arguments, 0, 5), lodashStable.cloneDeep));\n      });\n\n      assert.deepEqual(argsList, expected, 'object values');\n\n      args = undefined;\n      object = { 'a': 1 };\n      source = { 'b': 2 };\n      expected = lodashStable.map([undefined, 2, 'b', object, source], lodashStable.cloneDeep);\n\n      func(object, source, function() {\n        args || (args = lodashStable.map(slice.call(arguments, 0, 5), lodashStable.cloneDeep));\n      });\n\n      assert.deepEqual(args, expected, 'undefined properties');\n    });\n\n    QUnit.test('`_.' + methodName + '` should not treat the second argument as a `customizer` callback', function(assert) {\n      assert.expect(2);\n\n      function callback() {}\n      callback.b = 2;\n\n      var actual = func({ 'a': 1 }, callback);\n      assert.deepEqual(actual, { 'a': 1, 'b': 2 });\n\n      actual = func({ 'a': 1 }, callback, { 'c': 3 });\n      assert.deepEqual(actual, { 'a': 1, 'b': 2, 'c': 3 });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('exit early');\n\n  lodashStable.each(['_baseEach', 'forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'transform'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` can exit early when iterating arrays', function(assert) {\n      assert.expect(1);\n\n      if (func) {\n        var array = [1, 2, 3],\n            values = [];\n\n        func(array, function(value, other) {\n          values.push(lodashStable.isArray(value) ? other : value);\n          return false;\n        });\n\n        assert.deepEqual(values, [lodashStable.endsWith(methodName, 'Right') ? 3 : 1]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` can exit early when iterating objects', function(assert) {\n      assert.expect(1);\n\n      if (func) {\n        var object = { 'a': 1, 'b': 2, 'c': 3 },\n            values = [];\n\n        func(object, function(value, other) {\n          values.push(lodashStable.isArray(value) ? other : value);\n          return false;\n        });\n\n        assert.strictEqual(values.length, 1);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('`__proto__` property bugs');\n\n  (function() {\n    QUnit.test('should work with the \"__proto__\" key in internal data objects', function(assert) {\n      assert.expect(4);\n\n      var stringLiteral = '__proto__',\n          stringObject = Object(stringLiteral),\n          expected = [stringLiteral, stringObject];\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, function(count) {\n        return isEven(count) ? stringLiteral : stringObject;\n      });\n\n      assert.deepEqual(_.difference(largeArray, largeArray), []);\n      assert.deepEqual(_.intersection(largeArray, largeArray), expected);\n      assert.deepEqual(_.uniq(largeArray), expected);\n      assert.deepEqual(_.without.apply(_, [largeArray].concat(largeArray)), []);\n    });\n\n    QUnit.test('should treat \"__proto__\" as a regular key in assignments', function(assert) {\n      assert.expect(2);\n\n      var methods = [\n        'assign',\n        'assignIn',\n        'defaults',\n        'defaultsDeep',\n        'merge'\n      ];\n\n      var source = create(null);\n      source.__proto__ = [];\n\n      var expected = lodashStable.map(methods, stubFalse);\n\n      var actual = lodashStable.map(methods, function(methodName) {\n        var result = _[methodName]({}, source);\n        return result instanceof Array;\n      });\n\n      assert.deepEqual(actual, expected);\n\n      actual = _.groupBy([{ 'a': '__proto__' }], 'a');\n      assert.notOk(actual instanceof Array);\n    });\n\n    QUnit.test('should not merge \"__proto__\" properties', function(assert) {\n      assert.expect(1);\n\n      if (JSON) {\n        _.merge({}, JSON.parse('{\"__proto__\":{\"a\":1}}'));\n\n        var actual = 'a' in objectProto;\n        delete objectProto.a;\n\n        assert.notOk(actual);\n      } else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should not indirectly merge builtin prototype properties', function(assert) {\n      assert.expect(2);\n\n      _.merge({}, { 'toString': { 'constructor': { 'prototype': { 'a': 1 } } } });\n\n      var actual = 'a' in funcProto;\n      delete funcProto.a;\n\n      assert.notOk(actual);\n\n      _.merge({}, { 'constructor': { 'prototype': { 'a': 1 } } });\n\n      actual = 'a' in objectProto;\n      delete objectProto.a;\n\n      assert.notOk(actual);\n    });\n\n    QUnit.test('should not indirectly merge `Object` properties', function(assert) {\n      assert.expect(1);\n\n      _.merge({}, { 'constructor': { 'a': 1 } });\n\n      var actual = 'a' in Object;\n      delete Object.a;\n\n      assert.notOk(actual);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.fromPairs');\n\n  (function() {\n    QUnit.test('should accept a two dimensional array', function(assert) {\n      assert.expect(1);\n\n      var array = [['a', 1], ['b', 2]],\n          object = { 'a': 1, 'b': 2 },\n          actual = _.fromPairs(array);\n\n      assert.deepEqual(actual, object);\n    });\n\n    QUnit.test('should accept a falsey `array`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubObject);\n\n      var actual = lodashStable.map(falsey, function(array, index) {\n        try {\n          return index ? _.fromPairs(array) : _.fromPairs();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not support deep paths', function(assert) {\n      assert.expect(1);\n\n      var actual = _.fromPairs([['a.b', 1]]);\n      assert.deepEqual(actual, { 'a.b': 1 });\n    });\n\n    QUnit.test('should support consuming the return value of `_.toPairs`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a.b': 1 };\n      assert.deepEqual(_.fromPairs(_.toPairs(object)), object);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.times(LARGE_ARRAY_SIZE, function(index) {\n          return ['key' + index, index];\n        });\n\n        var actual = _(array).fromPairs().map(square).filter(isEven).take().value();\n\n        assert.deepEqual(actual, _.take(_.filter(_.map(_.fromPairs(array), square), isEven)));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.functions');\n\n  (function() {\n    QUnit.test('should return the function names of an object', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 'a', 'b': identity, 'c': /x/, 'd': noop },\n          actual = _.functions(object).sort();\n\n      assert.deepEqual(actual, ['b', 'd']);\n    });\n\n    QUnit.test('should not include inherited functions', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = identity;\n        this.b = 'b';\n      }\n      Foo.prototype.c = noop;\n\n      assert.deepEqual(_.functions(new Foo), ['a']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.groupBy');\n\n  (function() {\n    var array = [6.1, 4.2, 6.3];\n\n    QUnit.test('should transform keys by `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.groupBy(array, Math.floor);\n      assert.deepEqual(actual, { '4': [4.2], '6': [6.1, 6.3] });\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var array = [6, 4, 6],\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant({ '4': [4], '6':  [6, 6] }));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.groupBy(array, value) : _.groupBy(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var actual = _.groupBy(['one', 'two', 'three'], 'length');\n      assert.deepEqual(actual, { '3': ['one', 'two'], '5': ['three'] });\n    });\n\n    QUnit.test('should only add values to own, not inherited, properties', function(assert) {\n      assert.expect(2);\n\n      var actual = _.groupBy(array, function(n) {\n        return Math.floor(n) > 4 ? 'hasOwnProperty' : 'constructor';\n      });\n\n      assert.deepEqual(actual.constructor, [4.2]);\n      assert.deepEqual(actual.hasOwnProperty, [6.1, 6.3]);\n    });\n\n    QUnit.test('should work with a number for `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var array = [\n        [1, 'a'],\n        [2, 'a'],\n        [2, 'b']\n      ];\n\n      assert.deepEqual(_.groupBy(array, 0), { '1': [[1, 'a']], '2': [[2, 'a'], [2, 'b']] });\n      assert.deepEqual(_.groupBy(array, 1), { 'a': [[1, 'a'], [2, 'a']], 'b': [[2, 'b']] });\n    });\n\n    QUnit.test('should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.groupBy({ 'a': 6.1, 'b': 4.2, 'c': 6.3 }, Math.floor);\n      assert.deepEqual(actual, { '4': [4.2], '6': [6.1, 6.3] });\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE).concat(\n          lodashStable.range(Math.floor(LARGE_ARRAY_SIZE / 2), LARGE_ARRAY_SIZE),\n          lodashStable.range(Math.floor(LARGE_ARRAY_SIZE / 1.5), LARGE_ARRAY_SIZE)\n        );\n\n        var iteratee = function(value) { value.push(value[0]); return value; },\n            predicate = function(value) { return isEven(value[0]); },\n            actual = _(array).groupBy().map(iteratee).filter(predicate).take().value();\n\n        assert.deepEqual(actual, _.take(_.filter(lodashStable.map(_.groupBy(array), iteratee), predicate)));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.gt');\n\n  (function() {\n    QUnit.test('should return `true` if `value` > `other`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.gt(3, 1), true);\n      assert.strictEqual(_.gt('def', 'abc'), true);\n    });\n\n    QUnit.test('should return `false` if `value` is <= `other`', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.gt(1, 3), false);\n      assert.strictEqual(_.gt(3, 3), false);\n      assert.strictEqual(_.gt('abc', 'def'), false);\n      assert.strictEqual(_.gt('def', 'def'), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.gte');\n\n  (function() {\n    QUnit.test('should return `true` if `value` >= `other`', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.gte(3, 1), true);\n      assert.strictEqual(_.gte(3, 3), true);\n      assert.strictEqual(_.gte('def', 'abc'), true);\n      assert.strictEqual(_.gte('def', 'def'), true);\n    });\n\n    QUnit.test('should return `false` if `value` is less than `other`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.gte(1, 3), false);\n      assert.strictEqual(_.gte('abc', 'def'), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('has methods');\n\n  lodashStable.each(['has', 'hasIn'], function(methodName) {\n    var func = _[methodName],\n        isHas = methodName == 'has',\n        sparseArgs = toArgs([1]),\n        sparseArray = Array(1),\n        sparseString = Object('a');\n\n    delete sparseArgs[0];\n    delete sparseString[0];\n\n    QUnit.test('`_.' + methodName + '` should check for own properties', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1 };\n\n      lodashStable.each(['a', ['a']], function(path) {\n        assert.strictEqual(func(object, path), true);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not use the `hasOwnProperty` method of `object`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'hasOwnProperty': null, 'a': 1 };\n      assert.strictEqual(func(object, 'a'), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support deep paths', function(assert) {\n      assert.expect(4);\n\n      var object = { 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(func(object, path), true);\n      });\n\n      lodashStable.each(['a.a', ['a', 'a']], function(path) {\n        assert.strictEqual(func(object, path), false);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `path` to a string', function(assert) {\n      assert.expect(2);\n\n      function fn() {}\n      fn.toString = lodashStable.constant('fn');\n\n      var object = { 'null': 1 , 'undefined': 2, 'fn': 3, '[object Object]': 4 },\n          paths = [null, undefined, fn, {}],\n          expected = lodashStable.map(paths, stubTrue);\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(paths, function(path) {\n          return func(object, index ? [path] : path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(args, 1), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a non-string `path`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3];\n\n      lodashStable.each([1, [1]], function(path) {\n        assert.strictEqual(func(array, path), true);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': 'a', '0': 'b' },\n          props = [-0, Object(-0), 0, Object(0)],\n          expected = lodashStable.map(props, stubTrue);\n\n      var actual = lodashStable.map(props, function(key) {\n        return func(object, key);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a symbol `path`', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n\n      if (Symbol) {\n        Foo.prototype[symbol] = 1;\n\n        var symbol2 = Symbol('b');\n        defineProperty(Foo.prototype, symbol2, {\n          'configurable': true,\n          'enumerable': false,\n          'writable': true,\n          'value': 2\n        });\n\n        var object = isHas ? Foo.prototype : new Foo;\n        assert.strictEqual(func(object, symbol), true);\n        assert.strictEqual(func(object, symbol2), true);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should check for a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1 };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        assert.strictEqual(func(object, path), true);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` for indexes of sparse values', function(assert) {\n      assert.expect(1);\n\n      var values = [sparseArgs, sparseArray, sparseString],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(value, 0);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` for indexes of sparse values with deep paths', function(assert) {\n      assert.expect(1);\n\n      var values = [sparseArgs, sparseArray, sparseString],\n          expected = lodashStable.map(values, lodashStable.constant([true, true]));\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.map(['a[0]', ['a', '0']], function(path) {\n          return func({ 'a': value }, path);\n        });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `' + (isHas ? 'false' : 'true') + '` for inherited properties', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.a = 1;\n\n      lodashStable.each(['a', ['a']], function(path) {\n        assert.strictEqual(func(new Foo, path), !isHas);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `' + (isHas ? 'false' : 'true') + '` for nested inherited properties', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.a = { 'b': 1 };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(func(new Foo, path), !isHas);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `false` when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        var actual = lodashStable.map(values, function(value) {\n          return func(value, path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `false` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      lodashStable.each(['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']], function(path) {\n        var actual = lodashStable.map(values, function(value) {\n          return func(value, path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `false` for nullish values of nested objects', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var actual = lodashStable.map(values, function(value, index) {\n          var object = index ? { 'a': value } : {};\n          return func(object, path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `false` over sparse values of deep paths', function(assert) {\n      assert.expect(1);\n\n      var values = [sparseArgs, sparseArray, sparseString],\n          expected = lodashStable.map(values, lodashStable.constant([false, false]));\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.map(['a[0].b', ['a', '0', 'b']], function(path) {\n          return func({ 'a': value }, path);\n        });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.head');\n\n  (function() {\n    var array = [1, 2, 3, 4];\n\n    QUnit.test('should return the first element', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.head(array), 1);\n    });\n\n    QUnit.test('should return `undefined` when querying empty arrays', function(assert) {\n      assert.expect(1);\n\n      arrayProto[0] = 1;\n      assert.strictEqual(_.head([]), undefined);\n      arrayProto.length = 0;\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.head);\n\n      assert.deepEqual(actual, [1, 4, 7]);\n    });\n\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.first, _.head);\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(array);\n        assert.strictEqual(wrapped.head(), 1);\n        assert.strictEqual(wrapped.first(), 1);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(array).chain();\n        assert.ok(wrapped.head() instanceof _);\n        assert.ok(wrapped.first() instanceof _);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should not execute immediately when explicitly chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(array).chain();\n        assert.strictEqual(wrapped.head().__wrapped__, array);\n        assert.strictEqual(wrapped.first().__wrapped__, array);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var largeArray = lodashStable.range(LARGE_ARRAY_SIZE),\n            smallArray = array;\n\n        lodashStable.each(['head', 'first'], function(methodName) {\n          lodashStable.times(2, function(index) {\n            var array = index ? largeArray : smallArray,\n                actual = _(array).filter(isEven)[methodName]();\n\n            assert.strictEqual(actual, _[methodName](_.filter(array, isEven)));\n          });\n        });\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.identity');\n\n  (function() {\n    QUnit.test('should return the first argument given', function(assert) {\n      assert.expect(1);\n\n      var object = { 'name': 'fred' };\n      assert.strictEqual(_.identity(object), object);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.includes');\n\n  (function() {\n    lodashStable.each({\n      'an `arguments` object': arguments,\n      'an array': [1, 2, 3, 4],\n      'an object': { 'a': 1, 'b': 2, 'c': 3, 'd': 4 },\n      'a string': '1234'\n    },\n    function(collection, key) {\n      QUnit.test('should work with ' + key + ' and  return `true` for  matched values', function(assert) {\n        assert.expect(1);\n\n        assert.strictEqual(_.includes(collection, 3), true);\n      });\n\n      QUnit.test('should work with ' + key + ' and  return `false` for unmatched values', function(assert) {\n        assert.expect(1);\n\n        assert.strictEqual(_.includes(collection, 5), false);\n      });\n\n      QUnit.test('should work with ' + key + ' and floor `position` values', function(assert) {\n        assert.expect(1);\n\n        assert.strictEqual(_.includes(collection, 2, 1.2), true);\n      });\n\n      QUnit.test('should work with ' + key + ' and return an unwrapped value implicitly when chaining', function(assert) {\n        assert.expect(1);\n\n        if (!isNpm) {\n          assert.strictEqual(_(collection).includes(3), true);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n\n      QUnit.test('should work with ' + key + ' and return a wrapped value when explicitly chaining', function(assert) {\n        assert.expect(1);\n\n        if (!isNpm) {\n          assert.ok(_(collection).chain().includes(3) instanceof _);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    lodashStable.each({\n      'literal': 'abc',\n      'object': Object('abc')\n    },\n    function(collection, key) {\n      QUnit.test('should work with a string ' + key + ' for `collection`', function(assert) {\n        assert.expect(2);\n\n        assert.strictEqual(_.includes(collection, 'bc'), true);\n        assert.strictEqual(_.includes(collection, 'd'), false);\n      });\n    });\n\n    QUnit.test('should return `false` for empty collections', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, stubFalse);\n\n      var actual = lodashStable.map(empties, function(value) {\n        try {\n          return _.includes(value);\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with a string and a `fromIndex` >= `length`', function(assert) {\n      assert.expect(1);\n\n      var string = '1234',\n          length = string.length,\n          indexes = [4, 6, Math.pow(2, 32), Infinity];\n\n      var expected = lodashStable.map(indexes, function(index) {\n        return [false, false, index == length];\n      });\n\n      var actual = lodashStable.map(indexes, function(fromIndex) {\n        return [\n          _.includes(string, 1, fromIndex),\n          _.includes(string, undefined, fromIndex),\n          _.includes(string, '', fromIndex)\n        ];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should match `NaN`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.includes([1, NaN, 3], NaN), true);\n    });\n\n    QUnit.test('should match `-0` as `0`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.includes([-0], 0), true);\n      assert.strictEqual(_.includes([0], -0), true);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.every`', function(assert) {\n      assert.expect(1);\n\n      var array = [2, 3, 1],\n          values = [1, 2, 3];\n\n      assert.ok(lodashStable.every(values, lodashStable.partial(_.includes, array)));\n    });\n  }(1, 2, 3, 4));\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.initial');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should accept a falsey `array`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubArray);\n\n      var actual = lodashStable.map(falsey, function(array, index) {\n        try {\n          return index ? _.initial(array) : _.initial();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should exclude last element', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.initial(array), [1, 2]);\n    });\n\n    QUnit.test('should return an empty when querying empty arrays', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.initial([]), []);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.initial);\n\n      assert.deepEqual(actual, [[1, 2], [4, 5], [7, 8]]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            values = [];\n\n        var actual = _(array).initial().filter(function(value) {\n          values.push(value);\n          return false;\n        })\n        .value();\n\n        assert.deepEqual(actual, []);\n        assert.deepEqual(values, _.initial(array));\n\n        values = [];\n\n        actual = _(array).filter(function(value) {\n          values.push(value);\n          return isEven(value);\n        })\n        .initial()\n        .value();\n\n        assert.deepEqual(actual, _.initial(lodashStable.filter(array, isEven)));\n        assert.deepEqual(values, array);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.inRange');\n\n  (function() {\n    QUnit.test('should work with an `end`', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.inRange(3, 5), true);\n      assert.strictEqual(_.inRange(5, 5), false);\n      assert.strictEqual(_.inRange(6, 5), false);\n    });\n\n    QUnit.test('should work with a `start` and `end`', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.inRange(1, 1, 5), true);\n      assert.strictEqual(_.inRange(3, 1, 5), true);\n      assert.strictEqual(_.inRange(0, 1, 5), false);\n      assert.strictEqual(_.inRange(5, 1, 5), false);\n    });\n\n    QUnit.test('should treat falsey `start` as `0`', function(assert) {\n      assert.expect(13);\n\n      lodashStable.each(falsey, function(value, index) {\n        if (index) {\n          assert.strictEqual(_.inRange(0, value), false);\n          assert.strictEqual(_.inRange(0, value, 1), true);\n        } else {\n          assert.strictEqual(_.inRange(0), false);\n        }\n      });\n    });\n\n    QUnit.test('should swap `start` and `end` when `start` > `end`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.inRange(2, 5, 1), true);\n      assert.strictEqual(_.inRange(-3, -2, -6), true);\n    });\n\n    QUnit.test('should work with a floating point `n` value', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.inRange(0.5, 5), true);\n      assert.strictEqual(_.inRange(1.2, 1, 5), true);\n      assert.strictEqual(_.inRange(5.2, 5), false);\n      assert.strictEqual(_.inRange(0.5, 1, 5), false);\n    });\n\n    QUnit.test('should coerce arguments to finite numbers', function(assert) {\n      assert.expect(1);\n\n      var actual = [\n        _.inRange(0, '1'),\n        _.inRange(0, '0', 1),\n        _.inRange(0, 0, '1'),\n        _.inRange(0, NaN, 1),\n        _.inRange(-1, -1, NaN)\n      ];\n\n      assert.deepEqual(actual, lodashStable.map(actual, stubTrue));\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('intersection methods');\n\n  lodashStable.each(['intersection', 'intersectionBy', 'intersectionWith'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return the intersection of two arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2, 1], [2, 3]);\n      assert.deepEqual(actual, [2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return the intersection of multiple arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2, 1, 2, 3], [3, 4], [3, 2]);\n      assert.deepEqual(actual, [3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an array of unique values', function(assert) {\n      assert.expect(1);\n\n      var actual = func([1, 1, 3, 2, 2], [5, 2, 2, 1, 4], [2, 1, 1]);\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a single array', function(assert) {\n      assert.expect(1);\n\n      var actual = func([1, 1, 3, 2, 2]);\n      assert.deepEqual(actual, [1, 3, 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `arguments` objects', function(assert) {\n      assert.expect(2);\n\n      var array = [0, 1, null, 3],\n          expected = [1, 3];\n\n      assert.deepEqual(func(array, args), expected);\n      assert.deepEqual(func(args, array), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat `-0` as `0`', function(assert) {\n      assert.expect(1);\n\n      var values = [-0, 0],\n          expected = lodashStable.map(values, lodashStable.constant(['0']));\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.map(func(values, [value]), lodashStable.toString);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `NaN`', function(assert) {\n      assert.expect(1);\n\n      var actual = func([1, NaN, 3], [NaN, 5, NaN]);\n      assert.deepEqual(actual, [NaN]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of `-0` as `0`', function(assert) {\n      assert.expect(1);\n\n      var values = [-0, 0],\n          expected = lodashStable.map(values, lodashStable.constant(['0']));\n\n      var actual = lodashStable.map(values, function(value) {\n        var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, lodashStable.constant(value));\n        return lodashStable.map(func(values, largeArray), lodashStable.toString);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of `NaN`', function(assert) {\n      assert.expect(1);\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, stubNaN);\n      assert.deepEqual(func([1, NaN, 3], largeArray), [NaN]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of objects', function(assert) {\n      assert.expect(2);\n\n      var object = {},\n          largeArray = lodashStable.times(LARGE_ARRAY_SIZE, lodashStable.constant(object));\n\n      assert.deepEqual(func([object], largeArray), [object]);\n      assert.deepEqual(func(lodashStable.range(LARGE_ARRAY_SIZE), [1]), [1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat values that are not arrays or `arguments` objects as empty', function(assert) {\n      assert.expect(3);\n\n      var array = [0, 1, null, 3];\n      assert.deepEqual(func(array, 3, { '0': 1 }, null), []);\n      assert.deepEqual(func(null, array, null, [2, 3]), []);\n      assert.deepEqual(func(array, null, args, null), []);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _([1, 3, 2])[methodName]([5, 2, 1, 4]);\n        assert.ok(wrapped instanceof _);\n        assert.deepEqual(wrapped.value(), [1, 2]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.intersectionBy');\n\n  (function() {\n    QUnit.test('should accept an `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var actual = _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n      assert.deepEqual(actual, [2.1]);\n\n      actual = _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n      assert.deepEqual(actual, [{ 'x': 1 }]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.intersectionBy([2.1, 1.2], [2.3, 3.4], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [2.3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.intersectionWith');\n\n  (function() {\n    QUnit.test('should work with a `comparator`', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }],\n          others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }],\n          actual = _.intersectionWith(objects, others, lodashStable.isEqual);\n\n      assert.deepEqual(actual, [objects[0]]);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var array = [-0],\n          largeArray = lodashStable.times(LARGE_ARRAY_SIZE, stubZero),\n          others = [[0], largeArray],\n          expected = lodashStable.map(others, lodashStable.constant(['-0']));\n\n      var actual = lodashStable.map(others, function(other) {\n        return lodashStable.map(_.intersectionWith(array, other, lodashStable.eq), lodashStable.toString);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.invert');\n\n  (function() {\n    QUnit.test('should invert an object', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1, 'b': 2 },\n          actual = _.invert(object);\n\n      assert.deepEqual(actual, { '1': 'a', '2': 'b' });\n      assert.deepEqual(_.invert(actual), { 'a': '1', 'b': '2' });\n    });\n\n    QUnit.test('should work with values that shadow keys on `Object.prototype`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 'hasOwnProperty', 'b': 'constructor' };\n      assert.deepEqual(_.invert(object), { 'hasOwnProperty': 'a', 'constructor': 'b' });\n    });\n\n    QUnit.test('should work with an object that has a `length` property', function(assert) {\n      assert.expect(1);\n\n      var object = { '0': 'a', '1': 'b', 'length': 2 };\n      assert.deepEqual(_.invert(object), { 'a': '0', 'b': '1', '2': 'length' });\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var object = { 'a': 1, 'b': 2 },\n            wrapped = _(object).invert();\n\n        assert.ok(wrapped instanceof _);\n        assert.deepEqual(wrapped.value(), { '1': 'a', '2': 'b' });\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.invertBy');\n\n  (function() {\n    var object = { 'a': 1, 'b': 2, 'c': 1 };\n\n    QUnit.test('should transform keys by `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'group1': ['a', 'c'], 'group2': ['b'] };\n\n      var actual = _.invertBy(object, function(value) {\n        return 'group' + value;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant({ '1': ['a', 'c'], '2': ['b'] }));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.invertBy(object, value) : _.invertBy(object);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should only add multiple values to own, not inherited, properties', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 'hasOwnProperty', 'b': 'constructor' },\n          expected = { 'hasOwnProperty': ['a'], 'constructor': ['b'] };\n\n      assert.ok(lodashStable.isEqual(_.invertBy(object), expected));\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(object).invertBy();\n\n        assert.ok(wrapped instanceof _);\n        assert.deepEqual(wrapped.value(), { '1': ['a', 'c'], '2': ['b'] });\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.invoke');\n\n  (function() {\n    QUnit.test('should invoke a method on `object`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': lodashStable.constant('A') },\n          actual = _.invoke(object, 'a');\n\n      assert.strictEqual(actual, 'A');\n    });\n\n    QUnit.test('should support invoking with arguments', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': function(a, b) { return [a, b]; } },\n          actual = _.invoke(object, 'a', 1, 2);\n\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('should not error on nullish elements', function(assert) {\n      assert.expect(1);\n\n      var values = [null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      var actual = lodashStable.map(values, function(value) {\n        try {\n          return _.invoke(value, 'a.b', 1, 2);\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': stubA, '0': stubB },\n          props = [-0, Object(-0), 0, Object(0)];\n\n      var actual = lodashStable.map(props, function(key) {\n        return _.invoke(object, key);\n      });\n\n      assert.deepEqual(actual, ['a', 'a', 'b', 'b']);\n    });\n\n    QUnit.test('should support deep paths', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': function(a, b) { return [a, b]; } } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var actual = _.invoke(object, path, 1, 2);\n        assert.deepEqual(actual, [1, 2]);\n      });\n    });\n\n    QUnit.test('should invoke deep property methods with the correct `this` binding', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': function() { return this.c; }, 'c': 1 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.deepEqual(_.invoke(object, path), 1);\n      });\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var object = { 'a': stubOne };\n        assert.strictEqual(_(object).invoke('a'), 1);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var object = { 'a': stubOne };\n        assert.ok(_(object).chain().invoke('a') instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.invokeMap');\n\n  (function() {\n    QUnit.test('should invoke a methods on each element of `collection`', function(assert) {\n      assert.expect(1);\n\n      var array = ['a', 'b', 'c'],\n          actual = _.invokeMap(array, 'toUpperCase');\n\n      assert.deepEqual(actual, ['A', 'B', 'C']);\n    });\n\n    QUnit.test('should support invoking with arguments', function(assert) {\n      assert.expect(1);\n\n      var array = [function() { return slice.call(arguments); }],\n          actual = _.invokeMap(array, 'call', null, 'a', 'b', 'c');\n\n      assert.deepEqual(actual, [['a', 'b', 'c']]);\n    });\n\n    QUnit.test('should work with a function for `methodName`', function(assert) {\n      assert.expect(1);\n\n      var array = ['a', 'b', 'c'];\n\n      var actual = _.invokeMap(array, function(left, right) {\n        return left + this.toUpperCase() + right;\n      }, '(', ')');\n\n      assert.deepEqual(actual, ['(A)', '(B)', '(C)']);\n    });\n\n    QUnit.test('should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          actual = _.invokeMap(object, 'toFixed', 1);\n\n      assert.deepEqual(actual, ['1.0', '2.0', '3.0']);\n    });\n\n    QUnit.test('should treat number values for `collection` as empty', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.invokeMap(1), []);\n    });\n\n    QUnit.test('should not error on nullish elements', function(assert) {\n      assert.expect(1);\n\n      var array = ['a', null, undefined, 'd'];\n\n      try {\n        var actual = _.invokeMap(array, 'toUpperCase');\n      } catch (e) {}\n\n      assert.deepEqual(actual, ['A', undefined, undefined, 'D']);\n    });\n\n    QUnit.test('should not error on elements with missing properties', function(assert) {\n      assert.expect(1);\n\n      var objects = lodashStable.map([null, undefined, stubOne], function(value) {\n        return { 'a': value };\n      });\n\n      var expected = lodashStable.map(objects, function(object) {\n        return object.a ? object.a() : undefined;\n      });\n\n      try {\n        var actual = _.invokeMap(objects, 'a');\n      } catch (e) {}\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should invoke deep property methods with the correct `this` binding', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': function() { return this.c; }, 'c': 1 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.deepEqual(_.invokeMap([object], path), [1]);\n      });\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var array = ['a', 'b', 'c'],\n            wrapped = _(array),\n            actual = wrapped.invokeMap('toUpperCase');\n\n        assert.ok(actual instanceof _);\n        assert.deepEqual(actual.valueOf(), ['A', 'B', 'C']);\n\n        actual = wrapped.invokeMap(function(left, right) {\n          return left + this.toUpperCase() + right;\n        }, '(', ')');\n\n        assert.ok(actual instanceof _);\n        assert.deepEqual(actual.valueOf(), ['(A)', '(B)', '(C)']);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should support shortcut fusion', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var count = 0,\n            method = function() { count++; return this.index; };\n\n        var array = lodashStable.times(LARGE_ARRAY_SIZE, function(index) {\n          return { 'index': index, 'method': method };\n        });\n\n        var actual = _(array).invokeMap('method').take(1).value();\n\n        assert.strictEqual(count, 1);\n        assert.deepEqual(actual, [0]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isArguments');\n\n  (function() {\n    QUnit.test('should return `true` for `arguments` objects', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.isArguments(args), true);\n      assert.strictEqual(_.isArguments(strictArgs), true);\n    });\n\n    QUnit.test('should return `false` for non `arguments` objects', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isArguments(value) : _.isArguments();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isArguments([1, 2, 3]), false);\n      assert.strictEqual(_.isArguments(true), false);\n      assert.strictEqual(_.isArguments(new Date), false);\n      assert.strictEqual(_.isArguments(new Error), false);\n      assert.strictEqual(_.isArguments(_), false);\n      assert.strictEqual(_.isArguments(slice), false);\n      assert.strictEqual(_.isArguments({ '0': 1, 'callee': noop, 'length': 1 }), false);\n      assert.strictEqual(_.isArguments(1), false);\n      assert.strictEqual(_.isArguments(/x/), false);\n      assert.strictEqual(_.isArguments('a'), false);\n      assert.strictEqual(_.isArguments(symbol), false);\n    });\n\n    QUnit.test('should work with an `arguments` object from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.arguments) {\n        assert.strictEqual(_.isArguments(realm.arguments), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isArray');\n\n  (function() {\n    QUnit.test('should return `true` for arrays', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isArray([1, 2, 3]), true);\n    });\n\n    QUnit.test('should return `false` for non-arrays', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isArray(value) : _.isArray();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isArray(args), false);\n      assert.strictEqual(_.isArray(true), false);\n      assert.strictEqual(_.isArray(new Date), false);\n      assert.strictEqual(_.isArray(new Error), false);\n      assert.strictEqual(_.isArray(_), false);\n      assert.strictEqual(_.isArray(slice), false);\n      assert.strictEqual(_.isArray({ '0': 1, 'length': 1 }), false);\n      assert.strictEqual(_.isArray(1), false);\n      assert.strictEqual(_.isArray(/x/), false);\n      assert.strictEqual(_.isArray('a'), false);\n      assert.strictEqual(_.isArray(symbol), false);\n    });\n\n    QUnit.test('should work with an array from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.array) {\n        assert.strictEqual(_.isArray(realm.array), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isArrayBuffer');\n\n  (function() {\n    QUnit.test('should return `true` for array buffers', function(assert) {\n      assert.expect(1);\n\n      if (ArrayBuffer) {\n        assert.strictEqual(_.isArrayBuffer(arrayBuffer), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non array buffers', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isArrayBuffer(value) : _.isArrayBuffer();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isArrayBuffer(args), false);\n      assert.strictEqual(_.isArrayBuffer([1]), false);\n      assert.strictEqual(_.isArrayBuffer(true), false);\n      assert.strictEqual(_.isArrayBuffer(new Date), false);\n      assert.strictEqual(_.isArrayBuffer(new Error), false);\n      assert.strictEqual(_.isArrayBuffer(_), false);\n      assert.strictEqual(_.isArrayBuffer(slice), false);\n      assert.strictEqual(_.isArrayBuffer({ 'a': 1 }), false);\n      assert.strictEqual(_.isArrayBuffer(1), false);\n      assert.strictEqual(_.isArrayBuffer(/x/), false);\n      assert.strictEqual(_.isArrayBuffer('a'), false);\n      assert.strictEqual(_.isArrayBuffer(symbol), false);\n    });\n\n    QUnit.test('should work with array buffers from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.arrayBuffer) {\n        assert.strictEqual(_.isArrayBuffer(realm.arrayBuffer), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isArrayLike');\n\n  (function() {\n    QUnit.test('should return `true` for array-like values', function(assert) {\n      assert.expect(1);\n\n      var values = [args, [1, 2, 3], { '0': 'a', 'length': 1 }, 'a'],\n          expected = lodashStable.map(values, stubTrue),\n          actual = lodashStable.map(values, _.isArrayLike);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-arrays', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === '';\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isArrayLike(value) : _.isArrayLike();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isArrayLike(true), false);\n      assert.strictEqual(_.isArrayLike(new Date), false);\n      assert.strictEqual(_.isArrayLike(new Error), false);\n      assert.strictEqual(_.isArrayLike(_), false);\n      assert.strictEqual(_.isArrayLike(asyncFunc), false);\n      assert.strictEqual(_.isArrayLike(genFunc), false);\n      assert.strictEqual(_.isArrayLike(slice), false);\n      assert.strictEqual(_.isArrayLike({ 'a': 1 }), false);\n      assert.strictEqual(_.isArrayLike(1), false);\n      assert.strictEqual(_.isArrayLike(/x/), false);\n      assert.strictEqual(_.isArrayLike(symbol), false);\n    });\n\n    QUnit.test('should work with an array from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.object) {\n        var values = [realm.arguments, realm.array, realm.string],\n            expected = lodashStable.map(values, stubTrue),\n            actual = lodashStable.map(values, _.isArrayLike);\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isBoolean');\n\n  (function() {\n    QUnit.test('should return `true` for booleans', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.isBoolean(true), true);\n      assert.strictEqual(_.isBoolean(false), true);\n      assert.strictEqual(_.isBoolean(Object(true)), true);\n      assert.strictEqual(_.isBoolean(Object(false)), true);\n    });\n\n    QUnit.test('should return `false` for non-booleans', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === false;\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isBoolean(value) : _.isBoolean();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isBoolean(args), false);\n      assert.strictEqual(_.isBoolean([1, 2, 3]), false);\n      assert.strictEqual(_.isBoolean(new Date), false);\n      assert.strictEqual(_.isBoolean(new Error), false);\n      assert.strictEqual(_.isBoolean(_), false);\n      assert.strictEqual(_.isBoolean(slice), false);\n      assert.strictEqual(_.isBoolean({ 'a': 1 }), false);\n      assert.strictEqual(_.isBoolean(1), false);\n      assert.strictEqual(_.isBoolean(/x/), false);\n      assert.strictEqual(_.isBoolean('a'), false);\n      assert.strictEqual(_.isBoolean(symbol), false);\n    });\n\n    QUnit.test('should work with a boolean from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.boolean) {\n        assert.strictEqual(_.isBoolean(realm.boolean), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isBuffer');\n\n  (function() {\n    QUnit.test('should return `true` for buffers', function(assert) {\n      assert.expect(1);\n\n      if (Buffer) {\n        assert.strictEqual(_.isBuffer(new Buffer(2)), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non-buffers', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isBuffer(value) : _.isBuffer();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isBuffer(args), false);\n      assert.strictEqual(_.isBuffer([1]), false);\n      assert.strictEqual(_.isBuffer(true), false);\n      assert.strictEqual(_.isBuffer(new Date), false);\n      assert.strictEqual(_.isBuffer(new Error), false);\n      assert.strictEqual(_.isBuffer(_), false);\n      assert.strictEqual(_.isBuffer(slice), false);\n      assert.strictEqual(_.isBuffer({ 'a': 1 }), false);\n      assert.strictEqual(_.isBuffer(1), false);\n      assert.strictEqual(_.isBuffer(/x/), false);\n      assert.strictEqual(_.isBuffer('a'), false);\n      assert.strictEqual(_.isBuffer(symbol), false);\n    });\n\n    QUnit.test('should return `false` if `Buffer` is not defined', function(assert) {\n      assert.expect(1);\n\n      if (!isStrict && Buffer && lodashBizarro) {\n        assert.strictEqual(lodashBizarro.isBuffer(new Buffer(2)), false);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isDate');\n\n  (function() {\n    QUnit.test('should return `true` for dates', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isDate(new Date), true);\n    });\n\n    QUnit.test('should return `false` for non-dates', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isDate(value) : _.isDate();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isDate(args), false);\n      assert.strictEqual(_.isDate([1, 2, 3]), false);\n      assert.strictEqual(_.isDate(true), false);\n      assert.strictEqual(_.isDate(new Error), false);\n      assert.strictEqual(_.isDate(_), false);\n      assert.strictEqual(_.isDate(slice), false);\n      assert.strictEqual(_.isDate({ 'a': 1 }), false);\n      assert.strictEqual(_.isDate(1), false);\n      assert.strictEqual(_.isDate(/x/), false);\n      assert.strictEqual(_.isDate('a'), false);\n      assert.strictEqual(_.isDate(symbol), false);\n    });\n\n    QUnit.test('should work with a date object from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.date) {\n        assert.strictEqual(_.isDate(realm.date), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isElement');\n\n  (function() {\n    QUnit.test('should return `true` for elements', function(assert) {\n      assert.expect(1);\n\n      if (document) {\n        assert.strictEqual(_.isElement(body), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `true` for non-plain objects', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.nodeType = 1;\n      }\n\n      assert.strictEqual(_.isElement(new Foo), true);\n    });\n\n    QUnit.test('should return `false` for non DOM elements', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isElement(value) : _.isElement();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isElement(args), false);\n      assert.strictEqual(_.isElement([1, 2, 3]), false);\n      assert.strictEqual(_.isElement(true), false);\n      assert.strictEqual(_.isElement(new Date), false);\n      assert.strictEqual(_.isElement(new Error), false);\n      assert.strictEqual(_.isElement(_), false);\n      assert.strictEqual(_.isElement(slice), false);\n      assert.strictEqual(_.isElement({ 'a': 1 }), false);\n      assert.strictEqual(_.isElement(1), false);\n      assert.strictEqual(_.isElement(/x/), false);\n      assert.strictEqual(_.isElement('a'), false);\n      assert.strictEqual(_.isElement(symbol), false);\n    });\n\n    QUnit.test('should return `false` for plain objects', function(assert) {\n      assert.expect(6);\n\n      assert.strictEqual(_.isElement({ 'nodeType': 1 }), false);\n      assert.strictEqual(_.isElement({ 'nodeType': Object(1) }), false);\n      assert.strictEqual(_.isElement({ 'nodeType': true }), false);\n      assert.strictEqual(_.isElement({ 'nodeType': [1] }), false);\n      assert.strictEqual(_.isElement({ 'nodeType': '1' }), false);\n      assert.strictEqual(_.isElement({ 'nodeType': '001' }), false);\n    });\n\n    QUnit.test('should work with a DOM element from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.element) {\n        assert.strictEqual(_.isElement(realm.element), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isEmpty');\n\n  (function() {\n    QUnit.test('should return `true` for empty values', function(assert) {\n      assert.expect(10);\n\n      var expected = lodashStable.map(empties, stubTrue),\n          actual = lodashStable.map(empties, _.isEmpty);\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isEmpty(true), true);\n      assert.strictEqual(_.isEmpty(slice), true);\n      assert.strictEqual(_.isEmpty(1), true);\n      assert.strictEqual(_.isEmpty(NaN), true);\n      assert.strictEqual(_.isEmpty(/x/), true);\n      assert.strictEqual(_.isEmpty(symbol), true);\n      assert.strictEqual(_.isEmpty(), true);\n\n      if (Buffer) {\n        assert.strictEqual(_.isEmpty(new Buffer(0)), true);\n        assert.strictEqual(_.isEmpty(new Buffer(1)), false);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should return `false` for non-empty values', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.isEmpty([0]), false);\n      assert.strictEqual(_.isEmpty({ 'a': 0 }), false);\n      assert.strictEqual(_.isEmpty('a'), false);\n    });\n\n    QUnit.test('should work with an object that has a `length` property', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isEmpty({ 'length': 0 }), false);\n    });\n\n    QUnit.test('should work with `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isEmpty(args), false);\n    });\n\n    QUnit.test('should work with prototytpe objects', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype = { 'constructor': Foo };\n\n      assert.strictEqual(_.isEmpty(Foo.prototype), true);\n\n      Foo.prototype.a = 1;\n      assert.strictEqual(_.isEmpty(Foo.prototype), false);\n    });\n\n    QUnit.test('should work with jQuery/MooTools DOM query collections', function(assert) {\n      assert.expect(1);\n\n      function Foo(elements) {\n        push.apply(this, elements);\n      }\n      Foo.prototype = { 'length': 0, 'splice': arrayProto.splice };\n\n      assert.strictEqual(_.isEmpty(new Foo([])), true);\n    });\n\n    QUnit.test('should work with maps', function(assert) {\n      assert.expect(4);\n\n      if (Map) {\n        lodashStable.each([new Map, realm.map], function(map) {\n          assert.strictEqual(_.isEmpty(map), true);\n          map.set('a', 1);\n          assert.strictEqual(_.isEmpty(map), false);\n          map.clear();\n        });\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should work with sets', function(assert) {\n      assert.expect(4);\n\n      if (Set) {\n        lodashStable.each([new Set, realm.set], function(set) {\n          assert.strictEqual(_.isEmpty(set), true);\n          set.add(1);\n          assert.strictEqual(_.isEmpty(set), false);\n          set.clear();\n        });\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should not treat objects with negative lengths as array-like', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype.length = -1;\n\n      assert.strictEqual(_.isEmpty(new Foo), true);\n    });\n\n    QUnit.test('should not treat objects with lengths larger than `MAX_SAFE_INTEGER` as array-like', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype.length = MAX_SAFE_INTEGER + 1;\n\n      assert.strictEqual(_.isEmpty(new Foo), true);\n    });\n\n    QUnit.test('should not treat objects with non-number lengths as array-like', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isEmpty({ 'length': '0' }), false);\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.strictEqual(_({}).isEmpty(), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_({}).chain().isEmpty() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isEqual');\n\n  (function() {\n    var symbol1 = Symbol ? Symbol('a') : true,\n        symbol2 = Symbol ? Symbol('b') : false;\n\n    QUnit.test('should compare primitives', function(assert) {\n      assert.expect(1);\n\n      var pairs = [\n        [1, 1, true], [1, Object(1), true], [1, '1', false], [1, 2, false],\n        [-0, -0, true], [0, 0, true], [0, Object(0), true], [Object(0), Object(0), true], [-0, 0, true], [0, '0', false], [0, null, false],\n        [NaN, NaN, true], [NaN, Object(NaN), true], [Object(NaN), Object(NaN), true], [NaN, 'a', false], [NaN, Infinity, false],\n        ['a', 'a', true], ['a', Object('a'), true], [Object('a'), Object('a'), true], ['a', 'b', false], ['a', ['a'], false],\n        [true, true, true], [true, Object(true), true], [Object(true), Object(true), true], [true, 1, false], [true, 'a', false],\n        [false, false, true], [false, Object(false), true], [Object(false), Object(false), true], [false, 0, false], [false, '', false],\n        [symbol1, symbol1, true], [symbol1, Object(symbol1), true], [Object(symbol1), Object(symbol1), true], [symbol1, symbol2, false],\n        [null, null, true], [null, undefined, false], [null, {}, false], [null, '', false],\n        [undefined, undefined, true], [undefined, null, false], [undefined, '', false]\n      ];\n\n      var expected = lodashStable.map(pairs, function(pair) {\n        return pair[2];\n      });\n\n      var actual = lodashStable.map(pairs, function(pair) {\n        return _.isEqual(pair[0], pair[1]);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should compare arrays', function(assert) {\n      assert.expect(6);\n\n      var array1 = [true, null, 1, 'a', undefined],\n          array2 = [true, null, 1, 'a', undefined];\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1 = [[1, 2, 3], new Date(2012, 4, 23), /x/, { 'e': 1 }];\n      array2 = [[1, 2, 3], new Date(2012, 4, 23), /x/, { 'e': 1 }];\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1 = [1];\n      array1[2] = 3;\n\n      array2 = [1];\n      array2[1] = undefined;\n      array2[2] = 3;\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1 = [Object(1), false, Object('a'), /x/, new Date(2012, 4, 23), ['a', 'b', [Object('c')]], { 'a': 1 }];\n      array2 = [1, Object(false), 'a', /x/, new Date(2012, 4, 23), ['a', Object('b'), ['c']], { 'a': 1 }];\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1 = [1, 2, 3];\n      array2 = [3, 2, 1];\n\n      assert.strictEqual(_.isEqual(array1, array2), false);\n\n      array1 = [1, 2];\n      array2 = [1, 2, 3];\n\n      assert.strictEqual(_.isEqual(array1, array2), false);\n    });\n\n    QUnit.test('should treat arrays with identical values but different non-index properties as equal', function(assert) {\n      assert.expect(3);\n\n      var array1 = [1, 2, 3],\n          array2 = [1, 2, 3];\n\n      array1.every = array1.filter = array1.forEach =\n      array1.indexOf = array1.lastIndexOf = array1.map =\n      array1.some = array1.reduce = array1.reduceRight = null;\n\n      array2.concat = array2.join = array2.pop =\n      array2.reverse = array2.shift = array2.slice =\n      array2.sort = array2.splice = array2.unshift = null;\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1 = [1, 2, 3];\n      array1.a = 1;\n\n      array2 = [1, 2, 3];\n      array2.b = 1;\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1 = /c/.exec('abcde');\n      array2 = ['c'];\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n    });\n\n    QUnit.test('should compare sparse arrays', function(assert) {\n      assert.expect(3);\n\n      var array = Array(1);\n\n      assert.strictEqual(_.isEqual(array, Array(1)), true);\n      assert.strictEqual(_.isEqual(array, [undefined]), true);\n      assert.strictEqual(_.isEqual(array, Array(2)), false);\n    });\n\n    QUnit.test('should compare plain objects', function(assert) {\n      assert.expect(5);\n\n      var object1 = { 'a': true, 'b': null, 'c': 1, 'd': 'a', 'e': undefined },\n          object2 = { 'a': true, 'b': null, 'c': 1, 'd': 'a', 'e': undefined };\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n\n      object1 = { 'a': [1, 2, 3], 'b': new Date(2012, 4, 23), 'c': /x/, 'd': { 'e': 1 } };\n      object2 = { 'a': [1, 2, 3], 'b': new Date(2012, 4, 23), 'c': /x/, 'd': { 'e': 1 } };\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n\n      object1 = { 'a': 1, 'b': 2, 'c': 3 };\n      object2 = { 'a': 3, 'b': 2, 'c': 1 };\n\n      assert.strictEqual(_.isEqual(object1, object2), false);\n\n      object1 = { 'a': 1, 'b': 2, 'c': 3 };\n      object2 = { 'd': 1, 'e': 2, 'f': 3 };\n\n      assert.strictEqual(_.isEqual(object1, object2), false);\n\n      object1 = { 'a': 1, 'b': 2 };\n      object2 = { 'a': 1, 'b': 2, 'c': 3 };\n\n      assert.strictEqual(_.isEqual(object1, object2), false);\n    });\n\n    QUnit.test('should compare objects regardless of key order', function(assert) {\n      assert.expect(1);\n\n      var object1 = { 'a': 1, 'b': 2, 'c': 3 },\n          object2 = { 'c': 3, 'a': 1, 'b': 2 };\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n    });\n\n    QUnit.test('should compare nested objects', function(assert) {\n      assert.expect(1);\n\n      var object1 = {\n        'a': [1, 2, 3],\n        'b': true,\n        'c': Object(1),\n        'd': 'a',\n        'e': {\n          'f': ['a', Object('b'), 'c'],\n          'g': Object(false),\n          'h': new Date(2012, 4, 23),\n          'i': noop,\n          'j': 'a'\n        }\n      };\n\n      var object2 = {\n        'a': [1, Object(2), 3],\n        'b': Object(true),\n        'c': 1,\n        'd': Object('a'),\n        'e': {\n          'f': ['a', 'b', 'c'],\n          'g': false,\n          'h': new Date(2012, 4, 23),\n          'i': noop,\n          'j': 'a'\n        }\n      };\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n    });\n\n    QUnit.test('should compare object instances', function(assert) {\n      assert.expect(4);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.a = 1;\n\n      function Bar() {\n        this.a = 1;\n      }\n      Bar.prototype.a = 2;\n\n      assert.strictEqual(_.isEqual(new Foo, new Foo), true);\n      assert.strictEqual(_.isEqual(new Foo, new Bar), false);\n      assert.strictEqual(_.isEqual({ 'a': 1 }, new Foo), false);\n      assert.strictEqual(_.isEqual({ 'a': 2 }, new Bar), false);\n    });\n\n    QUnit.test('should compare objects with constructor properties', function(assert) {\n      assert.expect(5);\n\n      assert.strictEqual(_.isEqual({ 'constructor': 1 },   { 'constructor': 1 }), true);\n      assert.strictEqual(_.isEqual({ 'constructor': 1 },   { 'constructor': '1' }), false);\n      assert.strictEqual(_.isEqual({ 'constructor': [1] }, { 'constructor': [1] }), true);\n      assert.strictEqual(_.isEqual({ 'constructor': [1] }, { 'constructor': ['1'] }), false);\n      assert.strictEqual(_.isEqual({ 'constructor': Object }, {}), false);\n    });\n\n    QUnit.test('should compare arrays with circular references', function(assert) {\n      assert.expect(6);\n\n      var array1 = [],\n          array2 = [];\n\n      array1.push(array1);\n      array2.push(array2);\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1.push('b');\n      array2.push('b');\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1.push('c');\n      array2.push('d');\n\n      assert.strictEqual(_.isEqual(array1, array2), false);\n\n      array1 = ['a', 'b', 'c'];\n      array1[1] = array1;\n      array2 = ['a', ['a', 'b', 'c'], 'c'];\n\n      assert.strictEqual(_.isEqual(array1, array2), false);\n\n      array1 = [[[]]];\n      array1[0][0][0] = array1;\n      array2 = [];\n      array2[0] = array2;\n\n      assert.strictEqual(_.isEqual(array1, array2), false);\n      assert.strictEqual(_.isEqual(array2, array1), false);\n    });\n\n    QUnit.test('should have transitive equivalence for circular references of arrays', function(assert) {\n      assert.expect(3);\n\n      var array1 = [],\n          array2 = [array1],\n          array3 = [array2];\n\n      array1[0] = array1;\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n      assert.strictEqual(_.isEqual(array2, array3), true);\n      assert.strictEqual(_.isEqual(array1, array3), true);\n    });\n\n    QUnit.test('should compare objects with circular references', function(assert) {\n      assert.expect(6);\n\n      var object1 = {},\n          object2 = {};\n\n      object1.a = object1;\n      object2.a = object2;\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n\n      object1.b = 0;\n      object2.b = Object(0);\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n\n      object1.c = Object(1);\n      object2.c = Object(2);\n\n      assert.strictEqual(_.isEqual(object1, object2), false);\n\n      object1 = { 'a': 1, 'b': 2, 'c': 3 };\n      object1.b = object1;\n      object2 = { 'a': 1, 'b': { 'a': 1, 'b': 2, 'c': 3 }, 'c': 3 };\n\n      assert.strictEqual(_.isEqual(object1, object2), false);\n\n      object1 = {self: {self: {self: {}}}};\n      object1.self.self.self = object1;\n      object2 = {self: {}};\n      object2.self = object2;\n\n      assert.strictEqual(_.isEqual(object1, object2), false);\n      assert.strictEqual(_.isEqual(object2, object1), false);\n    });\n\n    QUnit.test('should have transitive equivalence for circular references of objects', function(assert) {\n      assert.expect(3);\n\n      var object1 = {},\n          object2 = { 'a': object1 },\n          object3 = { 'a': object2 };\n\n      object1.a = object1;\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n      assert.strictEqual(_.isEqual(object2, object3), true);\n      assert.strictEqual(_.isEqual(object1, object3), true);\n    });\n\n    QUnit.test('should compare objects with multiple circular references', function(assert) {\n      assert.expect(3);\n\n      var array1 = [{}],\n          array2 = [{}];\n\n      (array1[0].a = array1).push(array1);\n      (array2[0].a = array2).push(array2);\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1[0].b = 0;\n      array2[0].b = Object(0);\n\n      assert.strictEqual(_.isEqual(array1, array2), true);\n\n      array1[0].c = Object(1);\n      array2[0].c = Object(2);\n\n      assert.strictEqual(_.isEqual(array1, array2), false);\n    });\n\n    QUnit.test('should compare objects with complex circular references', function(assert) {\n      assert.expect(1);\n\n      var object1 = {\n        'foo': { 'b': { 'c': { 'd': {} } } },\n        'bar': { 'a': 2 }\n      };\n\n      var object2 = {\n        'foo': { 'b': { 'c': { 'd': {} } } },\n        'bar': { 'a': 2 }\n      };\n\n      object1.foo.b.c.d = object1;\n      object1.bar.b = object1.foo.b;\n\n      object2.foo.b.c.d = object2;\n      object2.bar.b = object2.foo.b;\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n    });\n\n    QUnit.test('should compare objects with shared property values', function(assert) {\n      assert.expect(1);\n\n      var object1 = {\n        'a': [1, 2]\n      };\n\n      var object2 = {\n        'a': [1, 2],\n        'b': [1, 2]\n      };\n\n      object1.b = object1.a;\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n    });\n\n    QUnit.test('should treat objects created by `Object.create(null)` like plain objects', function(assert) {\n      assert.expect(2);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.constructor = null;\n\n      var object1 = create(null);\n      object1.a = 1;\n\n      var object2 = { 'a': 1 };\n\n      assert.strictEqual(_.isEqual(object1, object2), true);\n      assert.strictEqual(_.isEqual(new Foo, object2), false);\n    });\n\n    QUnit.test('should avoid common type coercions', function(assert) {\n      assert.expect(9);\n\n      assert.strictEqual(_.isEqual(true, Object(false)), false);\n      assert.strictEqual(_.isEqual(Object(false), Object(0)), false);\n      assert.strictEqual(_.isEqual(false, Object('')), false);\n      assert.strictEqual(_.isEqual(Object(36), Object('36')), false);\n      assert.strictEqual(_.isEqual(0, ''), false);\n      assert.strictEqual(_.isEqual(1, true), false);\n      assert.strictEqual(_.isEqual(1337756400000, new Date(2012, 4, 23)), false);\n      assert.strictEqual(_.isEqual('36', 36), false);\n      assert.strictEqual(_.isEqual(36, '36'), false);\n    });\n\n    QUnit.test('should compare `arguments` objects', function(assert) {\n      assert.expect(2);\n\n      var args1 = (function() { return arguments; }()),\n          args2 = (function() { return arguments; }()),\n          args3 = (function() { return arguments; }(1, 2));\n\n      assert.strictEqual(_.isEqual(args1, args2), true);\n      assert.strictEqual(_.isEqual(args1, args3), false);\n    });\n\n    QUnit.test('should treat `arguments` objects like `Object` objects', function(assert) {\n      assert.expect(4);\n\n      var object = { '0': 1, '1': 2, '2': 3 };\n\n      function Foo() {}\n      Foo.prototype = object;\n\n      assert.strictEqual(_.isEqual(args, object), true);\n      assert.strictEqual(_.isEqual(object, args), true);\n      assert.strictEqual(_.isEqual(args, new Foo), false);\n      assert.strictEqual(_.isEqual(new Foo, args), false);\n    });\n\n    QUnit.test('should compare array buffers', function(assert) {\n      assert.expect(2);\n\n      if (ArrayBuffer) {\n        var buffer = new Int8Array([-1]).buffer;\n\n        assert.strictEqual(_.isEqual(buffer, new Uint8Array([255]).buffer), true);\n        assert.strictEqual(_.isEqual(buffer, new ArrayBuffer(1)), false);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should compare array views', function(assert) {\n      assert.expect(2);\n\n      lodashStable.times(2, function(index) {\n        var ns = index ? realm : root;\n\n        var pairs = lodashStable.map(arrayViews, function(type, viewIndex) {\n          var otherType = arrayViews[(viewIndex + 1) % arrayViews.length],\n              CtorA = ns[type] || function(n) { this.n = n; },\n              CtorB = ns[otherType] || function(n) { this.n = n; },\n              bufferA = ns[type] ? new ns.ArrayBuffer(8) : 8,\n              bufferB = ns[otherType] ? new ns.ArrayBuffer(8) : 8,\n              bufferC = ns[otherType] ? new ns.ArrayBuffer(16) : 16;\n\n          return [new CtorA(bufferA), new CtorA(bufferA), new CtorB(bufferB), new CtorB(bufferC)];\n        });\n\n        var expected = lodashStable.map(pairs, lodashStable.constant([true, false, false]));\n\n        var actual = lodashStable.map(pairs, function(pair) {\n          return [_.isEqual(pair[0], pair[1]), _.isEqual(pair[0], pair[2]), _.isEqual(pair[2], pair[3])];\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should compare buffers', function(assert) {\n      assert.expect(3);\n\n      if (Buffer) {\n        var buffer = new Buffer([1]);\n\n        assert.strictEqual(_.isEqual(buffer, new Buffer([1])), true);\n        assert.strictEqual(_.isEqual(buffer, new Buffer([2])), false);\n        assert.strictEqual(_.isEqual(buffer, new Uint8Array([1])), false);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should compare date objects', function(assert) {\n      assert.expect(4);\n\n      var date = new Date(2012, 4, 23);\n\n      assert.strictEqual(_.isEqual(date, new Date(2012, 4, 23)), true);\n      assert.strictEqual(_.isEqual(new Date('a'), new Date('b')), true);\n      assert.strictEqual(_.isEqual(date, new Date(2013, 3, 25)), false);\n      assert.strictEqual(_.isEqual(date, { 'getTime': lodashStable.constant(+date) }), false);\n    });\n\n    QUnit.test('should compare error objects', function(assert) {\n      assert.expect(1);\n\n      var pairs = lodashStable.map([\n        'Error',\n        'EvalError',\n        'RangeError',\n        'ReferenceError',\n        'SyntaxError',\n        'TypeError',\n        'URIError'\n      ], function(type, index, errorTypes) {\n        var otherType = errorTypes[++index % errorTypes.length],\n            CtorA = root[type],\n            CtorB = root[otherType];\n\n        return [new CtorA('a'), new CtorA('a'), new CtorB('a'), new CtorB('b')];\n      });\n\n      var expected = lodashStable.map(pairs, lodashStable.constant([true, false, false]));\n\n      var actual = lodashStable.map(pairs, function(pair) {\n        return [_.isEqual(pair[0], pair[1]), _.isEqual(pair[0], pair[2]), _.isEqual(pair[2], pair[3])];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should compare functions', function(assert) {\n      assert.expect(2);\n\n      function a() { return 1 + 2; }\n      function b() { return 1 + 2; }\n\n      assert.strictEqual(_.isEqual(a, a), true);\n      assert.strictEqual(_.isEqual(a, b), false);\n    });\n\n    QUnit.test('should compare maps', function(assert) {\n      assert.expect(8);\n\n      if (Map) {\n        lodashStable.each([[map, new Map], [map, realm.map]], function(maps) {\n          var map1 = maps[0],\n              map2 = maps[1];\n\n          map1.set('a', 1);\n          map2.set('b', 2);\n          assert.strictEqual(_.isEqual(map1, map2), false);\n\n          map1.set('b', 2);\n          map2.set('a', 1);\n          assert.strictEqual(_.isEqual(map1, map2), true);\n\n          map1.delete('a');\n          map1.set('a', 1);\n          assert.strictEqual(_.isEqual(map1, map2), true);\n\n          map2.delete('a');\n          assert.strictEqual(_.isEqual(map1, map2), false);\n\n          map1.clear();\n          map2.clear();\n        });\n      }\n      else {\n        skipAssert(assert, 8);\n      }\n    });\n\n    QUnit.test('should compare maps with circular references', function(assert) {\n      assert.expect(2);\n\n      if (Map) {\n        var map1 = new Map,\n            map2 = new Map;\n\n        map1.set('a', map1);\n        map2.set('a', map2);\n        assert.strictEqual(_.isEqual(map1, map2), true);\n\n        map1.set('b', 1);\n        map2.set('b', 2);\n        assert.strictEqual(_.isEqual(map1, map2), false);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should compare promises by reference', function(assert) {\n      assert.expect(4);\n\n      if (promise) {\n        lodashStable.each([[promise, Promise.resolve(1)], [promise, realm.promise]], function(promises) {\n          var promise1 = promises[0],\n              promise2 = promises[1];\n\n          assert.strictEqual(_.isEqual(promise1, promise2), false);\n          assert.strictEqual(_.isEqual(promise1, promise1), true);\n        });\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should compare regexes', function(assert) {\n      assert.expect(5);\n\n      assert.strictEqual(_.isEqual(/x/gim, /x/gim), true);\n      assert.strictEqual(_.isEqual(/x/gim, /x/mgi), true);\n      assert.strictEqual(_.isEqual(/x/gi, /x/g), false);\n      assert.strictEqual(_.isEqual(/x/, /y/), false);\n      assert.strictEqual(_.isEqual(/x/g, { 'global': true, 'ignoreCase': false, 'multiline': false, 'source': 'x' }), false);\n    });\n\n    QUnit.test('should compare sets', function(assert) {\n      assert.expect(8);\n\n      if (Set) {\n        lodashStable.each([[set, new Set], [set, realm.set]], function(sets) {\n          var set1 = sets[0],\n              set2 = sets[1];\n\n          set1.add(1);\n          set2.add(2);\n          assert.strictEqual(_.isEqual(set1, set2), false);\n\n          set1.add(2);\n          set2.add(1);\n          assert.strictEqual(_.isEqual(set1, set2), true);\n\n          set1.delete(1);\n          set1.add(1);\n          assert.strictEqual(_.isEqual(set1, set2), true);\n\n          set2.delete(1);\n          assert.strictEqual(_.isEqual(set1, set2), false);\n\n          set1.clear();\n          set2.clear();\n        });\n      }\n      else {\n        skipAssert(assert, 8);\n      }\n    });\n\n    QUnit.test('should compare sets with circular references', function(assert) {\n      assert.expect(2);\n\n      if (Set) {\n        var set1 = new Set,\n            set2 = new Set;\n\n        set1.add(set1);\n        set2.add(set2);\n        assert.strictEqual(_.isEqual(set1, set2), true);\n\n        set1.add(1);\n        set2.add(2);\n        assert.strictEqual(_.isEqual(set1, set2), false);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should compare symbol properties', function(assert) {\n      assert.expect(3);\n\n      if (Symbol) {\n        var object1 = { 'a': 1 },\n            object2 = { 'a': 1 };\n\n        object1[symbol1] = { 'a': { 'b': 2 } };\n        object2[symbol1] = { 'a': { 'b': 2 } };\n\n        defineProperty(object2, symbol2, {\n          'configurable': true,\n          'enumerable': false,\n          'writable': true,\n          'value': 2\n        });\n\n        assert.strictEqual(_.isEqual(object1, object2), true);\n\n        object2[symbol1] = { 'a': 1 };\n        assert.strictEqual(_.isEqual(object1, object2), false);\n\n        delete object2[symbol1];\n        object2[Symbol('a')] = { 'a': { 'b': 2 } };\n        assert.strictEqual(_.isEqual(object1, object2), false);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should compare wrapped values', function(assert) {\n      assert.expect(32);\n\n      var stamp = +new Date;\n\n      var values = [\n        [[1, 2], [1, 2], [1, 2, 3]],\n        [true, true, false],\n        [new Date(stamp), new Date(stamp), new Date(stamp - 100)],\n        [{ 'a': 1, 'b': 2 }, { 'a': 1, 'b': 2 }, { 'a': 1, 'b': 1 }],\n        [1, 1, 2],\n        [NaN, NaN, Infinity],\n        [/x/, /x/, /x/i],\n        ['a', 'a', 'A']\n      ];\n\n      lodashStable.each(values, function(vals) {\n        if (!isNpm) {\n          var wrapped1 = _(vals[0]),\n              wrapped2 = _(vals[1]),\n              actual = wrapped1.isEqual(wrapped2);\n\n          assert.strictEqual(actual, true);\n          assert.strictEqual(_.isEqual(_(actual), _(true)), true);\n\n          wrapped1 = _(vals[0]);\n          wrapped2 = _(vals[2]);\n\n          actual = wrapped1.isEqual(wrapped2);\n          assert.strictEqual(actual, false);\n          assert.strictEqual(_.isEqual(_(actual), _(false)), true);\n        }\n        else {\n          skipAssert(assert, 4);\n        }\n      });\n    });\n\n    QUnit.test('should compare wrapped and non-wrapped values', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var object1 = _({ 'a': 1, 'b': 2 }),\n            object2 = { 'a': 1, 'b': 2 };\n\n        assert.strictEqual(object1.isEqual(object2), true);\n        assert.strictEqual(_.isEqual(object1, object2), true);\n\n        object1 = _({ 'a': 1, 'b': 2 });\n        object2 = { 'a': 1, 'b': 1 };\n\n        assert.strictEqual(object1.isEqual(object2), false);\n        assert.strictEqual(_.isEqual(object1, object2), false);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should work as an iteratee for `_.every`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.every([1, 1, 1], lodashStable.partial(_.isEqual, 1));\n      assert.ok(actual);\n    });\n\n    QUnit.test('should not error on DOM elements', function(assert) {\n      assert.expect(1);\n\n      if (document) {\n        var element1 = document.createElement('div'),\n            element2 = element1.cloneNode(true);\n\n        try {\n          assert.strictEqual(_.isEqual(element1, element2), false);\n        } catch (e) {\n          assert.ok(false, e.message);\n        }\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `true` for like-objects from different documents', function(assert) {\n      assert.expect(4);\n\n      if (realm.object) {\n        assert.strictEqual(_.isEqual([1], realm.array), true);\n        assert.strictEqual(_.isEqual([2], realm.array), false);\n        assert.strictEqual(_.isEqual({ 'a': 1 }, realm.object), true);\n        assert.strictEqual(_.isEqual({ 'a': 2 }, realm.object), false);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should return `false` for objects with custom `toString` methods', function(assert) {\n      assert.expect(1);\n\n      var primitive,\n          object = { 'toString': function() { return primitive; } },\n          values = [true, null, 1, 'a', undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value) {\n        primitive = value;\n        return _.isEqual(object, value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.strictEqual(_('a').isEqual('a'), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_('a').chain().isEqual('a') instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isEqualWith');\n\n  (function() {\n    QUnit.test('should provide correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var argsList = [],\n          object1 = { 'a': [1, 2], 'b': null },\n          object2 = { 'a': [1, 2], 'b': null };\n\n      object1.b = object2;\n      object2.b = object1;\n\n      var expected = [\n        [object1, object2],\n        [object1.a, object2.a, 'a', object1, object2],\n        [object1.a[0], object2.a[0], 0, object1.a, object2.a],\n        [object1.a[1], object2.a[1], 1, object1.a, object2.a],\n        [object1.b, object2.b, 'b', object1.b, object2.b]\n      ];\n\n      _.isEqualWith(object1, object2, function(assert) {\n        var length = arguments.length,\n            args = slice.call(arguments, 0, length - (length > 2 ? 1 : 0));\n\n        argsList.push(args);\n      });\n\n      assert.deepEqual(argsList, expected);\n    });\n\n    QUnit.test('should handle comparisons when `customizer` returns `undefined`', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.isEqualWith('a', 'a', noop), true);\n      assert.strictEqual(_.isEqualWith(['a'], ['a'], noop), true);\n      assert.strictEqual(_.isEqualWith({ '0': 'a' }, { '0': 'a' }, noop), true);\n    });\n\n    QUnit.test('should not handle comparisons when `customizer` returns `true`', function(assert) {\n      assert.expect(3);\n\n      var customizer = function(value) {\n        return _.isString(value) || undefined;\n      };\n\n      assert.strictEqual(_.isEqualWith('a', 'b', customizer), true);\n      assert.strictEqual(_.isEqualWith(['a'], ['b'], customizer), true);\n      assert.strictEqual(_.isEqualWith({ '0': 'a' }, { '0': 'b' }, customizer), true);\n    });\n\n    QUnit.test('should not handle comparisons when `customizer` returns `false`', function(assert) {\n      assert.expect(3);\n\n      var customizer = function(value) {\n        return _.isString(value) ? false : undefined;\n      };\n\n      assert.strictEqual(_.isEqualWith('a', 'a', customizer), false);\n      assert.strictEqual(_.isEqualWith(['a'], ['a'], customizer), false);\n      assert.strictEqual(_.isEqualWith({ '0': 'a' }, { '0': 'a' }, customizer), false);\n    });\n\n    QUnit.test('should return a boolean value even when `customizer` does not', function(assert) {\n      assert.expect(2);\n\n      var actual = _.isEqualWith('a', 'b', stubC);\n      assert.strictEqual(actual, true);\n\n      var values = _.without(falsey, undefined),\n          expected = lodashStable.map(values, stubFalse);\n\n      actual = [];\n      lodashStable.each(values, function(value) {\n        actual.push(_.isEqualWith('a', 'a', lodashStable.constant(value)));\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should ensure `customizer` is a function', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3],\n          eq = _.partial(_.isEqualWith, array),\n          actual = lodashStable.map([array, [1, 0, 3]], eq);\n\n      assert.deepEqual(actual, [true, false]);\n    });\n\n    QUnit.test('should call `customizer` for values maps and sets', function(assert) {\n      assert.expect(2);\n\n      var value = { 'a': { 'b': 2 } };\n\n      if (Map) {\n        var map1 = new Map;\n        map1.set('a', value);\n\n        var map2 = new Map;\n        map2.set('a', value);\n      }\n      if (Set) {\n        var set1 = new Set;\n        set1.add(value);\n\n        var set2 = new Set;\n        set2.add(value);\n      }\n      lodashStable.each([[map1, map2], [set1, set2]], function(pair, index) {\n        if (pair[0]) {\n          var argsList = [],\n              array = lodashStable.toArray(pair[0]);\n\n          var expected = [\n            [pair[0], pair[1]],\n            [array[0], array[0], 0, array, array],\n            [array[0][0], array[0][0], 0, array[0], array[0]],\n            [array[0][1], array[0][1], 1, array[0], array[0]]\n          ];\n\n          if (index) {\n            expected.length = 2;\n          }\n          _.isEqualWith(pair[0], pair[1], function() {\n            var length = arguments.length,\n                args = slice.call(arguments, 0, length - (length > 2 ? 1 : 0));\n\n            argsList.push(args);\n          });\n\n          assert.deepEqual(argsList, expected, index ? 'Set' : 'Map');\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isError');\n\n  (function() {\n    QUnit.test('should return `true` for error objects', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(errors, stubTrue);\n\n      var actual = lodashStable.map(errors, function(error) {\n        return _.isError(error) === true;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `true` for subclassed values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isError(new CustomError('x')), true);\n    });\n\n    QUnit.test('should return `false` for non error objects', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isError(value) : _.isError();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isError(args), false);\n      assert.strictEqual(_.isError([1, 2, 3]), false);\n      assert.strictEqual(_.isError(true), false);\n      assert.strictEqual(_.isError(new Date), false);\n      assert.strictEqual(_.isError(_), false);\n      assert.strictEqual(_.isError(slice), false);\n      assert.strictEqual(_.isError({ 'a': 1 }), false);\n      assert.strictEqual(_.isError(1), false);\n      assert.strictEqual(_.isError(/x/), false);\n      assert.strictEqual(_.isError('a'), false);\n      assert.strictEqual(_.isError(symbol), false);\n    });\n\n    QUnit.test('should return `false` for plain objects', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isError({ 'name': 'Error', 'message': '' }), false);\n    });\n\n    QUnit.test('should work with an error object from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.errors) {\n        var expected = lodashStable.map(realm.errors, stubTrue);\n\n        var actual = lodashStable.map(realm.errors, function(error) {\n          return _.isError(error) === true;\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isFinite');\n\n  (function() {\n    QUnit.test('should return `true` for finite values', function(assert) {\n      assert.expect(1);\n\n      var values = [0, 1, 3.14, -1],\n          expected = lodashStable.map(values, stubTrue),\n          actual = lodashStable.map(values, _.isFinite);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-finite values', function(assert) {\n      assert.expect(1);\n\n      var values = [NaN, Infinity, -Infinity, Object(1)],\n          expected = lodashStable.map(values, stubFalse),\n          actual = lodashStable.map(values, _.isFinite);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-numeric values', function(assert) {\n      assert.expect(10);\n\n      var values = [undefined, [], true, '', ' ', '2px'],\n          expected = lodashStable.map(values, stubFalse),\n          actual = lodashStable.map(values, _.isFinite);\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isFinite(args), false);\n      assert.strictEqual(_.isFinite([1, 2, 3]), false);\n      assert.strictEqual(_.isFinite(true), false);\n      assert.strictEqual(_.isFinite(new Date), false);\n      assert.strictEqual(_.isFinite(new Error), false);\n      assert.strictEqual(_.isFinite({ 'a': 1 }), false);\n      assert.strictEqual(_.isFinite(/x/), false);\n      assert.strictEqual(_.isFinite('a'), false);\n      assert.strictEqual(_.isFinite(symbol), false);\n    });\n\n    QUnit.test('should return `false` for numeric string values', function(assert) {\n      assert.expect(1);\n\n      var values = ['2', '0', '08'],\n          expected = lodashStable.map(values, stubFalse),\n          actual = lodashStable.map(values, _.isFinite);\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isFunction');\n\n  (function() {\n    QUnit.test('should return `true` for functions', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.isFunction(_), true);\n      assert.strictEqual(_.isFunction(slice), true);\n    });\n\n    QUnit.test('should return `true` for async functions', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isFunction(asyncFunc), typeof asyncFunc == 'function');\n    });\n\n    QUnit.test('should return `true` for generator functions', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isFunction(genFunc), typeof genFunc == 'function');\n    });\n\n    QUnit.test('should return `true` for the `Proxy` constructor', function(assert) {\n      assert.expect(1);\n\n      if (Proxy) {\n        assert.strictEqual(_.isFunction(Proxy), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `true` for array view constructors', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(arrayViews, function(type) {\n        return objToString.call(root[type]) == funcTag;\n      });\n\n      var actual = lodashStable.map(arrayViews, function(type) {\n        return _.isFunction(root[type]);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-functions', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isFunction(value) : _.isFunction();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isFunction(args), false);\n      assert.strictEqual(_.isFunction([1, 2, 3]), false);\n      assert.strictEqual(_.isFunction(true), false);\n      assert.strictEqual(_.isFunction(new Date), false);\n      assert.strictEqual(_.isFunction(new Error), false);\n      assert.strictEqual(_.isFunction({ 'a': 1 }), false);\n      assert.strictEqual(_.isFunction(1), false);\n      assert.strictEqual(_.isFunction(/x/), false);\n      assert.strictEqual(_.isFunction('a'), false);\n      assert.strictEqual(_.isFunction(symbol), false);\n\n      if (document) {\n        assert.strictEqual(_.isFunction(document.getElementsByTagName('body')), false);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work with a function from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.function) {\n        assert.strictEqual(_.isFunction(realm.function), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('isInteger methods');\n\n  lodashStable.each(['isInteger', 'isSafeInteger'], function(methodName) {\n    var func = _[methodName],\n        isSafe = methodName == 'isSafeInteger';\n\n    QUnit.test('`_.' + methodName + '` should return `true` for integer values', function(assert) {\n      assert.expect(2);\n\n      var values = [-1, 0, 1],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(value);\n      });\n\n      assert.deepEqual(actual, expected);\n      assert.strictEqual(func(MAX_INTEGER), !isSafe);\n    });\n\n    QUnit.test('should return `false` for non-integer number values', function(assert) {\n      assert.expect(1);\n\n      var values = [NaN, Infinity, -Infinity, Object(1), 3.14],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-numeric values', function(assert) {\n      assert.expect(10);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === 0;\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? func(value) : func();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(func(args), false);\n      assert.strictEqual(func([1, 2, 3]), false);\n      assert.strictEqual(func(true), false);\n      assert.strictEqual(func(new Date), false);\n      assert.strictEqual(func(new Error), false);\n      assert.strictEqual(func({ 'a': 1 }), false);\n      assert.strictEqual(func(/x/), false);\n      assert.strictEqual(func('a'), false);\n      assert.strictEqual(func(symbol), false);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isLength');\n\n  (function() {\n    QUnit.test('should return `true` for lengths', function(assert) {\n      assert.expect(1);\n\n      var values = [0, 3, MAX_SAFE_INTEGER],\n          expected = lodashStable.map(values, stubTrue),\n          actual = lodashStable.map(values, _.isLength);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-lengths', function(assert) {\n      assert.expect(1);\n\n      var values = [-1, '1', 1.1, MAX_SAFE_INTEGER + 1],\n          expected = lodashStable.map(values, stubFalse),\n          actual = lodashStable.map(values, _.isLength);\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isMap');\n\n  (function() {\n    QUnit.test('should return `true` for maps', function(assert) {\n      assert.expect(1);\n\n      if (Map) {\n        assert.strictEqual(_.isMap(map), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non-maps', function(assert) {\n      assert.expect(14);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isMap(value) : _.isMap();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isMap(args), false);\n      assert.strictEqual(_.isMap([1, 2, 3]), false);\n      assert.strictEqual(_.isMap(true), false);\n      assert.strictEqual(_.isMap(new Date), false);\n      assert.strictEqual(_.isMap(new Error), false);\n      assert.strictEqual(_.isMap(_), false);\n      assert.strictEqual(_.isMap(slice), false);\n      assert.strictEqual(_.isMap({ 'a': 1 }), false);\n      assert.strictEqual(_.isMap(1), false);\n      assert.strictEqual(_.isMap(/x/), false);\n      assert.strictEqual(_.isMap('a'), false);\n      assert.strictEqual(_.isMap(symbol), false);\n      assert.strictEqual(_.isMap(weakMap), false);\n    });\n\n    QUnit.test('should work for objects with a non-function `constructor` (test in IE 11)', function(assert) {\n      assert.expect(1);\n\n      var values = [false, true],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.isMap({ 'constructor': value });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with maps from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.map) {\n        assert.strictEqual(_.isMap(realm.map), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isMatchWith');\n\n  (function() {\n    QUnit.test('should provide correct `customizer` arguments', function(assert) {\n      assert.expect(1);\n\n      var argsList = [],\n          object1 = { 'a': [1, 2], 'b': null },\n          object2 = { 'a': [1, 2], 'b': null };\n\n      object1.b = object2;\n      object2.b = object1;\n\n      var expected = [\n        [object1.a, object2.a, 'a', object1, object2],\n        [object1.a[0], object2.a[0], 0, object1.a, object2.a],\n        [object1.a[1], object2.a[1], 1, object1.a, object2.a],\n        [object1.b, object2.b, 'b', object1, object2],\n        [object1.b.a, object2.b.a, 'a', object1.b, object2.b],\n        [object1.b.a[0], object2.b.a[0], 0, object1.b.a, object2.b.a],\n        [object1.b.a[1], object2.b.a[1], 1, object1.b.a, object2.b.a],\n        [object1.b.b, object2.b.b, 'b', object1.b, object2.b]\n      ];\n\n      _.isMatchWith(object1, object2, function(assert) {\n        argsList.push(slice.call(arguments, 0, -1));\n      });\n\n      assert.deepEqual(argsList, expected);\n    });\n\n    QUnit.test('should handle comparisons when `customizer` returns `undefined`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isMatchWith({ 'a': 1 }, { 'a': 1 }, noop), true);\n    });\n\n    QUnit.test('should not handle comparisons when `customizer` returns `true`', function(assert) {\n      assert.expect(2);\n\n      var customizer = function(value) {\n        return _.isString(value) || undefined;\n      };\n\n      assert.strictEqual(_.isMatchWith(['a'], ['b'], customizer), true);\n      assert.strictEqual(_.isMatchWith({ '0': 'a' }, { '0': 'b' }, customizer), true);\n    });\n\n    QUnit.test('should not handle comparisons when `customizer` returns `false`', function(assert) {\n      assert.expect(2);\n\n      var customizer = function(value) {\n        return _.isString(value) ? false : undefined;\n      };\n\n      assert.strictEqual(_.isMatchWith(['a'], ['a'], customizer), false);\n      assert.strictEqual(_.isMatchWith({ '0': 'a' }, { '0': 'a' }, customizer), false);\n    });\n\n    QUnit.test('should return a boolean value even when `customizer` does not', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1 },\n          actual = _.isMatchWith(object, { 'a': 1 }, stubA);\n\n      assert.strictEqual(actual, true);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      actual = [];\n      lodashStable.each(falsey, function(value) {\n        actual.push(_.isMatchWith(object, { 'a': 2 }, lodashStable.constant(value)));\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should provide `stack` to `customizer`', function(assert) {\n      assert.expect(1);\n\n      var actual;\n\n      _.isMatchWith({ 'a': 1 }, { 'a': 1 }, function() {\n        actual = _.last(arguments);\n      });\n\n      assert.ok(isNpm\n        ? actual.constructor.name == 'Stack'\n        : actual instanceof mapCaches.Stack\n      );\n    });\n\n    QUnit.test('should ensure `customizer` is a function', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1 },\n          matches = _.partial(_.isMatchWith, object),\n          actual = lodashStable.map([object, { 'a': 2 }], matches);\n\n      assert.deepEqual(actual, [true, false]);\n    });\n\n    QUnit.test('should call `customizer` for values maps and sets', function(assert) {\n      assert.expect(2);\n\n      var value = { 'a': { 'b': 2 } };\n\n      if (Map) {\n        var map1 = new Map;\n        map1.set('a', value);\n\n        var map2 = new Map;\n        map2.set('a', value);\n      }\n      if (Set) {\n        var set1 = new Set;\n        set1.add(value);\n\n        var set2 = new Set;\n        set2.add(value);\n      }\n      lodashStable.each([[map1, map2], [set1, set2]], function(pair, index) {\n        if (pair[0]) {\n          var argsList = [],\n              array = lodashStable.toArray(pair[0]),\n              object1 = { 'a': pair[0] },\n              object2 = { 'a': pair[1] };\n\n          var expected = [\n            [pair[0], pair[1], 'a', object1, object2],\n            [array[0], array[0], 0, array, array],\n            [array[0][0], array[0][0], 0, array[0], array[0]],\n            [array[0][1], array[0][1], 1, array[0], array[0]]\n          ];\n\n          if (index) {\n            expected.length = 2;\n          }\n          _.isMatchWith({ 'a': pair[0] }, { 'a': pair[1] }, function() {\n            argsList.push(slice.call(arguments, 0, -1));\n          });\n\n          assert.deepEqual(argsList, expected, index ? 'Set' : 'Map');\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isNaN');\n\n  (function() {\n    QUnit.test('should return `true` for NaNs', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.isNaN(NaN), true);\n      assert.strictEqual(_.isNaN(Object(NaN)), true);\n    });\n\n    QUnit.test('should return `false` for non-NaNs', function(assert) {\n      assert.expect(14);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value !== value;\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isNaN(value) : _.isNaN();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isNaN(args), false);\n      assert.strictEqual(_.isNaN([1, 2, 3]), false);\n      assert.strictEqual(_.isNaN(true), false);\n      assert.strictEqual(_.isNaN(new Date), false);\n      assert.strictEqual(_.isNaN(new Error), false);\n      assert.strictEqual(_.isNaN(_), false);\n      assert.strictEqual(_.isNaN(slice), false);\n      assert.strictEqual(_.isNaN({ 'a': 1 }), false);\n      assert.strictEqual(_.isNaN(1), false);\n      assert.strictEqual(_.isNaN(Object(1)), false);\n      assert.strictEqual(_.isNaN(/x/), false);\n      assert.strictEqual(_.isNaN('a'), false);\n      assert.strictEqual(_.isNaN(symbol), false);\n    });\n\n    QUnit.test('should work with `NaN` from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.object) {\n        assert.strictEqual(_.isNaN(realm.nan), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isNative');\n\n  (function() {\n    QUnit.test('should return `true` for native methods', function(assert) {\n      assert.expect(1);\n\n      var values = [Array, body && body.cloneNode, create, root.encodeURI, Promise, slice, Uint8Array],\n          expected = lodashStable.map(values, Boolean),\n          actual = lodashStable.map(values, _.isNative);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non-native methods', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isNative(value) : _.isNative();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isNative(args), false);\n      assert.strictEqual(_.isNative([1, 2, 3]), false);\n      assert.strictEqual(_.isNative(true), false);\n      assert.strictEqual(_.isNative(new Date), false);\n      assert.strictEqual(_.isNative(new Error), false);\n      assert.strictEqual(_.isNative(_), false);\n      assert.strictEqual(_.isNative({ 'a': 1 }), false);\n      assert.strictEqual(_.isNative(1), false);\n      assert.strictEqual(_.isNative(/x/), false);\n      assert.strictEqual(_.isNative('a'), false);\n      assert.strictEqual(_.isNative(symbol), false);\n    });\n\n    QUnit.test('should work with native functions from another realm', function(assert) {\n      assert.expect(2);\n\n      if (realm.element) {\n        assert.strictEqual(_.isNative(realm.element.cloneNode), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n      if (realm.object) {\n        assert.strictEqual(_.isNative(realm.object.valueOf), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should throw an error if core-js is detected', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var lodash = _.runInContext({\n          '__core-js_shared__': {}\n        });\n\n        assert.raises(function() { lodash.isNative(noop); });\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should detect methods masquerading as native (test in Node.js)', function(assert) {\n      assert.expect(2);\n\n      if (!amd && _._baseEach) {\n        var path = require('path'),\n            basePath = path.dirname(filePath),\n            uid = 'e0gvgyrad1jor',\n            coreKey = '__core-js_shared__',\n            fakeSrcKey = 'Symbol(src)_1.' + uid;\n\n        root[coreKey] = { 'keys': { 'IE_PROTO': 'Symbol(IE_PROTO)_3.' + uid } };\n        emptyObject(require.cache);\n\n        var baseIsNative = interopRequire(path.join(basePath, '_baseIsNative'));\n        assert.strictEqual(baseIsNative(slice), true);\n\n        slice[fakeSrcKey] = slice + '';\n        assert.strictEqual(baseIsNative(slice), false);\n\n        delete slice[fakeSrcKey];\n        delete root[coreKey];\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isNil');\n\n  (function() {\n    QUnit.test('should return `true` for nullish values', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.isNil(null), true);\n      assert.strictEqual(_.isNil(), true);\n      assert.strictEqual(_.isNil(undefined), true);\n    });\n\n    QUnit.test('should return `false` for non-nullish values', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value == null;\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isNil(value) : _.isNil();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isNil(args), false);\n      assert.strictEqual(_.isNil([1, 2, 3]), false);\n      assert.strictEqual(_.isNil(true), false);\n      assert.strictEqual(_.isNil(new Date), false);\n      assert.strictEqual(_.isNil(new Error), false);\n      assert.strictEqual(_.isNil(_), false);\n      assert.strictEqual(_.isNil(slice), false);\n      assert.strictEqual(_.isNil({ 'a': 1 }), false);\n      assert.strictEqual(_.isNil(1), false);\n      assert.strictEqual(_.isNil(/x/), false);\n      assert.strictEqual(_.isNil('a'), false);\n\n      if (Symbol) {\n        assert.strictEqual(_.isNil(symbol), false);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work with nils from another realm', function(assert) {\n      assert.expect(2);\n\n      if (realm.object) {\n        assert.strictEqual(_.isNil(realm.null), true);\n        assert.strictEqual(_.isNil(realm.undefined), true);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isNull');\n\n  (function() {\n    QUnit.test('should return `true` for `null` values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isNull(null), true);\n    });\n\n    QUnit.test('should return `false` for non `null` values', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === null;\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isNull(value) : _.isNull();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isNull(args), false);\n      assert.strictEqual(_.isNull([1, 2, 3]), false);\n      assert.strictEqual(_.isNull(true), false);\n      assert.strictEqual(_.isNull(new Date), false);\n      assert.strictEqual(_.isNull(new Error), false);\n      assert.strictEqual(_.isNull(_), false);\n      assert.strictEqual(_.isNull(slice), false);\n      assert.strictEqual(_.isNull({ 'a': 1 }), false);\n      assert.strictEqual(_.isNull(1), false);\n      assert.strictEqual(_.isNull(/x/), false);\n      assert.strictEqual(_.isNull('a'), false);\n      assert.strictEqual(_.isNull(symbol), false);\n    });\n\n    QUnit.test('should work with nulls from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.object) {\n        assert.strictEqual(_.isNull(realm.null), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isNumber');\n\n  (function() {\n    QUnit.test('should return `true` for numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.isNumber(0), true);\n      assert.strictEqual(_.isNumber(Object(0)), true);\n      assert.strictEqual(_.isNumber(NaN), true);\n    });\n\n    QUnit.test('should return `false` for non-numbers', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return typeof value == 'number';\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isNumber(value) : _.isNumber();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isNumber(args), false);\n      assert.strictEqual(_.isNumber([1, 2, 3]), false);\n      assert.strictEqual(_.isNumber(true), false);\n      assert.strictEqual(_.isNumber(new Date), false);\n      assert.strictEqual(_.isNumber(new Error), false);\n      assert.strictEqual(_.isNumber(_), false);\n      assert.strictEqual(_.isNumber(slice), false);\n      assert.strictEqual(_.isNumber({ 'a': 1 }), false);\n      assert.strictEqual(_.isNumber(/x/), false);\n      assert.strictEqual(_.isNumber('a'), false);\n      assert.strictEqual(_.isNumber(symbol), false);\n    });\n\n    QUnit.test('should work with numbers from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.number) {\n        assert.strictEqual(_.isNumber(realm.number), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isObject');\n\n  (function() {\n    QUnit.test('should return `true` for objects', function(assert) {\n      assert.expect(13);\n\n      assert.strictEqual(_.isObject(args), true);\n      assert.strictEqual(_.isObject([1, 2, 3]), true);\n      assert.strictEqual(_.isObject(Object(false)), true);\n      assert.strictEqual(_.isObject(new Date), true);\n      assert.strictEqual(_.isObject(new Error), true);\n      assert.strictEqual(_.isObject(_), true);\n      assert.strictEqual(_.isObject(slice), true);\n      assert.strictEqual(_.isObject({ 'a': 1 }), true);\n      assert.strictEqual(_.isObject(Object(0)), true);\n      assert.strictEqual(_.isObject(/x/), true);\n      assert.strictEqual(_.isObject(Object('a')), true);\n\n      if (document) {\n        assert.strictEqual(_.isObject(body), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n      if (Symbol) {\n        assert.strictEqual(_.isObject(Object(symbol)), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non-objects', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat(true, 1, 'a', symbol),\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.isObject(value) : _.isObject();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with objects from another realm', function(assert) {\n      assert.expect(8);\n\n      if (realm.element) {\n        assert.strictEqual(_.isObject(realm.element), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n      if (realm.object) {\n        assert.strictEqual(_.isObject(realm.boolean), true);\n        assert.strictEqual(_.isObject(realm.date), true);\n        assert.strictEqual(_.isObject(realm.function), true);\n        assert.strictEqual(_.isObject(realm.number), true);\n        assert.strictEqual(_.isObject(realm.object), true);\n        assert.strictEqual(_.isObject(realm.regexp), true);\n        assert.strictEqual(_.isObject(realm.string), true);\n      }\n      else {\n        skipAssert(assert, 7);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isObjectLike');\n\n  (function() {\n    QUnit.test('should return `true` for objects', function(assert) {\n      assert.expect(9);\n\n      assert.strictEqual(_.isObjectLike(args), true);\n      assert.strictEqual(_.isObjectLike([1, 2, 3]), true);\n      assert.strictEqual(_.isObjectLike(Object(false)), true);\n      assert.strictEqual(_.isObjectLike(new Date), true);\n      assert.strictEqual(_.isObjectLike(new Error), true);\n      assert.strictEqual(_.isObjectLike({ 'a': 1 }), true);\n      assert.strictEqual(_.isObjectLike(Object(0)), true);\n      assert.strictEqual(_.isObjectLike(/x/), true);\n      assert.strictEqual(_.isObjectLike(Object('a')), true);\n    });\n\n    QUnit.test('should return `false` for non-objects', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat(true, _, slice, 1, 'a', symbol),\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.isObjectLike(value) : _.isObjectLike();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with objects from another realm', function(assert) {\n      assert.expect(6);\n\n      if (realm.object) {\n        assert.strictEqual(_.isObjectLike(realm.boolean), true);\n        assert.strictEqual(_.isObjectLike(realm.date), true);\n        assert.strictEqual(_.isObjectLike(realm.number), true);\n        assert.strictEqual(_.isObjectLike(realm.object), true);\n        assert.strictEqual(_.isObjectLike(realm.regexp), true);\n        assert.strictEqual(_.isObjectLike(realm.string), true);\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isPlainObject');\n\n  (function() {\n    var element = document && document.createElement('div');\n\n    QUnit.test('should detect plain objects', function(assert) {\n      assert.expect(5);\n\n      function Foo(a) {\n        this.a = 1;\n      }\n\n      assert.strictEqual(_.isPlainObject({}), true);\n      assert.strictEqual(_.isPlainObject({ 'a': 1 }), true);\n      assert.strictEqual(_.isPlainObject({ 'constructor': Foo }), true);\n      assert.strictEqual(_.isPlainObject([1, 2, 3]), false);\n      assert.strictEqual(_.isPlainObject(new Foo(1)), false);\n    });\n\n    QUnit.test('should return `true` for objects with a `[[Prototype]]` of `null`', function(assert) {\n      assert.expect(2);\n\n      var object = create(null);\n      assert.strictEqual(_.isPlainObject(object), true);\n\n      object.constructor = objectProto.constructor;\n      assert.strictEqual(_.isPlainObject(object), true);\n    });\n\n    QUnit.test('should return `true` for objects with a `valueOf` property', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.isPlainObject({ 'valueOf': 0 }), true);\n    });\n\n    QUnit.test('should return `true` for objects with a writable `Symbol.toStringTag` property', function(assert) {\n      assert.expect(1);\n\n      if (Symbol && Symbol.toStringTag) {\n        var object = {};\n        object[Symbol.toStringTag] = 'X';\n\n        assert.deepEqual(_.isPlainObject(object), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for objects with a custom `[[Prototype]]`', function(assert) {\n      assert.expect(1);\n\n      var object = create({ 'a': 1 });\n      assert.strictEqual(_.isPlainObject(object), false);\n    });\n\n    QUnit.test('should return `false` for DOM elements', function(assert) {\n      assert.expect(1);\n\n      if (element) {\n        assert.strictEqual(_.isPlainObject(element), false);\n      } else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non-Object objects', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.isPlainObject(arguments), false);\n      assert.strictEqual(_.isPlainObject(Error), false);\n      assert.strictEqual(_.isPlainObject(Math), false);\n    });\n\n    QUnit.test('should return `false` for non-objects', function(assert) {\n      assert.expect(4);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isPlainObject(value) : _.isPlainObject();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isPlainObject(true), false);\n      assert.strictEqual(_.isPlainObject('a'), false);\n      assert.strictEqual(_.isPlainObject(symbol), false);\n    });\n\n    QUnit.test('should return `false` for objects with a read-only `Symbol.toStringTag` property', function(assert) {\n      assert.expect(1);\n\n      if (Symbol && Symbol.toStringTag) {\n        var object = {};\n        defineProperty(object, Symbol.toStringTag, {\n          'configurable': true,\n          'enumerable': false,\n          'writable': false,\n          'value': 'X'\n        });\n\n        assert.deepEqual(_.isPlainObject(object), false);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should not mutate `value`', function(assert) {\n      assert.expect(2);\n\n      if (Symbol && Symbol.toStringTag) {\n        var proto = {};\n        proto[Symbol.toStringTag] = undefined;\n        var object = create(proto);\n\n        assert.strictEqual(_.isPlainObject(object), false);\n        assert.notOk(lodashStable.has(object, Symbol.toStringTag));\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should work with objects from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.object) {\n        assert.strictEqual(_.isPlainObject(realm.object), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isRegExp');\n\n  (function() {\n    QUnit.test('should return `true` for regexes', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.isRegExp(/x/), true);\n      assert.strictEqual(_.isRegExp(RegExp('x')), true);\n    });\n\n    QUnit.test('should return `false` for non-regexes', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isRegExp(value) : _.isRegExp();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isRegExp(args), false);\n      assert.strictEqual(_.isRegExp([1, 2, 3]), false);\n      assert.strictEqual(_.isRegExp(true), false);\n      assert.strictEqual(_.isRegExp(new Date), false);\n      assert.strictEqual(_.isRegExp(new Error), false);\n      assert.strictEqual(_.isRegExp(_), false);\n      assert.strictEqual(_.isRegExp(slice), false);\n      assert.strictEqual(_.isRegExp({ 'a': 1 }), false);\n      assert.strictEqual(_.isRegExp(1), false);\n      assert.strictEqual(_.isRegExp('a'), false);\n      assert.strictEqual(_.isRegExp(symbol), false);\n    });\n\n    QUnit.test('should work with regexes from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.regexp) {\n        assert.strictEqual(_.isRegExp(realm.regexp), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isSet');\n\n  (function() {\n    QUnit.test('should return `true` for sets', function(assert) {\n      assert.expect(1);\n\n      if (Set) {\n        assert.strictEqual(_.isSet(set), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non-sets', function(assert) {\n      assert.expect(14);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isSet(value) : _.isSet();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isSet(args), false);\n      assert.strictEqual(_.isSet([1, 2, 3]), false);\n      assert.strictEqual(_.isSet(true), false);\n      assert.strictEqual(_.isSet(new Date), false);\n      assert.strictEqual(_.isSet(new Error), false);\n      assert.strictEqual(_.isSet(_), false);\n      assert.strictEqual(_.isSet(slice), false);\n      assert.strictEqual(_.isSet({ 'a': 1 }), false);\n      assert.strictEqual(_.isSet(1), false);\n      assert.strictEqual(_.isSet(/x/), false);\n      assert.strictEqual(_.isSet('a'), false);\n      assert.strictEqual(_.isSet(symbol), false);\n      assert.strictEqual(_.isSet(weakSet), false);\n    });\n\n    QUnit.test('should work for objects with a non-function `constructor` (test in IE 11)', function(assert) {\n      assert.expect(1);\n\n      var values = [false, true],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.isSet({ 'constructor': value });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with weak sets from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.set) {\n        assert.strictEqual(_.isSet(realm.set), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isString');\n\n  (function() {\n    QUnit.test('should return `true` for strings', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.isString('a'), true);\n      assert.strictEqual(_.isString(Object('a')), true);\n    });\n\n    QUnit.test('should return `false` for non-strings', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === '';\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isString(value) : _.isString();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isString(args), false);\n      assert.strictEqual(_.isString([1, 2, 3]), false);\n      assert.strictEqual(_.isString(true), false);\n      assert.strictEqual(_.isString(new Date), false);\n      assert.strictEqual(_.isString(new Error), false);\n      assert.strictEqual(_.isString(_), false);\n      assert.strictEqual(_.isString(slice), false);\n      assert.strictEqual(_.isString({ '0': 1, 'length': 1 }), false);\n      assert.strictEqual(_.isString(1), false);\n      assert.strictEqual(_.isString(/x/), false);\n      assert.strictEqual(_.isString(symbol), false);\n    });\n\n    QUnit.test('should work with strings from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.string) {\n        assert.strictEqual(_.isString(realm.string), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isSymbol');\n\n  (function() {\n    QUnit.test('should return `true` for symbols', function(assert) {\n      assert.expect(2);\n\n      if (Symbol) {\n        assert.strictEqual(_.isSymbol(symbol), true);\n        assert.strictEqual(_.isSymbol(Object(symbol)), true);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should return `false` for non-symbols', function(assert) {\n      assert.expect(12);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isSymbol(value) : _.isSymbol();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isSymbol(args), false);\n      assert.strictEqual(_.isSymbol([1, 2, 3]), false);\n      assert.strictEqual(_.isSymbol(true), false);\n      assert.strictEqual(_.isSymbol(new Date), false);\n      assert.strictEqual(_.isSymbol(new Error), false);\n      assert.strictEqual(_.isSymbol(_), false);\n      assert.strictEqual(_.isSymbol(slice), false);\n      assert.strictEqual(_.isSymbol({ '0': 1, 'length': 1 }), false);\n      assert.strictEqual(_.isSymbol(1), false);\n      assert.strictEqual(_.isSymbol(/x/), false);\n      assert.strictEqual(_.isSymbol('a'), false);\n    });\n\n    QUnit.test('should work with symbols from another realm', function(assert) {\n      assert.expect(1);\n\n      if (Symbol && realm.symbol) {\n        assert.strictEqual(_.isSymbol(realm.symbol), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isTypedArray');\n\n  (function() {\n    QUnit.test('should return `true` for typed arrays', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(typedArrays, function(type) {\n        return type in root;\n      });\n\n      var actual = lodashStable.map(typedArrays, function(type) {\n        var Ctor = root[type];\n        return Ctor ? _.isTypedArray(new Ctor(new ArrayBuffer(8))) : false;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `false` for non typed arrays', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isTypedArray(value) : _.isTypedArray();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isTypedArray(args), false);\n      assert.strictEqual(_.isTypedArray([1, 2, 3]), false);\n      assert.strictEqual(_.isTypedArray(true), false);\n      assert.strictEqual(_.isTypedArray(new Date), false);\n      assert.strictEqual(_.isTypedArray(new Error), false);\n      assert.strictEqual(_.isTypedArray(_), false);\n      assert.strictEqual(_.isTypedArray(slice), false);\n      assert.strictEqual(_.isTypedArray({ 'a': 1 }), false);\n      assert.strictEqual(_.isTypedArray(1), false);\n      assert.strictEqual(_.isTypedArray(/x/), false);\n      assert.strictEqual(_.isTypedArray('a'), false);\n      assert.strictEqual(_.isTypedArray(symbol), false);\n    });\n\n    QUnit.test('should work with typed arrays from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.object) {\n        var props = lodashStable.invokeMap(typedArrays, 'toLowerCase');\n\n        var expected = lodashStable.map(props, function(key) {\n          return realm[key] !== undefined;\n        });\n\n        var actual = lodashStable.map(props, function(key) {\n          var value = realm[key];\n          return value ? _.isTypedArray(value) : false;\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isUndefined');\n\n  (function() {\n    QUnit.test('should return `true` for `undefined` values', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.isUndefined(), true);\n      assert.strictEqual(_.isUndefined(undefined), true);\n    });\n\n    QUnit.test('should return `false` for non `undefined` values', function(assert) {\n      assert.expect(13);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined;\n      });\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isUndefined(value) : _.isUndefined();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isUndefined(args), false);\n      assert.strictEqual(_.isUndefined([1, 2, 3]), false);\n      assert.strictEqual(_.isUndefined(true), false);\n      assert.strictEqual(_.isUndefined(new Date), false);\n      assert.strictEqual(_.isUndefined(new Error), false);\n      assert.strictEqual(_.isUndefined(_), false);\n      assert.strictEqual(_.isUndefined(slice), false);\n      assert.strictEqual(_.isUndefined({ 'a': 1 }), false);\n      assert.strictEqual(_.isUndefined(1), false);\n      assert.strictEqual(_.isUndefined(/x/), false);\n      assert.strictEqual(_.isUndefined('a'), false);\n\n      if (Symbol) {\n        assert.strictEqual(_.isUndefined(symbol), false);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work with `undefined` from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.object) {\n        assert.strictEqual(_.isUndefined(realm.undefined), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isWeakMap');\n\n  (function() {\n    QUnit.test('should return `true` for weak maps', function(assert) {\n      assert.expect(1);\n\n      if (WeakMap) {\n        assert.strictEqual(_.isWeakMap(weakMap), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non weak maps', function(assert) {\n      assert.expect(14);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isWeakMap(value) : _.isWeakMap();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isWeakMap(args), false);\n      assert.strictEqual(_.isWeakMap([1, 2, 3]), false);\n      assert.strictEqual(_.isWeakMap(true), false);\n      assert.strictEqual(_.isWeakMap(new Date), false);\n      assert.strictEqual(_.isWeakMap(new Error), false);\n      assert.strictEqual(_.isWeakMap(_), false);\n      assert.strictEqual(_.isWeakMap(slice), false);\n      assert.strictEqual(_.isWeakMap({ 'a': 1 }), false);\n      assert.strictEqual(_.isWeakMap(map), false);\n      assert.strictEqual(_.isWeakMap(1), false);\n      assert.strictEqual(_.isWeakMap(/x/), false);\n      assert.strictEqual(_.isWeakMap('a'), false);\n      assert.strictEqual(_.isWeakMap(symbol), false);\n    });\n\n    QUnit.test('should work for objects with a non-function `constructor` (test in IE 11)', function(assert) {\n      assert.expect(1);\n\n      var values = [false, true],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.isWeakMap({ 'constructor': value });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with weak maps from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.weakMap) {\n        assert.strictEqual(_.isWeakMap(realm.weakMap), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.isWeakSet');\n\n  (function() {\n    QUnit.test('should return `true` for weak sets', function(assert) {\n      assert.expect(1);\n\n      if (WeakSet) {\n        assert.strictEqual(_.isWeakSet(weakSet), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return `false` for non weak sets', function(assert) {\n      assert.expect(14);\n\n      var expected = lodashStable.map(falsey, stubFalse);\n\n      var actual = lodashStable.map(falsey, function(value, index) {\n        return index ? _.isWeakSet(value) : _.isWeakSet();\n      });\n\n      assert.deepEqual(actual, expected);\n\n      assert.strictEqual(_.isWeakSet(args), false);\n      assert.strictEqual(_.isWeakSet([1, 2, 3]), false);\n      assert.strictEqual(_.isWeakSet(true), false);\n      assert.strictEqual(_.isWeakSet(new Date), false);\n      assert.strictEqual(_.isWeakSet(new Error), false);\n      assert.strictEqual(_.isWeakSet(_), false);\n      assert.strictEqual(_.isWeakSet(slice), false);\n      assert.strictEqual(_.isWeakSet({ 'a': 1 }), false);\n      assert.strictEqual(_.isWeakSet(1), false);\n      assert.strictEqual(_.isWeakSet(/x/), false);\n      assert.strictEqual(_.isWeakSet('a'), false);\n      assert.strictEqual(_.isWeakSet(set), false);\n      assert.strictEqual(_.isWeakSet(symbol), false);\n    });\n\n    QUnit.test('should work with weak sets from another realm', function(assert) {\n      assert.expect(1);\n\n      if (realm.weakSet) {\n        assert.strictEqual(_.isWeakSet(realm.weakSet), true);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('isType checks');\n\n  (function() {\n    QUnit.test('should return `false` for subclassed values', function(assert) {\n      assert.expect(7);\n\n      var funcs = [\n        'isArray', 'isBoolean', 'isDate', 'isFunction',\n        'isNumber', 'isRegExp', 'isString'\n      ];\n\n      lodashStable.each(funcs, function(methodName) {\n        function Foo() {}\n        Foo.prototype = root[methodName.slice(2)].prototype;\n\n        var object = new Foo;\n        if (objToString.call(object) == objectTag) {\n          assert.strictEqual(_[methodName](object), false, '`_.' + methodName + '` returns `false`');\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    QUnit.test('should not error on host objects (test in IE)', function(assert) {\n      assert.expect(26);\n\n      var funcs = [\n        'isArguments', 'isArray', 'isArrayBuffer', 'isArrayLike', 'isBoolean',\n        'isBuffer', 'isDate', 'isElement', 'isError', 'isFinite', 'isFunction',\n        'isInteger', 'isMap', 'isNaN', 'isNil', 'isNull', 'isNumber', 'isObject',\n        'isObjectLike', 'isRegExp', 'isSet', 'isSafeInteger', 'isString',\n        'isUndefined', 'isWeakMap', 'isWeakSet'\n      ];\n\n      lodashStable.each(funcs, function(methodName) {\n        if (xml) {\n          _[methodName](xml);\n          assert.ok(true, '`_.' + methodName + '` should not error');\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.iteratee');\n\n  (function() {\n    QUnit.test('should provide arguments to `func`', function(assert) {\n      assert.expect(1);\n\n      var fn = function() { return slice.call(arguments); },\n          iteratee = _.iteratee(fn),\n          actual = iteratee('a', 'b', 'c', 'd', 'e', 'f');\n\n      assert.deepEqual(actual, ['a', 'b', 'c', 'd', 'e', 'f']);\n    });\n\n    QUnit.test('should return `_.identity` when `func` is nullish', function(assert) {\n      assert.expect(1);\n\n      var object = {},\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([!isNpm && _.identity, object]));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var identity = index ? _.iteratee(value) : _.iteratee();\n        return [!isNpm && identity, identity(object)];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an iteratee created by `_.matches` when `func` is an object', function(assert) {\n      assert.expect(2);\n\n      var matches = _.iteratee({ 'a': 1, 'b': 2 });\n      assert.strictEqual(matches({ 'a': 1, 'b': 2, 'c': 3 }), true);\n      assert.strictEqual(matches({ 'b': 2 }), false);\n    });\n\n    QUnit.test('should not change `_.matches` behavior if `source` is modified', function(assert) {\n      assert.expect(9);\n\n      var sources = [\n        { 'a': { 'b': 2, 'c': 3 } },\n        { 'a': 1, 'b': 2 },\n        { 'a': 1 }\n      ];\n\n      lodashStable.each(sources, function(source, index) {\n        var object = lodashStable.cloneDeep(source),\n            matches = _.iteratee(source);\n\n        assert.strictEqual(matches(object), true);\n\n        if (index) {\n          source.a = 2;\n          source.b = 1;\n          source.c = 3;\n        } else {\n          source.a.b = 1;\n          source.a.c = 2;\n          source.a.d = 3;\n        }\n        assert.strictEqual(matches(object), true);\n        assert.strictEqual(matches(source), false);\n      });\n    });\n\n    QUnit.test('should return an iteratee created by `_.matchesProperty` when `func` is an array', function(assert) {\n      assert.expect(3);\n\n      var array = ['a', undefined],\n          matches = _.iteratee([0, 'a']);\n\n      assert.strictEqual(matches(array), true);\n\n      matches = _.iteratee(['0', 'a']);\n      assert.strictEqual(matches(array), true);\n\n      matches = _.iteratee([1, undefined]);\n      assert.strictEqual(matches(array), true);\n    });\n\n    QUnit.test('should support deep paths for `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': { 'c': 1, 'd': 2 } } },\n          matches = _.iteratee(['a.b', { 'c': 1 }]);\n\n      assert.strictEqual(matches(object), true);\n    });\n\n    QUnit.test('should not change `_.matchesProperty` behavior if `source` is modified', function(assert) {\n      assert.expect(9);\n\n      var sources = [\n        { 'a': { 'b': 2, 'c': 3 } },\n        { 'a': 1, 'b': 2 },\n        { 'a': 1 }\n      ];\n\n      lodashStable.each(sources, function(source, index) {\n        var object = { 'a': lodashStable.cloneDeep(source) },\n            matches = _.iteratee(['a', source]);\n\n        assert.strictEqual(matches(object), true);\n\n        if (index) {\n          source.a = 2;\n          source.b = 1;\n          source.c = 3;\n        } else {\n          source.a.b = 1;\n          source.a.c = 2;\n          source.a.d = 3;\n        }\n        assert.strictEqual(matches(object), true);\n        assert.strictEqual(matches({ 'a': source }), false);\n      });\n    });\n\n    QUnit.test('should return an iteratee created by `_.property` when `func` is a number or string', function(assert) {\n      assert.expect(2);\n\n      var array = ['a'],\n          prop = _.iteratee(0);\n\n      assert.strictEqual(prop(array), 'a');\n\n      prop = _.iteratee('0');\n      assert.strictEqual(prop(array), 'a');\n    });\n\n    QUnit.test('should support deep paths for `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': 2 } },\n          prop = _.iteratee('a.b');\n\n      assert.strictEqual(prop(object), 2);\n    });\n\n    QUnit.test('should work with functions created by `_.partial` and `_.partialRight`', function(assert) {\n      assert.expect(2);\n\n      var fn = function() {\n        var result = [this.a];\n        push.apply(result, arguments);\n        return result;\n      };\n\n      var expected = [1, 2, 3],\n          object = { 'a': 1 , 'iteratee': _.iteratee(_.partial(fn, 2)) };\n\n      assert.deepEqual(object.iteratee(3), expected);\n\n      object.iteratee = _.iteratee(_.partialRight(fn, 3));\n      assert.deepEqual(object.iteratee(2), expected);\n    });\n\n    QUnit.test('should use internal `iteratee` if external is unavailable', function(assert) {\n      assert.expect(1);\n\n      var iteratee = _.iteratee;\n      delete _.iteratee;\n\n      assert.deepEqual(_.map([{ 'a': 1 }], 'a'), [1]);\n\n      _.iteratee = iteratee;\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var fn = function() { return this instanceof Number; },\n          array = [fn, fn, fn],\n          iteratees = lodashStable.map(array, _.iteratee),\n          expected = lodashStable.map(array, stubFalse);\n\n      var actual = lodashStable.map(iteratees, function(iteratee) {\n        return iteratee();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('custom `_.iteratee` methods');\n\n  (function() {\n    var array = ['one', 'two', 'three'],\n        getPropA = _.partial(_.property, 'a'),\n        getPropB = _.partial(_.property, 'b'),\n        getLength = _.partial(_.property, 'length'),\n        iteratee = _.iteratee;\n\n    var getSum = function() {\n      return function(result, object) {\n        return result + object.a;\n      };\n    };\n\n    var objects = [\n      { 'a': 0, 'b': 0 },\n      { 'a': 1, 'b': 0 },\n      { 'a': 1, 'b': 1 }\n    ];\n\n    QUnit.test('`_.countBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getLength;\n        assert.deepEqual(_.countBy(array), { '3': 2, '5': 1 });\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.differenceBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.deepEqual(_.differenceBy(objects, [objects[1]]), [objects[0]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.dropRightWhile` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.dropRightWhile(objects), objects.slice(0, 2));\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.dropWhile` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.dropWhile(objects.reverse()).reverse(), objects.reverse().slice(0, 2));\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.every` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.strictEqual(_.every(objects.slice(1)), true);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.filter` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var objects = [{ 'a': 0 }, { 'a': 1 }];\n\n        _.iteratee = getPropA;\n        assert.deepEqual(_.filter(objects), [objects[1]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.find` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.strictEqual(_.find(objects), objects[1]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.findIndex` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.strictEqual(_.findIndex(objects), 1);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.findLast` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.strictEqual(_.findLast(objects), objects[2]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.findLastIndex` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.strictEqual(_.findLastIndex(objects), 2);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.findKey` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.strictEqual(_.findKey(objects), '2');\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.findLastKey` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.strictEqual(_.findLastKey(objects), '2');\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.groupBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getLength;\n        assert.deepEqual(_.groupBy(array), { '3': ['one', 'two'], '5': ['three'] });\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.intersectionBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.deepEqual(_.intersectionBy(objects, [objects[2]]), [objects[1]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.keyBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getLength;\n        assert.deepEqual(_.keyBy(array), { '3': 'two', '5': 'three' });\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.map` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.deepEqual(_.map(objects), [0, 1, 1]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.mapKeys` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.mapKeys({ 'a': { 'b': 2 } }), { '2':  { 'b': 2 } });\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.mapValues` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.mapValues({ 'a': { 'b': 2 } }), { 'a': 2 });\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.maxBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.maxBy(objects), objects[2]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.meanBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.strictEqual(_.meanBy(objects), 2 / 3);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.minBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.minBy(objects), objects[0]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.partition` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var objects = [{ 'a': 1 }, { 'a': 1 }, { 'b': 2 }];\n\n        _.iteratee = getPropA;\n        assert.deepEqual(_.partition(objects), [objects.slice(0, 2), objects.slice(2)]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.pullAllBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.deepEqual(_.pullAllBy(objects.slice(), [{ 'a': 1, 'b': 0 }]), [objects[0]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.reduce` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getSum;\n        assert.strictEqual(_.reduce(objects, undefined, 0), 2);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.reduceRight` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getSum;\n        assert.strictEqual(_.reduceRight(objects, undefined, 0), 2);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.reject` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var objects = [{ 'a': 0 }, { 'a': 1 }];\n\n        _.iteratee = getPropA;\n        assert.deepEqual(_.reject(objects), [objects[0]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.remove` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var objects = [{ 'a': 0 }, { 'a': 1 }];\n\n        _.iteratee = getPropA;\n        _.remove(objects);\n        assert.deepEqual(objects, [{ 'a': 0 }]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.some` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.strictEqual(_.some(objects), true);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.sortBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.deepEqual(_.sortBy(objects.slice().reverse()), [objects[0], objects[2], objects[1]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.sortedIndexBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var objects = [{ 'a': 30 }, { 'a': 50 }];\n\n        _.iteratee = getPropA;\n        assert.strictEqual(_.sortedIndexBy(objects, { 'a': 40 }), 1);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.sortedLastIndexBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var objects = [{ 'a': 30 }, { 'a': 50 }];\n\n        _.iteratee = getPropA;\n        assert.strictEqual(_.sortedLastIndexBy(objects, { 'a': 40 }), 1);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.sumBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.strictEqual(_.sumBy(objects), 1);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.takeRightWhile` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.takeRightWhile(objects), objects.slice(2));\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.takeWhile` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.takeWhile(objects.reverse()), objects.reverse().slice(2));\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.transform` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = function() {\n          return function(result, object) {\n            result.sum += object.a;\n          };\n        };\n\n        assert.deepEqual(_.transform(objects, undefined, { 'sum': 0 }), { 'sum': 2 });\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.uniqBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.uniqBy(objects), [objects[0], objects[2]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.unionBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropB;\n        assert.deepEqual(_.unionBy(objects.slice(0, 1), [objects[2]]), [objects[0], objects[2]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.xorBy` should use `_.iteratee` internally', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        _.iteratee = getPropA;\n        assert.deepEqual(_.xorBy(objects, objects.slice(1)), [objects[0]]);\n        _.iteratee = iteratee;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.join');\n\n  (function() {\n    var array = ['a', 'b', 'c'];\n\n    QUnit.test('should return join all array elements into a string', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.join(array, '~'), 'a~b~c');\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(array);\n        assert.strictEqual(wrapped.join('~'), 'a~b~c');\n        assert.strictEqual(wrapped.value(), array);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(array).chain().join('~') instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.keyBy');\n\n  (function() {\n    var array = [\n      { 'dir': 'left', 'code': 97 },\n      { 'dir': 'right', 'code': 100 }\n    ];\n\n    QUnit.test('should transform keys by `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } };\n\n      var actual = _.keyBy(array, function(object) {\n        return String.fromCharCode(object.code);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var array = [4, 6, 6],\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant({ '4': 4, '6': 6 }));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.keyBy(array, value) : _.keyBy(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } },\n          actual = _.keyBy(array, 'dir');\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should only add values to own, not inherited, properties', function(assert) {\n      assert.expect(2);\n\n      var actual = _.keyBy([6.1, 4.2, 6.3], function(n) {\n        return Math.floor(n) > 4 ? 'hasOwnProperty' : 'constructor';\n      });\n\n      assert.deepEqual(actual.constructor, 4.2);\n      assert.deepEqual(actual.hasOwnProperty, 6.3);\n    });\n\n    QUnit.test('should work with a number for `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var array = [\n        [1, 'a'],\n        [2, 'a'],\n        [2, 'b']\n      ];\n\n      assert.deepEqual(_.keyBy(array, 0), { '1': [1, 'a'], '2': [2, 'b'] });\n      assert.deepEqual(_.keyBy(array, 1), { 'a': [2, 'a'], 'b': [2, 'b'] });\n    });\n\n    QUnit.test('should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.keyBy({ 'a': 6.1, 'b': 4.2, 'c': 6.3 }, Math.floor);\n      assert.deepEqual(actual, { '4': 4.2, '6': 6.3 });\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE).concat(\n          lodashStable.range(Math.floor(LARGE_ARRAY_SIZE / 2), LARGE_ARRAY_SIZE),\n          lodashStable.range(Math.floor(LARGE_ARRAY_SIZE / 1.5), LARGE_ARRAY_SIZE)\n        );\n\n        var actual = _(array).keyBy().map(square).filter(isEven).take().value();\n\n        assert.deepEqual(actual, _.take(_.filter(_.map(_.keyBy(array), square), isEven)));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('keys methods');\n\n  lodashStable.each(['keys', 'keysIn'], function(methodName) {\n    var func = _[methodName],\n        isKeys = methodName == 'keys';\n\n    QUnit.test('`_.' + methodName + '` should return the string keyed property names of `object`', function(assert) {\n      assert.expect(1);\n\n      var actual = func({ 'a': 1, 'b': 1 }).sort();\n\n      assert.deepEqual(actual, ['a', 'b']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isKeys ? 'not ' : '') + 'include inherited string keyed properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var expected = isKeys ? ['a'] : ['a', 'b'],\n          actual = func(new Foo).sort();\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat sparse arrays as dense', function(assert) {\n      assert.expect(1);\n\n      var array = [1];\n      array[2] = 3;\n\n      var actual = func(array).sort();\n\n      assert.deepEqual(actual, ['0', '1', '2']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return keys for custom properties on arrays', function(assert) {\n      assert.expect(1);\n\n      var array = [1];\n      array.a = 1;\n\n      var actual = func(array).sort();\n\n      assert.deepEqual(actual, ['0', 'a']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isKeys ? 'not ' : '') + 'include inherited string keyed properties of arrays', function(assert) {\n      assert.expect(1);\n\n      arrayProto.a = 1;\n\n      var expected = isKeys ? ['0'] : ['0', 'a'],\n          actual = func([1]).sort();\n\n      assert.deepEqual(actual, expected);\n\n      delete arrayProto.a;\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      var values = [args, strictArgs],\n          expected = lodashStable.map(values, lodashStable.constant(['0', '1', '2']));\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(value).sort();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return keys for custom properties on `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      var values = [args, strictArgs],\n          expected = lodashStable.map(values, lodashStable.constant(['0', '1', '2', 'a']));\n\n      var actual = lodashStable.map(values, function(value) {\n        value.a = 1;\n        var result = func(value).sort();\n        delete value.a;\n        return result;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isKeys ? 'not ' : '') + 'include inherited string keyed properties of `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      var values = [args, strictArgs],\n          expected = lodashStable.map(values, lodashStable.constant(isKeys ? ['0', '1', '2'] : ['0', '1', '2', 'a']));\n\n      var actual = lodashStable.map(values, function(value) {\n        objectProto.a = 1;\n        var result = func(value).sort();\n        delete objectProto.a;\n        return result;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with string objects', function(assert) {\n      assert.expect(1);\n\n      var actual = func(Object('abc')).sort();\n\n      assert.deepEqual(actual, ['0', '1', '2']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return keys for custom properties on string objects', function(assert) {\n      assert.expect(1);\n\n      var object = Object('a');\n      object.a = 1;\n\n      var actual = func(object).sort();\n\n      assert.deepEqual(actual, ['0', 'a']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isKeys ? 'not ' : '') + 'include inherited string keyed properties of string objects', function(assert) {\n      assert.expect(1);\n\n      stringProto.a = 1;\n\n      var expected = isKeys ? ['0'] : ['0', 'a'],\n          actual = func(Object('a')).sort();\n\n      assert.deepEqual(actual, expected);\n\n      delete stringProto.a;\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with array-like objects', function(assert) {\n      assert.expect(1);\n\n      var object = { '0': 'a', 'length': 1 },\n          actual = func(object).sort();\n\n      assert.deepEqual(actual, ['0', 'length']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce primitives to objects (test in IE 9)', function(assert) {\n      assert.expect(2);\n\n      var expected = lodashStable.map(primitives, function(value) {\n        return typeof value == 'string' ? ['0'] : [];\n      });\n\n      var actual = lodashStable.map(primitives, func);\n      assert.deepEqual(actual, expected);\n\n      // IE 9 doesn't box numbers in for-in loops.\n      numberProto.a = 1;\n      assert.deepEqual(func(0), isKeys ? [] : ['a']);\n      delete numberProto.a;\n    });\n\n    QUnit.test('`_.' + methodName + '` skips the `constructor` property on prototype objects', function(assert) {\n      assert.expect(3);\n\n      function Foo() {}\n      Foo.prototype.a = 1;\n\n      var expected = ['a'];\n      assert.deepEqual(func(Foo.prototype), expected);\n\n      Foo.prototype = { 'constructor': Foo, 'a': 1 };\n      assert.deepEqual(func(Foo.prototype), expected);\n\n      var Fake = { 'prototype': {} };\n      Fake.prototype.constructor = Fake;\n      assert.deepEqual(func(Fake.prototype), ['constructor']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an empty array when `object` is nullish', function(assert) {\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubArray);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        objectProto.a = 1;\n        var result = index ? func(value) : func();\n        delete objectProto.a;\n        return result;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.last');\n\n  (function() {\n    var array = [1, 2, 3, 4];\n\n    QUnit.test('should return the last element', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.last(array), 4);\n    });\n\n    QUnit.test('should return `undefined` when querying empty arrays', function(assert) {\n      assert.expect(1);\n\n      var array = [];\n      array['-1'] = 1;\n\n      assert.strictEqual(_.last([]), undefined);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.last);\n\n      assert.deepEqual(actual, [3, 6, 9]);\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.strictEqual(_(array).last(), 4);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(array).chain().last() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should not execute immediately when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _(array).chain().last();\n        assert.strictEqual(wrapped.__wrapped__, array);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var largeArray = lodashStable.range(LARGE_ARRAY_SIZE),\n            smallArray = array;\n\n        lodashStable.times(2, function(index) {\n          var array = index ? largeArray : smallArray,\n              wrapped = _(array).filter(isEven);\n\n          assert.strictEqual(wrapped.last(), _.last(_.filter(array, isEven)));\n        });\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.lowerCase');\n\n  (function() {\n    QUnit.test('should lowercase as space-separated words', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.lowerCase('--Foo-Bar--'), 'foo bar');\n      assert.strictEqual(_.lowerCase('fooBar'), 'foo bar');\n      assert.strictEqual(_.lowerCase('__FOO_BAR__'), 'foo bar');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.lowerFirst');\n\n  (function() {\n    QUnit.test('should lowercase only the first character', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.lowerFirst('fred'), 'fred');\n      assert.strictEqual(_.lowerFirst('Fred'), 'fred');\n      assert.strictEqual(_.lowerFirst('FRED'), 'fRED');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.lt');\n\n  (function() {\n    QUnit.test('should return `true` if `value` is less than `other`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.lt(1, 3), true);\n      assert.strictEqual(_.lt('abc', 'def'), true);\n    });\n\n    QUnit.test('should return `false` if `value` >= `other`', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.lt(3, 1), false);\n      assert.strictEqual(_.lt(3, 3), false);\n      assert.strictEqual(_.lt('def', 'abc'), false);\n      assert.strictEqual(_.lt('def', 'def'), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.lte');\n\n  (function() {\n    QUnit.test('should return `true` if `value` is <= `other`', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.lte(1, 3), true);\n      assert.strictEqual(_.lte(3, 3), true);\n      assert.strictEqual(_.lte('abc', 'def'), true);\n      assert.strictEqual(_.lte('def', 'def'), true);\n    });\n\n    QUnit.test('should return `false` if `value` > `other`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.lt(3, 1), false);\n      assert.strictEqual(_.lt('def', 'abc'), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.findLastIndex and lodash.lastIndexOf');\n\n  lodashStable.each(['findLastIndex', 'lastIndexOf'], function(methodName) {\n    var array = [1, 2, 3, 1, 2, 3],\n        func = _[methodName],\n        resolve = methodName == 'findLastIndex' ? lodashStable.curry(lodashStable.eq) : identity;\n\n    QUnit.test('`_.' + methodName + '` should return the index of the last matched value', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(3)), 5);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a positive `fromIndex`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(1), 2), 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a `fromIndex` >= `length`', function(assert) {\n      assert.expect(1);\n\n      var values = [6, 8, Math.pow(2, 32), Infinity],\n          expected = lodashStable.map(values, lodashStable.constant([-1, 3, -1]));\n\n      var actual = lodashStable.map(values, function(fromIndex) {\n        return [\n          func(array, resolve(undefined), fromIndex),\n          func(array, resolve(1), fromIndex),\n          func(array, resolve(''), fromIndex)\n        ];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a negative `fromIndex`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(2), -3), 1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a negative `fromIndex` <= `-length`', function(assert) {\n      assert.expect(1);\n\n      var values = [-6, -8, -Infinity],\n          expected = lodashStable.map(values, stubZero);\n\n      var actual = lodashStable.map(values, function(fromIndex) {\n        return func(array, resolve(1), fromIndex);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat falsey `fromIndex` values correctly', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? 5 : -1;\n      });\n\n      var actual = lodashStable.map(falsey, function(fromIndex) {\n        return func(array, resolve(3), fromIndex);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `fromIndex` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array, resolve(2), 4.2), 4);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('indexOf methods');\n\n  lodashStable.each(['indexOf', 'lastIndexOf', 'sortedIndexOf', 'sortedLastIndexOf'], function(methodName) {\n    var func = _[methodName],\n        isIndexOf = !/last/i.test(methodName),\n        isSorted = /^sorted/.test(methodName);\n\n    QUnit.test('`_.' + methodName + '` should accept a falsey `array`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, lodashStable.constant(-1));\n\n      var actual = lodashStable.map(falsey, function(array, index) {\n        try {\n          return index ? func(array) : func();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `-1` for an unmatched value', function(assert) {\n      assert.expect(5);\n\n      var array = [1, 2, 3],\n          empty = [];\n\n      assert.strictEqual(func(array, 4), -1);\n      assert.strictEqual(func(array, 4, true), -1);\n      assert.strictEqual(func(array, undefined, true), -1);\n\n      assert.strictEqual(func(empty, undefined), -1);\n      assert.strictEqual(func(empty, undefined, true), -1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not match values on empty arrays', function(assert) {\n      assert.expect(2);\n\n      var array = [];\n      array[-1] = 0;\n\n      assert.strictEqual(func(array, undefined), -1);\n      assert.strictEqual(func(array, 0, true), -1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `NaN`', function(assert) {\n      assert.expect(3);\n\n      var array = isSorted\n        ? [1, 2, NaN, NaN]\n        : [1, NaN, 3, NaN, 5, NaN];\n\n      if (isSorted) {\n        assert.strictEqual(func(array, NaN, true), isIndexOf ? 2 : 3);\n        skipAssert(assert, 2);\n      }\n      else {\n        assert.strictEqual(func(array, NaN), isIndexOf ? 1 : 5);\n        assert.strictEqual(func(array, NaN, 2), isIndexOf ? 3 : 1);\n        assert.strictEqual(func(array, NaN, -2), isIndexOf ? 5 : 3);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `-0` as `0`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(func([-0], 0), 0);\n      assert.strictEqual(func([0], -0), 0);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.map');\n\n  (function() {\n    var array = [1, 2];\n\n    QUnit.test('should map values in `collection` to a new array', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1, 'b': 2 },\n          expected = ['1', '2'];\n\n      assert.deepEqual(_.map(array, String), expected);\n      assert.deepEqual(_.map(object, String), expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': 'x' }, { 'a': 'y' }];\n      assert.deepEqual(_.map(objects, 'a'), ['x', 'y']);\n    });\n\n    QUnit.test('should iterate over own string keyed properties of objects', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var actual = _.map(new Foo, identity);\n      assert.deepEqual(actual, [1]);\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1, 'b': 2 },\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([1, 2]));\n\n      lodashStable.each([array, object], function(collection) {\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? _.map(collection, value) : _.map(collection);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should accept a falsey `collection`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubArray);\n\n      var actual = lodashStable.map(falsey, function(collection, index) {\n        try {\n          return index ? _.map(collection) : _.map();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should treat number values for `collection` as empty', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.map(1), []);\n    });\n\n    QUnit.test('should treat a nodelist as an array-like object', function(assert) {\n      assert.expect(1);\n\n      if (document) {\n        var actual = _.map(document.getElementsByTagName('body'), function(element) {\n          return element.nodeName.toLowerCase();\n        });\n\n        assert.deepEqual(actual, ['body']);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should work with objects with non-number length properties', function(assert) {\n      assert.expect(1);\n\n      var value = { 'value': 'x' },\n          object = { 'length': { 'value': 'x' } };\n\n      assert.deepEqual(_.map(object, identity), [value]);\n    });\n\n    QUnit.test('should return a wrapped value when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(array).map(noop) instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should provide correct `predicate` arguments in a lazy sequence', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var args,\n            array = lodashStable.range(LARGE_ARRAY_SIZE + 1),\n            expected = [1, 0, _.map(array.slice(1), square)];\n\n        _(array).slice(1).map(function(value, index, array) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, [1, 0, array.slice(1)]);\n\n        args = undefined;\n        _(array).slice(1).map(square).map(function(value, index, array) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        args = undefined;\n        _(array).slice(1).map(square).map(function(value, index) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        args = undefined;\n        _(array).slice(1).map(square).map(function(value) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, [1]);\n\n        args = undefined;\n        _(array).slice(1).map(square).map(function() {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, expected);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.mapKeys');\n\n  (function() {\n    var array = [1, 2],\n        object = { 'a': 1, 'b': 2 };\n\n    QUnit.test('should map keys in `object` to a new object', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mapKeys(object, String);\n      assert.deepEqual(actual, { '1': 1, '2': 2 });\n    });\n\n    QUnit.test('should treat arrays like objects', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mapKeys(array, String);\n      assert.deepEqual(actual, { '1': 1, '2': 2 });\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mapKeys({ 'a': { 'b': 'c' } }, 'b');\n      assert.deepEqual(actual, { 'c': { 'b': 'c' } });\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2 },\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant({ '1': 1, '2': 2 }));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.mapKeys(object, value) : _.mapKeys(object);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.mapValues');\n\n  (function() {\n    var array = [1, 2],\n        object = { 'a': 1, 'b': 2 };\n\n    QUnit.test('should map values in `object` to a new object', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mapValues(object, String);\n      assert.deepEqual(actual, { 'a': '1', 'b': '2' });\n    });\n\n    QUnit.test('should treat arrays like objects', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mapValues(array, String);\n      assert.deepEqual(actual, { '0': '1', '1': '2' });\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mapValues({ 'a': { 'b': 2 } }, 'b');\n      assert.deepEqual(actual, { 'a': 2 });\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2 },\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([true, false]));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var result = index ? _.mapValues(object, value) : _.mapValues(object);\n        return [lodashStable.isEqual(result, object), result === object];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.mapKeys and lodash.mapValues');\n\n  lodashStable.each(['mapKeys', 'mapValues'], function(methodName) {\n    var func = _[methodName],\n        object = { 'a': 1, 'b': 2 };\n\n    QUnit.test('`_.' + methodName + '` should iterate over own string keyed properties of objects', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 'a';\n      }\n      Foo.prototype.b = 'b';\n\n      var actual = func(new Foo, function(value, key) { return key; });\n      assert.deepEqual(actual, { 'a': 'a' });\n    });\n\n    QUnit.test('`_.' + methodName + '` should accept a falsey `object`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubObject);\n\n      var actual = lodashStable.map(falsey, function(object, index) {\n        try {\n          return index ? func(object) : func();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(object)[methodName](noop) instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  QUnit.module('lodash.matches');\n\n  (function() {\n    QUnit.test('should not change behavior if `source` is modified', function(assert) {\n      assert.expect(9);\n\n      var sources = [\n        { 'a': { 'b': 2, 'c': 3 } },\n        { 'a': 1, 'b': 2 },\n        { 'a': 1 }\n      ];\n\n      lodashStable.each(sources, function(source, index) {\n        var object = lodashStable.cloneDeep(source),\n            par = _.matches(source);\n\n        assert.strictEqual(par(object), true);\n\n        if (index) {\n          source.a = 2;\n          source.b = 1;\n          source.c = 3;\n        } else {\n          source.a.b = 1;\n          source.a.c = 2;\n          source.a.d = 3;\n        }\n        assert.strictEqual(par(object), true);\n        assert.strictEqual(par(source), false);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('matches methods');\n\n  lodashStable.each(['matches', 'isMatch'], function(methodName) {\n    var isMatches = methodName == 'matches';\n\n    function matches(source) {\n      return isMatches ? _.matches(source) : function(object) {\n        return _.isMatch(object, source);\n      };\n    }\n\n    QUnit.test('`_.' + methodName + '` should perform a deep comparison between `source` and `object`', function(assert) {\n      assert.expect(5);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          par = matches({ 'a': 1 });\n\n      assert.strictEqual(par(object), true);\n\n      par = matches({ 'b': 1 });\n      assert.strictEqual(par(object), false);\n\n      par = matches({ 'a': 1, 'c': 3 });\n      assert.strictEqual(par(object), true);\n\n      par = matches({ 'c': 3, 'd': 4 });\n      assert.strictEqual(par(object), false);\n\n      object = { 'a': { 'b': { 'c': 1, 'd': 2 }, 'e': 3 }, 'f': 4 };\n      par = matches({ 'a': { 'b': { 'c': 1 } } });\n\n      assert.strictEqual(par(object), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match inherited string keyed `object` properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var object = { 'a': new Foo },\n          par = matches({ 'a': { 'b': 2 } });\n\n      assert.strictEqual(par(object), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not match by inherited `source` properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var objects = [{ 'a': 1 }, { 'a': 1, 'b': 2 }],\n          source = new Foo,\n          actual = lodashStable.map(objects, matches(source)),\n          expected = lodashStable.map(objects, stubTrue);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should compare a variety of `source` property values', function(assert) {\n      assert.expect(2);\n\n      var object1 = { 'a': false, 'b': true, 'c': '3', 'd': 4, 'e': [5], 'f': { 'g': 6 } },\n          object2 = { 'a': 0, 'b': 1, 'c': 3, 'd': '4', 'e': ['5'], 'f': { 'g': '6' } },\n          par = matches(object1);\n\n      assert.strictEqual(par(object1), true);\n      assert.strictEqual(par(object2), false);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `-0` as `0`', function(assert) {\n      assert.expect(2);\n\n      var object1 = { 'a': -0 },\n          object2 = { 'a': 0 },\n          par = matches(object1);\n\n      assert.strictEqual(par(object2), true);\n\n      par = matches(object2);\n      assert.strictEqual(par(object1), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should compare functions by reference', function(assert) {\n      assert.expect(3);\n\n      var object1 = { 'a': lodashStable.noop },\n          object2 = { 'a': noop },\n          object3 = { 'a': {} },\n          par = matches(object1);\n\n      assert.strictEqual(par(object1), true);\n      assert.strictEqual(par(object2), false);\n      assert.strictEqual(par(object3), false);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a function for `object`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.a = { 'b': 2, 'c': 3 };\n\n      var par = matches({ 'a': { 'b': 2 } });\n      assert.strictEqual(par(Foo), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a function for `source`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.a = 1;\n      Foo.b = function() {};\n      Foo.c = 3;\n\n      var objects = [{ 'a': 1 }, { 'a': 1, 'b': Foo.b, 'c': 3 }],\n          actual = lodashStable.map(objects, matches(Foo));\n\n      assert.deepEqual(actual, [false, true]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a non-plain `object`', function(assert) {\n      assert.expect(1);\n\n      function Foo(object) { lodashStable.assign(this, object); }\n\n      var object = new Foo({ 'a': new Foo({ 'b': 2, 'c': 3 }) }),\n          par = matches({ 'a': { 'b': 2 } });\n\n      assert.strictEqual(par(object), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should partial match arrays', function(assert) {\n      assert.expect(3);\n\n      var objects = [{ 'a': ['b'] }, { 'a': ['c', 'd'] }],\n          actual = lodashStable.filter(objects, matches({ 'a': ['d'] }));\n\n      assert.deepEqual(actual, [objects[1]]);\n\n      actual = lodashStable.filter(objects, matches({ 'a': ['b', 'd'] }));\n      assert.deepEqual(actual, []);\n\n      actual = lodashStable.filter(objects, matches({ 'a': ['d', 'b'] }));\n      assert.deepEqual(actual, []);\n    });\n\n    QUnit.test('`_.' + methodName + '` should partial match arrays with duplicate values', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': [1, 2] }, { 'a': [2, 2] }],\n          actual = lodashStable.filter(objects, matches({ 'a': [2, 2] }));\n\n      assert.deepEqual(actual, [objects[1]]);\n    });\n\n    QUnit.test('should partial match arrays of objects', function(assert) {\n      assert.expect(1);\n\n      var objects = [\n        { 'a': [{ 'b': 1, 'c': 2 }, { 'b': 4, 'c': 5, 'd': 6 }] },\n        { 'a': [{ 'b': 1, 'c': 2 }, { 'b': 4, 'c': 6, 'd': 7 }] }\n      ];\n\n      var actual = lodashStable.filter(objects, matches({ 'a': [{ 'b': 1 }, { 'b': 4, 'c': 5 }] }));\n      assert.deepEqual(actual, [objects[0]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should partial match maps', function(assert) {\n      assert.expect(3);\n\n      if (Map) {\n        var objects = [{ 'a': new Map }, { 'a': new Map }];\n        objects[0].a.set('a', 1);\n        objects[1].a.set('a', 1);\n        objects[1].a.set('b', 2);\n\n        var map = new Map;\n        map.set('b', 2);\n        var actual = lodashStable.filter(objects, matches({ 'a': map }));\n\n        assert.deepEqual(actual, [objects[1]]);\n\n        map.delete('b');\n        actual = lodashStable.filter(objects, matches({ 'a': map }));\n\n        assert.deepEqual(actual, objects);\n\n        map.set('c', 3);\n        actual = lodashStable.filter(objects, matches({ 'a': map }));\n\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should partial match sets', function(assert) {\n      assert.expect(3);\n\n      if (Set) {\n        var objects = [{ 'a': new Set }, { 'a': new Set }];\n        objects[0].a.add(1);\n        objects[1].a.add(1);\n        objects[1].a.add(2);\n\n        var set = new Set;\n        set.add(2);\n        var actual = lodashStable.filter(objects, matches({ 'a': set }));\n\n        assert.deepEqual(actual, [objects[1]]);\n\n        set.delete(2);\n        actual = lodashStable.filter(objects, matches({ 'a': set }));\n\n        assert.deepEqual(actual, objects);\n\n        set.add(3);\n        actual = lodashStable.filter(objects, matches({ 'a': set }));\n\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `undefined` values', function(assert) {\n      assert.expect(3);\n\n      var objects = [{ 'a': 1 }, { 'a': 1, 'b': 1 }, { 'a': 1, 'b': undefined }],\n          actual = lodashStable.map(objects, matches({ 'b': undefined })),\n          expected = [false, false, true];\n\n      assert.deepEqual(actual, expected);\n\n      actual = lodashStable.map(objects, matches({ 'a': 1, 'b': undefined }));\n\n      assert.deepEqual(actual, expected);\n\n      objects = [{ 'a': { 'b': 2 } }, { 'a': { 'b': 2, 'c': 3 } }, { 'a': { 'b': 2, 'c': undefined } }];\n      actual = lodashStable.map(objects, matches({ 'a': { 'c': undefined } }));\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `undefined` values on primitives', function(assert) {\n      assert.expect(3);\n\n      numberProto.a = 1;\n      numberProto.b = undefined;\n\n      try {\n        var par = matches({ 'b': undefined });\n        assert.strictEqual(par(1), true);\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n      try {\n        par = matches({ 'a': 1, 'b': undefined });\n        assert.strictEqual(par(1), true);\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n      numberProto.a = { 'b': 1, 'c': undefined };\n      try {\n        par = matches({ 'a': { 'c': undefined } });\n        assert.strictEqual(par(1), true);\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n      delete numberProto.a;\n      delete numberProto.b;\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `false` when `object` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse),\n          par = matches({ 'a': 1 });\n\n      var actual = lodashStable.map(values, function(value, index) {\n        try {\n          return index ? par(value) : par();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` when comparing an empty `source`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1 },\n          expected = lodashStable.map(empties, stubTrue);\n\n      var actual = lodashStable.map(empties, function(value) {\n        var par = matches(value);\n        return par(object);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` when comparing an empty `source` to a nullish `object`', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubTrue),\n          par = matches({});\n\n      var actual = lodashStable.map(values, function(value, index) {\n        try {\n          return index ? par(value) : par();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `true` when comparing a `source` of empty arrays and objects', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': [1], 'b': { 'c': 1 } }, { 'a': [2, 3], 'b': { 'd': 2 } }],\n          actual = lodashStable.filter(objects, matches({ 'a': [], 'b': {} }));\n\n      assert.deepEqual(actual, objects);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.matchesProperty');\n\n  (function() {\n    QUnit.test('should create a function that performs a deep comparison between a property value and `srcValue`', function(assert) {\n      assert.expect(6);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          matches = _.matchesProperty('a', 1);\n\n      assert.strictEqual(matches.length, 1);\n      assert.strictEqual(matches(object), true);\n\n      matches = _.matchesProperty('b', 3);\n      assert.strictEqual(matches(object), false);\n\n      matches = _.matchesProperty('a', { 'a': 1, 'c': 3 });\n      assert.strictEqual(matches({ 'a': object }), true);\n\n      matches = _.matchesProperty('a', { 'c': 3, 'd': 4 });\n      assert.strictEqual(matches(object), false);\n\n      object = { 'a': { 'b': { 'c': 1, 'd': 2 }, 'e': 3 }, 'f': 4 };\n      matches = _.matchesProperty('a', { 'b': { 'c': 1 } });\n\n      assert.strictEqual(matches(object), true);\n    });\n\n    QUnit.test('should support deep paths', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var matches = _.matchesProperty(path, 2);\n        assert.strictEqual(matches(object), true);\n      });\n    });\n\n    QUnit.test('should work with a non-string `path`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3];\n\n      lodashStable.each([1, [1]], function(path) {\n        var matches = _.matchesProperty(path, 2);\n        assert.strictEqual(matches(array), true);\n      });\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object1 = { '-0': 'a' },\n          object2 = { '0': 'b' },\n          pairs = [[object1, object2], [object1, object2], [object2, object1], [object2, object1]],\n          props = [-0, Object(-0), 0, Object(0)],\n          values = ['a', 'a', 'b', 'b'],\n          expected = lodashStable.map(props, lodashStable.constant([true, false]));\n\n      var actual = lodashStable.map(props, function(key, index) {\n        var matches = _.matchesProperty(key, values[index]),\n            pair = pairs[index];\n\n        return [matches(pair[0]), matches(pair[1])];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should coerce `path` to a string', function(assert) {\n      assert.expect(2);\n\n      function fn() {}\n      fn.toString = lodashStable.constant('fn');\n\n      var object = { 'null': 1, 'undefined': 2, 'fn': 3, '[object Object]': 4 },\n          paths = [null, undefined, fn, {}],\n          expected = lodashStable.map(paths, stubTrue);\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(paths, function(path) {\n          var matches = _.matchesProperty(index ? [path] : path, object[path]);\n          return matches(object);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should match a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        var matches = _.matchesProperty(path, 1);\n        assert.strictEqual(matches(object), true);\n      });\n    });\n\n    QUnit.test('should return `false` when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        var matches = _.matchesProperty(path, 1);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          try {\n            return index ? matches(value) : matches();\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `false` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      lodashStable.each(['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']], function(path) {\n        var matches = _.matchesProperty(path, 1);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          try {\n            return index ? matches(value) : matches();\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `false` if parts of `path` are missing', function(assert) {\n      assert.expect(4);\n\n      var object = {};\n\n      lodashStable.each(['a', 'a[1].b.c', ['a'], ['a', '1', 'b', 'c']], function(path) {\n        var matches = _.matchesProperty(path, 1);\n        assert.strictEqual(matches(object), false);\n      });\n    });\n\n    QUnit.test('should match inherited string keyed `srcValue` properties', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.b = 2;\n\n      var object = { 'a': new Foo };\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var matches = _.matchesProperty(path, { 'b': 2 });\n        assert.strictEqual(matches(object), true);\n      });\n    });\n\n    QUnit.test('should not match by inherited `srcValue` properties', function(assert) {\n      assert.expect(2);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var objects = [{ 'a': { 'a': 1 } }, { 'a': { 'a': 1, 'b': 2 } }],\n          expected = lodashStable.map(objects, stubTrue);\n\n      lodashStable.each(['a', ['a']], function(path) {\n        assert.deepEqual(lodashStable.map(objects, _.matchesProperty(path, new Foo)), expected);\n      });\n    });\n\n    QUnit.test('should compare a variety of values', function(assert) {\n      assert.expect(2);\n\n      var object1 = { 'a': false, 'b': true, 'c': '3', 'd': 4, 'e': [5], 'f': { 'g': 6 } },\n          object2 = { 'a': 0, 'b': 1, 'c': 3, 'd': '4', 'e': ['5'], 'f': { 'g': '6' } },\n          matches = _.matchesProperty('a', object1);\n\n      assert.strictEqual(matches({ 'a': object1 }), true);\n      assert.strictEqual(matches({ 'a': object2 }), false);\n    });\n\n    QUnit.test('should match `-0` as `0`', function(assert) {\n      assert.expect(2);\n\n      var matches = _.matchesProperty('a', -0);\n      assert.strictEqual(matches({ 'a': 0 }), true);\n\n      matches = _.matchesProperty('a', 0);\n      assert.strictEqual(matches({ 'a': -0 }), true);\n    });\n\n    QUnit.test('should compare functions by reference', function(assert) {\n      assert.expect(3);\n\n      var object1 = { 'a': lodashStable.noop },\n          object2 = { 'a': noop },\n          object3 = { 'a': {} },\n          matches = _.matchesProperty('a', object1);\n\n      assert.strictEqual(matches({ 'a': object1 }), true);\n      assert.strictEqual(matches({ 'a': object2 }), false);\n      assert.strictEqual(matches({ 'a': object3 }), false);\n    });\n\n    QUnit.test('should work with a function for `srcValue`', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.a = 1;\n      Foo.b = function() {};\n      Foo.c = 3;\n\n      var objects = [{ 'a': { 'a': 1 } }, { 'a': { 'a': 1, 'b': Foo.b, 'c': 3 } }],\n          actual = lodashStable.map(objects, _.matchesProperty('a', Foo));\n\n      assert.deepEqual(actual, [false, true]);\n    });\n\n    QUnit.test('should work with a non-plain `srcValue`', function(assert) {\n      assert.expect(1);\n\n      function Foo(object) { lodashStable.assign(this, object); }\n\n      var object = new Foo({ 'a': new Foo({ 'b': 1, 'c': 2 }) }),\n          matches = _.matchesProperty('a', { 'b': 1 });\n\n      assert.strictEqual(matches(object), true);\n    });\n\n    QUnit.test('should partial match arrays', function(assert) {\n      assert.expect(3);\n\n      var objects = [{ 'a': ['b'] }, { 'a': ['c', 'd'] }],\n          actual = lodashStable.filter(objects, _.matchesProperty('a', ['d']));\n\n      assert.deepEqual(actual, [objects[1]]);\n\n      actual = lodashStable.filter(objects, _.matchesProperty('a', ['b', 'd']));\n      assert.deepEqual(actual, []);\n\n      actual = lodashStable.filter(objects, _.matchesProperty('a', ['d', 'b']));\n      assert.deepEqual(actual, []);\n    });\n\n    QUnit.test('should partial match arrays with duplicate values', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': [1, 2] }, { 'a': [2, 2] }],\n          actual = lodashStable.filter(objects, _.matchesProperty('a', [2, 2]));\n\n      assert.deepEqual(actual, [objects[1]]);\n    });\n\n    QUnit.test('should partial match arrays of objects', function(assert) {\n      assert.expect(1);\n\n      var objects = [\n        { 'a': [{ 'a': 1, 'b': 2 }, { 'a': 4, 'b': 5, 'c': 6 }] },\n        { 'a': [{ 'a': 1, 'b': 2 }, { 'a': 4, 'b': 6, 'c': 7 }] }\n      ];\n\n      var actual = lodashStable.filter(objects, _.matchesProperty('a', [{ 'a': 1 }, { 'a': 4, 'b': 5 }]));\n      assert.deepEqual(actual, [objects[0]]);\n    });\n    QUnit.test('should partial match maps', function(assert) {\n      assert.expect(3);\n\n      if (Map) {\n        var objects = [{ 'a': new Map }, { 'a': new Map }];\n        objects[0].a.set('a', 1);\n        objects[1].a.set('a', 1);\n        objects[1].a.set('b', 2);\n\n        var map = new Map;\n        map.set('b', 2);\n        var actual = lodashStable.filter(objects, _.matchesProperty('a', map));\n\n        assert.deepEqual(actual, [objects[1]]);\n\n        map.delete('b');\n        actual = lodashStable.filter(objects, _.matchesProperty('a', map));\n\n        assert.deepEqual(actual, objects);\n\n        map.set('c', 3);\n        actual = lodashStable.filter(objects, _.matchesProperty('a', map));\n\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should partial match sets', function(assert) {\n      assert.expect(3);\n\n      if (Set) {\n        var objects = [{ 'a': new Set }, { 'a': new Set }];\n        objects[0].a.add(1);\n        objects[1].a.add(1);\n        objects[1].a.add(2);\n\n        var set = new Set;\n        set.add(2);\n        var actual = lodashStable.filter(objects, _.matchesProperty('a', set));\n\n        assert.deepEqual(actual, [objects[1]]);\n\n        set.delete(2);\n        actual = lodashStable.filter(objects, _.matchesProperty('a', set));\n\n        assert.deepEqual(actual, objects);\n\n        set.add(3);\n        actual = lodashStable.filter(objects, _.matchesProperty('a', set));\n\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should match `undefined` values', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 1 }, { 'a': 1, 'b': 1 }, { 'a': 1, 'b': undefined }],\n          actual = lodashStable.map(objects, _.matchesProperty('b', undefined)),\n          expected = [false, false, true];\n\n      assert.deepEqual(actual, expected);\n\n      objects = [{ 'a': { 'a': 1 } }, { 'a': { 'a': 1, 'b': 1 } }, { 'a': { 'a': 1, 'b': undefined } }];\n      actual = lodashStable.map(objects, _.matchesProperty('a', { 'b': undefined }));\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should match `undefined` values of nested objects', function(assert) {\n      assert.expect(4);\n\n      var object = { 'a': { 'b': undefined } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var matches = _.matchesProperty(path, undefined);\n        assert.strictEqual(matches(object), true);\n      });\n\n      lodashStable.each(['a.a', ['a', 'a']], function(path) {\n        var matches = _.matchesProperty(path, undefined);\n        assert.strictEqual(matches(object), false);\n      });\n    });\n\n    QUnit.test('should match `undefined` values on primitives', function(assert) {\n      assert.expect(2);\n\n      numberProto.a = 1;\n      numberProto.b = undefined;\n\n      try {\n        var matches = _.matchesProperty('b', undefined);\n        assert.strictEqual(matches(1), true);\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n      numberProto.a = { 'b': 1, 'c': undefined };\n      try {\n        matches = _.matchesProperty('a', { 'c': undefined });\n        assert.strictEqual(matches(1), true);\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n      delete numberProto.a;\n      delete numberProto.b;\n    });\n\n    QUnit.test('should return `true` when comparing a `srcValue` of empty arrays and objects', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': [1], 'b': { 'c': 1 } }, { 'a': [2, 3], 'b': { 'd': 2 } }],\n          matches = _.matchesProperty('a', { 'a': [], 'b': {} });\n\n      var actual = lodashStable.filter(objects, function(object) {\n        return matches({ 'a': object });\n      });\n\n      assert.deepEqual(actual, objects);\n    });\n\n    QUnit.test('should not change behavior if `srcValue` is modified', function(assert) {\n      assert.expect(9);\n\n      lodashStable.each([{ 'a': { 'b': 2, 'c': 3 } }, { 'a': 1, 'b': 2 }, { 'a': 1 }], function(source, index) {\n        var object = lodashStable.cloneDeep(source),\n            matches = _.matchesProperty('a', source);\n\n        assert.strictEqual(matches({ 'a': object }), true);\n\n        if (index) {\n          source.a = 2;\n          source.b = 1;\n          source.c = 3;\n        } else {\n          source.a.b = 1;\n          source.a.c = 2;\n          source.a.d = 3;\n        }\n        assert.strictEqual(matches({ 'a': object }), true);\n        assert.strictEqual(matches({ 'a': source }), false);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.max');\n\n  (function() {\n    QUnit.test('should return the largest value from a collection', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.max([1, 2, 3]), 3);\n    });\n\n    QUnit.test('should return `undefined` for empty collections', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat([[]]),\n          expected = lodashStable.map(values, noop);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        try {\n          return index ? _.max(value) : _.max();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with non-numeric collection values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.max(['a', 'b']), 'b');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.mean');\n\n  (function() {\n    QUnit.test('should return the mean of an array of numbers', function(assert) {\n      assert.expect(1);\n\n      var array = [4, 2, 8, 6];\n      assert.strictEqual(_.mean(array), 5);\n    });\n\n    QUnit.test('should return `NaN` when passing empty `array` values', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, stubNaN),\n          actual = lodashStable.map(empties, _.mean);\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.meanBy');\n\n  (function() {\n    var objects = [{ 'a': 2 }, { 'a': 3 }, { 'a': 1 }];\n\n    QUnit.test('should work with an `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.meanBy(objects, function(object) {\n        return object.a;\n      });\n\n      assert.deepEqual(actual, 2);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.meanBy(objects, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [{ 'a': 2 }]);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var arrays = [[2], [3], [1]];\n      assert.strictEqual(_.meanBy(arrays, 0), 2);\n      assert.strictEqual(_.meanBy(objects, 'a'), 2);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.memoize');\n\n  (function() {\n    function CustomCache() {\n      this.clear();\n    }\n\n    CustomCache.prototype = {\n      'clear': function() {\n        this.__data__ = [];\n        return this;\n      },\n      'get': function(key) {\n        var entry = lodashStable.find(this.__data__, ['key', key]);\n        return entry && entry.value;\n      },\n      'has': function(key) {\n        return lodashStable.some(this.__data__, ['key', key]);\n      },\n      'set': function(key, value) {\n        this.__data__.push({ 'key': key, 'value': value });\n        return this;\n      }\n    };\n\n    function ImmutableCache() {\n      this.__data__ = [];\n    }\n\n    ImmutableCache.prototype = lodashStable.create(CustomCache.prototype, {\n      'constructor': ImmutableCache,\n      'clear': function() {\n        return new ImmutableCache;\n      },\n      'set': function(key, value) {\n        var result = new ImmutableCache;\n        result.__data__ = this.__data__.concat({ 'key': key, 'value': value });\n        return result;\n      }\n    });\n\n    QUnit.test('should memoize results based on the first argument given', function(assert) {\n      assert.expect(2);\n\n      var memoized = _.memoize(function(a, b, c) {\n        return a + b + c;\n      });\n\n      assert.strictEqual(memoized(1, 2, 3), 6);\n      assert.strictEqual(memoized(1, 3, 5), 6);\n    });\n\n    QUnit.test('should support a `resolver`', function(assert) {\n      assert.expect(2);\n\n      var fn = function(a, b, c) { return a + b + c; },\n          memoized = _.memoize(fn, fn);\n\n      assert.strictEqual(memoized(1, 2, 3), 6);\n      assert.strictEqual(memoized(1, 3, 5), 9);\n    });\n\n    QUnit.test('should use `this` binding of function for `resolver`', function(assert) {\n      assert.expect(2);\n\n      var fn = function(a, b, c) { return a + this.b + this.c; },\n          memoized = _.memoize(fn, fn);\n\n      var object = { 'memoized': memoized, 'b': 2, 'c': 3 };\n      assert.strictEqual(object.memoized(1), 6);\n\n      object.b = 3;\n      object.c = 5;\n      assert.strictEqual(object.memoized(1), 9);\n    });\n\n    QUnit.test('should throw a TypeError if `resolve` is truthy and not a function', function(assert) {\n      assert.expect(1);\n\n      assert.raises(function() { _.memoize(noop, true); }, TypeError);\n    });\n\n    QUnit.test('should not error if `resolver` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(resolver, index) {\n        try {\n          return _.isFunction(index ? _.memoize(noop, resolver) : _.memoize(noop));\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should check cache for own properties', function(assert) {\n      assert.expect(1);\n\n      var props = [\n        'constructor',\n        'hasOwnProperty',\n        'isPrototypeOf',\n        'propertyIsEnumerable',\n        'toLocaleString',\n        'toString',\n        'valueOf'\n      ];\n\n      var memoized = _.memoize(identity);\n\n      var actual = lodashStable.map(props, function(value) {\n        return memoized(value);\n      });\n\n      assert.deepEqual(actual, props);\n    });\n\n    QUnit.test('should cache the `__proto__` key', function(assert) {\n      assert.expect(8);\n\n      var array = [],\n          key = '__proto__';\n\n      lodashStable.times(2, function(index) {\n        var count = 0,\n            resolver = index ? identity : undefined;\n\n        var memoized = _.memoize(function() {\n          count++;\n          return array;\n        }, resolver);\n\n        var cache = memoized.cache;\n\n        memoized(key);\n        memoized(key);\n\n        assert.strictEqual(count, 1);\n        assert.strictEqual(cache.get(key), array);\n        assert.notOk(cache.__data__ instanceof Array);\n        assert.strictEqual(cache.delete(key), true);\n      });\n    });\n\n    QUnit.test('should allow `_.memoize.Cache` to be customized', function(assert) {\n      assert.expect(4);\n\n      var oldCache = _.memoize.Cache;\n      _.memoize.Cache = CustomCache;\n\n      var memoized = _.memoize(function(object) {\n        return object.id;\n      });\n\n      var cache = memoized.cache,\n          key1 = { 'id': 'a' },\n          key2 = { 'id': 'b' };\n\n      assert.strictEqual(memoized(key1), 'a');\n      assert.strictEqual(cache.has(key1), true);\n\n      assert.strictEqual(memoized(key2), 'b');\n      assert.strictEqual(cache.has(key2), true);\n\n      _.memoize.Cache = oldCache;\n    });\n\n    QUnit.test('should works with an immutable `_.memoize.Cache` ', function(assert) {\n      assert.expect(2);\n\n      var oldCache = _.memoize.Cache;\n      _.memoize.Cache = ImmutableCache;\n\n      var memoized = _.memoize(function(object) {\n        return object.id;\n      });\n\n      var key1 = { 'id': 'a' },\n          key2 = { 'id': 'b' };\n\n      memoized(key1);\n      memoized(key2);\n\n      var cache = memoized.cache;\n      assert.strictEqual(cache.has(key1), true);\n      assert.strictEqual(cache.has(key2), true);\n\n      _.memoize.Cache = oldCache;\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('memoizeCapped');\n\n  (function() {\n    var func = _._memoizeCapped;\n\n    QUnit.test('should enforce a max cache size of `MAX_MEMOIZE_SIZE`', function(assert) {\n      assert.expect(2);\n\n      if (func) {\n        var memoized = func(identity),\n            cache = memoized.cache;\n\n        lodashStable.times(MAX_MEMOIZE_SIZE, memoized);\n        assert.strictEqual(cache.size, MAX_MEMOIZE_SIZE);\n\n        memoized(MAX_MEMOIZE_SIZE);\n        assert.strictEqual(cache.size, 1);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.merge');\n\n  (function() {\n    QUnit.test('should merge `source` into `object`', function(assert) {\n      assert.expect(1);\n\n      var names = {\n        'characters': [\n          { 'name': 'barney' },\n          { 'name': 'fred' }\n        ]\n      };\n\n      var ages = {\n        'characters': [\n          { 'age': 36 },\n          { 'age': 40 }\n        ]\n      };\n\n      var heights = {\n        'characters': [\n          { 'height': '5\\'4\"' },\n          { 'height': '5\\'5\"' }\n        ]\n      };\n\n      var expected = {\n        'characters': [\n          { 'name': 'barney', 'age': 36, 'height': '5\\'4\"' },\n          { 'name': 'fred', 'age': 40, 'height': '5\\'5\"' }\n        ]\n      };\n\n      assert.deepEqual(_.merge(names, ages, heights), expected);\n    });\n\n    QUnit.test('should merge sources containing circular references', function(assert) {\n      assert.expect(2);\n\n      var object = {\n        'foo': { 'a': 1 },\n        'bar': { 'a': 2 }\n      };\n\n      var source = {\n        'foo': { 'b': { 'c': { 'd': {} } } },\n        'bar': {}\n      };\n\n      source.foo.b.c.d = source;\n      source.bar.b = source.foo.b;\n\n      var actual = _.merge(object, source);\n\n      assert.notStrictEqual(actual.bar.b, actual.foo.b);\n      assert.strictEqual(actual.foo.b.c.d, actual.foo.b.c.d.foo.b.c.d);\n    });\n\n    QUnit.test('should work with four arguments', function(assert) {\n      assert.expect(1);\n\n      var expected = { 'a': 4 },\n          actual = _.merge({ 'a': 1 }, { 'a': 2 }, { 'a': 3 }, expected);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should merge onto function `object` values', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n\n      var source = { 'a': 1 },\n          actual = _.merge(Foo, source);\n\n      assert.strictEqual(actual, Foo);\n      assert.strictEqual(Foo.a, 1);\n    });\n\n    QUnit.test('should merge first source object properties to function', function(assert) {\n      assert.expect(1);\n\n      var fn = function() {},\n          object = { 'prop': {} },\n          actual = _.merge({ 'prop': fn }, object);\n\n      assert.deepEqual(actual, object);\n    });\n\n    QUnit.test('should merge first and second source object properties to function', function(assert) {\n      assert.expect(1);\n\n      var fn = function() {},\n          object = { 'prop': {} },\n          actual = _.merge({ 'prop': fn }, { 'prop': fn }, object);\n\n      assert.deepEqual(actual, object);\n    });\n\n    QUnit.test('should not merge onto function values of sources', function(assert) {\n      assert.expect(3);\n\n      var source1 = { 'a': function() {} },\n          source2 = { 'a': { 'b': 2 } },\n          expected = { 'a': { 'b': 2 } },\n          actual = _.merge({}, source1, source2);\n\n      assert.deepEqual(actual, expected);\n      assert.notOk('b' in source1.a);\n\n      actual = _.merge(source1, source2);\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should merge onto non-plain `object` values', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n\n      var object = new Foo,\n          actual = _.merge(object, { 'a': 1 });\n\n      assert.strictEqual(actual, object);\n      assert.strictEqual(object.a, 1);\n    });\n\n    QUnit.test('should treat sparse array sources as dense', function(assert) {\n      assert.expect(2);\n\n      var array = [1];\n      array[2] = 3;\n\n      var actual = _.merge([], array),\n          expected = array.slice();\n\n      expected[1] = undefined;\n\n      assert.ok('1' in actual);\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should merge `arguments` objects', function(assert) {\n      assert.expect(7);\n\n      var object1 = { 'value': args },\n          object2 = { 'value': { '3': 4 } },\n          expected = { '0': 1, '1': 2, '2': 3, '3': 4 },\n          actual = _.merge(object1, object2);\n\n      assert.notOk('3' in args);\n      assert.notOk(_.isArguments(actual.value));\n      assert.deepEqual(actual.value, expected);\n      object1.value = args;\n\n      actual = _.merge(object2, object1);\n      assert.notOk(_.isArguments(actual.value));\n      assert.deepEqual(actual.value, expected);\n\n      expected = { '0': 1, '1': 2, '2': 3 };\n\n      actual = _.merge({}, object1);\n      assert.notOk(_.isArguments(actual.value));\n      assert.deepEqual(actual.value, expected);\n    });\n\n    QUnit.test('should merge typed arrays', function(assert) {\n      assert.expect(4);\n\n      var array1 = [0],\n          array2 = [0, 0],\n          array3 = [0, 0, 0, 0],\n          array4 = [0, 0, 0, 0, 0, 0, 0, 0];\n\n      var arrays = [array2, array1, array4, array3, array2, array4, array4, array3, array2],\n          buffer = ArrayBuffer && new ArrayBuffer(8);\n\n      var expected = lodashStable.map(typedArrays, function(type, index) {\n        var array = arrays[index].slice();\n        array[0] = 1;\n        return root[type] ? { 'value': array } : false;\n      });\n\n      var actual = lodashStable.map(typedArrays, function(type) {\n        var Ctor = root[type];\n        return Ctor ? _.merge({ 'value': new Ctor(buffer) }, { 'value': [1] }) : false;\n      });\n\n      assert.ok(lodashStable.isArray(actual));\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(typedArrays, function(type, index) {\n        var array = arrays[index].slice();\n        array.push(1);\n        return root[type] ? { 'value': array } : false;\n      });\n\n      actual = lodashStable.map(typedArrays, function(type, index) {\n        var Ctor = root[type],\n            array = lodashStable.range(arrays[index].length);\n\n        array.push(1);\n        return Ctor ? _.merge({ 'value': array }, { 'value': new Ctor(buffer) }) : false;\n      });\n\n      assert.ok(lodashStable.isArray(actual));\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should assign `null` values', function(assert) {\n      assert.expect(1);\n\n      var actual = _.merge({ 'a': 1 }, { 'a': null });\n      assert.strictEqual(actual.a, null);\n    });\n\n    QUnit.test('should assign non array/buffer/typed-array/plain-object source values directly', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n\n      var values = [new Foo, new Boolean, new Date, Foo, new Number, new String, new RegExp],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        var object = _.merge({}, { 'a': value, 'b': { 'c': value } });\n        return object.a === value && object.b.c === value;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should clone buffer source values', function(assert) {\n      assert.expect(3);\n\n      if (Buffer) {\n        var buffer = new Buffer([1]),\n            actual = _.merge({}, { 'value': buffer }).value;\n\n        assert.ok(lodashStable.isBuffer(actual));\n        assert.strictEqual(actual[0], buffer[0]);\n        assert.notStrictEqual(actual, buffer);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should deep clone array/typed-array/plain-object source values', function(assert) {\n      assert.expect(1);\n\n      var typedArray = Uint8Array\n        ? new Uint8Array([1])\n        : { 'buffer': [1] };\n\n      var props = ['0', 'buffer', 'a'],\n          values = [[{ 'a': 1 }], typedArray, { 'a': [1] }],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var key = props[index],\n            object = _.merge({}, { 'value': value }),\n            subValue = value[key],\n            newValue = object.value,\n            newSubValue = newValue[key];\n\n        return (\n          newValue !== value &&\n          newSubValue !== subValue &&\n          lodashStable.isEqual(newValue, value)\n        );\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not augment source objects', function(assert) {\n      assert.expect(6);\n\n      var source1 = { 'a': [{ 'a': 1 }] },\n          source2 = { 'a': [{ 'b': 2 }] },\n          actual = _.merge({}, source1, source2);\n\n      assert.deepEqual(source1.a, [{ 'a': 1 }]);\n      assert.deepEqual(source2.a, [{ 'b': 2 }]);\n      assert.deepEqual(actual.a, [{ 'a': 1, 'b': 2 }]);\n\n      var source1 = { 'a': [[1, 2, 3]] },\n          source2 = { 'a': [[3, 4]] },\n          actual = _.merge({}, source1, source2);\n\n      assert.deepEqual(source1.a, [[1, 2, 3]]);\n      assert.deepEqual(source2.a, [[3, 4]]);\n      assert.deepEqual(actual.a, [[3, 4, 3]]);\n    });\n\n    QUnit.test('should merge plain objects onto non-plain objects', function(assert) {\n      assert.expect(4);\n\n      function Foo(object) {\n        lodashStable.assign(this, object);\n      }\n\n      var object = { 'a': 1 },\n          actual = _.merge(new Foo, object);\n\n      assert.ok(actual instanceof Foo);\n      assert.deepEqual(actual, new Foo(object));\n\n      actual = _.merge([new Foo], [object]);\n      assert.ok(actual[0] instanceof Foo);\n      assert.deepEqual(actual, [new Foo(object)]);\n    });\n\n    QUnit.test('should not overwrite existing values with `undefined` values of object sources', function(assert) {\n      assert.expect(1);\n\n      var actual = _.merge({ 'a': 1 }, { 'a': undefined, 'b': undefined });\n      assert.deepEqual(actual, { 'a': 1, 'b': undefined });\n    });\n\n    QUnit.test('should not overwrite existing values with `undefined` values of array sources', function(assert) {\n      assert.expect(2);\n\n      var array = [1];\n      array[2] = 3;\n\n      var actual = _.merge([4, 5, 6], array),\n          expected = [1, 5, 3];\n\n      assert.deepEqual(actual, expected);\n\n      array = [1, , 3];\n      array[1] = undefined;\n\n      actual = _.merge([4, 5, 6], array);\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should skip merging when `object` and `source` are the same value', function(assert) {\n      assert.expect(1);\n\n      var object = {},\n          pass = true;\n\n      defineProperty(object, 'a', {\n        'configurable': true,\n        'enumerable': true,\n        'get': function() { pass = false; },\n        'set': function() { pass = false; }\n      });\n\n      _.merge(object, object);\n      assert.ok(pass);\n    });\n\n    QUnit.test('should convert values to arrays when merging arrays of `source`', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { '1': 'y', 'b': 'z', 'length': 2 } },\n          actual = _.merge(object, { 'a': ['x'] });\n\n      assert.deepEqual(actual, { 'a': ['x', 'y'] });\n\n      actual = _.merge({ 'a': {} }, { 'a': [] });\n      assert.deepEqual(actual, { 'a': [] });\n    });\n\n    QUnit.test('should not convert strings to arrays when merging arrays of `source`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 'abcde' },\n          actual = _.merge(object, { 'a': ['x', 'y', 'z'] });\n\n      assert.deepEqual(actual, { 'a': ['x', 'y', 'z'] });\n    });\n\n    QUnit.test('should not error on DOM elements', function(assert) {\n      assert.expect(1);\n\n      var object1 = { 'el': document && document.createElement('div') },\n          object2 = { 'el': document && document.createElement('div') },\n          pairs = [[{}, object1], [object1, object2]],\n          expected = lodashStable.map(pairs, stubTrue);\n\n      var actual = lodashStable.map(pairs, function(pair) {\n        try {\n          return _.merge(pair[0], pair[1]).el === pair[1].el;\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.mergeWith');\n\n  (function() {\n    QUnit.test('should handle merging when `customizer` returns `undefined`', function(assert) {\n      assert.expect(2);\n\n      var actual = _.mergeWith({ 'a': { 'b': [1, 1] } }, { 'a': { 'b': [0] } }, noop);\n      assert.deepEqual(actual, { 'a': { 'b': [0, 1] } });\n\n      actual = _.mergeWith([], [undefined], identity);\n      assert.deepEqual(actual, [undefined]);\n    });\n\n    QUnit.test('should clone sources when `customizer` returns `undefined`', function(assert) {\n      assert.expect(1);\n\n      var source1 = { 'a': { 'b': { 'c': 1 } } },\n          source2 = { 'a': { 'b': { 'd': 2 } } };\n\n      _.mergeWith({}, source1, source2, noop);\n      assert.deepEqual(source1.a.b, { 'c': 1 });\n    });\n\n    QUnit.test('should defer to `customizer` for non `undefined` results', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mergeWith({ 'a': { 'b': [0, 1] } }, { 'a': { 'b': [2] } }, function(a, b) {\n        return lodashStable.isArray(a) ? a.concat(b) : undefined;\n      });\n\n      assert.deepEqual(actual, { 'a': { 'b': [0, 1, 2] } });\n    });\n\n    QUnit.test('should provide `stack` to `customizer`', function(assert) {\n      assert.expect(4);\n\n      var actual = [];\n\n      _.mergeWith({}, { 'z': 1, 'a': { 'b': 2 } }, function() {\n        actual.push(_.last(arguments));\n      });\n\n      assert.strictEqual(actual.length, 3);\n      _.each(actual, function(a) {\n        assert.ok(isNpm\n          ? a.constructor.name == 'Stack'\n          : a instanceof mapCaches.Stack\n        );\n      });\n    });\n\n    QUnit.test('should overwrite primitives with source object clones', function(assert) {\n      assert.expect(1);\n\n      var actual = _.mergeWith({ 'a': 0 }, { 'a': { 'b': ['c'] } }, function(a, b) {\n        return lodashStable.isArray(a) ? a.concat(b) : undefined;\n      });\n\n      assert.deepEqual(actual, { 'a': { 'b': ['c'] } });\n    });\n\n    QUnit.test('should pop the stack of sources for each sibling property', function(assert) {\n      assert.expect(1);\n\n      var array = ['b', 'c'],\n          object = { 'a': ['a'] },\n          source = { 'a': array, 'b': array };\n\n      var actual = _.mergeWith(object, source, function(a, b) {\n        return lodashStable.isArray(a) ? a.concat(b) : undefined;\n      });\n\n      assert.deepEqual(actual, { 'a': ['a', 'b', 'c'], 'b': ['b', 'c'] });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.method');\n\n  (function() {\n    QUnit.test('should create a function that calls a method of a given object', function(assert) {\n      assert.expect(4);\n\n      var object = { 'a': stubOne };\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method.length, 1);\n        assert.strictEqual(method(object), 1);\n      });\n    });\n\n    QUnit.test('should work with deep property values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': stubTwo } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method(object), 2);\n      });\n    });\n\n    QUnit.test('should work with a non-string `path`', function(assert) {\n      assert.expect(2);\n\n      var array = lodashStable.times(3, _.constant);\n\n      lodashStable.each([1, [1]], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method(array), 1);\n      });\n    });\n\n    QUnit.test('should coerce `path` to a string', function(assert) {\n      assert.expect(2);\n\n      function fn() {}\n      fn.toString = lodashStable.constant('fn');\n\n      var expected = [1, 2, 3, 4],\n          object = { 'null': stubOne, 'undefined': stubTwo, 'fn': stubThree, '[object Object]': stubFour },\n          paths = [null, undefined, fn, {}];\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(paths, function(path) {\n          var method = _.method(index ? [path] : path);\n          return method(object);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should work with inherited property values', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.a = stubOne;\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method(new Foo), 1);\n      });\n    });\n\n    QUnit.test('should use a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': stubOne, 'a': { 'b': stubTwo } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method(object), 1);\n      });\n    });\n\n    QUnit.test('should return `undefined` when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        var method = _.method(path);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? method(value) : method();\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']], function(path) {\n        var method = _.method(path);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? method(value) : method();\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` if parts of `path` are missing', function(assert) {\n      assert.expect(4);\n\n      var object = {};\n\n      lodashStable.each(['a', 'a[1].b.c', ['a'], ['a', '1', 'b', 'c']], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method(object), undefined);\n      });\n    });\n\n    QUnit.test('should apply partial arguments to function', function(assert) {\n      assert.expect(2);\n\n      var object = {\n        'fn': function() {\n          return slice.call(arguments);\n        }\n      };\n\n      lodashStable.each(['fn', ['fn']], function(path) {\n        var method = _.method(path, 1, 2, 3);\n        assert.deepEqual(method(object), [1, 2, 3]);\n      });\n    });\n\n    QUnit.test('should invoke deep property methods with the correct `this` binding', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': function() { return this.c; }, 'c': 1 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var method = _.method(path);\n        assert.strictEqual(method(object), 1);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.methodOf');\n\n  (function() {\n    QUnit.test('should create a function that calls a method of a given key', function(assert) {\n      assert.expect(4);\n\n      var object = { 'a': stubOne };\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var methodOf = _.methodOf(object);\n        assert.strictEqual(methodOf.length, 1);\n        assert.strictEqual(methodOf(path), 1);\n      });\n    });\n\n    QUnit.test('should work with deep property values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': stubTwo } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var methodOf = _.methodOf(object);\n        assert.strictEqual(methodOf(path), 2);\n      });\n    });\n\n    QUnit.test('should work with a non-string `path`', function(assert) {\n      assert.expect(2);\n\n      var array = lodashStable.times(3, _.constant);\n\n      lodashStable.each([1, [1]], function(path) {\n        var methodOf = _.methodOf(array);\n        assert.strictEqual(methodOf(path), 1);\n      });\n    });\n\n    QUnit.test('should coerce `path` to a string', function(assert) {\n      assert.expect(2);\n\n      function fn() {}\n      fn.toString = lodashStable.constant('fn');\n\n      var expected = [1, 2, 3, 4],\n          object = { 'null': stubOne, 'undefined': stubTwo, 'fn': stubThree, '[object Object]': stubFour },\n          paths = [null, undefined, fn, {}];\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(paths, function(path) {\n          var methodOf = _.methodOf(object);\n          return methodOf(index ? [path] : path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should work with inherited property values', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.a = stubOne;\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var methodOf = _.methodOf(new Foo);\n        assert.strictEqual(methodOf(path), 1);\n      });\n    });\n\n    QUnit.test('should use a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': stubOne, 'a': { 'b': stubTwo } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        var methodOf = _.methodOf(object);\n        assert.strictEqual(methodOf(path), 1);\n      });\n    });\n\n    QUnit.test('should return `undefined` when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        var actual = lodashStable.map(values, function(value, index) {\n          var methodOf = index ? _.methodOf() : _.methodOf(value);\n          return methodOf(path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']], function(path) {\n        var actual = lodashStable.map(values, function(value, index) {\n          var methodOf = index ? _.methodOf() : _.methodOf(value);\n          return methodOf(path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` if parts of `path` are missing', function(assert) {\n      assert.expect(4);\n\n      var object = {},\n          methodOf = _.methodOf(object);\n\n      lodashStable.each(['a', 'a[1].b.c', ['a'], ['a', '1', 'b', 'c']], function(path) {\n        assert.strictEqual(methodOf(path), undefined);\n      });\n    });\n\n    QUnit.test('should apply partial arguments to function', function(assert) {\n      assert.expect(2);\n\n      var object = {\n        'fn': function() {\n          return slice.call(arguments);\n        }\n      };\n\n      var methodOf = _.methodOf(object, 1, 2, 3);\n\n      lodashStable.each(['fn', ['fn']], function(path) {\n        assert.deepEqual(methodOf(path), [1, 2, 3]);\n      });\n    });\n\n    QUnit.test('should invoke deep property methods with the correct `this` binding', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': function() { return this.c; }, 'c': 1 } },\n          methodOf = _.methodOf(object);\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(methodOf(path), 1);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.min');\n\n  (function() {\n    QUnit.test('should return the smallest value from a collection', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.min([1, 2, 3]), 1);\n    });\n\n    QUnit.test('should return `undefined` for empty collections', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat([[]]),\n          expected = lodashStable.map(values, noop);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        try {\n          return index ? _.min(value) : _.min();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with non-numeric collection values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.min(['a', 'b']), 'a');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('extremum methods');\n\n  lodashStable.each(['max', 'maxBy', 'min', 'minBy'], function(methodName) {\n    var func = _[methodName],\n        isMax = /^max/.test(methodName);\n\n    QUnit.test('`_.' + methodName + '` should work with Date objects', function(assert) {\n      assert.expect(1);\n\n      var curr = new Date,\n          past = new Date(0);\n\n      assert.strictEqual(func([curr, past]), isMax ? curr : past);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with extremely large arrays', function(assert) {\n      assert.expect(1);\n\n      var array = lodashStable.range(0, 5e5);\n      assert.strictEqual(func(array), isMax ? 499999 : 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work when chaining on an array with only one value', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = _([40])[methodName]();\n        assert.strictEqual(actual, 40);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  lodashStable.each(['maxBy', 'minBy'], function(methodName) {\n    var array = [1, 2, 3],\n        func = _[methodName],\n        isMax = methodName == 'maxBy';\n\n    QUnit.test('`_.' + methodName + '` should work with an `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = func(array, function(n) {\n        return -n;\n      });\n\n      assert.strictEqual(actual, isMax ? 1 : 3);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 2 }, { 'a': 3 }, { 'a': 1 }],\n          actual = func(objects, 'a');\n\n      assert.deepEqual(actual, objects[isMax ? 1 : 2]);\n\n      var arrays = [[2], [3], [1]];\n      actual = func(arrays, 0);\n\n      assert.deepEqual(actual, arrays[isMax ? 1 : 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work when `iteratee` returns +/-Infinity', function(assert) {\n      assert.expect(1);\n\n      var value = isMax ? -Infinity : Infinity,\n          object = { 'a': value };\n\n      var actual = func([object, { 'a': value }], function(object) {\n        return object.a;\n      });\n\n      assert.strictEqual(actual, object);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.mixin');\n\n  (function() {\n    function reset(wrapper) {\n      delete wrapper.a;\n      delete wrapper.prototype.a;\n      delete wrapper.b;\n      delete wrapper.prototype.b;\n    }\n\n    function Wrapper(value) {\n      if (!(this instanceof Wrapper)) {\n        return new Wrapper(value);\n      }\n      if (_.has(value, '__wrapped__')) {\n        var actions = slice.call(value.__actions__),\n            chain = value.__chain__;\n\n        value = value.__wrapped__;\n      }\n      this.__wrapped__ = value;\n      this.__actions__ = actions || [];\n      this.__chain__ = chain || false;\n    }\n\n    Wrapper.prototype.value = function() {\n      return getUnwrappedValue(this);\n    };\n\n    var array = ['a'],\n        source = { 'a': function(array) { return array[0]; }, 'b': 'B' };\n\n    QUnit.test('should mixin `source` methods into lodash', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        _.mixin(source);\n\n        assert.strictEqual(_.a(array), 'a');\n        assert.strictEqual(_(array).a().value(), 'a');\n        assert.notOk('b' in _);\n        assert.notOk('b' in _.prototype);\n\n        reset(_);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should mixin chaining methods by reference', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        _.mixin(source);\n        _.a = stubB;\n\n        assert.strictEqual(_.a(array), 'b');\n        assert.strictEqual(_(array).a().value(), 'a');\n\n        reset(_);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should use a default `object` of `this`', function(assert) {\n      assert.expect(3);\n\n      var object = lodashStable.create(_);\n      object.mixin(source);\n\n      assert.strictEqual(object.a(array), 'a');\n      assert.notOk('a' in _);\n      assert.notOk('a' in _.prototype);\n\n      reset(_);\n    });\n\n    QUnit.test('should accept an `object`', function(assert) {\n      assert.expect(1);\n\n      var object = {};\n      _.mixin(object, source);\n      assert.strictEqual(object.a(array), 'a');\n    });\n\n    QUnit.test('should accept a function `object`', function(assert) {\n      assert.expect(2);\n\n      _.mixin(Wrapper, source);\n\n      var wrapped = Wrapper(array),\n          actual = wrapped.a();\n\n      assert.strictEqual(actual.value(), 'a');\n      assert.ok(actual instanceof Wrapper);\n\n      reset(Wrapper);\n    });\n\n    QUnit.test('should return `object`', function(assert) {\n      assert.expect(3);\n\n      var object = {};\n      assert.strictEqual(_.mixin(object, source), object);\n      assert.strictEqual(_.mixin(Wrapper, source), Wrapper);\n      assert.strictEqual(_.mixin(), _);\n\n      reset(Wrapper);\n    });\n\n    QUnit.test('should not assign inherited `source` methods', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype.a = noop;\n\n      var object = {};\n      assert.strictEqual(_.mixin(object, new Foo), object);\n    });\n\n    QUnit.test('should accept an `options`', function(assert) {\n      assert.expect(8);\n\n      function message(func, chain) {\n        return (func === _ ? 'lodash' : 'given') + ' function should ' + (chain ? '' : 'not ') + 'chain';\n      }\n\n      lodashStable.each([_, Wrapper], function(func) {\n        lodashStable.each([{ 'chain': false }, { 'chain': true }], function(options) {\n          if (!isNpm) {\n            if (func === _) {\n              _.mixin(source, options);\n            } else {\n              _.mixin(func, source, options);\n            }\n            var wrapped = func(array),\n                actual = wrapped.a();\n\n            if (options.chain) {\n              assert.strictEqual(actual.value(), 'a', message(func, true));\n              assert.ok(actual instanceof func, message(func, true));\n            } else {\n              assert.strictEqual(actual, 'a', message(func, false));\n              assert.notOk(actual instanceof func, message(func, false));\n            }\n            reset(func);\n          }\n          else {\n            skipAssert(assert, 2);\n          }\n        });\n      });\n    });\n\n    QUnit.test('should not extend lodash when an `object` is given with an empty `options` object', function(assert) {\n      assert.expect(1);\n\n      _.mixin({ 'a': noop }, {});\n      assert.notOk('a' in _);\n      reset(_);\n    });\n\n    QUnit.test('should not error for non-object `options` values', function(assert) {\n      assert.expect(2);\n\n      var pass = true;\n\n      try {\n        _.mixin({}, source, 1);\n      } catch (e) {\n        pass = false;\n      }\n      assert.ok(pass);\n\n      pass = true;\n\n      try {\n        _.mixin(source, 1);\n      } catch (e) {\n        pass = false;\n      }\n      assert.ok(pass);\n\n      reset(_);\n    });\n\n    QUnit.test('should not return the existing wrapped value when chaining', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([_, Wrapper], function(func) {\n        if (!isNpm) {\n          if (func === _) {\n            var wrapped = _(source),\n                actual = wrapped.mixin();\n\n            assert.strictEqual(actual.value(), _);\n          }\n          else {\n            wrapped = _(func);\n            actual = wrapped.mixin(source);\n            assert.notStrictEqual(actual, wrapped);\n          }\n          reset(func);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    QUnit.test('should produce methods that work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        _.mixin({ 'a': _.countBy, 'b': _.filter });\n\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            actual = _(array).a().map(square).b(isEven).take().value();\n\n        assert.deepEqual(actual, _.take(_.b(_.map(_.a(array), square), isEven)));\n\n        reset(_);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.multiply');\n\n  (function() {\n    QUnit.test('should multiply two numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.multiply(6, 4), 24);\n      assert.strictEqual(_.multiply(-6, 4), -24);\n      assert.strictEqual(_.multiply(-6, -4), 24);\n    });\n\n    QUnit.test('should coerce arguments to numbers', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.multiply('6', '4'), 24);\n      assert.deepEqual(_.multiply('x', 'y'), NaN);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.orderBy');\n\n  (function() {\n    var objects = [\n      { 'a': 'x', 'b': 3 },\n      { 'a': 'y', 'b': 4 },\n      { 'a': 'x', 'b': 1 },\n      { 'a': 'y', 'b': 2 }\n    ];\n\n    var nestedObj = [\n      { id: '4', address: { zipCode: 4, streetName: 'Beta' } },\n      { id: '3', address: { zipCode: 3, streetName: 'Alpha' } },\n      { id: '1', address: { zipCode: 1, streetName: 'Alpha' } },\n      { id: '2', address: { zipCode: 2, streetName: 'Alpha' } },\n      { id: '5', address: { zipCode: 4, streetName: 'Alpha' } },\n    ];\n\n    QUnit.test('should sort by a single property by a specified order', function(assert) {\n      assert.expect(1);\n\n      var actual = _.orderBy(objects, 'a', 'desc');\n      assert.deepEqual(actual, [objects[1], objects[3], objects[0], objects[2]]);\n    });\n\n    QUnit.test('should sort by nested key in array format', function(assert) {\n      assert.expect(1);\n\n      var actual = _.orderBy(\n        nestedObj,\n        [['address', 'zipCode'], ['address.streetName']],\n        ['asc', 'desc']\n      );\n      assert.deepEqual(actual, [nestedObj[2], nestedObj[3], nestedObj[1], nestedObj[0], nestedObj[4]]);\n    });\n\n    QUnit.test('should sort by multiple properties by specified orders', function(assert) {\n      assert.expect(1);\n\n      var actual = _.orderBy(objects, ['a', 'b'], ['desc', 'asc']);\n      assert.deepEqual(actual, [objects[3], objects[1], objects[2], objects[0]]);\n    });\n\n    QUnit.test('should sort by a property in ascending order when its order is not specified', function(assert) {\n      assert.expect(2);\n\n      var expected = [objects[2], objects[0], objects[3], objects[1]],\n          actual = _.orderBy(objects, ['a', 'b']);\n\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(falsey, lodashStable.constant([objects[3], objects[1], objects[2], objects[0]]));\n\n      actual = lodashStable.map(falsey, function(order, index) {\n        return _.orderBy(objects, ['a', 'b'], index ? ['desc', order] : ['desc']);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `orders` specified as string objects', function(assert) {\n      assert.expect(1);\n\n      var actual = _.orderBy(objects, ['a'], [Object('desc')]);\n      assert.deepEqual(actual, [objects[1], objects[3], objects[0], objects[2]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.overArgs');\n\n  (function() {\n    function fn() {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should transform each argument', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, doubled, square);\n      assert.deepEqual(over(5, 10), [10, 100]);\n    });\n\n    QUnit.test('should use `_.identity` when a predicate is nullish', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, undefined, null);\n      assert.deepEqual(over('a', 'b'), ['a', 'b']);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, 'b', 'a');\n      assert.deepEqual(over({ 'b': 2 }, { 'a': 1 }), [2, 1]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, { 'b': 1 }, { 'a': 1 });\n      assert.deepEqual(over({ 'b': 2 }, { 'a': 1 }), [false, true]);\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, [['b', 1], ['a', 1]]);\n      assert.deepEqual(over({ 'b': 2 }, { 'a': 1 }), [false, true]);\n    });\n\n    QUnit.test('should differentiate between `_.property` and `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overArgs(fn, ['a', 1]);\n      assert.deepEqual(over({ 'a': 1 }, { '1': 2 }), [1, 2]);\n\n      over = _.overArgs(fn, [['a', 1]]);\n      assert.deepEqual(over({ 'a': 1 }), [true]);\n    });\n\n    QUnit.test('should flatten `transforms`', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, [doubled, square], String);\n      assert.deepEqual(over(5, 10, 15), [10, 100, '15']);\n    });\n\n    QUnit.test('should not transform any argument greater than the number of transforms', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, doubled, square);\n      assert.deepEqual(over(5, 10, 18), [10, 100, 18]);\n    });\n\n    QUnit.test('should not transform any arguments if no transforms are given', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn);\n      assert.deepEqual(over(5, 10, 18), [5, 10, 18]);\n    });\n\n    QUnit.test('should not pass `undefined` if there are more transforms than arguments', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(fn, doubled, identity);\n      assert.deepEqual(over(5), [10]);\n    });\n\n    QUnit.test('should provide the correct argument to each transform', function(assert) {\n      assert.expect(1);\n\n      var argsList = [],\n          transform = function() { argsList.push(slice.call(arguments)); },\n          over = _.overArgs(noop, transform, transform, transform);\n\n      over('a', 'b');\n      assert.deepEqual(argsList, [['a'], ['b']]);\n    });\n\n    QUnit.test('should use `this` binding of function for `transforms`', function(assert) {\n      assert.expect(1);\n\n      var over = _.overArgs(function(x) {\n        return this[x];\n      }, function(x) {\n        return this === x;\n      });\n\n      var object = { 'over': over, 'true': 1 };\n      assert.strictEqual(object.over(object), 1);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.negate');\n\n  (function() {\n    QUnit.test('should create a function that negates the result of `func`', function(assert) {\n      assert.expect(2);\n\n      var negate = _.negate(isEven);\n\n      assert.strictEqual(negate(1), true);\n      assert.strictEqual(negate(2), false);\n    });\n\n    QUnit.test('should create a function that negates the result of `func`', function(assert) {\n      assert.expect(2);\n\n      var negate = _.negate(isEven);\n\n      assert.strictEqual(negate(1), true);\n      assert.strictEqual(negate(2), false);\n    });\n\n    QUnit.test('should create a function that accepts multiple arguments', function(assert) {\n      assert.expect(1);\n\n      var argCount,\n          count = 5,\n          negate = _.negate(function() { argCount = arguments.length; }),\n          expected = lodashStable.times(count, stubTrue);\n\n      var actual = lodashStable.times(count, function(index) {\n        switch (index) {\n          case 0: negate(); break;\n          case 1: negate(1); break;\n          case 2: negate(1, 2); break;\n          case 3: negate(1, 2, 3); break;\n          case 4: negate(1, 2, 3, 4);\n        }\n        return argCount == index;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.noConflict');\n\n  (function() {\n    QUnit.test('should return the `lodash` function', function(assert) {\n      assert.expect(2);\n\n      if (!isModularize) {\n        assert.strictEqual(_.noConflict(), oldDash);\n        assert.notStrictEqual(root._, oldDash);\n        root._ = oldDash;\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should restore `_` only if `lodash` is the current `_` value', function(assert) {\n      assert.expect(2);\n\n      if (!isModularize) {\n        var object = root._ = {};\n        assert.strictEqual(_.noConflict(), oldDash);\n        assert.strictEqual(root._, object);\n        root._ = oldDash;\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should work with a `root` of `this`', function(assert) {\n      assert.expect(2);\n\n      if (!coverage && !document && !isModularize && realm.object) {\n        var fs = require('fs'),\n            vm = require('vm'),\n            expected = {},\n            context = vm.createContext({ '_': expected, 'console': console }),\n            source = fs.readFileSync(filePath, 'utf8');\n\n        vm.runInContext(source + '\\nthis.lodash = this._.noConflict()', context);\n\n        assert.strictEqual(context._, expected);\n        assert.ok(context.lodash);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.now');\n\n  (function() {\n    QUnit.test('should return the number of milliseconds that have elapsed since the Unix epoch', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var stamp = +new Date,\n          actual = _.now();\n\n      assert.ok(actual >= stamp);\n\n      setTimeout(function() {\n        assert.ok(_.now() > actual);\n        done();\n      }, 32);\n    });\n\n    QUnit.test('should work with mocked `Date.now`', function(assert) {\n      assert.expect(1);\n\n      var now = Date.now;\n      Date.now = stubA;\n\n      var actual = _.now();\n      Date.now = now;\n\n      assert.strictEqual(actual, 'a');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.nth');\n\n  (function() {\n    var array = ['a', 'b', 'c', 'd'];\n\n    QUnit.test('should get the nth element of `array`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(array, function(value, index) {\n        return _.nth(array, index);\n      });\n\n      assert.deepEqual(actual, array);\n    });\n\n    QUnit.test('should work with a negative `n`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(lodashStable.range(1, array.length + 1), function(n) {\n        return _.nth(array, -n);\n      });\n\n      assert.deepEqual(actual, ['d', 'c', 'b', 'a']);\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(2);\n\n      var values = falsey,\n          expected = lodashStable.map(values, stubA);\n\n      var actual = lodashStable.map(values, function(n) {\n        return n ? _.nth(array, n) : _.nth(array);\n      });\n\n      assert.deepEqual(actual, expected);\n\n      values = ['1', 1.6];\n      expected = lodashStable.map(values, stubB);\n\n      actual = lodashStable.map(values, function(n) {\n        return _.nth(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `undefined` for empty arrays', function(assert) {\n      assert.expect(1);\n\n      var values = [null, undefined, []],\n          expected = lodashStable.map(values, noop);\n\n      var actual = lodashStable.map(values, function(array) {\n        return _.nth(array, 1);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `undefined` for non-indexes', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2],\n          values = [Infinity, array.length],\n          expected = lodashStable.map(values, noop);\n\n      array[-1] = 3;\n\n      var actual = lodashStable.map(values, function(n) {\n        return _.nth(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.nthArg');\n\n  (function() {\n    var args = ['a', 'b', 'c', 'd'];\n\n    QUnit.test('should create a function that returns its nth argument', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(args, function(value, index) {\n        var func = _.nthArg(index);\n        return func.apply(undefined, args);\n      });\n\n      assert.deepEqual(actual, args);\n    });\n\n    QUnit.test('should work with a negative `n`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(lodashStable.range(1, args.length + 1), function(n) {\n        var func = _.nthArg(-n);\n        return func.apply(undefined, args);\n      });\n\n      assert.deepEqual(actual, ['d', 'c', 'b', 'a']);\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(2);\n\n      var values = falsey,\n          expected = lodashStable.map(values, stubA);\n\n      var actual = lodashStable.map(values, function(n) {\n        var func = n ? _.nthArg(n) : _.nthArg();\n        return func.apply(undefined, args);\n      });\n\n      assert.deepEqual(actual, expected);\n\n      values = ['1', 1.6];\n      expected = lodashStable.map(values, stubB);\n\n      actual = lodashStable.map(values, function(n) {\n        var func = _.nthArg(n);\n        return func.apply(undefined, args);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `undefined` for empty arrays', function(assert) {\n      assert.expect(1);\n\n      var func = _.nthArg(1);\n      assert.strictEqual(func(), undefined);\n    });\n\n    QUnit.test('should return `undefined` for non-indexes', function(assert) {\n      assert.expect(1);\n\n      var values = [Infinity, args.length],\n          expected = lodashStable.map(values, noop);\n\n      var actual = lodashStable.map(values, function(n) {\n        var func = _.nthArg(n);\n        return func.apply(undefined, args);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.omit');\n\n  (function() {\n    var args = toArgs(['a', 'c']),\n        object = { 'a': 1, 'b': 2, 'c': 3, 'd': 4 },\n        nested = { 'a': 1, 'b': { 'c': 2, 'd': 3 } };\n\n    QUnit.test('should flatten `paths`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.omit(object, 'a', 'c'), { 'b': 2, 'd': 4 });\n      assert.deepEqual(_.omit(object, ['a', 'd'], 'c'), { 'b': 2 });\n    });\n\n    QUnit.test('should support deep paths', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.omit(nested, 'b.c'), { 'a': 1, 'b': { 'd': 3} });\n    });\n\n    QUnit.test('should support path arrays', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } },\n          actual = _.omit(object, [['a.b']]);\n\n      assert.deepEqual(actual, { 'a': { 'b': 2 } });\n    });\n\n    QUnit.test('should omit a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        assert.deepEqual(_.omit(object, path), { 'a': { 'b': 2 } });\n      });\n    });\n\n    QUnit.test('should coerce `paths` to strings', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.omit({ '0': 'a' }, 0), {});\n    });\n\n    QUnit.test('should return an empty object when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([null, undefined], function(value) {\n        objectProto.a = 1;\n        var actual = _.omit(value, 'valueOf');\n        delete objectProto.a;\n        assert.deepEqual(actual, {});\n      });\n    });\n\n    QUnit.test('should work with a primitive `object`', function(assert) {\n      assert.expect(1);\n\n      stringProto.a = 1;\n      stringProto.b = 2;\n\n      assert.deepEqual(_.omit('', 'b'), { 'a': 1 });\n\n      delete stringProto.a;\n      delete stringProto.b;\n    });\n\n    QUnit.test('should work with `arguments` object `paths`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.omit(object, args), { 'b': 2, 'd': 4 });\n    });\n\n    QUnit.test('should not mutate `object`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a', ['a'], 'a.b', ['a.b']], function(path) {\n        var object = { 'a': { 'b': 2 } };\n        _.omit(object, path);\n        assert.deepEqual(object, { 'a': { 'b': 2 } });\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.omitBy');\n\n  (function() {\n    QUnit.test('should work with a predicate argument', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3, 'd': 4 };\n\n      var actual = _.omitBy(object, function(n) {\n        return n != 2 && n != 4;\n      });\n\n      assert.deepEqual(actual, { 'b': 2, 'd': 4 });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('omit methods');\n\n  lodashStable.each(['omit', 'omitBy'], function(methodName) {\n    var expected = { 'b': 2, 'd': 4 },\n        func = _[methodName],\n        object = { 'a': 1, 'b': 2, 'c': 3, 'd': 4 },\n        resolve = lodashStable.nthArg(1);\n\n    if (methodName == 'omitBy') {\n      resolve = function(object, props) {\n        props = lodashStable.castArray(props);\n        return function(value) {\n          return lodashStable.some(props, function(key) {\n            key = lodashStable.isSymbol(key) ? key : lodashStable.toString(key);\n            return object[key] === value;\n          });\n        };\n      };\n    }\n    QUnit.test('`_.' + methodName + '` should create an object with omitted string keyed properties', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(func(object, resolve(object, 'a')), { 'b': 2, 'c': 3, 'd': 4 });\n      assert.deepEqual(func(object, resolve(object, ['a', 'c'])), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should include inherited string keyed properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype = object;\n\n      assert.deepEqual(func(new Foo, resolve(object, ['a', 'c'])), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': 'a', '0': 'b' },\n          props = [-0, Object(-0), 0, Object(0)],\n          expected = [{ '0': 'b' }, { '0': 'b' }, { '-0': 'a' }, { '-0': 'a' }];\n\n      var actual = lodashStable.map(props, function(key) {\n        return func(object, resolve(object, key));\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should include symbols', function(assert) {\n      assert.expect(3);\n\n      function Foo() {\n        this.a = 0;\n        this[symbol] = 1;\n      }\n\n      if (Symbol) {\n        var symbol2 = Symbol('b');\n        Foo.prototype[symbol2] = 2;\n\n        var symbol3 = Symbol('c');\n        defineProperty(Foo.prototype, symbol3, {\n          'configurable': true,\n          'enumerable': false,\n          'writable': true,\n          'value': 3\n        });\n\n        var foo = new Foo,\n            actual = func(foo, resolve(foo, 'a'));\n\n        assert.strictEqual(actual[symbol], 1);\n        assert.strictEqual(actual[symbol2], 2);\n        assert.notOk(symbol3 in actual);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should create an object with omitted symbols', function(assert) {\n      assert.expect(8);\n\n      function Foo() {\n        this.a = 0;\n        this[symbol] = 1;\n      }\n\n      if (Symbol) {\n        var symbol2 = Symbol('b');\n        Foo.prototype[symbol2] = 2;\n\n        var symbol3 = Symbol('c');\n        defineProperty(Foo.prototype, symbol3, {\n          'configurable': true,\n          'enumerable': false,\n          'writable': true,\n          'value': 3\n        });\n\n        var foo = new Foo,\n            actual = func(foo, resolve(foo, symbol));\n\n        assert.strictEqual(actual.a, 0);\n        assert.notOk(symbol in actual);\n        assert.strictEqual(actual[symbol2], 2);\n        assert.notOk(symbol3 in actual);\n\n        actual = func(foo, resolve(foo, symbol2));\n\n        assert.strictEqual(actual.a, 0);\n        assert.strictEqual(actual[symbol], 1);\n        assert.notOk(symbol2 in actual);\n        assert.notOk(symbol3 in actual);\n      }\n      else {\n        skipAssert(assert, 8);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with an array `object`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(func(array, resolve(array, ['0', '2'])), { '1': 2 });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.once');\n\n  (function() {\n    QUnit.test('should invoke `func` once', function(assert) {\n      assert.expect(2);\n\n      var count = 0,\n          once = _.once(function() { return ++count; });\n\n      once();\n      assert.strictEqual(once(), 1);\n      assert.strictEqual(count, 1);\n    });\n\n    QUnit.test('should ignore recursive calls', function(assert) {\n      assert.expect(2);\n\n      var count = 0;\n\n      var once = _.once(function() {\n        once();\n        return ++count;\n      });\n\n      assert.strictEqual(once(), 1);\n      assert.strictEqual(count, 1);\n    });\n\n    QUnit.test('should not throw more than once', function(assert) {\n      assert.expect(2);\n\n      var once = _.once(function() {\n        throw new Error;\n      });\n\n      assert.raises(once);\n\n      once();\n      assert.ok(true);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.over');\n\n  (function() {\n    QUnit.test('should create a function that invokes `iteratees`', function(assert) {\n      assert.expect(1);\n\n      var over = _.over(Math.max, Math.min);\n      assert.deepEqual(over(1, 2, 3, 4), [4, 1]);\n    });\n\n    QUnit.test('should use `_.identity` when a predicate is nullish', function(assert) {\n      assert.expect(1);\n\n      var over = _.over(undefined, null);\n      assert.deepEqual(over('a', 'b', 'c'), ['a', 'a']);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var over = _.over('b', 'a');\n      assert.deepEqual(over({ 'a': 1, 'b': 2 }), [2, 1]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      var over = _.over({ 'b': 1 }, { 'a': 1 });\n      assert.deepEqual(over({ 'a': 1, 'b': 2 }), [false, true]);\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.over([['b', 2], ['a', 2]]);\n\n      assert.deepEqual(over({ 'a': 1, 'b': 2 }), [true, false]);\n      assert.deepEqual(over({ 'a': 2, 'b': 1 }), [false, true]);\n    });\n\n    QUnit.test('should differentiate between `_.property` and `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(4);\n\n      var over = _.over(['a', 1]);\n\n      assert.deepEqual(over({ 'a': 1, '1': 2 }), [1, 2]);\n      assert.deepEqual(over({ 'a': 2, '1': 1 }), [2, 1]);\n\n      over = _.over([['a', 1]]);\n\n      assert.deepEqual(over({ 'a': 1 }), [true]);\n      assert.deepEqual(over({ 'a': 2 }), [false]);\n    });\n\n    QUnit.test('should provide arguments to predicates', function(assert) {\n      assert.expect(1);\n\n      var over = _.over(function() {\n        return slice.call(arguments);\n      });\n\n      assert.deepEqual(over('a', 'b', 'c'), [['a', 'b', 'c']]);\n    });\n\n    QUnit.test('should use `this` binding of function for `iteratees`', function(assert) {\n      assert.expect(1);\n\n      var over = _.over(function() { return this.b; }, function() { return this.a; }),\n          object = { 'over': over, 'a': 1, 'b': 2 };\n\n      assert.deepEqual(object.over(), [2, 1]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.overEvery');\n\n  (function() {\n    QUnit.test('should create a function that returns `true` if all predicates return truthy', function(assert) {\n      assert.expect(1);\n\n      var over = _.overEvery(stubTrue, stubOne, stubA);\n      assert.strictEqual(over(), true);\n    });\n\n    QUnit.test('should return `false` as soon as a predicate returns falsey', function(assert) {\n      assert.expect(2);\n\n      var count = 0,\n          countFalse = function() { count++; return false; },\n          countTrue = function() { count++; return true; },\n          over = _.overEvery(countTrue, countFalse, countTrue);\n\n      assert.strictEqual(over(), false);\n      assert.strictEqual(count, 2);\n    });\n\n    QUnit.test('should use `_.identity` when a predicate is nullish', function(assert) {\n      assert.expect(2);\n\n      var over = _.overEvery(undefined, null);\n\n      assert.strictEqual(over(true), true);\n      assert.strictEqual(over(false), false);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overEvery('b', 'a');\n\n      assert.strictEqual(over({ 'a': 1, 'b': 1 }), true);\n      assert.strictEqual(over({ 'a': 0, 'b': 1 }), false);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overEvery({ 'b': 2 }, { 'a': 1 });\n\n      assert.strictEqual(over({ 'a': 1, 'b': 2 }), true);\n      assert.strictEqual(over({ 'a': 0, 'b': 2 }), false);\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overEvery([['b', 2], ['a', 1]]);\n\n      assert.strictEqual(over({ 'a': 1, 'b': 2 }), true);\n      assert.strictEqual(over({ 'a': 0, 'b': 2 }), false);\n    });\n\n    QUnit.test('should differentiate between `_.property` and `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(5);\n\n      var over = _.overEvery(['a', 1]);\n\n      assert.strictEqual(over({ 'a': 1, '1': 1 }), true);\n      assert.strictEqual(over({ 'a': 1, '1': 0 }), false);\n      assert.strictEqual(over({ 'a': 0, '1': 1 }), false);\n\n      over = _.overEvery([['a', 1]]);\n\n      assert.strictEqual(over({ 'a': 1 }), true);\n      assert.strictEqual(over({ 'a': 2 }), false);\n    });\n\n    QUnit.test('should flatten `predicates`', function(assert) {\n      assert.expect(1);\n\n      var over = _.overEvery(stubTrue, [stubFalse]);\n      assert.strictEqual(over(), false);\n    });\n\n    QUnit.test('should provide arguments to predicates', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      var over = _.overEvery(function() {\n        args = slice.call(arguments);\n      });\n\n      over('a', 'b', 'c');\n      assert.deepEqual(args, ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should use `this` binding of function for `predicates`', function(assert) {\n      assert.expect(2);\n\n      var over = _.overEvery(function() { return this.b; }, function() { return this.a; }),\n          object = { 'over': over, 'a': 1, 'b': 2 };\n\n      assert.strictEqual(object.over(), true);\n\n      object.a = 0;\n      assert.strictEqual(object.over(), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.overSome');\n\n  (function() {\n    QUnit.test('should create a function that returns `true` if any predicates return truthy', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome(stubFalse, stubOne, stubString);\n      assert.strictEqual(over(), true);\n\n      over = _.overSome(stubNull, stubA, stubZero);\n      assert.strictEqual(over(), true);\n    });\n\n    QUnit.test('should return `true` as soon as `predicate` returns truthy', function(assert) {\n      assert.expect(2);\n\n      var count = 0,\n          countFalse = function() { count++; return false; },\n          countTrue = function() { count++; return true; },\n          over = _.overSome(countFalse, countTrue, countFalse);\n\n      assert.strictEqual(over(), true);\n      assert.strictEqual(count, 2);\n    });\n\n    QUnit.test('should return `false` if all predicates return falsey', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome(stubFalse, stubFalse, stubFalse);\n      assert.strictEqual(over(), false);\n\n      over = _.overSome(stubNull, stubZero, stubString);\n      assert.strictEqual(over(), false);\n    });\n\n    QUnit.test('should use `_.identity` when a predicate is nullish', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome(undefined, null);\n\n      assert.strictEqual(over(true), true);\n      assert.strictEqual(over(false), false);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome('b', 'a');\n\n      assert.strictEqual(over({ 'a': 1, 'b': 0 }), true);\n      assert.strictEqual(over({ 'a': 0, 'b': 0 }), false);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome({ 'b': 2 }, { 'a': 1 });\n\n      assert.strictEqual(over({ 'a': 0, 'b': 2 }), true);\n      assert.strictEqual(over({ 'a': 0, 'b': 0 }), false);\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome([['b', 2], ['a', 1]]);\n\n      assert.strictEqual(over({ 'a': 0, 'b': 2 }), true);\n      assert.strictEqual(over({ 'a': 0, 'b': 0 }), false);\n    });\n\n    QUnit.test('should differentiate between `_.property` and `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(5);\n\n      var over = _.overSome(['a', 1]);\n\n      assert.strictEqual(over({ 'a': 0, '1': 0 }), false);\n      assert.strictEqual(over({ 'a': 1, '1': 0 }), true);\n      assert.strictEqual(over({ 'a': 0, '1': 1 }), true);\n\n      over = _.overSome([['a', 1]]);\n\n      assert.strictEqual(over({ 'a': 1 }), true);\n      assert.strictEqual(over({ 'a': 2 }), false);\n    });\n\n    QUnit.test('should flatten `predicates`', function(assert) {\n      assert.expect(1);\n\n      var over = _.overSome(stubFalse, [stubTrue]);\n      assert.strictEqual(over(), true);\n    });\n\n    QUnit.test('should provide arguments to predicates', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      var over = _.overSome(function() {\n        args = slice.call(arguments);\n      });\n\n      over('a', 'b', 'c');\n      assert.deepEqual(args, ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should use `this` binding of function for `predicates`', function(assert) {\n      assert.expect(2);\n\n      var over = _.overSome(function() { return this.b; }, function() { return this.a; }),\n          object = { 'over': over, 'a': 1, 'b': 2 };\n\n      assert.strictEqual(object.over(), true);\n\n      object.a = object.b = 0;\n      assert.strictEqual(object.over(), false);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pad');\n\n  (function() {\n    var string = 'abc';\n\n    QUnit.test('should pad a string to a given length', function(assert) {\n      assert.expect(1);\n\n      var values = [, undefined],\n          expected = lodashStable.map(values, lodashStable.constant(' abc  '));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.pad(string, 6, value) : _.pad(string, 6);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should truncate pad characters to fit the pad length', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.pad(string, 8), '  abc   ');\n      assert.strictEqual(_.pad(string, 8, '_-'), '_-abc_-_');\n    });\n\n    QUnit.test('should coerce `string` to a string', function(assert) {\n      assert.expect(1);\n\n      var values = [Object(string), { 'toString': lodashStable.constant(string) }],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.pad(value, 6) === ' abc  ';\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.padEnd');\n\n  (function() {\n    var string = 'abc';\n\n    QUnit.test('should pad a string to a given length', function(assert) {\n      assert.expect(1);\n\n      var values = [, undefined],\n          expected = lodashStable.map(values, lodashStable.constant('abc   '));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.padEnd(string, 6, value) : _.padEnd(string, 6);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should truncate pad characters to fit the pad length', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.padEnd(string, 6, '_-'), 'abc_-_');\n    });\n\n    QUnit.test('should coerce `string` to a string', function(assert) {\n      assert.expect(1);\n\n      var values = [Object(string), { 'toString': lodashStable.constant(string) }],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.padEnd(value, 6) === 'abc   ';\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.padStart');\n\n  (function() {\n    var string = 'abc';\n\n    QUnit.test('should pad a string to a given length', function(assert) {\n      assert.expect(1);\n\n      var values = [, undefined],\n          expected = lodashStable.map(values, lodashStable.constant('   abc'));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.padStart(string, 6, value) : _.padStart(string, 6);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should truncate pad characters to fit the pad length', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.padStart(string, 6, '_-'), '_-_abc');\n    });\n\n    QUnit.test('should coerce `string` to a string', function(assert) {\n      assert.expect(1);\n\n      var values = [Object(string), { 'toString': lodashStable.constant(string) }],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.padStart(value, 6) === '   abc';\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('pad methods');\n\n  lodashStable.each(['pad', 'padStart', 'padEnd'], function(methodName) {\n    var func = _[methodName],\n        isPad = methodName == 'pad',\n        isStart = methodName == 'padStart',\n        string = 'abc';\n\n    QUnit.test('`_.' + methodName + '` should not pad if string is >= `length`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(func(string, 2), string);\n      assert.strictEqual(func(string, 3), string);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat negative `length` as `0`', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([0, -2], function(length) {\n        assert.strictEqual(func(string, length), string);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `length` to a number', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each(['', '4'], function(length) {\n        var actual = length ? (isStart ? ' abc' : 'abc ') : string;\n        assert.strictEqual(func(string, length), actual);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat nullish values as empty strings', function(assert) {\n      assert.expect(6);\n\n      lodashStable.each([undefined, '_-'], function(chars) {\n        var expected = chars ? (isPad ? '__' : chars) : '  ';\n        assert.strictEqual(func(null, 2, chars), expected);\n        assert.strictEqual(func(undefined, 2, chars), expected);\n        assert.strictEqual(func('', 2, chars), expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `string` when `chars` coerces to an empty string', function(assert) {\n      assert.expect(1);\n\n      var values = ['', Object('')],\n          expected = lodashStable.map(values, lodashStable.constant(string));\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.pad(string, 6, value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.parseInt');\n\n  (function() {\n    QUnit.test('should accept a `radix`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.range(2, 37);\n\n      var actual = lodashStable.map(expected, function(radix) {\n        return _.parseInt('10', radix);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should use a radix of `10`, for non-hexadecimals, if `radix` is `undefined` or `0`', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.parseInt('10'), 10);\n      assert.strictEqual(_.parseInt('10', 0), 10);\n      assert.strictEqual(_.parseInt('10', 10), 10);\n      assert.strictEqual(_.parseInt('10', undefined), 10);\n    });\n\n    QUnit.test('should use a radix of `16`, for hexadecimals, if `radix` is `undefined` or `0`', function(assert) {\n      assert.expect(8);\n\n      lodashStable.each(['0x20', '0X20'], function(string) {\n        assert.strictEqual(_.parseInt(string), 32);\n        assert.strictEqual(_.parseInt(string, 0), 32);\n        assert.strictEqual(_.parseInt(string, 16), 32);\n        assert.strictEqual(_.parseInt(string, undefined), 32);\n      });\n    });\n\n    QUnit.test('should use a radix of `10` for string with leading zeros', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.parseInt('08'), 8);\n      assert.strictEqual(_.parseInt('08', 10), 8);\n    });\n\n    QUnit.test('should parse strings with leading whitespace', function(assert) {\n      assert.expect(2);\n\n      var expected = [8, 8, 10, 10, 32, 32, 32, 32];\n\n      lodashStable.times(2, function(index) {\n        var actual = [],\n            func = (index ? (lodashBizarro || {}) : _).parseInt;\n\n        if (func) {\n          lodashStable.times(2, function(otherIndex) {\n            var string = otherIndex ? '10' : '08';\n            actual.push(\n              func(whitespace + string, 10),\n              func(whitespace + string)\n            );\n          });\n\n          lodashStable.each(['0x20', '0X20'], function(string) {\n            actual.push(\n              func(whitespace + string),\n              func(whitespace + string, 16)\n            );\n          });\n\n          assert.deepEqual(actual, expected);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    QUnit.test('should coerce `radix` to a number', function(assert) {\n      assert.expect(2);\n\n      var object = { 'valueOf': stubZero };\n      assert.strictEqual(_.parseInt('08', object), 8);\n      assert.strictEqual(_.parseInt('0x20', object), 32);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(2);\n\n      var strings = lodashStable.map(['6', '08', '10'], Object),\n          actual = lodashStable.map(strings, _.parseInt);\n\n      assert.deepEqual(actual, [6, 8, 10]);\n\n      actual = lodashStable.map('123', _.parseInt);\n      assert.deepEqual(actual, [1, 2, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('partial methods');\n\n  lodashStable.each(['partial', 'partialRight'], function(methodName) {\n    var func = _[methodName],\n        isPartial = methodName == 'partial',\n        ph = func.placeholder;\n\n    QUnit.test('`_.' + methodName + '` partially applies arguments', function(assert) {\n      assert.expect(1);\n\n      var par = func(identity, 'a');\n      assert.strictEqual(par(), 'a');\n    });\n\n    QUnit.test('`_.' + methodName + '` creates a function that can be invoked with additional arguments', function(assert) {\n      assert.expect(1);\n\n      var fn = function(a, b) { return [a, b]; },\n          par = func(fn, 'a'),\n          expected = isPartial ? ['a', 'b'] : ['b', 'a'];\n\n      assert.deepEqual(par('b'), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` works when there are no partially applied arguments and the created function is invoked without additional arguments', function(assert) {\n      assert.expect(1);\n\n      var fn = function() { return arguments.length; },\n          par = func(fn);\n\n      assert.strictEqual(par(), 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` works when there are no partially applied arguments and the created function is invoked with additional arguments', function(assert) {\n      assert.expect(1);\n\n      var par = func(identity);\n      assert.strictEqual(par('a'), 'a');\n    });\n\n    QUnit.test('`_.' + methodName + '` should support placeholders', function(assert) {\n      assert.expect(4);\n\n      var fn = function() { return slice.call(arguments); },\n          par = func(fn, ph, 'b', ph);\n\n      assert.deepEqual(par('a', 'c'), ['a', 'b', 'c']);\n      assert.deepEqual(par('a'), ['a', 'b', undefined]);\n      assert.deepEqual(par(), [undefined, 'b', undefined]);\n\n      if (isPartial) {\n        assert.deepEqual(par('a', 'c', 'd'), ['a', 'b', 'c', 'd']);\n      } else {\n        par = func(fn, ph, 'c', ph);\n        assert.deepEqual(par('a', 'b', 'd'), ['a', 'b', 'c', 'd']);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should use `_.placeholder` when set', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var _ph = _.placeholder = {},\n            fn = function() { return slice.call(arguments); },\n            par = func(fn, _ph, 'b', ph),\n            expected = isPartial ? ['a', 'b', ph, 'c'] : ['a', 'c', 'b', ph];\n\n        assert.deepEqual(par('a', 'c'), expected);\n        delete _.placeholder;\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` creates a function with a `length` of `0`', function(assert) {\n      assert.expect(1);\n\n      var fn = function(a, b, c) {},\n          par = func(fn, 'a');\n\n      assert.strictEqual(par.length, 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ensure `new par` is an instance of `func`', function(assert) {\n      assert.expect(2);\n\n      function Foo(value) {\n        return value && object;\n      }\n\n      var object = {},\n          par = func(Foo);\n\n      assert.ok(new par instanceof Foo);\n      assert.strictEqual(new par(true), object);\n    });\n\n    QUnit.test('`_.' + methodName + '` should clone metadata for created functions', function(assert) {\n      assert.expect(3);\n\n      function greet(greeting, name) {\n        return greeting + ' ' + name;\n      }\n\n      var par1 = func(greet, 'hi'),\n          par2 = func(par1, 'barney'),\n          par3 = func(par1, 'pebbles');\n\n      assert.strictEqual(par1('fred'), isPartial ? 'hi fred' : 'fred hi');\n      assert.strictEqual(par2(), isPartial ? 'hi barney'  : 'barney hi');\n      assert.strictEqual(par3(), isPartial ? 'hi pebbles' : 'pebbles hi');\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with curried functions', function(assert) {\n      assert.expect(2);\n\n      var fn = function(a, b, c) { return a + b + c; },\n          curried = _.curry(func(fn, 1), 2);\n\n      assert.strictEqual(curried(2, 3), 6);\n      assert.strictEqual(curried(2)(3), 6);\n    });\n\n    QUnit.test('should work with placeholders and curried functions', function(assert) {\n      assert.expect(1);\n\n      var fn = function() { return slice.call(arguments); },\n          curried = _.curry(fn),\n          par = func(curried, ph, 'b', ph, 'd');\n\n      assert.deepEqual(par('a', 'c'), ['a', 'b', 'c', 'd']);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.partialRight');\n\n  (function() {\n    QUnit.test('should work as a deep `_.defaults`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { 'b': 2 } },\n          source = { 'a': { 'b': 3, 'c': 3 } },\n          expected = { 'a': { 'b': 2, 'c': 3 } };\n\n      var defaultsDeep = _.partialRight(_.mergeWith, function deep(value, other) {\n        return lodashStable.isObject(value) ? _.mergeWith(value, other, deep) : value;\n      });\n\n      assert.deepEqual(defaultsDeep(object, source), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('methods using `createWrapper`');\n\n  (function() {\n    function fn() {\n      return slice.call(arguments);\n    }\n\n    var ph1 = _.bind.placeholder,\n        ph2 = _.bindKey.placeholder,\n        ph3 = _.partial.placeholder,\n        ph4 = _.partialRight.placeholder;\n\n    QUnit.test('should work with combinations of partial functions', function(assert) {\n      assert.expect(1);\n\n      var a = _.partial(fn),\n          b = _.partialRight(a, 3),\n          c = _.partial(b, 1);\n\n      assert.deepEqual(c(2), [1, 2, 3]);\n    });\n\n    QUnit.test('should work with combinations of bound and partial functions', function(assert) {\n      assert.expect(3);\n\n      var fn = function() {\n        var result = [this.a];\n        push.apply(result, arguments);\n        return result;\n      };\n\n      var expected = [1, 2, 3, 4],\n          object = { 'a': 1, 'fn': fn };\n\n      var a = _.bindKey(object, 'fn'),\n          b = _.partialRight(a, 4),\n          c = _.partial(b, 2);\n\n      assert.deepEqual(c(3), expected);\n\n      a = _.bind(fn, object);\n      b = _.partialRight(a, 4);\n      c = _.partial(b, 2);\n\n      assert.deepEqual(c(3), expected);\n\n      a = _.partial(fn, 2);\n      b = _.bind(a, object);\n      c = _.partialRight(b, 4);\n\n      assert.deepEqual(c(3), expected);\n    });\n\n    QUnit.test('should ensure `new combo` is an instance of `func`', function(assert) {\n      assert.expect(2);\n\n      function Foo(a, b, c) {\n        return b === 0 && object;\n      }\n\n      var combo = _.partial(_.partialRight(Foo, 3), 1),\n          object = {};\n\n      assert.ok(new combo(2) instanceof Foo);\n      assert.strictEqual(new combo(0), object);\n    });\n\n    QUnit.test('should work with combinations of functions with placeholders', function(assert) {\n      assert.expect(3);\n\n      var expected = [1, 2, 3, 4, 5, 6],\n          object = { 'fn': fn };\n\n      var a = _.bindKey(object, 'fn', ph2, 2),\n          b = _.partialRight(a, ph4, 6),\n          c = _.partial(b, 1, ph3, 4);\n\n      assert.deepEqual(c(3, 5), expected);\n\n      a = _.bind(fn, object, ph1, 2);\n      b = _.partialRight(a, ph4, 6);\n      c = _.partial(b, 1, ph3, 4);\n\n      assert.deepEqual(c(3, 5), expected);\n\n      a = _.partial(fn, ph3, 2);\n      b = _.bind(a, object, 1, ph1, 4);\n      c = _.partialRight(b, ph4, 6);\n\n      assert.deepEqual(c(3, 5), expected);\n    });\n\n    QUnit.test('should work with combinations of functions with overlapping placeholders', function(assert) {\n      assert.expect(3);\n\n      var expected = [1, 2, 3, 4],\n          object = { 'fn': fn };\n\n      var a = _.bindKey(object, 'fn', ph2, 2),\n          b = _.partialRight(a, ph4, 4),\n          c = _.partial(b, ph3, 3);\n\n      assert.deepEqual(c(1), expected);\n\n      a = _.bind(fn, object, ph1, 2);\n      b = _.partialRight(a, ph4, 4);\n      c = _.partial(b, ph3, 3);\n\n      assert.deepEqual(c(1), expected);\n\n      a = _.partial(fn, ph3, 2);\n      b = _.bind(a, object, ph1, 3);\n      c = _.partialRight(b, ph4, 4);\n\n      assert.deepEqual(c(1), expected);\n    });\n\n    QUnit.test('should work with recursively bound functions', function(assert) {\n      assert.expect(1);\n\n      var fn = function() {\n        return this.a;\n      };\n\n      var a = _.bind(fn, { 'a': 1 }),\n          b = _.bind(a,  { 'a': 2 }),\n          c = _.bind(b,  { 'a': 3 });\n\n      assert.strictEqual(c(), 1);\n    });\n\n    QUnit.test('should work when hot', function(assert) {\n      assert.expect(12);\n\n      lodashStable.times(2, function(index) {\n        var fn = function() {\n          var result = [this];\n          push.apply(result, arguments);\n          return result;\n        };\n\n        var object = {},\n            bound1 = index ? _.bind(fn, object, 1) : _.bind(fn, object),\n            expected = [object, 1, 2, 3];\n\n        var actual = _.last(lodashStable.times(HOT_COUNT, function() {\n          var bound2 = index ? _.bind(bound1, null, 2) : _.bind(bound1);\n          return index ? bound2(3) : bound2(1, 2, 3);\n        }));\n\n        assert.deepEqual(actual, expected);\n\n        actual = _.last(lodashStable.times(HOT_COUNT, function() {\n          var bound1 = index ? _.bind(fn, object, 1) : _.bind(fn, object),\n              bound2 = index ? _.bind(bound1, null, 2) : _.bind(bound1);\n\n          return index ? bound2(3) : bound2(1, 2, 3);\n        }));\n\n        assert.deepEqual(actual, expected);\n      });\n\n      lodashStable.each(['curry', 'curryRight'], function(methodName, index) {\n        var fn = function(a, b, c) { return [a, b, c]; },\n            curried = _[methodName](fn),\n            expected = index ? [3, 2, 1] :  [1, 2, 3];\n\n        var actual = _.last(lodashStable.times(HOT_COUNT, function() {\n          return curried(1)(2)(3);\n        }));\n\n        assert.deepEqual(actual, expected);\n\n        actual = _.last(lodashStable.times(HOT_COUNT, function() {\n          var curried = _[methodName](fn);\n          return curried(1)(2)(3);\n        }));\n\n        assert.deepEqual(actual, expected);\n      });\n\n      lodashStable.each(['partial', 'partialRight'], function(methodName, index) {\n        var func = _[methodName],\n            fn = function() { return slice.call(arguments); },\n            par1 = func(fn, 1),\n            expected = index ? [3, 2, 1] : [1, 2, 3];\n\n        var actual = _.last(lodashStable.times(HOT_COUNT, function() {\n          var par2 = func(par1, 2);\n          return par2(3);\n        }));\n\n        assert.deepEqual(actual, expected);\n\n        actual = _.last(lodashStable.times(HOT_COUNT, function() {\n          var par1 = func(fn, 1),\n              par2 = func(par1, 2);\n\n          return par2(3);\n        }));\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.partition');\n\n  (function() {\n    var array = [1, 0, 1];\n\n    QUnit.test('should split elements into two groups by `predicate`', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(_.partition([], identity), [[], []]);\n      assert.deepEqual(_.partition(array, stubTrue), [array, []]);\n      assert.deepEqual(_.partition(array, stubFalse), [[], array]);\n    });\n\n    QUnit.test('should use `_.identity` when `predicate` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([[1, 1], [0]]));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.partition(array, value) : _.partition(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': 1 }, { 'a': 1 }, { 'b': 2 }],\n          actual = _.partition(objects, 'a');\n\n      assert.deepEqual(actual, [objects.slice(0, 2), objects.slice(2)]);\n    });\n\n    QUnit.test('should work with a number for `predicate`', function(assert) {\n      assert.expect(2);\n\n      var array = [\n        [1, 0],\n        [0, 1],\n        [1, 0]\n      ];\n\n      assert.deepEqual(_.partition(array, 0), [[array[0], array[2]], [array[1]]]);\n      assert.deepEqual(_.partition(array, 1), [[array[1]], [array[0], array[2]]]);\n    });\n\n    QUnit.test('should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.partition({ 'a': 1.1, 'b': 0.2, 'c': 1.3 }, Math.floor);\n      assert.deepEqual(actual, [[1.1, 1.3], [0.2]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pick');\n\n  (function() {\n    var args = toArgs(['a', 'c']),\n        object = { 'a': 1, 'b': 2, 'c': 3, 'd': 4 },\n        nested = { 'a': 1, 'b': { 'c': 2, 'd': 3 } };\n\n    QUnit.test('should flatten `paths`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.pick(object, 'a', 'c'), { 'a': 1, 'c': 3 });\n      assert.deepEqual(_.pick(object, ['a', 'd'], 'c'), { 'a': 1, 'c': 3, 'd': 4 });\n    });\n\n    QUnit.test('should support deep paths', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.pick(nested, 'b.c'), { 'b': { 'c': 2 } });\n    });\n\n    QUnit.test('should support path arrays', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } },\n          actual = _.pick(object, [['a.b']]);\n\n      assert.deepEqual(actual, { 'a.b': 1 });\n    });\n\n    QUnit.test('should pick a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        assert.deepEqual(_.pick(object, path), { 'a.b': 1 });\n      });\n    });\n\n    QUnit.test('should coerce `paths` to strings', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.pick({ '0': 'a', '1': 'b' }, 0), { '0': 'a' });\n    });\n\n    QUnit.test('should return an empty object when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([null, undefined], function(value) {\n        assert.deepEqual(_.pick(value, 'valueOf'), {});\n      });\n    });\n\n    QUnit.test('should work with a primitive `object`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.pick('', 'slice'), { 'slice': ''.slice });\n    });\n\n    QUnit.test('should work with `arguments` object `paths`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.pick(object, args), { 'a': 1, 'c': 3 });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pickBy');\n\n  (function() {\n    QUnit.test('should work with a predicate argument', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3, 'd': 4 };\n\n      var actual = _.pickBy(object, function(n) {\n        return n == 1 || n == 3;\n      });\n\n      assert.deepEqual(actual, { 'a': 1, 'c': 3 });\n    });\n\n    QUnit.test('should not treat keys with dots as deep paths', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a.b.c': 1 },\n          actual = _.pickBy(object, stubTrue);\n\n      assert.deepEqual(actual, { 'a.b.c': 1 });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('pick methods');\n\n  lodashStable.each(['pick', 'pickBy'], function(methodName) {\n    var expected = { 'a': 1, 'c': 3 },\n        func = _[methodName],\n        isPick = methodName == 'pick',\n        object = { 'a': 1, 'b': 2, 'c': 3, 'd': 4 },\n        resolve = lodashStable.nthArg(1);\n\n    if (methodName == 'pickBy') {\n      resolve = function(object, props) {\n        props = lodashStable.castArray(props);\n        return function(value) {\n          return lodashStable.some(props, function(key) {\n            key = lodashStable.isSymbol(key) ? key : lodashStable.toString(key);\n            return object[key] === value;\n          });\n        };\n      };\n    }\n    QUnit.test('`_.' + methodName + '` should create an object of picked string keyed properties', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(func(object, resolve(object, 'a')), { 'a': 1 });\n      assert.deepEqual(func(object, resolve(object, ['a', 'c'])), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should pick inherited string keyed properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {}\n      Foo.prototype = object;\n\n      var foo = new Foo;\n      assert.deepEqual(func(foo, resolve(foo, ['a', 'c'])), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': 'a', '0': 'b' },\n          props = [-0, Object(-0), 0, Object(0)],\n          expected = [{ '-0': 'a' }, { '-0': 'a' }, { '0': 'b' }, { '0': 'b' }];\n\n      var actual = lodashStable.map(props, function(key) {\n        return func(object, resolve(object, key));\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should pick symbols', function(assert) {\n      assert.expect(3);\n\n      function Foo() {\n        this[symbol] = 1;\n      }\n\n      if (Symbol) {\n        var symbol2 = Symbol('b');\n        Foo.prototype[symbol2] = 2;\n\n        var symbol3 = Symbol('c');\n        defineProperty(Foo.prototype, symbol3, {\n          'configurable': true,\n          'enumerable': false,\n          'writable': true,\n          'value': 3\n        });\n\n        var foo = new Foo,\n            actual = func(foo, resolve(foo, [symbol, symbol2, symbol3]));\n\n        assert.strictEqual(actual[symbol], 1);\n        assert.strictEqual(actual[symbol2], 2);\n\n        if (isPick) {\n          assert.strictEqual(actual[symbol3], 3);\n        } else {\n          assert.notOk(symbol3 in actual);\n        }\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with an array `object`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      assert.deepEqual(func(array, resolve(array, '1')), { '1': 2 });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.property');\n\n  (function() {\n    QUnit.test('should create a function that plucks a property value of a given object', function(assert) {\n      assert.expect(4);\n\n      var object = { 'a': 1 };\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var prop = _.property(path);\n        assert.strictEqual(prop.length, 1);\n        assert.strictEqual(prop(object), 1);\n      });\n    });\n\n    QUnit.test('should pluck deep property values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var prop = _.property(path);\n        assert.strictEqual(prop(object), 2);\n      });\n    });\n\n    QUnit.test('should pluck inherited property values', function(assert) {\n      assert.expect(2);\n\n      function Foo() {}\n      Foo.prototype.a = 1;\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var prop = _.property(path);\n        assert.strictEqual(prop(new Foo), 1);\n      });\n    });\n\n    QUnit.test('should work with a non-string `path`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3];\n\n      lodashStable.each([1, [1]], function(path) {\n        var prop = _.property(path);\n        assert.strictEqual(prop(array), 2);\n      });\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': 'a', '0': 'b' },\n          props = [-0, Object(-0), 0, Object(0)];\n\n      var actual = lodashStable.map(props, function(key) {\n        var prop = _.property(key);\n        return prop(object);\n      });\n\n      assert.deepEqual(actual, ['a', 'a', 'b', 'b']);\n    });\n\n    QUnit.test('should coerce `path` to a string', function(assert) {\n      assert.expect(2);\n\n      function fn() {}\n      fn.toString = lodashStable.constant('fn');\n\n      var expected = [1, 2, 3, 4],\n          object = { 'null': 1, 'undefined': 2, 'fn': 3, '[object Object]': 4 },\n          paths = [null, undefined, fn, {}];\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(paths, function(path) {\n          var prop = _.property(index ? [path] : path);\n          return prop(object);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should pluck a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        var prop = _.property(path);\n        assert.strictEqual(prop(object), 1);\n      });\n    });\n\n    QUnit.test('should return `undefined` when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        var prop = _.property(path);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? prop(value) : prop();\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']], function(path) {\n        var prop = _.property(path);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? prop(value) : prop();\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` if parts of `path` are missing', function(assert) {\n      assert.expect(4);\n\n      var object = {};\n\n      lodashStable.each(['a', 'a[1].b.c', ['a'], ['a', '1', 'b', 'c']], function(path) {\n        var prop = _.property(path);\n        assert.strictEqual(prop(object), undefined);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.propertyOf');\n\n  (function() {\n    QUnit.test('should create a function that plucks a property value of a given key', function(assert) {\n      assert.expect(3);\n\n      var object = { 'a': 1 },\n          propOf = _.propertyOf(object);\n\n      assert.strictEqual(propOf.length, 1);\n      lodashStable.each(['a', ['a']], function(path) {\n        assert.strictEqual(propOf(path), 1);\n      });\n    });\n\n    QUnit.test('should pluck deep property values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2 } },\n          propOf = _.propertyOf(object);\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(propOf(path), 2);\n      });\n    });\n\n    QUnit.test('should pluck inherited property values', function(assert) {\n      assert.expect(2);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var propOf = _.propertyOf(new Foo);\n\n      lodashStable.each(['b', ['b']], function(path) {\n        assert.strictEqual(propOf(path), 2);\n      });\n    });\n\n    QUnit.test('should work with a non-string `path`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          propOf = _.propertyOf(array);\n\n      lodashStable.each([1, [1]], function(path) {\n        assert.strictEqual(propOf(path), 2);\n      });\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': 'a', '0': 'b' },\n          props = [-0, Object(-0), 0, Object(0)];\n\n      var actual = lodashStable.map(props, function(key) {\n        var propOf = _.propertyOf(object);\n        return propOf(key);\n      });\n\n      assert.deepEqual(actual, ['a', 'a', 'b', 'b']);\n    });\n\n    QUnit.test('should coerce `path` to a string', function(assert) {\n      assert.expect(2);\n\n      function fn() {}\n      fn.toString = lodashStable.constant('fn');\n\n      var expected = [1, 2, 3, 4],\n          object = { 'null': 1, 'undefined': 2, 'fn': 3, '[object Object]': 4 },\n          paths = [null, undefined, fn, {}];\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(paths, function(path) {\n          var propOf = _.propertyOf(object);\n          return propOf(index ? [path] : path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should pluck a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } },\n          propOf = _.propertyOf(object);\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        assert.strictEqual(propOf(path), 1);\n      });\n    });\n\n    QUnit.test('should return `undefined` when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        var actual = lodashStable.map(values, function(value, index) {\n          var propOf = index ? _.propertyOf(value) : _.propertyOf();\n          return propOf(path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, noop);\n\n      lodashStable.each(['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']], function(path) {\n        var actual = lodashStable.map(values, function(value, index) {\n          var propOf = index ? _.propertyOf(value) : _.propertyOf();\n          return propOf(path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should return `undefined` if parts of `path` are missing', function(assert) {\n      assert.expect(4);\n\n      var propOf = _.propertyOf({});\n\n      lodashStable.each(['a', 'a[1].b.c', ['a'], ['a', '1', 'b', 'c']], function(path) {\n        assert.strictEqual(propOf(path), undefined);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pullAll');\n\n  (function() {\n    QUnit.test('should work with the same value for `array` and `values`', function(assert) {\n      assert.expect(1);\n\n      var array = [{ 'a': 1 }, { 'b': 2 }],\n          actual = _.pullAll(array, array);\n\n      assert.deepEqual(actual, []);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pullAllBy');\n\n  (function() {\n    QUnit.test('should accept an `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n\n      var actual = _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], function(object) {\n        return object.x;\n      });\n\n      assert.deepEqual(actual, [{ 'x': 2 }]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args,\n          array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n\n      _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [{ 'x': 1 }]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pullAllWith');\n\n  (function() {\n    QUnit.test('should work with a `comparator`', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 1 }, { 'x': 2, 'y': 2 }, { 'x': 3, 'y': 3 }],\n          expected = [objects[0], objects[2]],\n          actual = _.pullAllWith(objects, [{ 'x': 2, 'y': 2 }], lodashStable.isEqual);\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('pull methods');\n\n  lodashStable.each(['pull', 'pullAll', 'pullAllWith'], function(methodName) {\n    var func = _[methodName],\n        isPull = methodName == 'pull';\n\n    function pull(array, values) {\n      return isPull\n        ? func.apply(undefined, [array].concat(values))\n        : func(array, values);\n    }\n\n    QUnit.test('`_.' + methodName + '` should modify and return the array', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = pull(array, [1, 3]);\n\n      assert.strictEqual(actual, array);\n      assert.deepEqual(array, [2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve holes in arrays', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4];\n      delete array[1];\n      delete array[3];\n\n      pull(array, [1]);\n      assert.notOk('0' in array);\n      assert.notOk('2' in array);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat holes as `undefined`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      delete array[1];\n\n      pull(array, [undefined]);\n      assert.deepEqual(array, [1, 3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `NaN`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, NaN, 3, NaN];\n\n      pull(array, [NaN]);\n      assert.deepEqual(array, [1, 3]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.pullAt');\n\n  (function() {\n    QUnit.test('should modify the array and return removed elements', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = _.pullAt(array, [0, 1]);\n\n      assert.deepEqual(array, [3]);\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('should work with unsorted indexes', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n          actual = _.pullAt(array, [1, 3, 11, 7, 5, 9]);\n\n      assert.deepEqual(array, [1, 3, 5, 7, 9, 11]);\n      assert.deepEqual(actual, [2, 4, 12, 8, 6, 10]);\n    });\n\n    QUnit.test('should work with repeated indexes', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4],\n          actual = _.pullAt(array, [0, 2, 0, 1, 0, 2]);\n\n      assert.deepEqual(array, [4]);\n      assert.deepEqual(actual, [1, 3, 1, 2, 1, 3]);\n    });\n\n    QUnit.test('should use `undefined` for nonexistent indexes', function(assert) {\n      assert.expect(2);\n\n      var array = ['a', 'b', 'c'],\n          actual = _.pullAt(array, [2, 4, 0]);\n\n      assert.deepEqual(array, ['b']);\n      assert.deepEqual(actual, ['c', undefined, 'a']);\n    });\n\n    QUnit.test('should flatten `indexes`', function(assert) {\n      assert.expect(4);\n\n      var array = ['a', 'b', 'c'];\n      assert.deepEqual(_.pullAt(array, 2, 0), ['c', 'a']);\n      assert.deepEqual(array, ['b']);\n\n      array = ['a', 'b', 'c', 'd'];\n      assert.deepEqual(_.pullAt(array, [3, 0], 2), ['d', 'a', 'c']);\n      assert.deepEqual(array, ['b']);\n    });\n\n    QUnit.test('should return an empty array when no indexes are given', function(assert) {\n      assert.expect(4);\n\n      var array = ['a', 'b', 'c'],\n          actual = _.pullAt(array);\n\n      assert.deepEqual(array, ['a', 'b', 'c']);\n      assert.deepEqual(actual, []);\n\n      actual = _.pullAt(array, [], []);\n\n      assert.deepEqual(array, ['a', 'b', 'c']);\n      assert.deepEqual(actual, []);\n    });\n\n    QUnit.test('should work with non-index paths', function(assert) {\n      assert.expect(2);\n\n      var values = lodashStable.reject(empties, function(value) {\n        return (value === 0) || lodashStable.isArray(value);\n      }).concat(-1, 1.1);\n\n      var array = lodashStable.transform(values, function(result, value) {\n        result[value] = 1;\n      }, []);\n\n      var expected = lodashStable.map(values, stubOne),\n          actual = _.pullAt(array, values);\n\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(values, noop);\n      actual = lodashStable.at(array, values);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var props = [-0, Object(-0), 0, Object(0)];\n\n      var actual = lodashStable.map(props, function(key) {\n        var array = [-1];\n        array['-0'] = -2;\n        return _.pullAt(array, key);\n      });\n\n      assert.deepEqual(actual, [[-2], [-2], [-1], [-1]]);\n    });\n\n    QUnit.test('should support deep paths', function(assert) {\n      assert.expect(3);\n\n      var array = [];\n      array.a = { 'b': 2 };\n\n      var actual = _.pullAt(array, 'a.b');\n\n      assert.deepEqual(actual, [2]);\n      assert.deepEqual(array.a, {});\n\n      try {\n        actual = _.pullAt(array, 'a.b.c');\n      } catch (e) {}\n\n      assert.deepEqual(actual, [undefined]);\n    });\n\n    QUnit.test('should work with a falsey `array` when keys are given', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.slice(),\n          expected = lodashStable.map(values, lodashStable.constant(Array(4)));\n\n      var actual = lodashStable.map(values, function(array) {\n        try {\n          return _.pullAt(array, 0, 1, 'pop', 'push');\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.random');\n\n  (function() {\n    var array = Array(1000);\n\n    QUnit.test('should return `0` or `1` when no arguments are given', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.uniq(lodashStable.map(array, function() {\n        return _.random();\n      })).sort();\n\n      assert.deepEqual(actual, [0, 1]);\n    });\n\n    QUnit.test('should support a `min` and `max`', function(assert) {\n      assert.expect(1);\n\n      var min = 5,\n          max = 10;\n\n      assert.ok(lodashStable.some(array, function() {\n        var result = _.random(min, max);\n        return result >= min && result <= max;\n      }));\n    });\n\n    QUnit.test('should support not providing a `max`', function(assert) {\n      assert.expect(1);\n\n      var min = 0,\n          max = 5;\n\n      assert.ok(lodashStable.some(array, function() {\n        var result = _.random(max);\n        return result >= min && result <= max;\n      }));\n    });\n\n    QUnit.test('should swap `min` and `max` when `min` > `max`', function(assert) {\n      assert.expect(1);\n\n      var min = 4,\n          max = 2,\n          expected = [2, 3, 4];\n\n      var actual = lodashStable.uniq(lodashStable.map(array, function() {\n        return _.random(min, max);\n      })).sort();\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should support large integer values', function(assert) {\n      assert.expect(2);\n\n      var min = Math.pow(2, 31),\n          max = Math.pow(2, 62);\n\n      assert.ok(lodashStable.every(array, function() {\n        var result = _.random(min, max);\n        return result >= min && result <= max;\n      }));\n\n      assert.ok(lodashStable.some(array, function() {\n        return _.random(MAX_INTEGER);\n      }));\n    });\n\n    QUnit.test('should coerce arguments to finite numbers', function(assert) {\n      assert.expect(1);\n\n      var actual = [\n        _.random(NaN, NaN),\n        _.random('1', '1'),\n        _.random(Infinity, Infinity)\n      ];\n\n      assert.deepEqual(actual, [0, 1, MAX_INTEGER]);\n    });\n\n    QUnit.test('should support floats', function(assert) {\n      assert.expect(2);\n\n      var min = 1.5,\n          max = 1.6,\n          actual = _.random(min, max);\n\n      assert.ok(actual % 1);\n      assert.ok(actual >= min && actual <= max);\n    });\n\n    QUnit.test('should support providing a `floating`', function(assert) {\n      assert.expect(3);\n\n      var actual = _.random(true);\n      assert.ok(actual % 1 && actual >= 0 && actual <= 1);\n\n      actual = _.random(2, true);\n      assert.ok(actual % 1 && actual >= 0 && actual <= 2);\n\n      actual = _.random(2, 4, true);\n      assert.ok(actual % 1 && actual >= 2 && actual <= 4);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3],\n          expected = lodashStable.map(array, stubTrue),\n          randoms = lodashStable.map(array, _.random);\n\n      var actual = lodashStable.map(randoms, function(result, index) {\n        return result >= 0 && result <= array[index] && (result % 1) == 0;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('range methods');\n\n  lodashStable.each(['range', 'rangeRight'], function(methodName) {\n    var func = _[methodName],\n        isRange = methodName == 'range';\n\n    function resolve(range) {\n      return isRange ? range : range.reverse();\n    }\n\n    QUnit.test('`_.' + methodName + '` should infer the sign of `step` when only `end` is given', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(func(4), resolve([0, 1, 2, 3]));\n      assert.deepEqual(func(-4), resolve([0, -1, -2, -3]));\n    });\n\n    QUnit.test('`_.' + methodName + '` should infer the sign of `step` when only `start` and `end` are given', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(func(1, 5), resolve([1, 2, 3, 4]));\n      assert.deepEqual(func(5, 1), resolve([5, 4, 3, 2]));\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a `start`, `end`, and `step`', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(func(0, -4, -1), resolve([0, -1, -2, -3]));\n      assert.deepEqual(func(5, 1, -1), resolve([5, 4, 3, 2]));\n      assert.deepEqual(func(0, 20, 5), resolve([0, 5, 10, 15]));\n    });\n\n    QUnit.test('`_.' + methodName + '` should support a `step` of `0`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(1, 4, 0), [1, 1, 1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a `step` larger than `end`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(1, 5, 20), [1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a negative `step`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(func(0, -4, -1), resolve([0, -1, -2, -3]));\n      assert.deepEqual(func(21, 10, -3), resolve([21, 18, 15, 12]));\n    });\n\n    QUnit.test('`_.' + methodName + '` should support `start` of `-0`', function(assert) {\n      assert.expect(1);\n\n      var actual = func(-0, 1);\n      assert.strictEqual(1 / actual[0], -Infinity);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat falsey `start` as `0`', function(assert) {\n      assert.expect(13);\n\n      lodashStable.each(falsey, function(value, index) {\n        if (index) {\n          assert.deepEqual(func(value), []);\n          assert.deepEqual(func(value, 1), [0]);\n        } else {\n          assert.deepEqual(func(), []);\n        }\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce arguments to finite numbers', function(assert) {\n      assert.expect(1);\n\n      var actual = [\n        func('1'),\n        func('0', 1),\n        func(0, 1, '1'),\n        func(NaN),\n        func(NaN, NaN)\n      ];\n\n      assert.deepEqual(actual, [[0], [0], [0], [], []]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          object = { 'a': 1, 'b': 2, 'c': 3 },\n          expected = lodashStable.map([[0], [0, 1], [0, 1, 2]], resolve);\n\n      lodashStable.each([array, object], function(collection) {\n        var actual = lodashStable.map(collection, func);\n        assert.deepEqual(actual, expected);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.rearg');\n\n  (function() {\n    function fn() {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should reorder arguments provided to `func`', function(assert) {\n      assert.expect(1);\n\n      var rearged = _.rearg(fn, [2, 0, 1]);\n      assert.deepEqual(rearged('b', 'c', 'a'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should work with repeated indexes', function(assert) {\n      assert.expect(1);\n\n      var rearged = _.rearg(fn, [1, 1, 1]);\n      assert.deepEqual(rearged('c', 'a', 'b'), ['a', 'a', 'a']);\n    });\n\n    QUnit.test('should use `undefined` for nonexistent indexes', function(assert) {\n      assert.expect(1);\n\n      var rearged = _.rearg(fn, [1, 4]);\n      assert.deepEqual(rearged('b', 'a', 'c'), ['a', undefined, 'c']);\n    });\n\n    QUnit.test('should use `undefined` for non-index values', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.reject(empties, function(value) {\n        return (value === 0) || lodashStable.isArray(value);\n      }).concat(-1, 1.1);\n\n      var expected = lodashStable.map(values, lodashStable.constant([undefined, 'b', 'c']));\n\n      var actual = lodashStable.map(values, function(value) {\n        var rearged = _.rearg(fn, [value]);\n        return rearged('a', 'b', 'c');\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not rearrange arguments when no indexes are given', function(assert) {\n      assert.expect(2);\n\n      var rearged = _.rearg(fn);\n      assert.deepEqual(rearged('a', 'b', 'c'), ['a', 'b', 'c']);\n\n      rearged = _.rearg(fn, [], []);\n      assert.deepEqual(rearged('a', 'b', 'c'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should accept multiple index arguments', function(assert) {\n      assert.expect(1);\n\n      var rearged = _.rearg(fn, 2, 0, 1);\n      assert.deepEqual(rearged('b', 'c', 'a'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should accept multiple arrays of indexes', function(assert) {\n      assert.expect(1);\n\n      var rearged = _.rearg(fn, [2], [0, 1]);\n      assert.deepEqual(rearged('b', 'c', 'a'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should work with fewer indexes than arguments', function(assert) {\n      assert.expect(1);\n\n      var rearged = _.rearg(fn, [1, 0]);\n      assert.deepEqual(rearged('b', 'a', 'c'), ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should work on functions that have been rearged', function(assert) {\n      assert.expect(1);\n\n      var rearged1 = _.rearg(fn, 2, 1, 0),\n          rearged2 = _.rearg(rearged1, 1, 0, 2);\n\n      assert.deepEqual(rearged2('b', 'c', 'a'), ['a', 'b', 'c']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.reduce');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should use the first element of a collection as the default `accumulator`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.reduce(array), 1);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments when iterating an array', function(assert) {\n      assert.expect(2);\n\n      var args;\n\n      _.reduce(array, function() {\n        args || (args = slice.call(arguments));\n      }, 0);\n\n      assert.deepEqual(args, [0, 1, 0, array]);\n\n      args = undefined;\n      _.reduce(array, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [1, 2, 1, array]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments when iterating an object', function(assert) {\n      assert.expect(2);\n\n      var args,\n          object = { 'a': 1, 'b': 2 },\n          firstKey = _.head(_.keys(object));\n\n      var expected = firstKey == 'a'\n        ? [0, 1, 'a', object]\n        : [0, 2, 'b', object];\n\n      _.reduce(object, function() {\n        args || (args = slice.call(arguments));\n      }, 0);\n\n      assert.deepEqual(args, expected);\n\n      args = undefined;\n      expected = firstKey == 'a'\n        ? [1, 2, 'b', object]\n        : [2, 1, 'a', object];\n\n      _.reduce(object, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.reduceRight');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should use the last element of a collection as the default `accumulator`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.reduceRight(array), 3);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments when iterating an array', function(assert) {\n      assert.expect(2);\n\n      var args;\n\n      _.reduceRight(array, function() {\n        args || (args = slice.call(arguments));\n      }, 0);\n\n      assert.deepEqual(args, [0, 3, 2, array]);\n\n      args = undefined;\n      _.reduceRight(array, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [3, 2, 1, array]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments when iterating an object', function(assert) {\n      assert.expect(2);\n\n      var args,\n          object = { 'a': 1, 'b': 2 },\n          isFIFO = lodashStable.keys(object)[0] == 'a';\n\n      var expected = isFIFO\n        ? [0, 2, 'b', object]\n        : [0, 1, 'a', object];\n\n      _.reduceRight(object, function() {\n        args || (args = slice.call(arguments));\n      }, 0);\n\n      assert.deepEqual(args, expected);\n\n      args = undefined;\n      expected = isFIFO\n        ? [2, 1, 'a', object]\n        : [1, 2, 'b', object];\n\n      _.reduceRight(object, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('reduce methods');\n\n  lodashStable.each(['reduce', 'reduceRight'], function(methodName) {\n    var func = _[methodName],\n        array = [1, 2, 3],\n        isReduce = methodName == 'reduce';\n\n    QUnit.test('`_.' + methodName + '` should reduce a collection to a single value', function(assert) {\n      assert.expect(1);\n\n      var actual = func(['a', 'b', 'c'], function(accumulator, value) {\n        return accumulator + value;\n      }, '');\n\n      assert.strictEqual(actual, isReduce ? 'abc' : 'cba');\n    });\n\n    QUnit.test('`_.' + methodName + '` should support empty collections without an initial `accumulator` value', function(assert) {\n      assert.expect(1);\n\n      var actual = [],\n          expected = lodashStable.map(empties, noop);\n\n      lodashStable.each(empties, function(value) {\n        try {\n          actual.push(func(value, noop));\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support empty collections with an initial `accumulator` value', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, lodashStable.constant('x'));\n\n      var actual = lodashStable.map(empties, function(value) {\n        try {\n          return func(value, noop, 'x');\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should handle an initial `accumulator` value of `undefined`', function(assert) {\n      assert.expect(1);\n\n      var actual = func([], noop, undefined);\n      assert.strictEqual(actual, undefined);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `undefined` for empty collections when no `accumulator` is given (test in IE > 9 and modern browsers)', function(assert) {\n      assert.expect(2);\n\n      var array = [],\n          object = { '0': 1, 'length': 0 };\n\n      if ('__proto__' in array) {\n        array.__proto__ = object;\n        assert.strictEqual(func(array, noop), undefined);\n      }\n      else {\n        skipAssert(assert);\n      }\n      assert.strictEqual(func(object, noop), undefined);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.strictEqual(_(array)[methodName](add), 6);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(array).chain()[methodName](add) instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.reject');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should return elements the `predicate` returns falsey for', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.reject(array, isEven), [1, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('filter methods');\n\n  lodashStable.each(['filter', 'reject'], function(methodName) {\n    var array = [1, 2, 3, 4],\n        func = _[methodName],\n        isFilter = methodName == 'filter',\n        objects = [{ 'a': 0 }, { 'a': 1 }];\n\n    QUnit.test('`_.' + methodName + '` should not modify the resulting value from within `predicate`', function(assert) {\n      assert.expect(1);\n\n      var actual = func([0], function(value, index, array) {\n        array[index] = 1;\n        return isFilter;\n      });\n\n      assert.deepEqual(actual, [0]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(objects, 'a'), [objects[isFilter ? 1 : 0]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(objects, objects[1]), [objects[isFilter ? 1 : 0]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not modify wrapped values', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _(array);\n\n        var actual = wrapped[methodName](function(n) {\n          return n < 3;\n        });\n\n        assert.deepEqual(actual.value(), isFilter ? [1, 2] : [3, 4]);\n\n        actual = wrapped[methodName](function(n) {\n          return n > 2;\n        });\n\n        assert.deepEqual(actual.value(), isFilter ? [3, 4] : [1, 2]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should work in a lazy sequence', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE + 1),\n            predicate = function(value) { return isFilter ? isEven(value) : !isEven(value); };\n\n        var object = lodashStable.zipObject(lodashStable.times(LARGE_ARRAY_SIZE, function(index) {\n          return ['key' + index, index];\n        }));\n\n        var actual = _(array).slice(1).map(square)[methodName](predicate).value();\n        assert.deepEqual(actual, _[methodName](lodashStable.map(array.slice(1), square), predicate));\n\n        actual = _(object).mapValues(square)[methodName](predicate).value();\n        assert.deepEqual(actual, _[methodName](lodashStable.mapValues(object, square), predicate));\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should provide correct `predicate` arguments in a lazy sequence', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var args,\n            array = lodashStable.range(LARGE_ARRAY_SIZE + 1),\n            expected = [1, 0, lodashStable.map(array.slice(1), square)];\n\n        _(array).slice(1)[methodName](function(value, index, array) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, [1, 0, array.slice(1)]);\n\n        args = undefined;\n        _(array).slice(1).map(square)[methodName](function(value, index, array) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        args = undefined;\n        _(array).slice(1).map(square)[methodName](function(value, index) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        args = undefined;\n        _(array).slice(1).map(square)[methodName](function(value) {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, [1]);\n\n        args = undefined;\n        _(array).slice(1).map(square)[methodName](function() {\n          args || (args = slice.call(arguments));\n        }).value();\n\n        assert.deepEqual(args, expected);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.remove');\n\n  (function() {\n    QUnit.test('should modify the array and return removed elements', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4],\n          actual = _.remove(array, isEven);\n\n      assert.deepEqual(array, [1, 3]);\n      assert.deepEqual(actual, [2, 4]);\n    });\n\n    QUnit.test('should provide correct `predicate` arguments', function(assert) {\n      assert.expect(1);\n\n      var argsList = [],\n          array = [1, 2, 3],\n          clone = array.slice();\n\n      _.remove(array, function(n, index) {\n        var args = slice.call(arguments);\n        args[2] = args[2].slice();\n        argsList.push(args);\n        return isEven(index);\n      });\n\n      assert.deepEqual(argsList, [[1, 0, clone], [2, 1, clone], [3, 2, clone]]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': 0, 'b': 1 }, { 'a': 1, 'b': 2 }];\n      _.remove(objects, { 'a': 1 });\n      assert.deepEqual(objects, [{ 'a': 0, 'b': 1 }]);\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': 0, 'b': 1 }, { 'a': 1, 'b': 2 }];\n      _.remove(objects, ['a', 1]);\n      assert.deepEqual(objects, [{ 'a': 0, 'b': 1 }]);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'a': 0 }, { 'a': 1 }];\n      _.remove(objects, 'a');\n      assert.deepEqual(objects, [{ 'a': 0 }]);\n    });\n\n    QUnit.test('should preserve holes in arrays', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3, 4];\n      delete array[1];\n      delete array[3];\n\n      _.remove(array, function(n) {\n        return n === 1;\n      });\n\n      assert.notOk('0' in array);\n      assert.notOk('2' in array);\n    });\n\n    QUnit.test('should treat holes as `undefined`', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n      delete array[1];\n\n      _.remove(array, function(n) {\n        return n == null;\n      });\n\n      assert.deepEqual(array, [1, 3]);\n    });\n\n    QUnit.test('should not mutate the array until all elements to remove are determined', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3];\n\n      _.remove(array, function(n, index) {\n        return isEven(index);\n      });\n\n      assert.deepEqual(array, [2]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.repeat');\n\n  (function() {\n    var string = 'abc';\n\n    QUnit.test('should repeat a string `n` times', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.repeat('*', 3), '***');\n      assert.strictEqual(_.repeat(string, 2), 'abcabc');\n    });\n\n    QUnit.test('should treat falsey `n` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? string : '';\n      });\n\n      var actual = lodashStable.map(falsey, function(n, index) {\n        return index ? _.repeat(string, n) : _.repeat(string);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an empty string if `n` is <= `0`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.repeat(string, 0), '');\n      assert.strictEqual(_.repeat(string, -2), '');\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.repeat(string, '2'), 'abcabc');\n      assert.strictEqual(_.repeat(string, 2.6), 'abcabc');\n      assert.strictEqual(_.repeat('*', { 'valueOf': stubThree }), '***');\n    });\n\n    QUnit.test('should coerce `string` to a string', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.repeat(Object(string), 2), 'abcabc');\n      assert.strictEqual(_.repeat({ 'toString': lodashStable.constant('*') }, 3), '***');\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(['a', 'b', 'c'], _.repeat);\n      assert.deepEqual(actual, ['a', 'b', 'c']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.replace');\n\n  (function() {\n    QUnit.test('should replace the matched pattern', function(assert) {\n      assert.expect(2);\n\n      var string = 'abcde';\n      assert.strictEqual(_.replace(string, 'de', '123'), 'abc123');\n      assert.strictEqual(_.replace(string, /[bd]/g, '-'), 'a-c-e');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.result');\n\n  (function() {\n    var object = { 'a': 1, 'b': stubB };\n\n    QUnit.test('should invoke function values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.result(object, 'b'), 'b');\n    });\n\n    QUnit.test('should invoke default function values', function(assert) {\n      assert.expect(1);\n\n      var actual = _.result(object, 'c', object.b);\n      assert.strictEqual(actual, 'b');\n    });\n\n    QUnit.test('should invoke nested function values', function(assert) {\n      assert.expect(2);\n\n      var value = { 'a': lodashStable.constant({ 'b': stubB }) };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(_.result(value, path), 'b');\n      });\n    });\n\n    QUnit.test('should invoke deep property methods with the correct `this` binding', function(assert) {\n      assert.expect(2);\n\n      var value = { 'a': { 'b': function() { return this.c; }, 'c': 1 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(_.result(value, path), 1);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.get and lodash.result');\n\n  lodashStable.each(['get', 'result'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should get string keyed property values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1 };\n\n      lodashStable.each(['a', ['a']], function(path) {\n        assert.strictEqual(func(object, path), 1);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var object = { '-0': 'a', '0': 'b' },\n          props = [-0, Object(-0), 0, Object(0)];\n\n      var actual = lodashStable.map(props, function(key) {\n        return func(object, key);\n      });\n\n      assert.deepEqual(actual, ['a', 'a', 'b', 'b']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should get symbol keyed property values', function(assert) {\n      assert.expect(1);\n\n      if (Symbol) {\n        var object = {};\n        object[symbol] = 1;\n\n        assert.strictEqual(func(object, symbol), 1);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should get deep property values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(func(object, path), 2);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should get a key over a path', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a.b': 1, 'a': { 'b': 2 } };\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        assert.strictEqual(func(object, path), 1);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not coerce array paths to strings', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a,b,c': 3, 'a': { 'b': { 'c': 4 } } };\n      assert.strictEqual(func(object, ['a', 'b', 'c']), 4);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not ignore empty brackets', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': { '': 1 } };\n      assert.strictEqual(func(object, 'a[]'), 1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should handle empty paths', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([['', ''], [[], ['']]], function(pair) {\n        assert.strictEqual(func({}, pair[0]), undefined);\n        assert.strictEqual(func({ '': 3 }, pair[1]), 3);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should handle complex paths', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { '-1.23': { '[\"b\"]': { 'c': { \"['d']\": { '\\ne\\n': { 'f': { 'g': 8 } } } } } } } };\n\n      var paths = [\n        'a[-1.23][\"[\\\\\"b\\\\\"]\"].c[\\'[\\\\\\'d\\\\\\']\\'][\\ne\\n][f].g',\n        ['a', '-1.23', '[\"b\"]', 'c', \"['d']\", '\\ne\\n', 'f', 'g']\n      ];\n\n      lodashStable.each(paths, function(path) {\n        assert.strictEqual(func(object, path), 8);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `undefined` when `object` is nullish', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['constructor', ['constructor']], function(path) {\n        assert.strictEqual(func(null, path), undefined);\n        assert.strictEqual(func(undefined, path), undefined);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `undefined` for deep paths when `object` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [null, undefined],\n          expected = lodashStable.map(values, noop),\n          paths = ['constructor.prototype.valueOf', ['constructor', 'prototype', 'valueOf']];\n\n      lodashStable.each(paths, function(path) {\n        var actual = lodashStable.map(values, function(value) {\n          return func(value, path);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `undefined` if parts of `path` are missing', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': [, null] };\n\n      lodashStable.each(['a[1].b.c', ['a', '1', 'b', 'c']], function(path) {\n        assert.strictEqual(func(object, path), undefined);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should be able to return `null` values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { 'b': null } };\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        assert.strictEqual(func(object, path), null);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should follow `path` over non-plain objects', function(assert) {\n      assert.expect(2);\n\n      var paths = ['a.b', ['a', 'b']];\n\n      lodashStable.each(paths, function(path) {\n        numberProto.a = { 'b': 2 };\n        assert.strictEqual(func(0, path), 2);\n        delete numberProto.a;\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return the default value for `undefined` values', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': {} },\n          values = empties.concat(true, new Date, 1, /x/, 'a'),\n          expected = lodashStable.map(values, function(value) { return [value, value]; });\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var actual = lodashStable.map(values, function(value) {\n          return [func(object, path, value), func(null, path, value)];\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should return the default value when `path` is empty', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func({}, [], 'a'), 'a');\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.rest');\n\n  (function() {\n    function fn(a, b, c) {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should apply a rest parameter to `func`', function(assert) {\n      assert.expect(1);\n\n      var rest = _.rest(fn);\n      assert.deepEqual(rest(1, 2, 3, 4), [1, 2, [3, 4]]);\n    });\n\n    QUnit.test('should work with `start`', function(assert) {\n      assert.expect(1);\n\n      var rest = _.rest(fn, 1);\n      assert.deepEqual(rest(1, 2, 3, 4), [1, [2, 3, 4]]);\n    });\n\n    QUnit.test('should treat `start` as `0` for `NaN` or negative values', function(assert) {\n      assert.expect(1);\n\n      var values = [-1, NaN, 'a'],\n          expected = lodashStable.map(values, lodashStable.constant([[1, 2, 3, 4]]));\n\n      var actual = lodashStable.map(values, function(value) {\n        var rest = _.rest(fn, value);\n        return rest(1, 2, 3, 4);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should coerce `start` to an integer', function(assert) {\n      assert.expect(1);\n\n      var rest = _.rest(fn, 1.6);\n      assert.deepEqual(rest(1, 2, 3), [1, [2, 3]]);\n    });\n\n    QUnit.test('should use an empty array when `start` is not reached', function(assert) {\n      assert.expect(1);\n\n      var rest = _.rest(fn);\n      assert.deepEqual(rest(1), [1, undefined, []]);\n    });\n\n    QUnit.test('should work on functions with more than three parameters', function(assert) {\n      assert.expect(1);\n\n      var rest = _.rest(function(a, b, c, d) {\n        return slice.call(arguments);\n      });\n\n      assert.deepEqual(rest(1, 2, 3, 4, 5), [1, 2, 3, [4, 5]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.reverse');\n\n  (function() {\n    var largeArray = lodashStable.range(LARGE_ARRAY_SIZE).concat(null),\n        smallArray = [0, 1, 2, null];\n\n    QUnit.test('should reverse `array`', function(assert) {\n      assert.expect(2);\n\n      var array = [1, 2, 3],\n          actual = _.reverse(array);\n\n      assert.strictEqual(actual, array);\n      assert.deepEqual(array, [3, 2, 1]);\n    });\n\n    QUnit.test('should return the wrapped reversed `array`', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        lodashStable.times(2, function(index) {\n          var array = (index ? largeArray : smallArray).slice(),\n              clone = array.slice(),\n              wrapped = _(array).reverse(),\n              actual = wrapped.value();\n\n          assert.ok(wrapped instanceof _);\n          assert.strictEqual(actual, array);\n          assert.deepEqual(actual, clone.slice().reverse());\n        });\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        lodashStable.times(2, function(index) {\n          var array = (index ? largeArray : smallArray).slice(),\n              expected = array.slice(),\n              actual = _(array).slice(1).reverse().value();\n\n          assert.deepEqual(actual, expected.slice(1).reverse());\n          assert.deepEqual(array, expected);\n        });\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should be lazy when in a lazy sequence', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var spy = {\n          'toString': function() {\n            throw new Error('spy was revealed');\n          }\n        };\n\n        var array = largeArray.concat(spy),\n            expected = array.slice();\n\n        try {\n          var wrapped = _(array).slice(1).map(String).reverse(),\n              actual = wrapped.last();\n        } catch (e) {}\n\n        assert.ok(wrapped instanceof _);\n        assert.strictEqual(actual, '1');\n        assert.deepEqual(array, expected);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should work in a hybrid sequence', function(assert) {\n      assert.expect(8);\n\n      if (!isNpm) {\n        lodashStable.times(2, function(index) {\n          var clone = (index ? largeArray : smallArray).slice();\n\n          lodashStable.each(['map', 'filter'], function(methodName) {\n            var array = clone.slice(),\n                expected = clone.slice(1, -1).reverse(),\n                actual = _(array)[methodName](identity).thru(_.compact).reverse().value();\n\n            assert.deepEqual(actual, expected);\n\n            array = clone.slice();\n            actual = _(array).thru(_.compact)[methodName](identity).pull(1).push(3).reverse().value();\n\n            assert.deepEqual(actual, [3].concat(expected.slice(0, -1)));\n          });\n        });\n      }\n      else {\n        skipAssert(assert, 8);\n      }\n    });\n\n    QUnit.test('should track the `__chain__` value of a wrapper', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        lodashStable.times(2, function(index) {\n          var array = (index ? largeArray : smallArray).slice(),\n              expected = array.slice().reverse(),\n              wrapped = _(array).chain().reverse().head();\n\n          assert.ok(wrapped instanceof _);\n          assert.strictEqual(wrapped.value(), _.head(expected));\n          assert.deepEqual(array, expected);\n        });\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('round methods');\n\n  lodashStable.each(['ceil', 'floor', 'round'], function(methodName) {\n    var func = _[methodName],\n        isCeil = methodName == 'ceil',\n        isFloor = methodName == 'floor';\n\n    QUnit.test('`_.' + methodName + '` should return a rounded number without a precision', function(assert) {\n      assert.expect(1);\n\n      var actual = func(4.006);\n      assert.strictEqual(actual, isCeil ? 5 : 4);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a precision of `0`', function(assert) {\n      assert.expect(1);\n\n      var actual = func(4.006, 0);\n      assert.strictEqual(actual, isCeil ? 5 : 4);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a positive precision', function(assert) {\n      assert.expect(2);\n\n      var actual = func(4.016, 2);\n      assert.strictEqual(actual, isFloor ? 4.01 : 4.02);\n\n      actual = func(4.1, 2);\n      assert.strictEqual(actual, 4.1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a negative precision', function(assert) {\n      assert.expect(1);\n\n      var actual = func(4160, -2);\n      assert.strictEqual(actual, isFloor ? 4100 : 4200);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `precision` to an integer', function(assert) {\n      assert.expect(3);\n\n      var actual = func(4.006, NaN);\n      assert.strictEqual(actual, isCeil ? 5 : 4);\n\n      var expected = isFloor ? 4.01 : 4.02;\n\n      actual = func(4.016, 2.6);\n      assert.strictEqual(actual, expected);\n\n      actual = func(4.016, '+2');\n      assert.strictEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with exponential notation and `precision`', function(assert) {\n      assert.expect(3);\n\n      var actual = func(5e1, 2);\n      assert.deepEqual(actual, 50);\n\n      actual = func('5e', 1);\n      assert.deepEqual(actual, NaN);\n\n      actual = func('5e1e1', 1);\n      assert.deepEqual(actual, NaN);\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var values = [[0], [-0], ['0'], ['-0'], [0, 1], [-0, 1], ['0', 1], ['-0', 1]],\n          expected = [Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity];\n\n      var actual = lodashStable.map(values, function(args) {\n        return 1 / func.apply(undefined, args);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not return `NaN` for large `precision` values', function(assert) {\n      assert.expect(1);\n\n      var results = [\n        _.round(10.0000001, 1000),\n        _.round(MAX_SAFE_INTEGER, 293)\n      ];\n\n      var expected = lodashStable.map(results, stubFalse),\n          actual = lodashStable.map(results, lodashStable.isNaN);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `Infinity` given `Infinity` regardless of `precision`', function(assert) {\n      assert.expect(6);\n\n      var actual = func(Infinity);\n      assert.strictEqual(actual, Infinity);\n\n      actual = func(Infinity, 0);\n      assert.strictEqual(actual, Infinity);\n\n      actual = func(Infinity, 2);\n      assert.strictEqual(actual, Infinity);\n\n      actual = func(Infinity, -2);\n      assert.strictEqual(actual, Infinity);\n\n      actual = func(Infinity, 2);\n      assert.strictEqual(actual, isFloor ? Infinity : Infinity);\n\n      actual = func(Infinity, 2);\n      assert.strictEqual(actual, isCeil ? Infinity : Infinity);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `-Infinity` given `-Infinity` regardless of `precision`', function(assert) {\n      assert.expect(6);\n\n      var actual = func(-Infinity);\n      assert.strictEqual(actual, -Infinity);\n\n      actual = func(-Infinity, 0);\n      assert.strictEqual(actual, -Infinity);\n\n      actual = func(-Infinity, 2);\n      assert.strictEqual(actual, -Infinity);\n\n      actual = func(-Infinity, -2);\n      assert.strictEqual(actual, -Infinity);\n\n      actual = func(-Infinity, 2);\n      assert.strictEqual(actual, isFloor ? -Infinity : -Infinity);\n\n      actual = func(-Infinity, 2);\n      assert.strictEqual(actual, isCeil ? -Infinity : -Infinity);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `NaN` given `NaN` regardless of `precision`', function(assert) {\n      assert.expect(6);\n\n      var actual = func(NaN);\n      assert.deepEqual(actual, NaN);\n\n      actual = func(NaN, 0);\n      assert.deepEqual(actual, NaN);\n\n      actual = func(NaN, 2);\n      assert.deepEqual(actual, NaN);\n\n      actual = func(NaN, -2);\n      assert.deepEqual(actual, NaN);\n\n      actual = func(NaN, 2);\n      assert.deepEqual(actual, isFloor ? NaN : NaN);\n\n      actual = func(NaN, 2);\n      assert.deepEqual(actual, isCeil ? NaN : NaN);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.runInContext');\n\n  (function() {\n    QUnit.test('should not require a fully populated `context` object', function(assert) {\n      assert.expect(1);\n\n      if (!isModularize) {\n        var lodash = _.runInContext({\n          'setTimeout': function(func) { func(); }\n        });\n\n        var pass = false;\n        lodash.delay(function() { pass = true; }, 32);\n        assert.ok(pass);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should use a zeroed `_.uniqueId` counter', function(assert) {\n      assert.expect(3);\n\n      if (!isModularize) {\n        lodashStable.times(2, _.uniqueId);\n\n        var oldId = Number(_.uniqueId()),\n            lodash = _.runInContext();\n\n        assert.ok(_.uniqueId() > oldId);\n\n        var id = lodash.uniqueId();\n        assert.strictEqual(id, '1');\n        assert.ok(id < oldId);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.sample');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should return a random element', function(assert) {\n      assert.expect(1);\n\n      var actual = _.sample(array);\n      assert.ok(lodashStable.includes(array, actual));\n    });\n\n    QUnit.test('should return `undefined` when sampling empty collections', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, noop);\n\n      var actual = lodashStable.transform(empties, function(result, value) {\n        try {\n          result.push(_.sample(value));\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should sample an object', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          actual = _.sample(object);\n\n      assert.ok(lodashStable.includes(array, actual));\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.sampleSize');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should return an array of random elements', function(assert) {\n      assert.expect(2);\n\n      var actual = _.sampleSize(array, 2);\n\n      assert.strictEqual(actual.length, 2);\n      assert.deepEqual(lodashStable.difference(actual, array), []);\n    });\n\n    QUnit.test('should contain elements of the collection', function(assert) {\n      assert.expect(1);\n\n      var actual = _.sampleSize(array, array.length).sort();\n\n      assert.deepEqual(actual, array);\n    });\n\n    QUnit.test('should treat falsey `size` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? ['a'] : [];\n      });\n\n      var actual = lodashStable.map(falsey, function(size, index) {\n        return index ? _.sampleSize(['a'], size) : _.sampleSize(['a']);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an empty array when `n` < `1` or `NaN`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([0, -1, -Infinity], function(n) {\n        assert.deepEqual(_.sampleSize(array, n), []);\n      });\n    });\n\n    QUnit.test('should return all elements when `n` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(n) {\n        var actual = _.sampleSize(array, n).sort();\n        assert.deepEqual(actual, array);\n      });\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(1);\n\n      var actual = _.sampleSize(array, 1.6);\n      assert.strictEqual(actual.length, 1);\n    });\n\n    QUnit.test('should return an empty array for empty collections', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, stubArray);\n\n      var actual = lodashStable.transform(empties, function(result, value) {\n        try {\n          result.push(_.sampleSize(value, 1));\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should sample an object', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': 1, 'b': 2, 'c': 3 },\n          actual = _.sampleSize(object, 2);\n\n      assert.strictEqual(actual.length, 2);\n      assert.deepEqual(lodashStable.difference(actual, lodashStable.values(object)), []);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map([['a']], _.sampleSize);\n      assert.deepEqual(actual, [['a']]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.setWith');\n\n  (function() {\n    QUnit.test('should work with a `customizer` callback', function(assert) {\n      assert.expect(1);\n\n      var actual = _.setWith({ '0': {} }, '[0][1][2]', 3, function(value) {\n        return lodashStable.isObject(value) ? undefined : {};\n      });\n\n      assert.deepEqual(actual, { '0': { '1': { '2': 3 } } });\n    });\n\n    QUnit.test('should work with a `customizer` that returns `undefined`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.setWith({}, 'a[0].b.c', 4, noop);\n      assert.deepEqual(actual, { 'a': [{ 'b': { 'c': 4 } }] });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('set methods');\n\n  lodashStable.each(['update', 'updateWith', 'set', 'setWith'], function(methodName) {\n    var func = _[methodName],\n        isUpdate = /^update/.test(methodName);\n\n    var oldValue = 1,\n        value = 2,\n        updater = isUpdate ? lodashStable.constant(value) : value;\n\n    QUnit.test('`_.' + methodName + '` should set property values', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var object = { 'a': oldValue },\n            actual = func(object, path, updater);\n\n        assert.strictEqual(actual, object);\n        assert.strictEqual(object.a, value);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var props = [-0, Object(-0), 0, Object(0)],\n          expected = lodashStable.map(props, lodashStable.constant(value));\n\n      var actual = lodashStable.map(props, function(key) {\n        var object = { '-0': 'a', '0': 'b' };\n        func(object, key, updater);\n        return object[lodashStable.toString(key)];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should unset symbol keyed property values', function(assert) {\n      assert.expect(2);\n\n      if (Symbol) {\n        var object = {};\n        object[symbol] = 1;\n\n        assert.strictEqual(_.unset(object, symbol), true);\n        assert.notOk(symbol in object);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should set deep property values', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var object = { 'a': { 'b': oldValue } },\n            actual = func(object, path, updater);\n\n        assert.strictEqual(actual, object);\n        assert.strictEqual(object.a.b, value);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should set a key over a path', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a.b', ['a.b']], function(path) {\n        var object = { 'a.b': oldValue },\n            actual = func(object, path, updater);\n\n        assert.strictEqual(actual, object);\n        assert.deepEqual(object, { 'a.b': value });\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not coerce array paths to strings', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a,b,c': 1, 'a': { 'b': { 'c': 1 } } };\n\n      func(object, ['a', 'b', 'c'], updater);\n      assert.strictEqual(object.a.b.c, value);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not ignore empty brackets', function(assert) {\n      assert.expect(1);\n\n      var object = {};\n\n      func(object, 'a[]', updater);\n      assert.deepEqual(object, { 'a': { '': value } });\n    });\n\n    QUnit.test('`_.' + methodName + '` should handle empty paths', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([['', ''], [[], ['']]], function(pair, index) {\n        var object = {};\n\n        func(object, pair[0], updater);\n        assert.deepEqual(object, index ? {} : { '': value });\n\n        func(object, pair[1], updater);\n        assert.deepEqual(object, { '': value });\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should handle complex paths', function(assert) {\n      assert.expect(2);\n\n      var object = { 'a': { '1.23': { '[\"b\"]': { 'c': { \"['d']\": { '\\ne\\n': { 'f': { 'g': oldValue } } } } } } } };\n\n      var paths = [\n        'a[-1.23][\"[\\\\\"b\\\\\"]\"].c[\\'[\\\\\\'d\\\\\\']\\'][\\ne\\n][f].g',\n        ['a', '-1.23', '[\"b\"]', 'c', \"['d']\", '\\ne\\n', 'f', 'g']\n      ];\n\n      lodashStable.each(paths, function(path) {\n        func(object, path, updater);\n        assert.strictEqual(object.a[-1.23]['[\"b\"]'].c[\"['d']\"]['\\ne\\n'].f.g, value);\n        object.a[-1.23]['[\"b\"]'].c[\"['d']\"]['\\ne\\n'].f.g = oldValue;\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should create parts of `path` that are missing', function(assert) {\n      assert.expect(6);\n\n      var object = {};\n\n      lodashStable.each(['a[1].b.c', ['a', '1', 'b', 'c']], function(path) {\n        var actual = func(object, path, updater);\n\n        assert.strictEqual(actual, object);\n        assert.deepEqual(actual, { 'a': [undefined, { 'b': { 'c': value } }] });\n        assert.notOk('0' in object.a);\n\n        delete object.a;\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not error when `object` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [null, undefined],\n          expected = [[null, null], [undefined, undefined]];\n\n      var actual = lodashStable.map(values, function(value) {\n        try {\n          return [func(value, 'a.b', updater), func(value, ['a', 'b'], updater)];\n        } catch (e) {\n          return e.message;\n        }\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should overwrite primitives in the path', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var object = { 'a': '' };\n\n        func(object, path, updater);\n        assert.deepEqual(object, { 'a': { 'b': 2 } });\n      });;\n    });\n\n    QUnit.test('`_.' + methodName + '` should not create an array for missing non-index property names that start with numbers', function(assert) {\n      assert.expect(1);\n\n      var object = {};\n\n      func(object, ['1a', '2b', '3c'], updater);\n      assert.deepEqual(object, { '1a': { '2b': { '3c': value } } });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not assign values that are the same as their destinations', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a', ['a'], { 'a': 1 }, NaN], function(value) {\n        var object = {},\n            pass = true,\n            updater = isUpdate ? lodashStable.constant(value) : value;\n\n        defineProperty(object, 'a', {\n          'configurable': true,\n          'enumerable': true,\n          'get': lodashStable.constant(value),\n          'set': function() { pass = false; }\n        });\n\n        func(object, 'a', updater);\n        assert.ok(pass);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.shuffle');\n\n  (function() {\n    var array = [1, 2, 3],\n        object = { 'a': 1, 'b': 2, 'c': 3 };\n\n    QUnit.test('should return a new array', function(assert) {\n      assert.expect(1);\n\n      assert.notStrictEqual(_.shuffle(array), array);\n    });\n\n    QUnit.test('should contain the same elements after a collection is shuffled', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.shuffle(array).sort(), array);\n      assert.deepEqual(_.shuffle(object).sort(), array);\n    });\n\n    QUnit.test('should shuffle small collections', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.times(1000, function(assert) {\n        return _.shuffle([1, 2]);\n      });\n\n      assert.deepEqual(lodashStable.sortBy(lodashStable.uniqBy(actual, String), '0'), [[1, 2], [2, 1]]);\n    });\n\n    QUnit.test('should treat number values for `collection` as empty', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.shuffle(1), []);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.size');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should return the number of own enumerable string keyed properties of an object', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.size({ 'one': 1, 'two': 2, 'three': 3 }), 3);\n    });\n\n    QUnit.test('should return the length of an array', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.size(array), 3);\n    });\n\n    QUnit.test('should accept a falsey `object`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubZero);\n\n      var actual = lodashStable.map(falsey, function(object, index) {\n        try {\n          return index ? _.size(object) : _.size();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.size(args), 3);\n    });\n\n    QUnit.test('should work with jQuery/MooTools DOM query collections', function(assert) {\n      assert.expect(1);\n\n      function Foo(elements) {\n        push.apply(this, elements);\n      }\n      Foo.prototype = { 'length': 0, 'splice': arrayProto.splice };\n\n      assert.strictEqual(_.size(new Foo(array)), 3);\n    });\n\n    QUnit.test('should work with maps', function(assert) {\n      assert.expect(2);\n\n      if (Map) {\n        lodashStable.each([new Map, realm.map], function(map) {\n          map.set('a', 1);\n          map.set('b', 2);\n          assert.strictEqual(_.size(map), 2);\n          map.clear();\n        });\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should work with sets', function(assert) {\n      assert.expect(2);\n\n      if (Set) {\n        lodashStable.each([new Set, realm.set], function(set) {\n          set.add(1);\n          set.add(2);\n          assert.strictEqual(_.size(set), 2);\n          set.clear();\n        });\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should not treat objects with negative lengths as array-like', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.size({ 'length': -1 }), 1);\n    });\n\n    QUnit.test('should not treat objects with lengths larger than `MAX_SAFE_INTEGER` as array-like', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.size({ 'length': MAX_SAFE_INTEGER + 1 }), 1);\n    });\n\n    QUnit.test('should not treat objects with non-number lengths as array-like', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.size({ 'length': '0' }), 1);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.slice');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should use a default `start` of `0` and a default `end` of `length`', function(assert) {\n      assert.expect(2);\n\n      var actual = _.slice(array);\n      assert.deepEqual(actual, array);\n      assert.notStrictEqual(actual, array);\n    });\n\n    QUnit.test('should work with a positive `start`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.slice(array, 1), [2, 3]);\n      assert.deepEqual(_.slice(array, 1, 3), [2, 3]);\n    });\n\n    QUnit.test('should work with a `start` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(start) {\n        assert.deepEqual(_.slice(array, start), []);\n      });\n    });\n\n    QUnit.test('should treat falsey `start` values as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, lodashStable.constant(array));\n\n      var actual = lodashStable.map(falsey, function(start) {\n        return _.slice(array, start);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with a negative `start`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.slice(array, -1), [3]);\n    });\n\n    QUnit.test('should work with a negative `start` <= negative `length`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([-3, -4, -Infinity], function(start) {\n        assert.deepEqual(_.slice(array, start), array);\n      });\n    });\n\n    QUnit.test('should work with `start` >= `end`', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([2, 3], function(start) {\n        assert.deepEqual(_.slice(array, start, 2), []);\n      });\n    });\n\n    QUnit.test('should work with a positive `end`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.slice(array, 0, 1), [1]);\n    });\n\n    QUnit.test('should work with a `end` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(end) {\n        assert.deepEqual(_.slice(array, 0, end), array);\n      });\n    });\n\n    QUnit.test('should treat falsey `end` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? array : [];\n      });\n\n      var actual = lodashStable.map(falsey, function(end, index) {\n        return index ? _.slice(array, 0, end) : _.slice(array, 0);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with a negative `end`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.slice(array, 0, -1), [1, 2]);\n    });\n\n    QUnit.test('should work with a negative `end` <= negative `length`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([-3, -4, -Infinity], function(end) {\n        assert.deepEqual(_.slice(array, 0, end), []);\n      });\n    });\n\n    QUnit.test('should coerce `start` and `end` to integers', function(assert) {\n      assert.expect(1);\n\n      var positions = [[0.1, 1.6], ['0', 1], [0, '1'], ['1'], [NaN, 1], [1, NaN]];\n\n      var actual = lodashStable.map(positions, function(pos) {\n        return _.slice.apply(_, [array].concat(pos));\n      });\n\n      assert.deepEqual(actual, [[1], [1], [1], [2, 3], [1], []]);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(2);\n\n      var array = [[1], [2, 3]],\n          actual = lodashStable.map(array, _.slice);\n\n      assert.deepEqual(actual, array);\n      assert.notStrictEqual(actual, array);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(38);\n\n      if (!isNpm) {\n        var array = lodashStable.range(1, LARGE_ARRAY_SIZE + 1),\n            length = array.length,\n            wrapped = _(array);\n\n        lodashStable.each(['map', 'filter'], function(methodName) {\n          assert.deepEqual(wrapped[methodName]().slice(0, -1).value(), array.slice(0, -1));\n          assert.deepEqual(wrapped[methodName]().slice(1).value(), array.slice(1));\n          assert.deepEqual(wrapped[methodName]().slice(1, 3).value(), array.slice(1, 3));\n          assert.deepEqual(wrapped[methodName]().slice(-1).value(), array.slice(-1));\n\n          assert.deepEqual(wrapped[methodName]().slice(length).value(), array.slice(length));\n          assert.deepEqual(wrapped[methodName]().slice(3, 2).value(), array.slice(3, 2));\n          assert.deepEqual(wrapped[methodName]().slice(0, -length).value(), array.slice(0, -length));\n          assert.deepEqual(wrapped[methodName]().slice(0, null).value(), array.slice(0, null));\n\n          assert.deepEqual(wrapped[methodName]().slice(0, length).value(), array.slice(0, length));\n          assert.deepEqual(wrapped[methodName]().slice(-length).value(), array.slice(-length));\n          assert.deepEqual(wrapped[methodName]().slice(null).value(), array.slice(null));\n\n          assert.deepEqual(wrapped[methodName]().slice(0, 1).value(), array.slice(0, 1));\n          assert.deepEqual(wrapped[methodName]().slice(NaN, '1').value(), array.slice(NaN, '1'));\n\n          assert.deepEqual(wrapped[methodName]().slice(0.1, 1.1).value(), array.slice(0.1, 1.1));\n          assert.deepEqual(wrapped[methodName]().slice('0', 1).value(), array.slice('0', 1));\n          assert.deepEqual(wrapped[methodName]().slice(0, '1').value(), array.slice(0, '1'));\n          assert.deepEqual(wrapped[methodName]().slice('1').value(), array.slice('1'));\n          assert.deepEqual(wrapped[methodName]().slice(NaN, 1).value(), array.slice(NaN, 1));\n          assert.deepEqual(wrapped[methodName]().slice(1, NaN).value(), array.slice(1, NaN));\n        });\n      }\n      else {\n        skipAssert(assert, 38);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.some');\n\n  (function() {\n    QUnit.test('should return `true` if `predicate` returns truthy for any element', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.some([false, 1, ''], identity), true);\n      assert.strictEqual(_.some([null, 'a', 0], identity), true);\n    });\n\n    QUnit.test('should return `false` for empty collections', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, stubFalse);\n\n      var actual = lodashStable.map(empties, function(value) {\n        try {\n          return _.some(value, identity);\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return `true` as soon as `predicate` returns truthy', function(assert) {\n      assert.expect(2);\n\n      var count = 0;\n\n      assert.strictEqual(_.some([null, true, null], function(value) {\n        count++;\n        return value;\n      }), true);\n\n      assert.strictEqual(count, 2);\n    });\n\n    QUnit.test('should return `false` if `predicate` returns falsey for all elements', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.some([false, false, false], identity), false);\n      assert.strictEqual(_.some([null, 0, ''], identity), false);\n    });\n\n    QUnit.test('should use `_.identity` when `predicate` is nullish', function(assert) {\n      assert.expect(2);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var array = [0, 0];\n        return index ? _.some(array, value) : _.some(array);\n      });\n\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(values, stubTrue);\n      actual = lodashStable.map(values, function(value, index) {\n        var array = [0, 1];\n        return index ? _.some(array, value) : _.some(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 0, 'b': 0 }, { 'a': 0, 'b': 1 }];\n      assert.strictEqual(_.some(objects, 'a'), false);\n      assert.strictEqual(_.some(objects, 'b'), true);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(2);\n\n      var objects = [{ 'a': 0, 'b': 0 }, { 'a': 1, 'b': 1}];\n      assert.strictEqual(_.some(objects, { 'a': 0 }), true);\n      assert.strictEqual(_.some(objects, { 'b': 2 }), false);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map([[1]], _.some);\n      assert.deepEqual(actual, [true]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.sortBy');\n\n  (function() {\n    var objects = [\n      { 'a': 'x', 'b': 3 },\n      { 'a': 'y', 'b': 4 },\n      { 'a': 'x', 'b': 1 },\n      { 'a': 'y', 'b': 2 }\n    ];\n\n    QUnit.test('should sort in ascending order by `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(_.sortBy(objects, function(object) {\n        return object.b;\n      }), 'b');\n\n      assert.deepEqual(actual, [1, 2, 3, 4]);\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var array = [3, 2, 1],\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([1, 2, 3]));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.sortBy(array, value) : _.sortBy(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(_.sortBy(objects.concat(undefined), 'b'), 'b');\n      assert.deepEqual(actual, [1, 2, 3, 4, undefined]);\n    });\n\n    QUnit.test('should work with an object for `collection`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.sortBy({ 'a': 1, 'b': 2, 'c': 3 }, Math.sin);\n      assert.deepEqual(actual, [3, 1, 2]);\n    });\n\n    QUnit.test('should move `NaN`, nullish, and symbol values to the end', function(assert) {\n      assert.expect(2);\n\n      var symbol1 = Symbol ? Symbol('a') : null,\n          symbol2 = Symbol ? Symbol('b') : null,\n          array = [NaN, undefined, null, 4, symbol1, null, 1, symbol2, undefined, 3, NaN, 2],\n          expected = [1, 2, 3, 4, symbol1, symbol2, null, null, undefined, undefined, NaN, NaN];\n\n      assert.deepEqual(_.sortBy(array), expected);\n\n      array = [NaN, undefined, symbol1, null, 'd', null, 'a', symbol2, undefined, 'c', NaN, 'b'];\n      expected = ['a', 'b', 'c', 'd', symbol1, symbol2, null, null, undefined, undefined, NaN, NaN];\n\n      assert.deepEqual(_.sortBy(array), expected);\n    });\n\n    QUnit.test('should treat number values for `collection` as empty', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.sortBy(1), []);\n    });\n\n    QUnit.test('should coerce arrays returned from `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.sortBy(objects, function(object) {\n        var result = [object.a, object.b];\n        result.toString = function() { return String(this[0]); };\n        return result;\n      });\n\n      assert.deepEqual(actual, [objects[0], objects[2], objects[1], objects[3]]);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map([[2, 1, 3], [3, 2, 1]], _.sortBy);\n      assert.deepEqual(actual, [[1, 2, 3], [1, 2, 3]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('sortBy methods');\n\n  lodashStable.each(['orderBy', 'sortBy'], function(methodName) {\n    var func = _[methodName];\n\n    function Pair(a, b, c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    var objects = [\n      { 'a': 'x', 'b': 3 },\n      { 'a': 'y', 'b': 4 },\n      { 'a': 'x', 'b': 1 },\n      { 'a': 'y', 'b': 2 }\n    ];\n\n    var stableArray = [\n      new Pair(1, 1, 1), new Pair(1, 2, 1),\n      new Pair(1, 1, 1), new Pair(1, 2, 1),\n      new Pair(1, 3, 1), new Pair(1, 4, 1),\n      new Pair(1, 5, 1), new Pair(1, 6, 1),\n      new Pair(2, 1, 2), new Pair(2, 2, 2),\n      new Pair(2, 3, 2), new Pair(2, 4, 2),\n      new Pair(2, 5, 2), new Pair(2, 6, 2),\n      new Pair(undefined, 1, 1), new Pair(undefined, 2, 1),\n      new Pair(undefined, 3, 1), new Pair(undefined, 4, 1),\n      new Pair(undefined, 5, 1), new Pair(undefined, 6, 1)\n    ];\n\n    var stableObject = lodashStable.zipObject('abcdefghijklmnopqrst'.split(''), stableArray);\n\n    QUnit.test('`_.' + methodName + '` should sort multiple properties in ascending order', function(assert) {\n      assert.expect(1);\n\n      var actual = func(objects, ['a', 'b']);\n      assert.deepEqual(actual, [objects[2], objects[0], objects[3], objects[1]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support iteratees', function(assert) {\n      assert.expect(1);\n\n      var actual = func(objects, ['a', function(object) { return object.b; }]);\n      assert.deepEqual(actual, [objects[2], objects[0], objects[3], objects[1]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should perform a stable sort (test in IE > 8 and V8)', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([stableArray, stableObject], function(value, index) {\n        var actual = func(value, ['a', 'c']);\n        assert.deepEqual(actual, stableArray, index ? 'object' : 'array');\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should not error on nullish elements', function(assert) {\n      assert.expect(1);\n\n      try {\n        var actual = func(objects.concat(null, undefined), ['a', 'b']);\n      } catch (e) {}\n\n      assert.deepEqual(actual, [objects[2], objects[0], objects[3], objects[1], null, undefined]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work as an iteratee for methods like `_.reduce`', function(assert) {\n      assert.expect(3);\n\n      var objects = [\n        { 'a': 'x', '0': 3 },\n        { 'a': 'y', '0': 4 },\n        { 'a': 'x', '0': 1 },\n        { 'a': 'y', '0': 2 }\n      ];\n\n      var funcs = [func, lodashStable.partialRight(func, 'bogus')];\n\n      lodashStable.each(['a', 0, [0]], function(props, index) {\n        var expected = lodashStable.map(funcs, lodashStable.constant(\n          index\n            ? [objects[2], objects[3], objects[0], objects[1]]\n            : [objects[0], objects[2], objects[1], objects[3]]\n        ));\n\n        var actual = lodashStable.map(funcs, function(func) {\n          return lodashStable.reduce([props], func, objects);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('sortedIndex methods');\n\n  lodashStable.each(['sortedIndex', 'sortedLastIndex'], function(methodName) {\n    var func = _[methodName],\n        isSortedIndex = methodName == 'sortedIndex';\n\n    QUnit.test('`_.' + methodName + '` should return the insert index', function(assert) {\n      assert.expect(1);\n\n      var array = [30, 50],\n          values = [30, 40, 50],\n          expected = isSortedIndex ? [0, 1, 1] : [1, 1, 2];\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(array, value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with an array of strings', function(assert) {\n      assert.expect(1);\n\n      var array = ['a', 'c'],\n          values = ['a', 'b', 'c'],\n          expected = isSortedIndex ? [0, 1, 1] : [1, 1, 2];\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(array, value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should accept a nullish `array` and a `value`', function(assert) {\n      assert.expect(1);\n\n      var values = [null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([0, 0, 0]));\n\n      var actual = lodashStable.map(values, function(array) {\n        return [func(array, 1), func(array, undefined), func(array, NaN)];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should align with `_.sortBy`', function(assert) {\n      assert.expect(12);\n\n      var symbol1 = Symbol ? Symbol('a') : null,\n          symbol2 = Symbol ? Symbol('b') : null,\n          symbol3 = Symbol ? Symbol('c') : null,\n          expected = [1, '2', {}, symbol1, symbol2, null, undefined, NaN, NaN];\n\n      lodashStable.each([\n        [NaN, symbol1, null, 1, '2', {}, symbol2, NaN, undefined],\n        ['2', null, 1, symbol1, NaN, {}, NaN, symbol2, undefined]\n      ], function(array) {\n        assert.deepEqual(_.sortBy(array), expected);\n        assert.strictEqual(func(expected, 3), 2);\n        assert.strictEqual(func(expected, symbol3), isSortedIndex ? 3 : (Symbol ? 5 : 6));\n        assert.strictEqual(func(expected, null), isSortedIndex ? (Symbol ? 5 : 3) : 6);\n        assert.strictEqual(func(expected, undefined), isSortedIndex ? 6 : 7);\n        assert.strictEqual(func(expected, NaN), isSortedIndex ? 7 : 9);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should align with `_.sortBy` for nulls', function(assert) {\n      assert.expect(3);\n\n      var array = [null, null];\n\n      assert.strictEqual(func(array, null), isSortedIndex ? 0 : 2);\n      assert.strictEqual(func(array, 1), 0);\n      assert.strictEqual(func(array, 'a'), 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` should align with `_.sortBy` for symbols', function(assert) {\n      assert.expect(3);\n\n      var symbol1 = Symbol ? Symbol('a') : null,\n          symbol2 = Symbol ? Symbol('b') : null,\n          symbol3 = Symbol ? Symbol('c') : null,\n          array = [symbol1, symbol2];\n\n      assert.strictEqual(func(array, symbol3), isSortedIndex ? 0 : 2);\n      assert.strictEqual(func(array, 1), 0);\n      assert.strictEqual(func(array, 'a'), 0);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('sortedIndexBy methods');\n\n  lodashStable.each(['sortedIndexBy', 'sortedLastIndexBy'], function(methodName) {\n    var func = _[methodName],\n        isSortedIndexBy = methodName == 'sortedIndexBy';\n\n    QUnit.test('`_.' + methodName + '` should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func([30, 50], 40, function(assert) {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [40]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 30 }, { 'x': 50 }],\n          actual = func(objects, { 'x': 40 }, 'x');\n\n      assert.strictEqual(actual, 1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should avoid calling iteratee when length is 0', function(assert) {\n      var objects = [],\n          iteratee = function() {\n            throw new Error;\n          },\n          actual = func(objects, { 'x': 50 }, iteratee);\n\n      assert.strictEqual(actual, 0);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support arrays larger than `MAX_ARRAY_LENGTH / 2`', function(assert) {\n      assert.expect(12);\n\n      lodashStable.each([Math.ceil(MAX_ARRAY_LENGTH / 2), MAX_ARRAY_LENGTH], function(length) {\n        var array = [],\n            values = [MAX_ARRAY_LENGTH, NaN, undefined];\n\n        array.length = length;\n\n        lodashStable.each(values, function(value) {\n          var steps = 0;\n\n          var actual = func(array, value, function(value) {\n            steps++;\n            return value;\n          });\n\n          var expected = (isSortedIndexBy ? !lodashStable.isNaN(value) : lodashStable.isFinite(value))\n            ? 0\n            : Math.min(length, MAX_ARRAY_INDEX);\n\n          assert.ok(steps == 32 || steps == 33);\n          assert.strictEqual(actual, expected);\n        });\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('sortedIndexOf methods');\n\n  lodashStable.each(['sortedIndexOf', 'sortedLastIndexOf'], function(methodName) {\n    var func = _[methodName],\n        isSortedIndexOf = methodName == 'sortedIndexOf';\n\n    QUnit.test('`_.' + methodName + '` should perform a binary search', function(assert) {\n      assert.expect(1);\n\n      var sorted = [4, 4, 5, 5, 6, 6];\n      assert.deepEqual(func(sorted, 5), isSortedIndexOf ? 2 : 3);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.sortedUniq');\n\n  (function() {\n    QUnit.test('should return unique values of a sorted array', function(assert) {\n      assert.expect(3);\n\n      var expected = [1, 2, 3];\n\n      lodashStable.each([[1, 2, 3], [1, 1, 2, 2, 3], [1, 2, 3, 3, 3, 3, 3]], function(array) {\n        assert.deepEqual(_.sortedUniq(array), expected);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.split');\n\n  (function() {\n    QUnit.test('should split a string by `separator`', function(assert) {\n      assert.expect(3);\n\n      var string = 'abcde';\n      assert.deepEqual(_.split(string, 'c'), ['ab', 'de']);\n      assert.deepEqual(_.split(string, /[bd]/), ['a', 'c', 'e']);\n      assert.deepEqual(_.split(string, '', 2), ['a', 'b']);\n    });\n\n    QUnit.test('should return an array containing an empty string for empty values', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined, ''],\n          expected = lodashStable.map(values, lodashStable.constant(['']));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.split(value) : _.split();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var strings = ['abc', 'def', 'ghi'],\n          actual = lodashStable.map(strings, _.split);\n\n      assert.deepEqual(actual, [['abc'], ['def'], ['ghi']]);\n    });\n\n    QUnit.test('should allow mixed string and array prototype methods', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _('abc');\n        assert.strictEqual(wrapped.split('b').join(','), 'a,c');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.spread');\n\n  (function() {\n    function fn(a, b, c) {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should spread arguments to `func`', function(assert) {\n      assert.expect(2);\n\n      var spread = _.spread(fn),\n          expected = [1, 2];\n\n      assert.deepEqual(spread([1, 2]), expected);\n      assert.deepEqual(spread([1, 2], 3), expected);\n    });\n\n    QUnit.test('should accept a falsey `array`', function(assert) {\n      assert.expect(1);\n\n      var spread = _.spread(stubTrue),\n          expected = lodashStable.map(falsey, stubTrue);\n\n      var actual = lodashStable.map(falsey, function(array, index) {\n        try {\n          return index ? spread(array) : spread();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with `start`', function(assert) {\n      assert.expect(2);\n\n      var spread = _.spread(fn, 1),\n          expected = [1, 2, 3];\n\n      assert.deepEqual(spread(1, [2, 3]), expected);\n      assert.deepEqual(spread(1, [2, 3], 4), expected);\n    });\n\n    QUnit.test('should treat `start` as `0` for negative or `NaN` values', function(assert) {\n      assert.expect(1);\n\n      var values = [-1, NaN, 'a'],\n          expected = lodashStable.map(values, lodashStable.constant([1, 2]));\n\n      var actual = lodashStable.map(values, function(value) {\n        var spread = _.spread(fn, value);\n        return spread([1, 2]);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should coerce `start` to an integer', function(assert) {\n      assert.expect(2);\n\n      var spread = _.spread(fn, 1.6),\n          expected = [1, 2, 3];\n\n      assert.deepEqual(spread(1, [2, 3]), expected);\n      assert.deepEqual(spread(1, [2, 3], 4), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.startCase');\n\n  (function() {\n    QUnit.test('should uppercase only the first character of each word', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.startCase('--foo-bar--'), 'Foo Bar');\n      assert.strictEqual(_.startCase('fooBar'), 'Foo Bar');\n      assert.strictEqual(_.startCase('__FOO_BAR__'), 'FOO BAR');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.startsWith');\n\n  (function() {\n    var string = 'abc';\n\n    QUnit.test('should return `true` if a string starts with `target`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.startsWith(string, 'a'), true);\n    });\n\n    QUnit.test('should return `false` if a string does not start with `target`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.startsWith(string, 'b'), false);\n    });\n\n    QUnit.test('should work with a `position`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.startsWith(string, 'b', 1), true);\n    });\n\n    QUnit.test('should work with `position` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 5, MAX_SAFE_INTEGER, Infinity], function(position) {\n        assert.strictEqual(_.startsWith(string, 'a', position), false);\n      });\n    });\n\n    QUnit.test('should treat falsey `position` values as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubTrue);\n\n      var actual = lodashStable.map(falsey, function(position) {\n        return _.startsWith(string, 'a', position);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should treat a negative `position` as `0`', function(assert) {\n      assert.expect(6);\n\n      lodashStable.each([-1, -3, -Infinity], function(position) {\n        assert.strictEqual(_.startsWith(string, 'a', position), true);\n        assert.strictEqual(_.startsWith(string, 'b', position), false);\n      });\n    });\n\n    QUnit.test('should coerce `position` to an integer', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.startsWith(string, 'bc', 1.2), true);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.startsWith and lodash.endsWith');\n\n  lodashStable.each(['startsWith', 'endsWith'], function(methodName) {\n    var func = _[methodName],\n        isStartsWith = methodName == 'startsWith';\n\n    var string = 'abc',\n        chr = isStartsWith ? 'a' : 'c';\n\n    QUnit.test('`_.' + methodName + '` should coerce `string` to a string', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(func(Object(string), chr), true);\n      assert.strictEqual(func({ 'toString': lodashStable.constant(string) }, chr), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `target` to a string', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(func(string, Object(chr)), true);\n      assert.strictEqual(func(string, { 'toString': lodashStable.constant(chr) }), true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `position` to a number', function(assert) {\n      assert.expect(2);\n\n      var position = isStartsWith ? 1 : 2;\n\n      assert.strictEqual(func(string, 'b', Object(position)), true);\n      assert.strictEqual(func(string, 'b', { 'toString': lodashStable.constant(String(position)) }), true);\n    });\n\n    QUnit.test('should return `true` when `target` is an empty string regardless of `position`', function(assert) {\n      assert.expect(1);\n\n      var positions = [-Infinity, NaN, -3, -1, 0, 1, 2, 3, 5, MAX_SAFE_INTEGER, Infinity];\n\n      assert.ok(lodashStable.every(positions, function(position) {\n        return func(string, '', position);\n      }));\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('stub methods');\n\n  lodashStable.each(['noop', 'stubTrue', 'stubFalse', 'stubArray', 'stubObject', 'stubString'], function(methodName) {\n    var func = _[methodName];\n\n    var pair = ({\n      'stubArray': [[], 'an empty array'],\n      'stubFalse': [false, '`false`'],\n      'stubObject': [{}, 'an empty object'],\n      'stubString': ['', 'an empty string'],\n      'stubTrue': [true, '`true`'],\n      'noop': [undefined, '`undefined`']\n    })[methodName];\n\n    var values = Array(2).concat(empties, true, 1, 'a'),\n        expected = lodashStable.map(values, lodashStable.constant(pair[0]));\n\n    QUnit.test('`_.' + methodName + '` should return ' + pair[1], function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        if (index < 2) {\n          return index ? func.call({}) : func();\n        }\n        return func(value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.subtract');\n\n  (function() {\n    QUnit.test('should subtract two numbers', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.subtract(6, 4), 2);\n      assert.strictEqual(_.subtract(-6, 4), -10);\n      assert.strictEqual(_.subtract(-6, -4), -2);\n    });\n\n    QUnit.test('should coerce arguments to numbers', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.subtract('6', '4'), 2);\n      assert.deepEqual(_.subtract('x', 'y'), NaN);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('math operator methods');\n\n  lodashStable.each(['add', 'divide', 'multiply', 'subtract'], function(methodName) {\n    var func = _[methodName],\n        isAddSub = methodName == 'add' || methodName == 'subtract';\n\n    QUnit.test('`_.' + methodName + '` should return `' + (isAddSub ? 0 : 1) + '` when no arguments are given', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(), isAddSub ? 0 : 1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with only one defined argument', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(func(6), 6);\n      assert.strictEqual(func(6, undefined), 6);\n      assert.strictEqual(func(undefined, 4), 4);\n    });\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(2);\n\n      var values = [0, '0', -0, '-0'],\n          expected = [[0, Infinity], ['0', Infinity], [-0, -Infinity], ['-0', -Infinity]];\n\n      lodashStable.times(2, function(index) {\n        var actual = lodashStable.map(values, function(value) {\n          var result = index ? func(undefined, value) : func(value);\n          return [result, 1 / result];\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert objects to `NaN`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(func(0, {}), NaN);\n      assert.deepEqual(func({}, 0), NaN);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert symbols to `NaN`', function(assert) {\n      assert.expect(2);\n\n      if (Symbol) {\n        assert.deepEqual(func(0, symbol), NaN);\n        assert.deepEqual(func(symbol, 0), NaN);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = _(1)[methodName](2);\n        assert.notOk(actual instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var actual = _(1).chain()[methodName](2);\n        assert.ok(actual instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.sumBy');\n\n  (function() {\n    var array = [6, 4, 2],\n        objects = [{ 'a': 2 }, { 'a': 3 }, { 'a': 1 }];\n\n    QUnit.test('should work with an `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.sumBy(objects, function(object) {\n        return object.a;\n      });\n\n      assert.deepEqual(actual, 6);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.sumBy(array, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [6]);\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var arrays = [[2], [3], [1]];\n      assert.strictEqual(_.sumBy(arrays, 0), 6);\n      assert.strictEqual(_.sumBy(objects, 'a'), 6);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('sum methods');\n\n  lodashStable.each(['sum', 'sumBy'], function(methodName) {\n    var array = [6, 4, 2],\n        func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return the sum of an array of numbers', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(array), 12);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return `0` when passing empty `array` values', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(empties, stubZero);\n\n      var actual = lodashStable.map(empties, function(value) {\n        return func(value);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should skip `undefined` values', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func([1, undefined]), 1);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not skip `NaN` values', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func([1, NaN]), NaN);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not coerce values to numbers', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(func(['1', '2']), '12');\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.tail');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should accept a falsey `array`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubArray);\n\n      var actual = lodashStable.map(falsey, function(array, index) {\n        try {\n          return index ? _.tail(array) : _.tail();\n        } catch (e) {}\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should exclude the first element', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.tail(array), [2, 3]);\n    });\n\n    QUnit.test('should return an empty when querying empty arrays', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.tail([]), []);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.tail);\n\n      assert.deepEqual(actual, [[2, 3], [5, 6], [8, 9]]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            values = [];\n\n        var actual = _(array).tail().filter(function(value) {\n          values.push(value);\n          return false;\n        })\n        .value();\n\n        assert.deepEqual(actual, []);\n        assert.deepEqual(values, array.slice(1));\n\n        values = [];\n\n        actual = _(array).filter(function(value) {\n          values.push(value);\n          return isEven(value);\n        })\n        .tail()\n        .value();\n\n        assert.deepEqual(actual, _.tail(_.filter(array, isEven)));\n        assert.deepEqual(values, array);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should not execute subsequent iteratees on an empty array in a lazy sequence', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            iteratee = function() { pass = false; },\n            pass = true,\n            actual = _(array).slice(0, 1).tail().map(iteratee).value();\n\n        assert.ok(pass);\n        assert.deepEqual(actual, []);\n\n        pass = true;\n        actual = _(array).filter().slice(0, 1).tail().map(iteratee).value();\n\n        assert.ok(pass);\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.take');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should take the first two elements', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.take(array, 2), [1, 2]);\n    });\n\n    QUnit.test('should treat falsey `n` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? [1] : [];\n      });\n\n      var actual = lodashStable.map(falsey, function(n) {\n        return _.take(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an empty array when `n` < `1`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([0, -1, -Infinity], function(n) {\n        assert.deepEqual(_.take(array, n), []);\n      });\n    });\n\n    QUnit.test('should return all elements when `n` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(n) {\n        assert.deepEqual(_.take(array, n), array);\n      });\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.take);\n\n      assert.deepEqual(actual, [[1], [4], [7]]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var array = lodashStable.range(1, LARGE_ARRAY_SIZE + 1),\n            predicate = function(value) { values.push(value); return isEven(value); },\n            values = [],\n            actual = _(array).take(2).take().value();\n\n        assert.deepEqual(actual, _.take(_.take(array, 2)));\n\n        actual = _(array).filter(predicate).take(2).take().value();\n        assert.deepEqual(values, [1, 2]);\n        assert.deepEqual(actual, _.take(_.take(_.filter(array, predicate), 2)));\n\n        actual = _(array).take(6).takeRight(4).take(2).takeRight().value();\n        assert.deepEqual(actual, _.takeRight(_.take(_.takeRight(_.take(array, 6), 4), 2)));\n\n        values = [];\n\n        actual = _(array).take(array.length - 1).filter(predicate).take(6).takeRight(4).take(2).takeRight().value();\n        assert.deepEqual(values, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n        assert.deepEqual(actual, _.takeRight(_.take(_.takeRight(_.take(_.filter(_.take(array, array.length - 1), predicate), 6), 4), 2)));\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.takeRight');\n\n  (function() {\n    var array = [1, 2, 3];\n\n    QUnit.test('should take the last two elements', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeRight(array, 2), [2, 3]);\n    });\n\n    QUnit.test('should treat falsey `n` values, except `undefined`, as `0`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, function(value) {\n        return value === undefined ? [3] : [];\n      });\n\n      var actual = lodashStable.map(falsey, function(n) {\n        return _.takeRight(array, n);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an empty array when `n` < `1`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([0, -1, -Infinity], function(n) {\n        assert.deepEqual(_.takeRight(array, n), []);\n      });\n    });\n\n    QUnit.test('should return all elements when `n` >= `length`', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each([3, 4, Math.pow(2, 32), Infinity], function(n) {\n        assert.deepEqual(_.takeRight(array, n), array);\n      });\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n          actual = lodashStable.map(array, _.takeRight);\n\n      assert.deepEqual(actual, [[3], [6], [9]]);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(6);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            predicate = function(value) { values.push(value); return isEven(value); },\n            values = [],\n            actual = _(array).takeRight(2).takeRight().value();\n\n        assert.deepEqual(actual, _.takeRight(_.takeRight(array)));\n\n        actual = _(array).filter(predicate).takeRight(2).takeRight().value();\n        assert.deepEqual(values, array);\n        assert.deepEqual(actual, _.takeRight(_.takeRight(_.filter(array, predicate), 2)));\n\n        actual = _(array).takeRight(6).take(4).takeRight(2).take().value();\n        assert.deepEqual(actual, _.take(_.takeRight(_.take(_.takeRight(array, 6), 4), 2)));\n\n        values = [];\n\n        actual = _(array).filter(predicate).takeRight(6).take(4).takeRight(2).take().value();\n        assert.deepEqual(values, array);\n        assert.deepEqual(actual, _.take(_.takeRight(_.take(_.takeRight(_.filter(array, predicate), 6), 4), 2)));\n      }\n      else {\n        skipAssert(assert, 6);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.takeRightWhile');\n\n  (function() {\n    var array = [1, 2, 3, 4];\n\n    var objects = [\n      { 'a': 0, 'b': 0 },\n      { 'a': 1, 'b': 1 },\n      { 'a': 2, 'b': 2 }\n    ];\n\n    QUnit.test('should take elements while `predicate` returns truthy', function(assert) {\n      assert.expect(1);\n\n      var actual = _.takeRightWhile(array, function(n) {\n        return n > 2;\n      });\n\n      assert.deepEqual(actual, [3, 4]);\n    });\n\n    QUnit.test('should provide correct `predicate` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.takeRightWhile(array, function() {\n        args = slice.call(arguments);\n      });\n\n      assert.deepEqual(args, [4, 3, array]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeRightWhile(objects, { 'b': 2 }), objects.slice(2));\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeRightWhile(objects, ['b', 2]), objects.slice(2));\n    });\n\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeRightWhile(objects, 'b'), objects.slice(1));\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            predicate = function(n) { return n > 2; },\n            expected = _.takeRightWhile(array, predicate),\n            wrapped = _(array).takeRightWhile(predicate);\n\n        assert.deepEqual(wrapped.value(), expected);\n        assert.deepEqual(wrapped.reverse().value(), expected.slice().reverse());\n        assert.strictEqual(wrapped.last(), _.last(expected));\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should provide correct `predicate` arguments in a lazy sequence', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var args,\n            array = lodashStable.range(LARGE_ARRAY_SIZE + 1);\n\n        var expected = [\n          square(LARGE_ARRAY_SIZE),\n          LARGE_ARRAY_SIZE - 1,\n          lodashStable.map(array.slice(1), square)\n        ];\n\n        _(array).slice(1).takeRightWhile(function(value, index, array) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, [LARGE_ARRAY_SIZE, LARGE_ARRAY_SIZE - 1, array.slice(1)]);\n\n        _(array).slice(1).map(square).takeRightWhile(function(value, index, array) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        _(array).slice(1).map(square).takeRightWhile(function(value, index) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        _(array).slice(1).map(square).takeRightWhile(function(index) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, [square(LARGE_ARRAY_SIZE)]);\n\n        _(array).slice(1).map(square).takeRightWhile(function() {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, expected);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.takeWhile');\n\n  (function() {\n    var array = [1, 2, 3, 4];\n\n    var objects = [\n      { 'a': 2, 'b': 2 },\n      { 'a': 1, 'b': 1 },\n      { 'a': 0, 'b': 0 }\n    ];\n\n    QUnit.test('should take elements while `predicate` returns truthy', function(assert) {\n      assert.expect(1);\n\n      var actual = _.takeWhile(array, function(n) {\n        return n < 3;\n      });\n\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('should provide correct `predicate` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.takeWhile(array, function() {\n        args = slice.call(arguments);\n      });\n\n      assert.deepEqual(args, [1, 0, array]);\n    });\n\n    QUnit.test('should work with `_.matches` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeWhile(objects, { 'b': 2 }), objects.slice(0, 1));\n    });\n\n    QUnit.test('should work with `_.matchesProperty` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeWhile(objects, ['b', 2]), objects.slice(0, 1));\n    });\n    QUnit.test('should work with `_.property` shorthands', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.takeWhile(objects, 'b'), objects.slice(0, 2));\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            predicate = function(n) { return n < 3; },\n            expected = _.takeWhile(array, predicate),\n            wrapped = _(array).takeWhile(predicate);\n\n        assert.deepEqual(wrapped.value(), expected);\n        assert.deepEqual(wrapped.reverse().value(), expected.slice().reverse());\n        assert.strictEqual(wrapped.last(), _.last(expected));\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence with `take`', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE);\n\n        var actual = _(array)\n          .takeWhile(function(n) { return n < 4; })\n          .take(2)\n          .takeWhile(function(n) { return n == 0; })\n          .value();\n\n        assert.deepEqual(actual, [0]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should provide correct `predicate` arguments in a lazy sequence', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var args,\n            array = lodashStable.range(LARGE_ARRAY_SIZE + 1),\n            expected = [1, 0, lodashStable.map(array.slice(1), square)];\n\n        _(array).slice(1).takeWhile(function(value, index, array) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, [1, 0, array.slice(1)]);\n\n        _(array).slice(1).map(square).takeWhile(function(value, index, array) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        _(array).slice(1).map(square).takeWhile(function(value, index) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, expected);\n\n        _(array).slice(1).map(square).takeWhile(function(value) {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, [1]);\n\n        _(array).slice(1).map(square).takeWhile(function() {\n          args = slice.call(arguments);\n        }).value();\n\n        assert.deepEqual(args, expected);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.tap');\n\n  (function() {\n    QUnit.test('should intercept and return the given value', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var intercepted,\n            array = [1, 2, 3];\n\n        var actual = _.tap(array, function(value) {\n          intercepted = value;\n        });\n\n        assert.strictEqual(actual, array);\n        assert.strictEqual(intercepted, array);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should intercept unwrapped values and return wrapped values when chaining', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var intercepted,\n            array = [1, 2, 3];\n\n        var wrapped = _(array).tap(function(value) {\n          intercepted = value;\n          value.pop();\n        });\n\n        assert.ok(wrapped instanceof _);\n\n        wrapped.value();\n        assert.strictEqual(intercepted, array);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.template');\n\n  (function() {\n    QUnit.test('should escape values in \"escape\" delimiters', function(assert) {\n      assert.expect(1);\n\n      var strings = ['<p><%- value %></p>', '<p><%-value%></p>', '<p><%-\\nvalue\\n%></p>'],\n          expected = lodashStable.map(strings, lodashStable.constant('<p>&amp;&lt;&gt;&quot;&#39;/</p>')),\n          data = { 'value': '&<>\"\\'/' };\n\n      var actual = lodashStable.map(strings, function(string) {\n        return _.template(string)(data);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not reference `_.escape` when \"escape\" delimiters are not used', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= typeof __e %>');\n      assert.strictEqual(compiled({}), 'undefined');\n    });\n\n    QUnit.test('should evaluate JavaScript in \"evaluate\" delimiters', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template(\n        '<ul><%\\\n        for (var key in collection) {\\\n          %><li><%= collection[key] %></li><%\\\n        } %></ul>'\n      );\n\n      var data = { 'collection': { 'a': 'A', 'b': 'B' } },\n          actual = compiled(data);\n\n      assert.strictEqual(actual, '<ul><li>A</li><li>B</li></ul>');\n    });\n\n    QUnit.test('should support \"evaluate\" delimiters with single line comments (test production builds)', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<% // A code comment. %><% if (value) { %>yap<% } else { %>nope<% } %>'),\n          data = { 'value': true };\n\n      assert.strictEqual(compiled(data), 'yap');\n    });\n\n    QUnit.test('should support referencing variables declared in \"evaluate\" delimiters from other delimiters', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<% var b = a; %><%= b.value %>'),\n          data = { 'a': { 'value': 1 } };\n\n      assert.strictEqual(compiled(data), '1');\n    });\n\n    QUnit.test('should interpolate data properties in \"interpolate\" delimiters', function(assert) {\n      assert.expect(1);\n\n      var strings = ['<%= a %>BC', '<%=a%>BC', '<%=\\na\\n%>BC'],\n          expected = lodashStable.map(strings, lodashStable.constant('ABC')),\n          data = { 'a': 'A' };\n\n      var actual = lodashStable.map(strings, function(string) {\n        return _.template(string)(data);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should support \"interpolate\" delimiters with escaped values', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= a ? \"a=\\\\\"A\\\\\"\" : \"\" %>'),\n          data = { 'a': true };\n\n      assert.strictEqual(compiled(data), 'a=\"A\"');\n    });\n\n    QUnit.test('should support \"interpolate\" delimiters containing ternary operators', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= value ? value : \"b\" %>'),\n          data = { 'value': 'a' };\n\n      assert.strictEqual(compiled(data), 'a');\n    });\n\n    QUnit.test('should support \"interpolate\" delimiters containing global values', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= typeof Math.abs %>');\n\n      try {\n        var actual = compiled();\n      } catch (e) {}\n\n      assert.strictEqual(actual, 'function');\n    });\n\n    QUnit.test('should support complex \"interpolate\" delimiters', function(assert) {\n      assert.expect(22);\n\n      lodashStable.forOwn({\n        '<%= a + b %>': '3',\n        '<%= b - a %>': '1',\n        '<%= a = b %>': '2',\n        '<%= !a %>': 'false',\n        '<%= ~a %>': '-2',\n        '<%= a * b %>': '2',\n        '<%= a / b %>': '0.5',\n        '<%= a % b %>': '1',\n        '<%= a >> b %>': '0',\n        '<%= a << b %>': '4',\n        '<%= a & b %>': '0',\n        '<%= a ^ b %>': '3',\n        '<%= a | b %>': '3',\n        '<%= {}.toString.call(0) %>': numberTag,\n        '<%= a.toFixed(2) %>': '1.00',\n        '<%= obj[\"a\"] %>': '1',\n        '<%= delete a %>': 'true',\n        '<%= \"a\" in obj %>': 'true',\n        '<%= obj instanceof Object %>': 'true',\n        '<%= new Boolean %>': 'false',\n        '<%= typeof a %>': 'number',\n        '<%= void a %>': ''\n      },\n      function(value, key) {\n        var compiled = _.template(key),\n            data = { 'a': 1, 'b': 2 };\n\n        assert.strictEqual(compiled(data), value, key);\n      });\n    });\n\n    QUnit.test('should support ES6 template delimiters', function(assert) {\n      assert.expect(2);\n\n      var data = { 'value': 2 };\n      assert.strictEqual(_.template('1${value}3')(data), '123');\n      assert.strictEqual(_.template('${\"{\" + value + \"\\\\}\"}')(data), '{2}');\n    });\n\n    QUnit.test('should support the \"imports\" option', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= a %>', { 'imports': { 'a': 1 } });\n      assert.strictEqual(compiled({}), '1');\n    });\n\n    QUnit.test('should support the \"variable\" options', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template(\n        '<% _.each( data.a, function( value ) { %>' +\n            '<%= value.valueOf() %>' +\n        '<% }) %>', { 'variable': 'data' }\n      );\n\n      var data = { 'a': [1, 2, 3] };\n\n      try {\n        assert.strictEqual(compiled(data), '123');\n      } catch (e) {\n        assert.ok(false, e.message);\n      }\n    });\n\n    QUnit.test('should forbid code injection through the \"variable\" options', function(assert) {\n      assert.expect(1);\n\n      assert.raises(function () {\n        _.template('', { 'variable': '){console.log(process.env)}; with(obj' });\n      });\n    });\n\n    QUnit.test('should support custom delimiters', function(assert) {\n      assert.expect(2);\n\n      lodashStable.times(2, function(index) {\n        var settingsClone = lodashStable.clone(_.templateSettings);\n\n        var settings = lodashStable.assign(index ? _.templateSettings : {}, {\n          'escape': /\\{\\{-([\\s\\S]+?)\\}\\}/g,\n          'evaluate': /\\{\\{([\\s\\S]+?)\\}\\}/g,\n          'interpolate': /\\{\\{=([\\s\\S]+?)\\}\\}/g\n        });\n\n        var expected = '<ul><li>0: a &amp; A</li><li>1: b &amp; B</li></ul>',\n            compiled = _.template('<ul>{{ _.each(collection, function(value, index) {}}<li>{{= index }}: {{- value }}</li>{{}); }}</ul>', index ? null : settings),\n            data = { 'collection': ['a & A', 'b & B'] };\n\n        assert.strictEqual(compiled(data), expected);\n        lodashStable.assign(_.templateSettings, settingsClone);\n      });\n    });\n\n    QUnit.test('should support custom delimiters containing special characters', function(assert) {\n      assert.expect(2);\n\n      lodashStable.times(2, function(index) {\n        var settingsClone = lodashStable.clone(_.templateSettings);\n\n        var settings = lodashStable.assign(index ? _.templateSettings : {}, {\n          'escape': /<\\?-([\\s\\S]+?)\\?>/g,\n          'evaluate': /<\\?([\\s\\S]+?)\\?>/g,\n          'interpolate': /<\\?=([\\s\\S]+?)\\?>/g\n        });\n\n        var expected = '<ul><li>0: a &amp; A</li><li>1: b &amp; B</li></ul>',\n            compiled = _.template('<ul><? _.each(collection, function(value, index) { ?><li><?= index ?>: <?- value ?></li><? }); ?></ul>', index ? null : settings),\n            data = { 'collection': ['a & A', 'b & B'] };\n\n        assert.strictEqual(compiled(data), expected);\n        lodashStable.assign(_.templateSettings, settingsClone);\n      });\n    });\n\n    QUnit.test('should use a `with` statement by default', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= index %><%= collection[index] %><% _.each(collection, function(value, index) { %><%= index %><% }); %>'),\n          actual = compiled({ 'index': 1, 'collection': ['a', 'b', 'c'] });\n\n      assert.strictEqual(actual, '1b012');\n    });\n\n    QUnit.test('should use `_.templateSettings.imports._.templateSettings`', function(assert) {\n      assert.expect(1);\n\n      var lodash = _.templateSettings.imports._,\n          settingsClone = lodashStable.clone(lodash.templateSettings);\n\n      lodash.templateSettings = lodashStable.assign(lodash.templateSettings, {\n        'interpolate': /\\{\\{=([\\s\\S]+?)\\}\\}/g\n      });\n\n      var compiled = _.template('{{= a }}');\n      assert.strictEqual(compiled({ 'a': 1 }), '1');\n\n      if (settingsClone) {\n        lodashStable.assign(lodash.templateSettings, settingsClone);\n      } else {\n        delete lodash.templateSettings;\n      }\n    });\n\n    QUnit.test('should fallback to `_.templateSettings`', function(assert) {\n      assert.expect(1);\n\n      var lodash = _.templateSettings.imports._,\n          delimiter = _.templateSettings.interpolate;\n\n      _.templateSettings.imports._ = { 'escape': lodashStable.escape };\n      _.templateSettings.interpolate = /\\{\\{=([\\s\\S]+?)\\}\\}/g;\n\n      var compiled = _.template('{{= a }}');\n      assert.strictEqual(compiled({ 'a': 1 }), '1');\n\n      _.templateSettings.imports._ = lodash;\n      _.templateSettings.interpolate = delimiter;\n    });\n\n    QUnit.test('should ignore `null` delimiters', function(assert) {\n      assert.expect(3);\n\n      var delimiter = {\n        'escape': /\\{\\{-([\\s\\S]+?)\\}\\}/g,\n        'evaluate': /\\{\\{([\\s\\S]+?)\\}\\}/g,\n        'interpolate': /\\{\\{=([\\s\\S]+?)\\}\\}/g\n      };\n\n      lodashStable.forOwn({\n        'escape': '{{- a }}',\n        'evaluate': '{{ print(a) }}',\n        'interpolate': '{{= a }}'\n      },\n      function(value, key) {\n        var settings = { 'escape': null, 'evaluate': null, 'interpolate': null };\n        settings[key] = delimiter[key];\n\n        var expected = '1 <%- a %> <% print(a) %> <%= a %>',\n            compiled = _.template(value + ' <%- a %> <% print(a) %> <%= a %>', settings),\n            data = { 'a': 1 };\n\n        assert.strictEqual(compiled(data), expected);\n      });\n    });\n\n    QUnit.test('should work without delimiters', function(assert) {\n      assert.expect(1);\n\n      var expected = 'abc';\n      assert.strictEqual(_.template(expected)({}), expected);\n    });\n\n    QUnit.test('should work with `this` references', function(assert) {\n      assert.expect(2);\n\n      var compiled = _.template('a<%= this.String(\"b\") %>c');\n      assert.strictEqual(compiled(), 'abc');\n\n      var object = { 'b': 'B' };\n      object.compiled = _.template('A<%= this.b %>C', { 'variable': 'obj' });\n      assert.strictEqual(object.compiled(), 'ABC');\n    });\n\n    QUnit.test('should work with backslashes', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= a %> \\\\b'),\n          data = { 'a': 'A' };\n\n      assert.strictEqual(compiled(data), 'A \\\\b');\n    });\n\n    QUnit.test('should work with escaped characters in string literals', function(assert) {\n      assert.expect(2);\n\n      var compiled = _.template('<% print(\"\\'\\\\n\\\\r\\\\t\\\\u2028\\\\u2029\\\\\\\\\") %>');\n      assert.strictEqual(compiled(), \"'\\n\\r\\t\\u2028\\u2029\\\\\");\n\n      var data = { 'a': 'A' };\n      compiled = _.template('\\'\\n\\r\\t<%= a %>\\u2028\\u2029\\\\\"');\n      assert.strictEqual(compiled(data), '\\'\\n\\r\\tA\\u2028\\u2029\\\\\"');\n    });\n\n    QUnit.test('should handle \\\\u2028 & \\\\u2029 characters', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('\\u2028<%= \"\\\\u2028\\\\u2029\" %>\\u2029');\n      assert.strictEqual(compiled(), '\\u2028\\u2028\\u2029\\u2029');\n    });\n\n    QUnit.test('should work with statements containing quotes', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template(\"<%\\\n        if (a == 'A' || a == \\\"a\\\") {\\\n          %>'a',\\\"A\\\"<%\\\n        } %>\"\n      );\n\n      var data = { 'a': 'A' };\n      assert.strictEqual(compiled(data), \"'a',\\\"A\\\"\");\n    });\n\n    QUnit.test('should work with templates containing newlines and comments', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%\\n\\\n        // A code comment.\\n\\\n        if (value) { value += 3; }\\n\\\n        %><p><%= value %></p>'\n      );\n\n      assert.strictEqual(compiled({ 'value': 3 }), '<p>6</p>');\n    });\n\n    QUnit.test('should tokenize delimiters', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<span class=\"icon-<%= type %>2\"></span>'),\n          data = { 'type': 1 };\n\n      assert.strictEqual(compiled(data), '<span class=\"icon-12\"></span>');\n    });\n\n    QUnit.test('should evaluate delimiters once', function(assert) {\n      assert.expect(1);\n\n      var actual = [],\n          compiled = _.template('<%= func(\"a\") %><%- func(\"b\") %><% func(\"c\") %>'),\n          data = { 'func': function(value) { actual.push(value); } };\n\n      compiled(data);\n      assert.deepEqual(actual, ['a', 'b', 'c']);\n    });\n\n    QUnit.test('should match delimiters before escaping text', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<<\\n a \\n>>', { 'evaluate': /<<(.*?)>>/g });\n      assert.strictEqual(compiled(), '<<\\n a \\n>>');\n    });\n\n    QUnit.test('should resolve nullish values to an empty string', function(assert) {\n      assert.expect(3);\n\n      var compiled = _.template('<%= a %><%- a %>'),\n          data = { 'a': null };\n\n      assert.strictEqual(compiled(data), '');\n\n      data = { 'a': undefined };\n      assert.strictEqual(compiled(data), '');\n\n      data = { 'a': {} };\n      compiled = _.template('<%= a.b %><%- a.b %>');\n      assert.strictEqual(compiled(data), '');\n    });\n\n    QUnit.test('should return an empty string for empty values', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined, ''],\n          expected = lodashStable.map(values, stubString),\n          data = { 'a': 1 };\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var compiled = index ? _.template(value) : _.template();\n        return compiled(data);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should parse delimiters without newlines', function(assert) {\n      assert.expect(1);\n\n      var expected = '<<\\nprint(\"<p>\" + (value ? \"yes\" : \"no\") + \"</p>\")\\n>>',\n          compiled = _.template(expected, { 'evaluate': /<<(.+?)>>/g }),\n          data = { 'value': true };\n\n      assert.strictEqual(compiled(data), expected);\n    });\n\n    QUnit.test('should support recursive calls', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('<%= a %><% a = _.template(c)(obj) %><%= a %>'),\n          data = { 'a': 'A', 'b': 'B', 'c': '<%= b %>' };\n\n      assert.strictEqual(compiled(data), 'AB');\n    });\n\n    QUnit.test('should coerce `text` to a string', function(assert) {\n      assert.expect(1);\n\n      var object = { 'toString': lodashStable.constant('<%= a %>') },\n          data = { 'a': 1 };\n\n      assert.strictEqual(_.template(object)(data), '1');\n    });\n\n    QUnit.test('should not modify the `options` object', function(assert) {\n      assert.expect(1);\n\n      var options = {};\n      _.template('', options);\n      assert.deepEqual(options, {});\n    });\n\n    QUnit.test('should not modify `_.templateSettings` when `options` are given', function(assert) {\n      assert.expect(2);\n\n      var data = { 'a': 1 };\n\n      assert.notOk('a' in _.templateSettings);\n      _.template('', {}, data);\n      assert.notOk('a' in _.templateSettings);\n\n      delete _.templateSettings.a;\n    });\n\n    QUnit.test('should not error for non-object `data` and `options` values', function(assert) {\n      assert.expect(2);\n\n      _.template('')(1);\n      assert.ok(true, '`data` value');\n\n      _.template('', 1)(1);\n      assert.ok(true, '`options` value');\n    });\n\n    QUnit.test('should expose the source on compiled templates', function(assert) {\n      assert.expect(1);\n\n      var compiled = _.template('x'),\n          values = [String(compiled), compiled.source],\n          expected = lodashStable.map(values, stubTrue);\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.includes(value, '__p');\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should expose the source on SyntaxErrors', function(assert) {\n      assert.expect(1);\n\n      try {\n        _.template('<% if x %>');\n      } catch (e) {\n        var source = e.source;\n      }\n      assert.ok(lodashStable.includes(source, '__p'));\n    });\n\n    QUnit.test('should not include sourceURLs in the source', function(assert) {\n      assert.expect(1);\n\n      var options = { 'sourceURL': '/a/b/c' },\n          compiled = _.template('x', options),\n          values = [compiled.source, undefined];\n\n      try {\n        _.template('<% if x %>', options);\n      } catch (e) {\n        values[1] = e.source;\n      }\n      var expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.includes(value, 'sourceURL');\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not let a sourceURL inject code', function(assert) {\n      assert.expect(1);\n\n      var actual,\n          expected = 'no error';\n      try {\n          actual = _.template(expected, {'sourceURL': '\\u2028\\u2029\\n!this would err if it was executed!'})();\n      } catch (e) {}\n\n      assert.equal(actual, expected);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = ['<%= a %>', '<%- b %>', '<% print(c) %>'],\n          compiles = lodashStable.map(array, _.template),\n          data = { 'a': 'one', 'b': '\"two\"', 'c': 'three' };\n\n      var actual = lodashStable.map(compiles, function(compiled) {\n        return compiled(data);\n      });\n\n      assert.deepEqual(actual, ['one', '&quot;two&quot;', 'three']);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.truncate');\n\n  (function() {\n    var string = 'hi-diddly-ho there, neighborino';\n\n    QUnit.test('should use a default `length` of `30`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.truncate(string), 'hi-diddly-ho there, neighbo...');\n    });\n\n    QUnit.test('should not truncate if `string` is <= `length`', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.truncate(string, { 'length': string.length }), string);\n      assert.strictEqual(_.truncate(string, { 'length': string.length + 2 }), string);\n    });\n\n    QUnit.test('should truncate string the given length', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.truncate(string, { 'length': 24 }), 'hi-diddly-ho there, n...');\n    });\n\n    QUnit.test('should support a `omission` option', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.truncate(string, { 'omission': ' [...]' }), 'hi-diddly-ho there, neig [...]');\n    });\n\n    QUnit.test('should coerce nullish `omission` values to strings', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.truncate(string, { 'omission': null }), 'hi-diddly-ho there, neighbnull');\n      assert.strictEqual(_.truncate(string, { 'omission': undefined }), 'hi-diddly-ho there, nundefined');\n    });\n\n    QUnit.test('should support a `length` option', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.truncate(string, { 'length': 4 }), 'h...');\n    });\n\n    QUnit.test('should support a `separator` option', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.truncate(string, { 'length': 24, 'separator': ' ' }), 'hi-diddly-ho there,...');\n      assert.strictEqual(_.truncate(string, { 'length': 24, 'separator': /,? +/ }), 'hi-diddly-ho there...');\n      assert.strictEqual(_.truncate(string, { 'length': 24, 'separator': /,? +/g }), 'hi-diddly-ho there...');\n    });\n\n    QUnit.test('should treat negative `length` as `0`', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each([0, -2], function(length) {\n        assert.strictEqual(_.truncate(string, { 'length': length }), '...');\n      });\n    });\n\n    QUnit.test('should coerce `length` to an integer', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['', NaN, 4.6, '4'], function(length, index) {\n        var actual = index > 1 ? 'h...' : '...';\n        assert.strictEqual(_.truncate(string, { 'length': { 'valueOf': lodashStable.constant(length) } }), actual);\n      });\n    });\n\n    QUnit.test('should coerce `string` to a string', function(assert) {\n      assert.expect(2);\n\n      assert.strictEqual(_.truncate(Object(string), { 'length': 4 }), 'h...');\n      assert.strictEqual(_.truncate({ 'toString': lodashStable.constant(string) }, { 'length': 5 }), 'hi...');\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map([string, string, string], _.truncate),\n          truncated = 'hi-diddly-ho there, neighbo...';\n\n      assert.deepEqual(actual, [truncated, truncated, truncated]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.throttle');\n\n  (function() {\n    QUnit.test('should throttle a function', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          throttled = _.throttle(function() { callCount++; }, 32);\n\n      throttled();\n      throttled();\n      throttled();\n\n      var lastCount = callCount;\n      assert.ok(callCount);\n\n      setTimeout(function() {\n        assert.ok(callCount > lastCount);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('subsequent calls should return the result of the first call', function(assert) {\n      assert.expect(5);\n\n      var done = assert.async();\n\n      var throttled = _.throttle(identity, 32),\n          results = [throttled('a'), throttled('b')];\n\n      assert.deepEqual(results, ['a', 'a']);\n\n      setTimeout(function() {\n        var results = [throttled('c'), throttled('d')];\n        assert.notEqual(results[0], 'a');\n        assert.notStrictEqual(results[0], undefined);\n\n        assert.notEqual(results[1], 'd');\n        assert.notStrictEqual(results[1], undefined);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('should clear timeout when `func` is called', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      if (!isModularize) {\n        var callCount = 0,\n            dateCount = 0;\n\n        var lodash = _.runInContext({\n          'Date': {\n            'now': function() {\n              return ++dateCount == 5 ? Infinity : +new Date;\n            }\n          }\n        });\n\n        var throttled = lodash.throttle(function() { callCount++; }, 32);\n\n        throttled();\n        throttled();\n\n        setTimeout(function() {\n          assert.strictEqual(callCount, 2);\n          done();\n        }, 64);\n      }\n      else {\n        skipAssert(assert);\n        done();\n      }\n    });\n\n    QUnit.test('should not trigger a trailing call when invoked once', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          throttled = _.throttle(function() { callCount++; }, 32);\n\n      throttled();\n      assert.strictEqual(callCount, 1);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n        done();\n      }, 64);\n    });\n\n    lodashStable.times(2, function(index) {\n      QUnit.test('should trigger a call when invoked repeatedly' + (index ? ' and `leading` is `false`' : ''), function(assert) {\n        assert.expect(1);\n\n        var done = assert.async();\n\n        var callCount = 0,\n            limit = (argv || isPhantom) ? 1000 : 320,\n            options = index ? { 'leading': false } : {},\n            throttled = _.throttle(function() { callCount++; }, 32, options);\n\n        var start = +new Date;\n        while ((new Date - start) < limit) {\n          throttled();\n        }\n        var actual = callCount > 1;\n        setTimeout(function() {\n          assert.ok(actual);\n          done();\n        }, 1);\n      });\n    });\n\n    QUnit.test('should trigger a second throttled call as soon as possible', function(assert) {\n      assert.expect(3);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var throttled = _.throttle(function() {\n        callCount++;\n      }, 128, { 'leading': false });\n\n      throttled();\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n        throttled();\n      }, 192);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n      }, 254);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        done();\n      }, 384);\n    });\n\n    QUnit.test('should apply default options', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          throttled = _.throttle(function() { callCount++; }, 32, {});\n\n      throttled();\n      throttled();\n      assert.strictEqual(callCount, 1);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 2);\n        done();\n      }, 128);\n    });\n\n    QUnit.test('should support a `leading` option', function(assert) {\n      assert.expect(2);\n\n      var withLeading = _.throttle(identity, 32, { 'leading': true });\n      assert.strictEqual(withLeading('a'), 'a');\n\n      var withoutLeading = _.throttle(identity, 32, { 'leading': false });\n      assert.strictEqual(withoutLeading('a'), undefined);\n    });\n\n    QUnit.test('should support a `trailing` option', function(assert) {\n      assert.expect(6);\n\n      var done = assert.async();\n\n      var withCount = 0,\n          withoutCount = 0;\n\n      var withTrailing = _.throttle(function(value) {\n        withCount++;\n        return value;\n      }, 64, { 'trailing': true });\n\n      var withoutTrailing = _.throttle(function(value) {\n        withoutCount++;\n        return value;\n      }, 64, { 'trailing': false });\n\n      assert.strictEqual(withTrailing('a'), 'a');\n      assert.strictEqual(withTrailing('b'), 'a');\n\n      assert.strictEqual(withoutTrailing('a'), 'a');\n      assert.strictEqual(withoutTrailing('b'), 'a');\n\n      setTimeout(function() {\n        assert.strictEqual(withCount, 2);\n        assert.strictEqual(withoutCount, 1);\n        done();\n      }, 256);\n    });\n\n    QUnit.test('should not update `lastCalled`, at the end of the timeout, when `trailing` is `false`', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var throttled = _.throttle(function() {\n        callCount++;\n      }, 64, { 'trailing': false });\n\n      throttled();\n      throttled();\n\n      setTimeout(function() {\n        throttled();\n        throttled();\n      }, 96);\n\n      setTimeout(function() {\n        assert.ok(callCount > 1);\n        done();\n      }, 192);\n    });\n\n    QUnit.test('should work with a system time of `0`', function(assert) {\n      assert.expect(3);\n\n      var done = assert.async();\n\n      if (!isModularize) {\n        var callCount = 0,\n            dateCount = 0;\n\n        var lodash = _.runInContext({\n          'Date': {\n            'now': function() {\n              return ++dateCount < 4 ? 0 : +new Date;\n            }\n          }\n        });\n\n        var throttled = lodash.throttle(function(value) {\n          callCount++;\n          return value;\n        }, 32);\n\n        var results = [throttled('a'), throttled('b'), throttled('c')];\n        assert.deepEqual(results, ['a', 'a', 'a']);\n        assert.strictEqual(callCount, 1);\n\n        setTimeout(function() {\n          assert.strictEqual(callCount, 2);\n          done();\n        }, 64);\n      }\n      else {\n        skipAssert(assert, 3);\n        done();\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.debounce and lodash.throttle');\n\n  lodashStable.each(['debounce', 'throttle'], function(methodName) {\n    var func = _[methodName],\n        isDebounce = methodName == 'debounce';\n\n    QUnit.test('`_.' + methodName + '` should not error for non-object `options` values', function(assert) {\n      assert.expect(1);\n\n      func(noop, 32, 1);\n      assert.ok(true);\n    });\n\n    QUnit.test('`_.' + methodName + '` should use a default `wait` of `0`', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          funced = func(function() { callCount++; });\n\n      funced();\n\n      setTimeout(function() {\n        funced();\n        assert.strictEqual(callCount, isDebounce ? 1 : 2);\n        done();\n      }, 32);\n    });\n\n    QUnit.test('`_.' + methodName + '` should invoke `func` with the correct `this` binding', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var actual = [],\n          object = { 'funced': func(function() { actual.push(this); }, 32) },\n          expected = lodashStable.times(isDebounce ? 1 : 2, lodashStable.constant(object));\n\n      object.funced();\n      if (!isDebounce) {\n        object.funced();\n      }\n      setTimeout(function() {\n        assert.deepEqual(actual, expected);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('`_.' + methodName + '` supports recursive calls', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var actual = [],\n          args = lodashStable.map(['a', 'b', 'c'], function(chr) { return [{}, chr]; }),\n          expected = args.slice(),\n          queue = args.slice();\n\n      var funced = func(function() {\n        var current = [this];\n        push.apply(current, arguments);\n        actual.push(current);\n\n        var next = queue.shift();\n        if (next) {\n          funced.call(next[0], next[1]);\n        }\n      }, 32);\n\n      var next = queue.shift();\n      funced.call(next[0], next[1]);\n      assert.deepEqual(actual, expected.slice(0, isDebounce ? 0 : 1));\n\n      setTimeout(function() {\n        assert.deepEqual(actual, expected.slice(0, actual.length));\n        done();\n      }, 256);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work if the system time is set backwards', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      if (!isModularize) {\n        var callCount = 0,\n            dateCount = 0;\n\n        var lodash = _.runInContext({\n          'Date': {\n            'now': function() {\n              return ++dateCount == 4\n                ? +new Date(2012, 3, 23, 23, 27, 18)\n                : +new Date;\n            }\n          }\n        });\n\n        var funced = lodash[methodName](function() {\n          callCount++;\n        }, 32);\n\n        funced();\n\n        setTimeout(function() {\n          funced();\n          assert.strictEqual(callCount, isDebounce ? 1 : 2);\n          done();\n        }, 64);\n      }\n      else {\n        skipAssert(assert);\n        done();\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should support cancelling delayed calls', function(assert) {\n      assert.expect(1);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var funced = func(function() {\n        callCount++;\n      }, 32, { 'leading': false });\n\n      funced();\n      funced.cancel();\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 0);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('`_.' + methodName + '` should reset `lastCalled` after cancelling', function(assert) {\n      assert.expect(3);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var funced = func(function() {\n        return ++callCount;\n      }, 32, { 'leading': true });\n\n      assert.strictEqual(funced(), 1);\n      funced.cancel();\n\n      assert.strictEqual(funced(), 2);\n      funced();\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 3);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support flushing delayed calls', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0;\n\n      var funced = func(function() {\n        return ++callCount;\n      }, 32, { 'leading': false });\n\n      funced();\n      assert.strictEqual(funced.flush(), 1);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 1);\n        done();\n      }, 64);\n    });\n\n    QUnit.test('`_.' + methodName + '` should noop `cancel` and `flush` when nothing is queued', function(assert) {\n      assert.expect(2);\n\n      var done = assert.async();\n\n      var callCount = 0,\n          funced = func(function() { callCount++; }, 32);\n\n      funced.cancel();\n      assert.strictEqual(funced.flush(), undefined);\n\n      setTimeout(function() {\n        assert.strictEqual(callCount, 0);\n        done();\n      }, 64);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.times');\n\n  (function() {\n    QUnit.test('should coerce non-finite `n` values to `0`', function(assert) {\n      assert.expect(3);\n\n      lodashStable.each([-Infinity, NaN, Infinity], function(n) {\n        assert.deepEqual(_.times(n), []);\n      });\n    });\n\n    QUnit.test('should coerce `n` to an integer', function(assert) {\n      assert.expect(1);\n\n      var actual = _.times(2.6, _.identity);\n      assert.deepEqual(actual, [0, 1]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.times(1, function(assert) {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [0]);\n    });\n\n    QUnit.test('should use `_.identity` when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant([0, 1, 2]));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.times(3, value) : _.times(3);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an array of the results of each `iteratee` execution', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.times(3, doubled), [0, 2, 4]);\n    });\n\n    QUnit.test('should return an empty array for falsey and negative `n` values', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat(-1, -Infinity),\n          expected = lodashStable.map(values, stubArray);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.times(value) : _.times();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.deepEqual(_(3).times(), [0, 1, 2]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        assert.ok(_(3).chain().times() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toArray');\n\n  (function() {\n    QUnit.test('should convert objects to arrays', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(_.toArray({ 'a': 1, 'b': 2 }), [1, 2]);\n    });\n\n    QUnit.test('should convert iterables to arrays', function(assert) {\n      assert.expect(1);\n\n      if (Symbol && Symbol.iterator) {\n        var object = { '0': 'a', 'length': 1 };\n        object[Symbol.iterator] = arrayProto[Symbol.iterator];\n\n        assert.deepEqual(_.toArray(object), ['a']);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should convert maps to arrays', function(assert) {\n      assert.expect(1);\n\n      if (Map) {\n        var map = new Map;\n        map.set('a', 1);\n        map.set('b', 2);\n        assert.deepEqual(_.toArray(map), [['a', 1], ['b', 2]]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should convert strings to arrays', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(_.toArray(''), []);\n      assert.deepEqual(_.toArray('ab'), ['a', 'b']);\n      assert.deepEqual(_.toArray(Object('ab')), ['a', 'b']);\n    });\n\n    QUnit.test('should work in a lazy sequence', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE + 1);\n\n        var object = lodashStable.zipObject(lodashStable.times(LARGE_ARRAY_SIZE, function(index) {\n          return ['key' + index, index];\n        }));\n\n        var actual = _(array).slice(1).map(String).toArray().value();\n        assert.deepEqual(actual, lodashStable.map(array.slice(1), String));\n\n        actual = _(object).toArray().slice(1).map(String).value();\n        assert.deepEqual(actual, _.map(_.toArray(object).slice(1), String));\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toLower');\n\n  (function() {\n    QUnit.test('should convert whole string to lower case', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(_.toLower('--Foo-Bar--'), '--foo-bar--');\n      assert.deepEqual(_.toLower('fooBar'), 'foobar');\n      assert.deepEqual(_.toLower('__FOO_BAR__'), '__foo_bar__');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toUpper');\n\n  (function() {\n    QUnit.test('should convert whole string to upper case', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(_.toUpper('--Foo-Bar'), '--FOO-BAR');\n      assert.deepEqual(_.toUpper('fooBar'), 'FOOBAR');\n      assert.deepEqual(_.toUpper('__FOO_BAR__'), '__FOO_BAR__');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.slice and lodash.toArray');\n\n  lodashStable.each(['slice', 'toArray'], function(methodName) {\n    var array = [1, 2, 3],\n        func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return a dense array', function(assert) {\n      assert.expect(3);\n\n      var sparse = Array(3);\n      sparse[1] = 2;\n\n      var actual = func(sparse);\n\n      assert.ok('0' in actual);\n      assert.ok('2' in actual);\n      assert.deepEqual(actual, sparse);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat array-like objects like arrays', function(assert) {\n      assert.expect(2);\n\n      var object = { '0': 'a', 'length': 1 };\n      assert.deepEqual(func(object), ['a']);\n      assert.deepEqual(func(args), array);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a shallow clone of arrays', function(assert) {\n      assert.expect(2);\n\n      var actual = func(array);\n      assert.deepEqual(actual, array);\n      assert.notStrictEqual(actual, array);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with a node list for `collection`', function(assert) {\n      assert.expect(1);\n\n      if (document) {\n        try {\n          var actual = func(document.getElementsByTagName('body'));\n        } catch (e) {}\n\n        assert.deepEqual(actual, [body]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('toInteger methods');\n\n  lodashStable.each(['toInteger', 'toSafeInteger'], function(methodName) {\n    var func = _[methodName],\n        isSafe = methodName == 'toSafeInteger';\n\n    QUnit.test('`_.' + methodName + '` should convert values to integers', function(assert) {\n      assert.expect(6);\n\n      assert.strictEqual(func(-5.6), -5);\n      assert.strictEqual(func('5.6'), 5);\n      assert.strictEqual(func(), 0);\n      assert.strictEqual(func(NaN), 0);\n\n      var expected = isSafe ? MAX_SAFE_INTEGER : MAX_INTEGER;\n      assert.strictEqual(func(Infinity), expected);\n      assert.strictEqual(func(-Infinity), -expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support `value` of `-0`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(1 / func(-0), -Infinity);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toLength');\n\n  (function() {\n    QUnit.test('should return a valid length', function(assert) {\n      assert.expect(4);\n\n      assert.strictEqual(_.toLength(-1), 0);\n      assert.strictEqual(_.toLength('1'), 1);\n      assert.strictEqual(_.toLength(1.1), 1);\n      assert.strictEqual(_.toLength(MAX_INTEGER), MAX_ARRAY_LENGTH);\n    });\n\n    QUnit.test('should return `value` if a valid length', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.toLength(0), 0);\n      assert.strictEqual(_.toLength(3), 3);\n      assert.strictEqual(_.toLength(MAX_ARRAY_LENGTH), MAX_ARRAY_LENGTH);\n    });\n\n    QUnit.test('should convert `-0` to `0`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(1 / _.toLength(-0), Infinity);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('number coercion methods');\n\n  lodashStable.each(['toFinite', 'toInteger', 'toNumber', 'toSafeInteger'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should preserve the sign of `0`', function(assert) {\n      assert.expect(2);\n\n      var values = [0, '0', -0, '-0'],\n          expected = [[0, Infinity], [0, Infinity], [-0, -Infinity], [-0, -Infinity]];\n\n      lodashStable.times(2, function(index) {\n        var others = lodashStable.map(values, index ? Object : identity);\n\n        var actual = lodashStable.map(others, function(value) {\n          var result = func(value);\n          return [result, 1 / result];\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  });\n\n  lodashStable.each(['toFinite', 'toInteger', 'toLength', 'toNumber', 'toSafeInteger'], function(methodName) {\n    var func = _[methodName],\n        isToFinite = methodName == 'toFinite',\n        isToLength = methodName == 'toLength',\n        isToNumber = methodName == 'toNumber',\n        isToSafeInteger = methodName == 'toSafeInteger';\n\n    function negative(string) {\n      return '-' + string;\n    }\n\n    function pad(string) {\n      return whitespace + string + whitespace;\n    }\n\n    function positive(string) {\n      return '+' + string;\n    }\n\n    QUnit.test('`_.' + methodName + '` should pass thru primitive number values', function(assert) {\n      assert.expect(1);\n\n      var values = [0, 1, NaN];\n\n      var expected = lodashStable.map(values, function(value) {\n        return (!isToNumber && value !== value) ? 0 : value;\n      });\n\n      var actual = lodashStable.map(values, func);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert number primitives and objects to numbers', function(assert) {\n      assert.expect(1);\n\n      var values = [2, 1.2, MAX_SAFE_INTEGER, MAX_INTEGER, Infinity, NaN];\n\n      var expected = lodashStable.map(values, function(value) {\n        if (!isToNumber) {\n          if (!isToFinite && value == 1.2) {\n            value = 1;\n          }\n          else if (value == Infinity) {\n            value = MAX_INTEGER;\n          }\n          else if (value !== value) {\n            value = 0;\n          }\n          if (isToLength || isToSafeInteger) {\n            value = Math.min(value, isToLength ? MAX_ARRAY_LENGTH : MAX_SAFE_INTEGER);\n          }\n        }\n        var neg = isToLength ? 0 : -value;\n        return [value, value, neg, neg];\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        return [func(value), func(Object(value)), func(-value), func(Object(-value))];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert string primitives and objects to numbers', function(assert) {\n      assert.expect(1);\n\n      var transforms = [identity, pad, positive, negative];\n\n      var values = [\n        '10', '1.234567890', (MAX_SAFE_INTEGER + ''),\n        '1e+308', '1e308', '1E+308', '1E308',\n        '5e-324', '5E-324',\n        'Infinity', 'NaN'\n      ];\n\n      var expected = lodashStable.map(values, function(value) {\n        var n = +value;\n        if (!isToNumber) {\n          if (!isToFinite && n == 1.234567890) {\n            n = 1;\n          }\n          else if (n == Infinity) {\n            n = MAX_INTEGER;\n          }\n          else if ((!isToFinite && n == Number.MIN_VALUE) || n !== n) {\n            n = 0;\n          }\n          if (isToLength || isToSafeInteger) {\n            n = Math.min(n, isToLength ? MAX_ARRAY_LENGTH : MAX_SAFE_INTEGER);\n          }\n        }\n        var neg = isToLength ? 0 : -n;\n        return [n, n, n, n, n, n, neg, neg];\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.flatMap(transforms, function(mod) {\n          return [func(mod(value)), func(Object(mod(value)))];\n        });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert binary/octal strings to numbers', function(assert) {\n      assert.expect(1);\n\n      var numbers = [42, 5349, 1715004],\n          transforms = [identity, pad],\n          values = ['0b101010', '0o12345', '0x1a2b3c'];\n\n      var expected = lodashStable.map(numbers, function(n) {\n        return lodashStable.times(8, lodashStable.constant(n));\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        var upper = value.toUpperCase();\n        return lodashStable.flatMap(transforms, function(mod) {\n          return [func(mod(value)), func(Object(mod(value))), func(mod(upper)), func(Object(mod(upper)))];\n        });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert invalid binary/octal strings to `' + (isToNumber ? 'NaN' : '0') + '`', function(assert) {\n      assert.expect(1);\n\n      var transforms = [identity, pad, positive, negative],\n          values = ['0b', '0o', '0x', '0b1010102', '0o123458', '0x1a2b3x'];\n\n      var expected = lodashStable.map(values, function(n) {\n        return lodashStable.times(8, lodashStable.constant(isToNumber ? NaN : 0));\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        return lodashStable.flatMap(transforms, function(mod) {\n          return [func(mod(value)), func(Object(mod(value)))];\n        });\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert symbols to `' + (isToNumber ? 'NaN' : '0') + '`', function(assert) {\n      assert.expect(1);\n\n      if (Symbol) {\n        var object1 = Object(symbol),\n            object2 = Object(symbol),\n            values = [symbol, object1, object2],\n            expected = lodashStable.map(values, lodashStable.constant(isToNumber ? NaN : 0));\n\n        object2.valueOf = undefined;\n        var actual = lodashStable.map(values, func);\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert empty values to `0` or `NaN`', function(assert) {\n      assert.expect(1);\n\n      var values = falsey.concat(whitespace);\n\n      var expected = lodashStable.map(values, function(value) {\n        return (isToNumber && value !== whitespace) ? Number(value) : 0;\n      });\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? func(value) : func();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce objects to numbers', function(assert) {\n      assert.expect(1);\n\n      var values = [\n        {},\n        [],\n        [1],\n        [1, 2],\n        { 'valueOf': '1.1' },\n        { 'valueOf': '1.1', 'toString': lodashStable.constant('2.2') },\n        { 'valueOf': lodashStable.constant('1.1'), 'toString': '2.2' },\n        { 'valueOf': lodashStable.constant('1.1'), 'toString': lodashStable.constant('2.2') },\n        { 'valueOf': lodashStable.constant('-0x1a2b3c') },\n        { 'toString': lodashStable.constant('-0x1a2b3c') },\n        { 'valueOf': lodashStable.constant('0o12345') },\n        { 'toString': lodashStable.constant('0o12345') },\n        { 'valueOf': lodashStable.constant('0b101010') },\n        { 'toString': lodashStable.constant('0b101010') }\n      ];\n\n      var expected = [\n        NaN,  0,   1,   NaN,\n        NaN,  2.2, 1.1, 1.1,\n        NaN,  NaN,\n        5349, 5349,\n        42,   42\n      ];\n\n      if (isToFinite) {\n        expected = [\n          0,    0,    1,   0,\n          0,    2.2,  1.1, 1.1,\n          0,    0,\n          5349, 5349,\n          42,   42\n        ];\n      }\n      else if (!isToNumber) {\n        expected = [\n          0,    0,    1, 0,\n          0,    2,    1, 1,\n          0,    0,\n          5349, 5349,\n          42,   42\n        ];\n      }\n      var actual = lodashStable.map(values, func);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.`' + methodName + '` should prevent ReDoS', function(assert) {\n      assert.expect(2);\n\n      var largeStrLen = 50000,\n          largeStr = '1' + lodashStable.repeat(' ', largeStrLen) + '1',\n          maxMs = 1000,\n          startTime = lodashStable.now();\n\n      assert.deepEqual(_[methodName](largeStr), methodName == 'toNumber' ? NaN : 0);\n\n      var endTime = lodashStable.now(),\n          timeSpent = endTime - startTime;\n\n      assert.ok(timeSpent < maxMs, 'operation took ' + timeSpent + 'ms');\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toPairs');\n\n  (function() {\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.entries, _.toPairs);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toPairsIn');\n\n  (function() {\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.entriesIn, _.toPairsIn);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('toPairs methods');\n\n  lodashStable.each(['toPairs', 'toPairsIn'], function(methodName) {\n    var func = _[methodName],\n        isToPairs = methodName == 'toPairs';\n\n    QUnit.test('`_.' + methodName + '` should create an array of string keyed-value pairs', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2 },\n          actual = lodashStable.sortBy(func(object), 0);\n\n      assert.deepEqual(actual, [['a', 1], ['b', 2]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isToPairs ? 'not ' : '') + 'include inherited string keyed property values', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var expected = isToPairs ? [['a', 1]] : [['a', 1], ['b', 2]],\n          actual = lodashStable.sortBy(func(new Foo), 0);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert objects with a `length` property', function(assert) {\n      assert.expect(1);\n\n      var object = { '0': 'a', '1': 'b', 'length': 2 },\n          actual = lodashStable.sortBy(func(object), 0);\n\n      assert.deepEqual(actual, [['0', 'a'], ['1', 'b'], ['length', 2]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert maps', function(assert) {\n      assert.expect(1);\n\n      if (Map) {\n        var map = new Map;\n        map.set('a', 1);\n        map.set('b', 2);\n        assert.deepEqual(func(map), [['a', 1], ['b', 2]]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert sets', function(assert) {\n      assert.expect(1);\n\n      if (Set) {\n        var set = new Set;\n        set.add(1);\n        set.add(2);\n        assert.deepEqual(func(set), [[1, 1], [2, 2]]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should convert strings', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each(['xo', Object('xo')], function(string) {\n        var actual = lodashStable.sortBy(func(string), 0);\n        assert.deepEqual(actual, [['0', 'x'], ['1', 'o']]);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toPath');\n\n  (function() {\n    QUnit.test('should convert a string to a path', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.toPath('a.b.c'), ['a', 'b', 'c']);\n      assert.deepEqual(_.toPath('a[0].b.c'), ['a', '0', 'b', 'c']);\n    });\n\n    QUnit.test('should coerce array elements to strings', function(assert) {\n      assert.expect(4);\n\n      var array = ['a', 'b', 'c'];\n\n      lodashStable.each([array, lodashStable.map(array, Object)], function(value) {\n        var actual = _.toPath(value);\n        assert.deepEqual(actual, array);\n        assert.notStrictEqual(actual, array);\n      });\n    });\n\n    QUnit.test('should return new path array', function(assert) {\n      assert.expect(1);\n\n      assert.notStrictEqual(_.toPath('a.b.c'), _.toPath('a.b.c'));\n    });\n\n    QUnit.test('should not coerce symbols to strings', function(assert) {\n      assert.expect(4);\n\n      if (Symbol) {\n        var object = Object(symbol);\n        lodashStable.each([symbol, object, [symbol], [object]], function(value) {\n          var actual = _.toPath(value);\n          assert.ok(lodashStable.isSymbol(actual[0]));\n        });\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should handle complex paths', function(assert) {\n      assert.expect(1);\n\n      var actual = _.toPath('a[-1.23][\"[\\\\\"b\\\\\"]\"].c[\\'[\\\\\\'d\\\\\\']\\'][\\ne\\n][f].g');\n      assert.deepEqual(actual, ['a', '-1.23', '[\"b\"]', 'c', \"['d']\", '\\ne\\n', 'f', 'g']);\n    });\n\n    QUnit.test('should handle consecutive empty brackets and dots', function(assert) {\n      assert.expect(12);\n\n      var expected = ['', 'a'];\n      assert.deepEqual(_.toPath('.a'), expected);\n      assert.deepEqual(_.toPath('[].a'), expected);\n\n      expected = ['', '', 'a'];\n      assert.deepEqual(_.toPath('..a'), expected);\n      assert.deepEqual(_.toPath('[][].a'), expected);\n\n      expected = ['a', '', 'b'];\n      assert.deepEqual(_.toPath('a..b'), expected);\n      assert.deepEqual(_.toPath('a[].b'), expected);\n\n      expected = ['a', '', '', 'b'];\n      assert.deepEqual(_.toPath('a...b'), expected);\n      assert.deepEqual(_.toPath('a[][].b'), expected);\n\n      expected = ['a', ''];\n      assert.deepEqual(_.toPath('a.'), expected);\n      assert.deepEqual(_.toPath('a[]'), expected);\n\n      expected = ['a', '', ''];\n      assert.deepEqual(_.toPath('a..'), expected);\n      assert.deepEqual(_.toPath('a[][]'), expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toPlainObject');\n\n  (function() {\n    QUnit.test('should flatten inherited string keyed properties', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.b = 2;\n      }\n      Foo.prototype.c = 3;\n\n      var actual = lodashStable.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n      assert.deepEqual(actual, { 'a': 1, 'b': 2, 'c': 3 });\n    });\n\n    QUnit.test('should convert `arguments` objects to plain objects', function(assert) {\n      assert.expect(1);\n\n      var actual = _.toPlainObject(args),\n          expected = { '0': 1, '1': 2, '2': 3 };\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should convert arrays to plain objects', function(assert) {\n      assert.expect(1);\n\n      var actual = _.toPlainObject(['a', 'b', 'c']),\n          expected = { '0': 'a', '1': 'b', '2': 'c' };\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.toString');\n\n  (function() {\n    QUnit.test('should treat nullish values as empty strings', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubString);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.toString(value) : _.toString();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var values = [-0, Object(-0), 0, Object(0)],\n          expected = ['-0', '-0', '0', '0'],\n          actual = lodashStable.map(values, _.toString);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should preserve the sign of `0` in an array', function(assert) {\n      assert.expect(1);\n\n      var values = [-0, Object(-0), 0, Object(0)];\n      assert.deepEqual(_.toString(values), '-0,-0,0,0');\n    });\n\n    QUnit.test('should not error on symbols', function(assert) {\n      assert.expect(1);\n\n      if (Symbol) {\n        try {\n          assert.strictEqual(_.toString(symbol), 'Symbol(a)');\n        } catch (e) {\n          assert.ok(false, e.message);\n        }\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should not error on an array of symbols', function(assert) {\n      assert.expect(1);\n\n      if (Symbol) {\n        try {\n          assert.strictEqual(_.toString([symbol]), 'Symbol(a)');\n        } catch (e) {\n          assert.ok(false, e.message);\n        }\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should return the `toString` result of the wrapped value', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _([1, 2, 3]);\n        assert.strictEqual(wrapped.toString(), '1,2,3');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.transform');\n\n  (function() {\n    function Foo() {\n      this.a = 1;\n      this.b = 2;\n      this.c = 3;\n    }\n\n    QUnit.test('should create an object with the same `[[Prototype]]` as `object` when `accumulator` is nullish', function(assert) {\n      assert.expect(4);\n\n      var accumulators = [, null, undefined],\n          object = new Foo,\n          expected = lodashStable.map(accumulators, stubTrue);\n\n      var iteratee = function(result, value, key) {\n        result[key] = square(value);\n      };\n\n      var mapper = function(accumulator, index) {\n        return index ? _.transform(object, iteratee, accumulator) : _.transform(object, iteratee);\n      };\n\n      var results = lodashStable.map(accumulators, mapper);\n\n      var actual = lodashStable.map(results, function(result) {\n        return result instanceof Foo;\n      });\n\n      assert.deepEqual(actual, expected);\n\n      expected = lodashStable.map(accumulators, lodashStable.constant({ 'a': 1, 'b': 4, 'c': 9 }));\n      actual = lodashStable.map(results, lodashStable.toPlainObject);\n\n      assert.deepEqual(actual, expected);\n\n      object = { 'a': 1, 'b': 2, 'c': 3 };\n      actual = lodashStable.map(accumulators, mapper);\n\n      assert.deepEqual(actual, expected);\n\n      object = [1, 2, 3];\n      expected = lodashStable.map(accumulators, lodashStable.constant([1, 4, 9]));\n      actual = lodashStable.map(accumulators, mapper);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should create regular arrays from typed arrays', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(typedArrays, stubTrue);\n\n      var actual = lodashStable.map(typedArrays, function(type) {\n        var Ctor = root[type],\n            array = Ctor ? new Ctor(new ArrayBuffer(24)) : [];\n\n        return lodashStable.isArray(_.transform(array, noop));\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should support an `accumulator` value', function(assert) {\n      assert.expect(6);\n\n      var values = [new Foo, [1, 2, 3], { 'a': 1, 'b': 2, 'c': 3 }],\n          expected = lodashStable.map(values, lodashStable.constant([1, 4, 9]));\n\n      var actual = lodashStable.map(values, function(value) {\n        return _.transform(value, function(result, value) {\n          result.push(square(value));\n        }, []);\n      });\n\n      assert.deepEqual(actual, expected);\n\n      var object = { 'a': 1, 'b': 4, 'c': 9 },\n      expected = [object, { '0': 1, '1': 4, '2': 9 }, object];\n\n      actual = lodashStable.map(values, function(value) {\n        return _.transform(value, function(result, value, key) {\n          result[key] = square(value);\n        }, {});\n      });\n\n      assert.deepEqual(actual, expected);\n\n      lodashStable.each([[], {}], function(accumulator) {\n        var actual = lodashStable.map(values, function(value) {\n          return _.transform(value, noop, accumulator);\n        });\n\n        assert.ok(lodashStable.every(actual, function(result) {\n          return result === accumulator;\n        }));\n\n        assert.strictEqual(_.transform(null, null, accumulator), accumulator);\n      });\n    });\n\n    QUnit.test('should treat sparse arrays as dense', function(assert) {\n      assert.expect(1);\n\n      var actual = _.transform(Array(1), function(result, value, index) {\n        result[index] = String(value);\n      });\n\n      assert.deepEqual(actual, ['undefined']);\n    });\n\n    QUnit.test('should work without an `iteratee`', function(assert) {\n      assert.expect(1);\n\n      assert.ok(_.transform(new Foo) instanceof Foo);\n    });\n\n    QUnit.test('should ensure `object` is an object before using its `[[Prototype]]`', function(assert) {\n      assert.expect(2);\n\n      var Ctors = [Boolean, Boolean, Number, Number, Number, String, String],\n          values = [false, true, 0, 1, NaN, '', 'a'],\n          expected = lodashStable.map(values, stubObject);\n\n      var results = lodashStable.map(values, function(value) {\n        return _.transform(value);\n      });\n\n      assert.deepEqual(results, expected);\n\n      expected = lodashStable.map(values, stubFalse);\n\n      var actual = lodashStable.map(results, function(value, index) {\n        return value instanceof Ctors[index];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should ensure `object` constructor is a function before using its `[[Prototype]]`', function(assert) {\n      assert.expect(1);\n\n      Foo.prototype.constructor = null;\n      assert.notOk(_.transform(new Foo) instanceof Foo);\n      Foo.prototype.constructor = Foo;\n    });\n\n    QUnit.test('should create an empty object when given a falsey `object`', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubObject);\n\n      var actual = lodashStable.map(falsey, function(object, index) {\n        return index ? _.transform(object) : _.transform();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    lodashStable.each({\n      'array': [1, 2, 3],\n      'object': { 'a': 1, 'b': 2, 'c': 3 }\n    },\n    function(object, key) {\n      QUnit.test('should provide correct `iteratee` arguments when transforming an ' + key, function(assert) {\n        assert.expect(2);\n\n        var args;\n\n        _.transform(object, function() {\n          args || (args = slice.call(arguments));\n        });\n\n        var first = args[0];\n        if (key == 'array') {\n          assert.ok(first !== object && lodashStable.isArray(first));\n          assert.deepEqual(args, [first, 1, 0, object]);\n        } else {\n          assert.ok(first !== object && lodashStable.isPlainObject(first));\n          assert.deepEqual(args, [first, 1, 'a', object]);\n        }\n      });\n    });\n\n    QUnit.test('should create an object from the same realm as `object`', function(assert) {\n      assert.expect(1);\n\n      var objects = lodashStable.filter(realm, function(value) {\n        return lodashStable.isObject(value) && !lodashStable.isElement(value);\n      });\n\n      var expected = lodashStable.map(objects, stubTrue);\n\n      var actual = lodashStable.map(objects, function(object) {\n        var Ctor = object.constructor,\n            result = _.transform(object);\n\n        if (result === object) {\n          return false;\n        }\n        if (lodashStable.isTypedArray(object)) {\n          return result instanceof Array;\n        }\n        return result instanceof Ctor || !(new Ctor instanceof Ctor);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('trim methods');\n\n  lodashStable.each(['trim', 'trimStart', 'trimEnd'], function(methodName, index) {\n    var func = _[methodName],\n        parts = [];\n\n    if (index != 2) {\n      parts.push('leading');\n    }\n    if (index != 1) {\n      parts.push('trailing');\n    }\n    parts = parts.join(' and ');\n\n    QUnit.test('`_.' + methodName + '` should remove ' + parts + ' whitespace', function(assert) {\n      assert.expect(1);\n\n      var string = whitespace + 'a b c' + whitespace,\n          expected = (index == 2 ? whitespace : '') + 'a b c' + (index == 1 ? whitespace : '');\n\n      assert.strictEqual(func(string), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `string` to a string', function(assert) {\n      assert.expect(1);\n\n      var object = { 'toString': lodashStable.constant(whitespace + 'a b c' + whitespace) },\n          expected = (index == 2 ? whitespace : '') + 'a b c' + (index == 1 ? whitespace : '');\n\n      assert.strictEqual(func(object), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should remove ' + parts + ' `chars`', function(assert) {\n      assert.expect(1);\n\n      var string = '-_-a-b-c-_-',\n          expected = (index == 2 ? '-_-' : '') + 'a-b-c' + (index == 1 ? '-_-' : '');\n\n      assert.strictEqual(func(string, '_-'), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should coerce `chars` to a string', function(assert) {\n      assert.expect(1);\n\n      var object = { 'toString': lodashStable.constant('_-') },\n          string = '-_-a-b-c-_-',\n          expected = (index == 2 ? '-_-' : '') + 'a-b-c' + (index == 1 ? '-_-' : '');\n\n      assert.strictEqual(func(string, object), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an empty string for empty values and `chars`', function(assert) {\n      assert.expect(6);\n\n      lodashStable.each([null, '_-'], function(chars) {\n        assert.strictEqual(func(null, chars), '');\n        assert.strictEqual(func(undefined, chars), '');\n        assert.strictEqual(func('', chars), '');\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `undefined` or empty string values for `chars`', function(assert) {\n      assert.expect(2);\n\n      var string = whitespace + 'a b c' + whitespace,\n          expected = (index == 2 ? whitespace : '') + 'a b c' + (index == 1 ? whitespace : '');\n\n      assert.strictEqual(func(string, undefined), expected);\n      assert.strictEqual(func(string, ''), string);\n    });\n\n    QUnit.test('`_.`' + methodName + '` should prevent ReDoS', function(assert) {\n      assert.expect(2);\n\n      var largeStrLen = 50000,\n          largeStr = 'A' + lodashStable.repeat(' ', largeStrLen) + 'A',\n          maxMs = 1000,\n          startTime = lodashStable.now();\n\n      assert.strictEqual(_[methodName](largeStr), largeStr);\n\n      var endTime = lodashStable.now(),\n          timeSpent = endTime - startTime;\n\n      assert.ok(timeSpent < maxMs, 'operation took ' + timeSpent + 'ms');\n    });\n\n    QUnit.test('`_.' + methodName + '` should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var string = Object(whitespace + 'a b c' + whitespace),\n          trimmed = (index == 2 ? whitespace : '') + 'a b c' + (index == 1 ? whitespace : ''),\n          actual = lodashStable.map([string, string, string], func);\n\n      assert.deepEqual(actual, [trimmed, trimmed, trimmed]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an unwrapped value when implicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var string = whitespace + 'a b c' + whitespace,\n            expected = (index == 2 ? whitespace : '') + 'a b c' + (index == 1 ? whitespace : '');\n\n        assert.strictEqual(_(string)[methodName](), expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var string = whitespace + 'a b c' + whitespace;\n        assert.ok(_(string).chain()[methodName]() instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('uncommon symbols');\n\n  (function() {\n    var flag = '\\ud83c\\uddfa\\ud83c\\uddf8',\n        heart = '\\u2764' + emojiVar,\n        hearts = '\\ud83d\\udc95',\n        comboGlyph = '\\ud83d\\udc68\\u200d' + heart + '\\u200d\\ud83d\\udc8B\\u200d\\ud83d\\udc68',\n        hashKeycap = '#' + emojiVar + '\\u20e3',\n        leafs = '\\ud83c\\udf42',\n        mic = '\\ud83c\\udf99',\n        noMic = mic + '\\u20e0',\n        raisedHand = '\\u270B' + emojiVar,\n        rocket = '\\ud83d\\ude80',\n        thumbsUp = '\\ud83d\\udc4d';\n\n    QUnit.test('should account for astral symbols', function(assert) {\n      assert.expect(34);\n\n      var allHearts = _.repeat(hearts, 10),\n          chars = hearts + comboGlyph,\n          string = 'A ' + leafs + ', ' + comboGlyph + ', and ' + rocket,\n          trimChars = comboGlyph + hearts,\n          trimString = trimChars + string + trimChars;\n\n      assert.strictEqual(_.camelCase(hearts + ' the ' + leafs), hearts + 'The' + leafs);\n      assert.strictEqual(_.camelCase(string), 'a' + leafs + comboGlyph + 'And' + rocket);\n      assert.strictEqual(_.capitalize(rocket), rocket);\n\n      assert.strictEqual(_.pad(string, 16), ' ' + string + '  ');\n      assert.strictEqual(_.padStart(string, 16), '   ' + string);\n      assert.strictEqual(_.padEnd(string, 16), string + '   ');\n\n      assert.strictEqual(_.pad(string, 16, chars), hearts + string + chars);\n      assert.strictEqual(_.padStart(string, 16, chars), chars + hearts + string);\n      assert.strictEqual(_.padEnd(string, 16, chars), string + chars + hearts);\n\n      assert.strictEqual(_.size(string), 13);\n      assert.deepEqual(_.split(string, ' '), ['A', leafs + ',', comboGlyph + ',', 'and', rocket]);\n      assert.deepEqual(_.split(string, ' ', 3), ['A', leafs + ',', comboGlyph + ',']);\n      assert.deepEqual(_.split(string, undefined), [string]);\n      assert.deepEqual(_.split(string, undefined, -1), [string]);\n      assert.deepEqual(_.split(string, undefined, 0), []);\n\n      var expected = ['A', ' ', leafs, ',', ' ', comboGlyph, ',', ' ', 'a', 'n', 'd', ' ', rocket];\n\n      assert.deepEqual(_.split(string, ''), expected);\n      assert.deepEqual(_.split(string, '', 6), expected.slice(0, 6));\n      assert.deepEqual(_.toArray(string), expected);\n\n      assert.strictEqual(_.trim(trimString, chars), string);\n      assert.strictEqual(_.trimStart(trimString, chars), string + trimChars);\n      assert.strictEqual(_.trimEnd(trimString, chars), trimChars + string);\n\n      assert.strictEqual(_.truncate(string, { 'length': 13 }), string);\n      assert.strictEqual(_.truncate(string, { 'length': 6 }), 'A ' + leafs + '...');\n\n      assert.deepEqual(_.words(string), ['A', leafs, comboGlyph, 'and', rocket]);\n      assert.deepEqual(_.toArray(hashKeycap), [hashKeycap]);\n      assert.deepEqual(_.toArray(noMic), [noMic]);\n\n      lodashStable.times(2, function(index) {\n        var separator = index ? RegExp(hearts) : hearts,\n            options = { 'length': 4, 'separator': separator },\n            actual = _.truncate(string, options);\n\n        assert.strictEqual(actual, 'A...');\n        assert.strictEqual(actual.length, 4);\n\n        actual = _.truncate(allHearts, options);\n        assert.strictEqual(actual, hearts + '...');\n        assert.strictEqual(actual.length, 5);\n      });\n    });\n\n    QUnit.test('should account for combining diacritical marks', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.map(comboMarks, function(mark) {\n        return 'o' + mark;\n      });\n\n      var expected = lodashStable.map(values, function(value) {\n        return [1, [value], [value]];\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        return [_.size(value), _.toArray(value), _.words(value)];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should account for fitzpatrick modifiers', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.map(fitzModifiers, function(modifier) {\n        return thumbsUp + modifier;\n      });\n\n      var expected = lodashStable.map(values, function(value) {\n        return [1, [value], [value]];\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        return [_.size(value), _.toArray(value), _.words(value)];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should account for regional symbols', function(assert) {\n      assert.expect(6);\n\n      var pair = flag.match(/\\ud83c[\\udde6-\\uddff]/g),\n          regionals = pair.join(' ');\n\n      assert.strictEqual(_.size(flag), 1);\n      assert.strictEqual(_.size(regionals), 3);\n\n      assert.deepEqual(_.toArray(flag), [flag]);\n      assert.deepEqual(_.toArray(regionals), [pair[0], ' ', pair[1]]);\n\n      assert.deepEqual(_.words(flag), [flag]);\n      assert.deepEqual(_.words(regionals), [pair[0], pair[1]]);\n    });\n\n    QUnit.test('should account for variation selectors', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.size(heart), 1);\n      assert.deepEqual(_.toArray(heart), [heart]);\n      assert.deepEqual(_.words(heart), [heart]);\n    });\n\n    QUnit.test('should account for variation selectors with fitzpatrick modifiers', function(assert) {\n      assert.expect(1);\n\n      var values = lodashStable.map(fitzModifiers, function(modifier) {\n        return raisedHand + modifier;\n      });\n\n      var expected = lodashStable.map(values, function(value) {\n        return [1, [value], [value]];\n      });\n\n      var actual = lodashStable.map(values, function(value) {\n        return [_.size(value), _.toArray(value), _.words(value)];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should match lone surrogates', function(assert) {\n      assert.expect(3);\n\n      var pair = hearts.split(''),\n          surrogates = pair[0] + ' ' + pair[1];\n\n      assert.strictEqual(_.size(surrogates), 3);\n      assert.deepEqual(_.toArray(surrogates), [pair[0], ' ', pair[1]]);\n      assert.deepEqual(_.words(surrogates), []);\n    });\n\n    QUnit.test('should match side by side fitzpatrick modifiers separately ', function(assert) {\n      assert.expect(1);\n\n      var string = fitzModifiers[0] + fitzModifiers[0];\n      assert.deepEqual(_.toArray(string), [fitzModifiers[0], fitzModifiers[0]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unary');\n\n  (function() {\n    function fn() {\n      return slice.call(arguments);\n    }\n\n    QUnit.test('should cap the number of arguments provided to `func`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(['6', '8', '10'], _.unary(parseInt));\n      assert.deepEqual(actual, [6, 8, 10]);\n    });\n\n    QUnit.test('should not force a minimum argument count', function(assert) {\n      assert.expect(1);\n\n      var capped = _.unary(fn);\n      assert.deepEqual(capped(), []);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(1);\n\n      var capped = _.unary(function(a, b) { return this; }),\n          object = { 'capped': capped };\n\n      assert.strictEqual(object.capped(), object);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unescape');\n\n  (function() {\n    var escaped = '&amp;&lt;&gt;&quot;&#39;/',\n        unescaped = '&<>\"\\'/';\n\n    escaped += escaped;\n    unescaped += unescaped;\n\n    QUnit.test('should unescape entities in order', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.unescape('&amp;lt;'), '&lt;');\n    });\n\n    QUnit.test('should unescape the proper entities', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.unescape(escaped), unescaped);\n    });\n\n    QUnit.test('should handle strings with nothing to unescape', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.unescape('abc'), 'abc');\n    });\n\n    QUnit.test('should unescape the same characters escaped by `_.escape`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(_.unescape(_.escape(unescaped)), unescaped);\n    });\n\n    lodashStable.each(['&#96;', '&#x2F;'], function(entity) {\n      QUnit.test('should not unescape the \"' + entity + '\" entity', function(assert) {\n        assert.expect(1);\n\n        assert.strictEqual(_.unescape(entity), entity);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('union methods');\n\n  lodashStable.each(['union', 'unionBy', 'unionWith'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return the union of two arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2], [1, 2]);\n      assert.deepEqual(actual, [2, 1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return the union of multiple arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2], [1, 2], [2, 3]);\n      assert.deepEqual(actual, [2, 1, 3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should not flatten nested arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([1, 3, 2], [1, [5]], [2, [4]]);\n      assert.deepEqual(actual, [1, 3, 2, [5], [4]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ignore values that are not arrays or `arguments` objects', function(assert) {\n      assert.expect(3);\n\n      var array = [0];\n      assert.deepEqual(func(array, 3, { '0': 1 }, null), array);\n      assert.deepEqual(func(null, array, null, [2, 1]), [0, 2, 1]);\n      assert.deepEqual(func(array, null, args, null), [0, 1, 2, 3]);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unionBy');\n\n  (function() {\n    QUnit.test('should accept an `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var actual = _.unionBy([2.1], [1.2, 2.3], Math.floor);\n      assert.deepEqual(actual, [2.1, 1.2]);\n\n      actual = _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n      assert.deepEqual(actual, [{ 'x': 1 }, { 'x': 2 }]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.unionBy([2.1], [1.2, 2.3], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [2.1]);\n    });\n\n    QUnit.test('should output values from the first possible array', function(assert) {\n      assert.expect(1);\n\n      var actual = _.unionBy([{ 'x': 1, 'y': 1 }], [{ 'x': 1, 'y': 2 }], 'x');\n      assert.deepEqual(actual, [{ 'x': 1, 'y': 1 }]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unionWith');\n\n  (function() {\n    QUnit.test('should work with a `comparator`', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }],\n          others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }],\n          actual = _.unionWith(objects, others, lodashStable.isEqual);\n\n      assert.deepEqual(actual, [objects[0], objects[1], others[0]]);\n    });\n\n    QUnit.test('should output values from the first possible array', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 1 }],\n          others = [{ 'x': 1, 'y': 2 }];\n\n      var actual = _.unionWith(objects, others, function(a, b) {\n        return a.x == b.x;\n      });\n\n      assert.deepEqual(actual, [{ 'x': 1, 'y': 1 }]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('uniq methods');\n\n  lodashStable.each(['uniq', 'uniqBy', 'uniqWith', 'sortedUniq', 'sortedUniqBy'], function(methodName) {\n    var func = _[methodName],\n        isSorted = /^sorted/.test(methodName),\n        objects = [{ 'a': 2 }, { 'a': 3 }, { 'a': 1 }, { 'a': 2 }, { 'a': 3 }, { 'a': 1 }];\n\n    if (isSorted) {\n      objects = _.sortBy(objects, 'a');\n    }\n    else {\n      QUnit.test('`_.' + methodName + '` should return unique values of an unsorted array', function(assert) {\n        assert.expect(1);\n\n        var array = [2, 1, 2];\n        assert.deepEqual(func(array), [2, 1]);\n      });\n    }\n    QUnit.test('`_.' + methodName + '` should return unique values of a sorted array', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 2];\n      assert.deepEqual(func(array), [1, 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat object instances as unique', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(objects), objects);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat `-0` as `0`', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.map(func([-0, 0]), lodashStable.toString);\n      assert.deepEqual(actual, ['0']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should match `NaN`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func([NaN, NaN]), [NaN]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays', function(assert) {\n      assert.expect(1);\n\n      var largeArray = [],\n          expected = [0, {}, 'a'],\n          count = Math.ceil(LARGE_ARRAY_SIZE / expected.length);\n\n      lodashStable.each(expected, function(value) {\n        lodashStable.times(count, function() {\n          largeArray.push(value);\n        });\n      });\n\n      assert.deepEqual(func(largeArray), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of `-0` as `0`', function(assert) {\n      assert.expect(1);\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, function(index) {\n        return isEven(index) ? -0 : 0;\n      });\n\n      var actual = lodashStable.map(func(largeArray), lodashStable.toString);\n      assert.deepEqual(actual, ['0']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of boolean, `NaN`, and nullish values', function(assert) {\n      assert.expect(1);\n\n      var largeArray = [],\n          expected = [null, undefined, false, true, NaN],\n          count = Math.ceil(LARGE_ARRAY_SIZE / expected.length);\n\n      lodashStable.each(expected, function(value) {\n        lodashStable.times(count, function() {\n          largeArray.push(value);\n        });\n      });\n\n      assert.deepEqual(func(largeArray), expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of symbols', function(assert) {\n      assert.expect(1);\n\n      if (Symbol) {\n        var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, Symbol);\n        assert.deepEqual(func(largeArray), largeArray);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with large arrays of well-known symbols', function(assert) {\n      assert.expect(1);\n\n      // See http://www.ecma-international.org/ecma-262/6.0/#sec-well-known-symbols.\n      if (Symbol) {\n        var expected = [\n          Symbol.hasInstance, Symbol.isConcatSpreadable, Symbol.iterator,\n          Symbol.match, Symbol.replace, Symbol.search, Symbol.species,\n          Symbol.split, Symbol.toPrimitive, Symbol.toStringTag, Symbol.unscopables\n        ];\n\n        var largeArray = [],\n            count = Math.ceil(LARGE_ARRAY_SIZE / expected.length);\n\n        expected = lodashStable.map(expected, function(symbol) {\n          return symbol || {};\n        });\n\n        lodashStable.each(expected, function(value) {\n          lodashStable.times(count, function() {\n            largeArray.push(value);\n          });\n        });\n\n        assert.deepEqual(func(largeArray), expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should distinguish between numbers and numeric strings', function(assert) {\n      assert.expect(1);\n\n      var largeArray = [],\n          expected = ['2', 2, Object('2'), Object(2)],\n          count = Math.ceil(LARGE_ARRAY_SIZE / expected.length);\n\n      lodashStable.each(expected, function(value) {\n        lodashStable.times(count, function() {\n          largeArray.push(value);\n        });\n      });\n\n      assert.deepEqual(func(largeArray), expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.uniq');\n\n  (function() {\n    QUnit.test('should perform an unsorted uniq when used as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var array = [[2, 1, 2], [1, 2, 1]],\n          actual = lodashStable.map(array, lodashStable.uniq);\n\n      assert.deepEqual(actual, [[2, 1], [1, 2]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('uniqBy methods');\n\n  lodashStable.each(['uniqBy', 'sortedUniqBy'], function(methodName) {\n    var func = _[methodName],\n        isSorted = methodName == 'sortedUniqBy',\n        objects = [{ 'a': 2 }, { 'a': 3 }, { 'a': 1 }, { 'a': 2 }, { 'a': 3 }, { 'a': 1 }];\n\n    if (isSorted) {\n      objects = _.sortBy(objects, 'a');\n    }\n    QUnit.test('`_.' + methodName + '` should work with an `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var expected = isSorted ? [{ 'a': 1 }, { 'a': 2 }, { 'a': 3 }] : objects.slice(0, 3);\n\n      var actual = func(objects, function(object) {\n        return object.a;\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work with large arrays', function(assert) {\n      assert.expect(2);\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, function() {\n        return [1, 2];\n      });\n\n      var actual = func(largeArray, String);\n      assert.strictEqual(actual[0], largeArray[0]);\n      assert.deepEqual(actual, [[1, 2]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      func(objects, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [objects[0]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `_.property` shorthands', function(assert) {\n      assert.expect(2);\n\n      var expected = isSorted ? [{ 'a': 1 }, { 'a': 2 }, { 'a': 3 }] : objects.slice(0, 3),\n          actual = func(objects, 'a');\n\n      assert.deepEqual(actual, expected);\n\n      var arrays = [[2], [3], [1], [2], [3], [1]];\n      if (isSorted) {\n        arrays = lodashStable.sortBy(arrays, 0);\n      }\n      expected = isSorted ? [[1], [2], [3]] : arrays.slice(0, 3);\n      actual = func(arrays, 0);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    lodashStable.each({\n      'an array': [0, 'a'],\n      'an object': { '0': 'a' },\n      'a number': 0,\n      'a string': '0'\n    },\n    function(iteratee, key) {\n      QUnit.test('`_.' + methodName + '` should work with ' + key + ' for `iteratee`', function(assert) {\n        assert.expect(1);\n\n        var actual = func([['a'], ['a'], ['b']], iteratee);\n        assert.deepEqual(actual, [['a'], ['b']]);\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.uniqWith');\n\n  (function() {\n    QUnit.test('should work with a `comparator`', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }],\n          actual = _.uniqWith(objects, lodashStable.isEqual);\n\n      assert.deepEqual(actual, [objects[0], objects[1]]);\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var largeArray = lodashStable.times(LARGE_ARRAY_SIZE, function(index) {\n        return isEven(index) ? -0 : 0;\n      });\n\n      var arrays = [[-0, 0], largeArray],\n          expected = lodashStable.map(arrays, lodashStable.constant(['-0']));\n\n      var actual = lodashStable.map(arrays, function(array) {\n        return lodashStable.map(_.uniqWith(array, lodashStable.eq), lodashStable.toString);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.uniqueId');\n\n  (function() {\n    QUnit.test('should generate unique ids', function(assert) {\n      assert.expect(1);\n\n      var actual = lodashStable.times(1000, function(assert) {\n        return _.uniqueId();\n      });\n\n      assert.strictEqual(lodashStable.uniq(actual).length, actual.length);\n    });\n\n    QUnit.test('should return a string value when not providing a `prefix`', function(assert) {\n      assert.expect(1);\n\n      assert.strictEqual(typeof _.uniqueId(), 'string');\n    });\n\n    QUnit.test('should coerce the prefix argument to a string', function(assert) {\n      assert.expect(1);\n\n      var actual = [_.uniqueId(3), _.uniqueId(2), _.uniqueId(1)];\n      assert.ok(/3\\d+,2\\d+,1\\d+/.test(actual));\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unset');\n\n  (function() {\n    QUnit.test('should unset property values', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a', ['a']], function(path) {\n        var object = { 'a': 1, 'c': 2 };\n        assert.strictEqual(_.unset(object, path), true);\n        assert.deepEqual(object, { 'c': 2 });\n      });\n    });\n\n    QUnit.test('should preserve the sign of `0`', function(assert) {\n      assert.expect(1);\n\n      var props = [-0, Object(-0), 0, Object(0)],\n          expected = lodashStable.map(props, lodashStable.constant([true, false]));\n\n      var actual = lodashStable.map(props, function(key) {\n        var object = { '-0': 'a', '0': 'b' };\n        return [_.unset(object, key), lodashStable.toString(key) in object];\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should unset symbol keyed property values', function(assert) {\n      assert.expect(2);\n\n      if (Symbol) {\n        var object = {};\n        object[symbol] = 1;\n\n        assert.strictEqual(_.unset(object, symbol), true);\n        assert.notOk(symbol in object);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should unset deep property values', function(assert) {\n      assert.expect(4);\n\n      lodashStable.each(['a.b', ['a', 'b']], function(path) {\n        var object = { 'a': { 'b': null } };\n        assert.strictEqual(_.unset(object, path), true);\n        assert.deepEqual(object, { 'a': {} });\n      });\n    });\n\n    QUnit.test('should handle complex paths', function(assert) {\n      assert.expect(4);\n\n      var paths = [\n        'a[-1.23][\"[\\\\\"b\\\\\"]\"].c[\\'[\\\\\\'d\\\\\\']\\'][\\ne\\n][f].g',\n        ['a', '-1.23', '[\"b\"]', 'c', \"['d']\", '\\ne\\n', 'f', 'g']\n      ];\n\n      lodashStable.each(paths, function(path) {\n        var object = { 'a': { '-1.23': { '[\"b\"]': { 'c': { \"['d']\": { '\\ne\\n': { 'f': { 'g': 8 } } } } } } } };\n        assert.strictEqual(_.unset(object, path), true);\n        assert.notOk('g' in object.a[-1.23]['[\"b\"]'].c[\"['d']\"]['\\ne\\n'].f);\n      });\n    });\n\n    QUnit.test('should return `true` for nonexistent paths', function(assert) {\n      assert.expect(5);\n\n      var object = { 'a': { 'b': { 'c': null } } };\n\n      lodashStable.each(['z', 'a.z', 'a.b.z', 'a.b.c.z'], function(path) {\n        assert.strictEqual(_.unset(object, path), true);\n      });\n\n      assert.deepEqual(object, { 'a': { 'b': { 'c': null } } });\n    });\n\n    QUnit.test('should not error when `object` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [null, undefined],\n          expected = [[true, true], [true, true]];\n\n      var actual = lodashStable.map(values, function(value) {\n        try {\n          return [_.unset(value, 'a.b'), _.unset(value, ['a', 'b'])];\n        } catch (e) {\n          return e.message;\n        }\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should follow `path` over non-plain objects', function(assert) {\n      assert.expect(8);\n\n      var object = { 'a': '' },\n          paths = ['constructor.prototype.a', ['constructor', 'prototype', 'a']];\n\n      lodashStable.each(paths, function(path) {\n        numberProto.a = 1;\n\n        var actual = _.unset(0, path);\n        assert.strictEqual(actual, true);\n        assert.notOk('a' in numberProto);\n\n        delete numberProto.a;\n      });\n\n      lodashStable.each(['a.replace.b', ['a', 'replace', 'b']], function(path) {\n        stringProto.replace.b = 1;\n\n        var actual = _.unset(object, path);\n        assert.strictEqual(actual, true);\n        assert.notOk('a' in stringProto.replace);\n\n        delete stringProto.replace.b;\n      });\n    });\n\n    QUnit.test('should return `false` for non-configurable properties', function(assert) {\n      assert.expect(1);\n\n      var object = {};\n\n      if (!isStrict) {\n        defineProperty(object, 'a', {\n          'configurable': false,\n          'enumerable': true,\n          'writable': true,\n          'value': 1,\n        });\n        assert.strictEqual(_.unset(object, 'a'), false);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unzipWith');\n\n  (function() {\n    QUnit.test('should unzip arrays combining regrouped elements with `iteratee`', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 4], [2, 5], [3, 6]];\n\n      var actual = _.unzipWith(array, function(a, b, c) {\n        return a + b + c;\n      });\n\n      assert.deepEqual(actual, [6, 15]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.unzipWith([[1, 3, 5], [2, 4, 6]], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [1, 2]);\n    });\n\n    QUnit.test('should perform a basic unzip when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 3], [2, 4]],\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant(_.unzip(array)));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.unzipWith(array, value) : _.unzipWith(array);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.updateWith');\n\n  (function() {\n    QUnit.test('should work with a `customizer` callback', function(assert) {\n      assert.expect(1);\n\n      var actual = _.updateWith({ '0': {} }, '[0][1][2]', stubThree, function(value) {\n        return lodashStable.isObject(value) ? undefined : {};\n      });\n\n      assert.deepEqual(actual, { '0': { '1': { '2': 3 } } });\n    });\n\n    QUnit.test('should work with a `customizer` that returns `undefined`', function(assert) {\n      assert.expect(1);\n\n      var actual = _.updateWith({}, 'a[0].b.c', stubFour, noop);\n      assert.deepEqual(actual, { 'a': [{ 'b': { 'c': 4 } }] });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('update methods');\n\n  lodashStable.each(['update', 'updateWith'], function(methodName) {\n    var func = _[methodName],\n        oldValue = 1;\n\n    QUnit.test('`_.' + methodName + '` should invoke `updater` with the value on `path` of `object`', function(assert) {\n      assert.expect(4);\n\n      var object = { 'a': [{ 'b': { 'c': oldValue } }] },\n          expected = oldValue + 1;\n\n      lodashStable.each(['a[0].b.c', ['a', '0', 'b', 'c']], function(path) {\n        func(object, path, function(n) {\n          assert.strictEqual(n, oldValue);\n          return ++n;\n        });\n\n        assert.strictEqual(object.a[0].b.c, expected);\n        object.a[0].b.c = oldValue;\n      });\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.upperCase');\n\n  (function() {\n    QUnit.test('should uppercase as space-separated words', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.upperCase('--foo-bar--'), 'FOO BAR');\n      assert.strictEqual(_.upperCase('fooBar'), 'FOO BAR');\n      assert.strictEqual(_.upperCase('__foo_bar__'), 'FOO BAR');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.upperFirst');\n\n  (function() {\n    QUnit.test('should uppercase only the first character', function(assert) {\n      assert.expect(3);\n\n      assert.strictEqual(_.upperFirst('fred'), 'Fred');\n      assert.strictEqual(_.upperFirst('Fred'), 'Fred');\n      assert.strictEqual(_.upperFirst('FRED'), 'FRED');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('values methods');\n\n  lodashStable.each(['values', 'valuesIn'], function(methodName) {\n    var func = _[methodName],\n        isValues = methodName == 'values';\n\n    QUnit.test('`_.' + methodName + '` should get string keyed values of `object`', function(assert) {\n      assert.expect(1);\n\n      var object = { 'a': 1, 'b': 2 },\n          actual = func(object).sort();\n\n      assert.deepEqual(actual, [1, 2]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with an object that has a `length` property', function(assert) {\n      assert.expect(1);\n\n      var object = { '0': 'a', '1': 'b', 'length': 2 },\n          actual = func(object).sort();\n\n      assert.deepEqual(actual, [2, 'a', 'b']);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isValues ? 'not ' : '') + 'include inherited string keyed property values', function(assert) {\n      assert.expect(1);\n\n      function Foo() {\n        this.a = 1;\n      }\n      Foo.prototype.b = 2;\n\n      var expected = isValues ? [1] : [1, 2],\n          actual = func(new Foo).sort();\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      var values = [args, strictArgs],\n          expected = lodashStable.map(values, lodashStable.constant([1, 2, 3]));\n\n      var actual = lodashStable.map(values, function(value) {\n        return func(value).sort();\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.without');\n\n  (function() {\n    QUnit.test('should return the difference of values', function(assert) {\n      assert.expect(1);\n\n      var actual = _.without([2, 1, 2, 3], 1, 2);\n      assert.deepEqual(actual, [3]);\n    });\n\n    QUnit.test('should use strict equality to determine the values to reject', function(assert) {\n      assert.expect(2);\n\n      var object1 = { 'a': 1 },\n          object2 = { 'b': 2 },\n          array = [object1, object2];\n\n      assert.deepEqual(_.without(array, { 'a': 1 }), array);\n      assert.deepEqual(_.without(array, object1), [object2]);\n    });\n\n    QUnit.test('should remove all occurrences of each value from an array', function(assert) {\n      assert.expect(1);\n\n      var array = [1, 2, 3, 1, 2, 3];\n      assert.deepEqual(_.without(array, 1, 2), [3, 3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.words');\n\n  (function() {\n    QUnit.test('should match words containing Latin Unicode letters', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(burredLetters, function(letter) {\n        return [letter];\n      });\n\n      var actual = lodashStable.map(burredLetters, function(letter) {\n        return _.words(letter);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should support a `pattern`', function(assert) {\n      assert.expect(2);\n\n      assert.deepEqual(_.words('abcd', /ab|cd/g), ['ab', 'cd']);\n      assert.deepEqual(_.words('abcd', 'ab|cd'), ['ab']);\n    });\n\n    QUnit.test('should work with compound words', function(assert) {\n      assert.expect(12);\n\n      assert.deepEqual(_.words('12ft'), ['12', 'ft']);\n      assert.deepEqual(_.words('aeiouAreVowels'), ['aeiou', 'Are', 'Vowels']);\n      assert.deepEqual(_.words('enable 6h format'), ['enable', '6', 'h', 'format']);\n      assert.deepEqual(_.words('enable 24H format'), ['enable', '24', 'H', 'format']);\n      assert.deepEqual(_.words('isISO8601'), ['is', 'ISO', '8601']);\n      assert.deepEqual(_.words('LETTERSAeiouAreVowels'), ['LETTERS', 'Aeiou', 'Are', 'Vowels']);\n      assert.deepEqual(_.words('tooLegit2Quit'), ['too', 'Legit', '2', 'Quit']);\n      assert.deepEqual(_.words('walk500Miles'), ['walk', '500', 'Miles']);\n      assert.deepEqual(_.words('xhr2Request'), ['xhr', '2', 'Request']);\n      assert.deepEqual(_.words('XMLHttp'), ['XML', 'Http']);\n      assert.deepEqual(_.words('XmlHTTP'), ['Xml', 'HTTP']);\n      assert.deepEqual(_.words('XmlHttp'), ['Xml', 'Http']);\n    });\n\n    QUnit.test('should work with compound words containing diacritical marks', function(assert) {\n      assert.expect(3);\n\n      assert.deepEqual(_.words('LETTERSÆiouAreVowels'), ['LETTERS', 'Æiou', 'Are', 'Vowels']);\n      assert.deepEqual(_.words('æiouAreVowels'), ['æiou', 'Are', 'Vowels']);\n      assert.deepEqual(_.words('æiou2Consonants'), ['æiou', '2', 'Consonants']);\n    });\n\n    QUnit.test('should not treat contractions as separate words', function(assert) {\n      assert.expect(4);\n\n      var postfixes = ['d', 'll', 'm', 're', 's', 't', 've'];\n\n      lodashStable.each([\"'\", '\\u2019'], function(apos) {\n        lodashStable.times(2, function(index) {\n          var actual = lodashStable.map(postfixes, function(postfix) {\n            var string = 'a b' + apos + postfix +  ' c';\n            return _.words(string[index ? 'toUpperCase' : 'toLowerCase']());\n          });\n\n          var expected = lodashStable.map(postfixes, function(postfix) {\n            var words = ['a', 'b' + apos + postfix, 'c'];\n            return lodashStable.map(words, function(word) {\n              return word[index ? 'toUpperCase' : 'toLowerCase']();\n            });\n          });\n\n          assert.deepEqual(actual, expected);\n        });\n      });\n    });\n\n    QUnit.test('should not treat ordinal numbers as separate words', function(assert) {\n      assert.expect(2);\n\n      var ordinals = ['1st', '2nd', '3rd', '4th'];\n\n      lodashStable.times(2, function(index) {\n        var expected = lodashStable.map(ordinals, function(ordinal) {\n          return [ordinal[index ? 'toUpperCase' : 'toLowerCase']()];\n        });\n\n        var actual = lodashStable.map(expected, function(words) {\n          return _.words(words[0]);\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n\n    QUnit.test('should not treat mathematical operators as words', function(assert) {\n      assert.expect(1);\n\n      var operators = ['\\xac', '\\xb1', '\\xd7', '\\xf7'],\n          expected = lodashStable.map(operators, stubArray),\n          actual = lodashStable.map(operators, _.words);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should not treat punctuation as words', function(assert) {\n      assert.expect(1);\n\n      var marks = [\n        '\\u2012', '\\u2013', '\\u2014', '\\u2015',\n        '\\u2024', '\\u2025', '\\u2026',\n        '\\u205d', '\\u205e'\n      ];\n\n      var expected = lodashStable.map(marks, stubArray),\n          actual = lodashStable.map(marks, _.words);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should work as an iteratee for methods like `_.map`', function(assert) {\n      assert.expect(1);\n\n      var strings = lodashStable.map(['a', 'b', 'c'], Object),\n          actual = lodashStable.map(strings, _.words);\n\n      assert.deepEqual(actual, [['a'], ['b'], ['c']]);\n    });\n\n    QUnit.test('should prevent ReDoS', function(assert) {\n      assert.expect(2);\n\n      var largeWordLen = 50000,\n          largeWord = _.repeat('A', largeWordLen),\n          maxMs = 1000,\n          startTime = lodashStable.now();\n\n      assert.deepEqual(_.words(largeWord + 'ÆiouAreVowels'), [largeWord, 'Æiou', 'Are', 'Vowels']);\n\n      var endTime = lodashStable.now(),\n          timeSpent = endTime - startTime;\n\n      assert.ok(timeSpent < maxMs, 'operation took ' + timeSpent + 'ms');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.wrap');\n\n  (function() {\n    QUnit.test('should create a wrapped function', function(assert) {\n      assert.expect(1);\n\n      var p = _.wrap(lodashStable.escape, function(func, text) {\n        return '<p>' + func(text) + '</p>';\n      });\n\n      assert.strictEqual(p('fred, barney, & pebbles'), '<p>fred, barney, &amp; pebbles</p>');\n    });\n\n    QUnit.test('should provide correct `wrapper` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      var wrapped = _.wrap(noop, function() {\n        args || (args = slice.call(arguments));\n      });\n\n      wrapped(1, 2, 3);\n      assert.deepEqual(args, [noop, 1, 2, 3]);\n    });\n\n    QUnit.test('should use `_.identity` when `wrapper` is nullish', function(assert) {\n      assert.expect(1);\n\n      var values = [, null, undefined],\n          expected = lodashStable.map(values, stubA);\n\n      var actual = lodashStable.map(values, function(value, index) {\n        var wrapped = index ? _.wrap('a', value) : _.wrap('a');\n        return wrapped('b', 'c');\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(1);\n\n      var p = _.wrap(lodashStable.escape, function(func) {\n        return '<p>' + func(this.text) + '</p>';\n      });\n\n      var object = { 'p': p, 'text': 'fred, barney, & pebbles' };\n      assert.strictEqual(object.p(), '<p>fred, barney, &amp; pebbles</p>');\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('xor methods');\n\n  lodashStable.each(['xor', 'xorBy', 'xorWith'], function(methodName) {\n    var func = _[methodName];\n\n    QUnit.test('`_.' + methodName + '` should return the symmetric difference of two arrays', function(assert) {\n      assert.expect(1);\n\n      var actual = func([2, 1], [2, 3]);\n      assert.deepEqual(actual, [1, 3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return the symmetric difference of multiple arrays', function(assert) {\n      assert.expect(2);\n\n      var actual = func([2, 1], [2, 3], [3, 4]);\n      assert.deepEqual(actual, [1, 4]);\n\n      actual = func([1, 2], [2, 1], [1, 2]);\n      assert.deepEqual(actual, []);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an empty array when comparing the same array', function(assert) {\n      assert.expect(1);\n\n      var array = [1],\n          actual = func(array, array, array);\n\n      assert.deepEqual(actual, []);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return an array of unique values', function(assert) {\n      assert.expect(2);\n\n      var actual = func([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]);\n      assert.deepEqual(actual, [1, 4]);\n\n      actual = func([1, 1]);\n      assert.deepEqual(actual, [1]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a new array when a single array is given', function(assert) {\n      assert.expect(1);\n\n      var array = [1];\n      assert.notStrictEqual(func(array), array);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ignore individual secondary arguments', function(assert) {\n      assert.expect(1);\n\n      var array = [0];\n      assert.deepEqual(func(array, 3, null, { '0': 1 }), array);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ignore values that are not arrays or `arguments` objects', function(assert) {\n      assert.expect(3);\n\n      var array = [1, 2];\n      assert.deepEqual(func(array, 3, { '0': 1 }, null), array);\n      assert.deepEqual(func(null, array, null, [2, 3]), [1, 3]);\n      assert.deepEqual(func(array, null, args, null), [3]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should return a wrapped value when chaining', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _([1, 2, 3])[methodName]([5, 2, 1, 4]);\n        assert.ok(wrapped instanceof _);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('`_.' + methodName + '` should work when in a lazy sequence before `head` or `last`', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE + 1),\n            wrapped = _(array).slice(1)[methodName]([LARGE_ARRAY_SIZE, LARGE_ARRAY_SIZE + 1]);\n\n        var actual = lodashStable.map(['head', 'last'], function(methodName) {\n          return wrapped[methodName]();\n        });\n\n        assert.deepEqual(actual, [1, LARGE_ARRAY_SIZE + 1]);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.xorBy');\n\n  (function() {\n    QUnit.test('should accept an `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var actual = _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n      assert.deepEqual(actual, [1.2, 3.4]);\n\n      actual = _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n      assert.deepEqual(actual, [{ 'x': 2 }]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.xorBy([2.1, 1.2], [2.3, 3.4], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [2.3]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.xorWith');\n\n  (function() {\n    QUnit.test('should work with a `comparator`', function(assert) {\n      assert.expect(1);\n\n      var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }],\n          others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }],\n          actual = _.xorWith(objects, others, lodashStable.isEqual);\n\n      assert.deepEqual(actual, [objects[1], others[0]]);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('zipObject methods');\n\n  lodashStable.each(['zipObject', 'zipObjectDeep'], function(methodName) {\n    var func = _[methodName],\n        object = { 'barney': 36, 'fred': 40 },\n        isDeep = methodName == 'zipObjectDeep';\n\n    QUnit.test('`_.' + methodName + '` should zip together key/value arrays into an object', function(assert) {\n      assert.expect(1);\n\n      var actual = func(['barney', 'fred'], [36, 40]);\n      assert.deepEqual(actual, object);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ignore extra `values`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(['a'], [1, 2]), { 'a': 1 });\n    });\n\n    QUnit.test('`_.' + methodName + '` should assign `undefined` values for extra `keys`', function(assert) {\n      assert.expect(1);\n\n      assert.deepEqual(func(['a', 'b'], [1]), { 'a': 1, 'b': undefined });\n    });\n\n    QUnit.test('`_.' + methodName + '` should ' + (isDeep ? '' : 'not ') + 'support deep paths', function(assert) {\n      assert.expect(2);\n\n      lodashStable.each(['a.b.c', ['a', 'b', 'c']], function(path, index) {\n        var expected = isDeep ? ({ 'a': { 'b': { 'c': 1 } } }) : (index ? { 'a,b,c': 1 } : { 'a.b.c': 1 });\n        assert.deepEqual(func([path], [1]), expected);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work in a lazy sequence', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var values = lodashStable.range(LARGE_ARRAY_SIZE),\n            props = lodashStable.map(values, function(value) { return 'key' + value; }),\n            actual = _(props)[methodName](values).map(square).filter(isEven).take().value();\n\n        assert.deepEqual(actual, _.take(_.filter(_.map(func(props, values), square), isEven)));\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  });\n\n  // zipObjectDeep prototype pollution\n  ['__proto__', 'constructor', 'prototype'].forEach(function (keyToTest) {\n    QUnit.test('zipObjectDeep is not setting ' + keyToTest + ' on global', function (assert) {\n      assert.expect(1);\n\n      _.zipObjectDeep([keyToTest + '.a'], ['newValue']);\n      // Can't access plain `a` as it's not defined and test fails\n      assert.notEqual(root['a'], 'newValue');\n    });\n\n    QUnit.test('zipObjectDeep is not overwriting ' + keyToTest + ' on vars', function (assert) {\n      assert.expect(3);\n\n      const b = 'oldValue'\n      _.zipObjectDeep([keyToTest + '.b'], ['newValue']);\n      assert.equal(b, 'oldValue');\n      assert.notEqual(root['b'], 'newValue');\n\n      // ensure nothing was created\n      assert.notOk(root['b']);\n    });\n\n    QUnit.test('zipObjectDeep is not overwriting global.' + keyToTest, function (assert) {\n      assert.expect(2);\n\n      _.zipObjectDeep([root + '.' + keyToTest + '.c'], ['newValue']);\n      assert.notEqual(root['c'], 'newValue');\n\n      // ensure nothing was created\n      assert.notOk(root['c']);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.zipWith');\n\n  (function() {\n    QUnit.test('should zip arrays combining grouped elements with `iteratee`', function(assert) {\n      assert.expect(2);\n\n      var array1 = [1, 2, 3],\n          array2 = [4, 5, 6],\n          array3 = [7, 8, 9];\n\n      var actual = _.zipWith(array1, array2, array3, function(a, b, c) {\n        return a + b + c;\n      });\n\n      assert.deepEqual(actual, [12, 15, 18]);\n\n      var actual = _.zipWith(array1, [], function(a, b) {\n        return a + (b || 0);\n      });\n\n      assert.deepEqual(actual, [1, 2, 3]);\n    });\n\n    QUnit.test('should provide correct `iteratee` arguments', function(assert) {\n      assert.expect(1);\n\n      var args;\n\n      _.zipWith([1, 2], [3, 4], [5, 6], function() {\n        args || (args = slice.call(arguments));\n      });\n\n      assert.deepEqual(args, [1, 3, 5]);\n    });\n\n    QUnit.test('should perform a basic zip when `iteratee` is nullish', function(assert) {\n      assert.expect(1);\n\n      var array1 = [1, 2],\n          array2 = [3, 4],\n          values = [, null, undefined],\n          expected = lodashStable.map(values, lodashStable.constant(_.zip(array1, array2)));\n\n      var actual = lodashStable.map(values, function(value, index) {\n        return index ? _.zipWith(array1, array2, value) : _.zipWith(array1, array2);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash.unzip and lodash.zip');\n\n  lodashStable.each(['unzip', 'zip'], function(methodName, index) {\n    var func = _[methodName];\n    func = lodashStable.bind(index ? func.apply : func.call, func, null);\n\n    var object = {\n      'an empty array': [\n        [],\n        []\n      ],\n      '0-tuples': [\n        [[], []],\n        []\n      ],\n      '2-tuples': [\n        [['barney', 'fred'], [36, 40]],\n        [['barney', 36], ['fred', 40]]\n      ],\n      '3-tuples': [\n        [['barney', 'fred'], [36, 40], [false, true]],\n        [['barney', 36, false], ['fred', 40, true]]\n      ]\n    };\n\n    lodashStable.forOwn(object, function(pair, key) {\n      QUnit.test('`_.' + methodName + '` should work with ' + key, function(assert) {\n        assert.expect(2);\n\n        var actual = func(pair[0]);\n        assert.deepEqual(actual, pair[1]);\n        assert.deepEqual(func(actual), actual.length ? pair[0] : []);\n      });\n    });\n\n    QUnit.test('`_.' + methodName + '` should work with tuples of different lengths', function(assert) {\n      assert.expect(4);\n\n      var pair = [\n        [['barney', 36], ['fred', 40, false]],\n        [['barney', 'fred'], [36, 40], [undefined, false]]\n      ];\n\n      var actual = func(pair[0]);\n      assert.ok('0' in actual[2]);\n      assert.deepEqual(actual, pair[1]);\n\n      actual = func(actual);\n      assert.ok('2' in actual[0]);\n      assert.deepEqual(actual, [['barney', 36, undefined], ['fred', 40, false]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should treat falsey values as empty arrays', function(assert) {\n      assert.expect(1);\n\n      var expected = lodashStable.map(falsey, stubArray);\n\n      var actual = lodashStable.map(falsey, function(value) {\n        return func([value, value, value]);\n      });\n\n      assert.deepEqual(actual, expected);\n    });\n\n    QUnit.test('`_.' + methodName + '` should ignore values that are not arrays or `arguments` objects', function(assert) {\n      assert.expect(1);\n\n      var array = [[1, 2], [3, 4], null, undefined, { '0': 1 }];\n      assert.deepEqual(func(array), [[1, 3], [2, 4]]);\n    });\n\n    QUnit.test('`_.' + methodName + '` should support consuming its return value', function(assert) {\n      assert.expect(1);\n\n      var expected = [['barney', 'fred'], [36, 40]];\n      assert.deepEqual(func(func(func(func(expected)))), expected);\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).commit');\n\n  (function() {\n    QUnit.test('should execute the chained sequence and returns the wrapped result', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var array = [1],\n            wrapped = _(array).push(2).push(3);\n\n        assert.deepEqual(array, [1]);\n\n        var otherWrapper = wrapped.commit();\n        assert.ok(otherWrapper instanceof _);\n        assert.deepEqual(otherWrapper.value(), [1, 2, 3]);\n        assert.deepEqual(wrapped.value(), [1, 2, 3, 2, 3]);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should track the `__chain__` value of a wrapper', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var wrapped = _([1]).chain().commit().head();\n        assert.ok(wrapped instanceof _);\n        assert.strictEqual(wrapped.value(), 1);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).next');\n\n  lodashStable.each([false, true], function(implicit) {\n    function chain(value) {\n      return implicit ? _(value) : _.chain(value);\n    }\n\n    var chainType = 'in an ' + (implicit ? 'implicit' : 'explict') + ' chain';\n\n    QUnit.test('should follow the iterator protocol ' + chainType, function(assert) {\n      assert.expect(3);\n\n      if (!isNpm) {\n        var wrapped = chain([1, 2]);\n\n        assert.deepEqual(wrapped.next(), { 'done': false, 'value': 1 });\n        assert.deepEqual(wrapped.next(), { 'done': false, 'value': 2 });\n        assert.deepEqual(wrapped.next(), { 'done': true,  'value': undefined });\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should act as an iterable ' + chainType, function(assert) {\n      assert.expect(2);\n\n      if (!isNpm && Symbol && Symbol.iterator) {\n        var array = [1, 2],\n            wrapped = chain(array);\n\n        assert.strictEqual(wrapped[Symbol.iterator](), wrapped);\n        assert.deepEqual(lodashStable.toArray(wrapped), array);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should use `_.toArray` to generate the iterable result ' + chainType, function(assert) {\n      assert.expect(3);\n\n      if (!isNpm && Array.from) {\n        var hearts = '\\ud83d\\udc95',\n            values = [[1], { 'a': 1 }, hearts];\n\n        lodashStable.each(values, function(value) {\n          var wrapped = chain(value);\n          assert.deepEqual(Array.from(wrapped), _.toArray(value));\n        });\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n\n    QUnit.test('should reset the iterator correctly ' + chainType, function(assert) {\n      assert.expect(4);\n\n      if (!isNpm && Symbol && Symbol.iterator) {\n        var array = [1, 2],\n            wrapped = chain(array);\n\n        assert.deepEqual(lodashStable.toArray(wrapped), array);\n        assert.deepEqual(lodashStable.toArray(wrapped), [], 'produces an empty array for exhausted iterator');\n\n        var other = wrapped.filter();\n        assert.deepEqual(lodashStable.toArray(other), array, 'reset for new chain segments');\n        assert.deepEqual(lodashStable.toArray(wrapped), [], 'iterator is still exhausted');\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should work in a lazy sequence ' + chainType, function(assert) {\n      assert.expect(3);\n\n      if (!isNpm && Symbol && Symbol.iterator) {\n        var array = lodashStable.range(LARGE_ARRAY_SIZE),\n            predicate = function(value) { values.push(value); return isEven(value); },\n            values = [],\n            wrapped = chain(array);\n\n        assert.deepEqual(lodashStable.toArray(wrapped), array);\n\n        wrapped = wrapped.filter(predicate);\n        assert.deepEqual(lodashStable.toArray(wrapped), _.filter(array, isEven), 'reset for new lazy chain segments');\n        assert.deepEqual(values, array, 'memoizes iterator values');\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).plant');\n\n  (function() {\n    QUnit.test('should clone the chained sequence planting `value` as the wrapped value', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array1 = [5, null, 3, null, 1],\n            array2 = [10, null, 8, null, 6],\n            wrapped1 = _(array1).thru(_.compact).map(square).takeRight(2).sort(),\n            wrapped2 = wrapped1.plant(array2);\n\n        assert.deepEqual(wrapped2.value(), [36, 64]);\n        assert.deepEqual(wrapped1.value(), [1, 9]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should clone `chainAll` settings', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var array1 = [2, 4],\n            array2 = [6, 8],\n            wrapped1 = _(array1).chain().map(square),\n            wrapped2 = wrapped1.plant(array2);\n\n        assert.deepEqual(wrapped2.head().value(), 36);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should reset iterator data on cloned sequences', function(assert) {\n      assert.expect(3);\n\n      if (!isNpm && Symbol && Symbol.iterator) {\n        var array1 = [2, 4],\n            array2 = [6, 8],\n            wrapped1 = _(array1).map(square);\n\n        assert.deepEqual(lodashStable.toArray(wrapped1), [4, 16]);\n        assert.deepEqual(lodashStable.toArray(wrapped1), []);\n\n        var wrapped2 = wrapped1.plant(array2);\n        assert.deepEqual(lodashStable.toArray(wrapped2), [36, 64]);\n      }\n      else {\n        skipAssert(assert, 3);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).pop');\n\n  (function() {\n    QUnit.test('should remove elements from the end of `array`', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var array = [1, 2],\n            wrapped = _(array);\n\n        assert.strictEqual(wrapped.pop(), 2);\n        assert.deepEqual(wrapped.value(), [1]);\n        assert.strictEqual(wrapped.pop(), 1);\n\n        var actual = wrapped.value();\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var expected = lodashStable.map(falsey, stubTrue);\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          try {\n            var result = index ? _(value).pop() : _().pop();\n            return result === undefined;\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).push');\n\n  (function() {\n    QUnit.test('should append elements to `array`', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array = [1],\n            wrapped = _(array).push(2, 3),\n            actual = wrapped.value();\n\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, [1, 2, 3]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var expected = lodashStable.map(falsey, stubTrue);\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          try {\n            var result = index ? _(value).push(1).value() : _().push(1).value();\n            return lodashStable.eq(result, value);\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).shift');\n\n  (function() {\n    QUnit.test('should remove elements from the front of `array`', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var array = [1, 2],\n            wrapped = _(array);\n\n        assert.strictEqual(wrapped.shift(), 1);\n        assert.deepEqual(wrapped.value(), [2]);\n        assert.strictEqual(wrapped.shift(), 2);\n\n        var actual = wrapped.value();\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var expected = lodashStable.map(falsey, stubTrue);\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          try {\n            var result = index ? _(value).shift() : _().shift();\n            return result === undefined;\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).sort');\n\n  (function() {\n    QUnit.test('should return the wrapped sorted `array`', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array = [3, 1, 2],\n            wrapped = _(array).sort(),\n            actual = wrapped.value();\n\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, [1, 2, 3]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var expected = lodashStable.map(falsey, stubTrue);\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          try {\n            var result = index ? _(value).sort().value() : _().sort().value();\n            return lodashStable.eq(result, value);\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).splice');\n\n  (function() {\n    QUnit.test('should support removing and inserting elements', function(assert) {\n      assert.expect(5);\n\n      if (!isNpm) {\n        var array = [1, 2],\n            wrapped = _(array);\n\n        assert.deepEqual(wrapped.splice(1, 1, 3).value(), [2]);\n        assert.deepEqual(wrapped.value(), [1, 3]);\n        assert.deepEqual(wrapped.splice(0, 2).value(), [1, 3]);\n\n        var actual = wrapped.value();\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, []);\n      }\n      else {\n        skipAssert(assert, 5);\n      }\n    });\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var expected = lodashStable.map(falsey, stubTrue);\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          try {\n            var result = index ? _(value).splice(0, 1).value() : _().splice(0, 1).value();\n            return lodashStable.isEqual(result, []);\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).unshift');\n\n  (function() {\n    QUnit.test('should prepend elements to `array`', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var array = [3],\n            wrapped = _(array).unshift(1, 2),\n            actual = wrapped.value();\n\n        assert.strictEqual(actual, array);\n        assert.deepEqual(actual, [1, 2, 3]);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var expected = lodashStable.map(falsey, stubTrue);\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          try {\n            var result = index ? _(value).unshift(1).value() : _().unshift(1).value();\n            return lodashStable.eq(result, value);\n          } catch (e) {}\n        });\n\n        assert.deepEqual(actual, expected);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...).value');\n\n  (function() {\n    QUnit.test('should execute the chained sequence and extract the unwrapped value', function(assert) {\n      assert.expect(4);\n\n      if (!isNpm) {\n        var array = [1],\n            wrapped = _(array).push(2).push(3);\n\n        assert.deepEqual(array, [1]);\n        assert.deepEqual(wrapped.value(), [1, 2, 3]);\n        assert.deepEqual(wrapped.value(), [1, 2, 3, 2, 3]);\n        assert.deepEqual(array, [1, 2, 3, 2, 3]);\n      }\n      else {\n        skipAssert(assert, 4);\n      }\n    });\n\n    QUnit.test('should return the `valueOf` result of the wrapped value', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm) {\n        var wrapped = _(123);\n        assert.strictEqual(Number(wrapped), 123);\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should stringify the wrapped value when used by `JSON.stringify`', function(assert) {\n      assert.expect(1);\n\n      if (!isNpm && JSON) {\n        var wrapped = _([1, 2, 3]);\n        assert.strictEqual(JSON.stringify(wrapped), '[1,2,3]');\n      }\n      else {\n        skipAssert(assert);\n      }\n    });\n\n    QUnit.test('should be aliased', function(assert) {\n      assert.expect(2);\n\n      if (!isNpm) {\n        var expected = _.prototype.value;\n        assert.strictEqual(_.prototype.toJSON, expected);\n        assert.strictEqual(_.prototype.valueOf, expected);\n      }\n      else {\n        skipAssert(assert, 2);\n      }\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...) methods that return the wrapped modified array');\n\n  (function() {\n    var funcs = [\n      'push',\n      'reverse',\n      'sort',\n      'unshift'\n    ];\n\n    lodashStable.each(funcs, function(methodName) {\n      QUnit.test('`_(...).' + methodName + '` should return a new wrapper', function(assert) {\n        assert.expect(2);\n\n        if (!isNpm) {\n          var array = [1, 2, 3],\n              wrapped = _(array),\n              actual = wrapped[methodName]();\n\n          assert.ok(actual instanceof _);\n          assert.notStrictEqual(actual, wrapped);\n        }\n        else {\n          skipAssert(assert, 2);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...) methods that return new wrapped values');\n\n  (function() {\n    var funcs = [\n      'castArray',\n      'concat',\n      'difference',\n      'differenceBy',\n      'differenceWith',\n      'intersection',\n      'intersectionBy',\n      'intersectionWith',\n      'pull',\n      'pullAll',\n      'pullAt',\n      'sampleSize',\n      'shuffle',\n      'slice',\n      'splice',\n      'split',\n      'toArray',\n      'union',\n      'unionBy',\n      'unionWith',\n      'uniq',\n      'uniqBy',\n      'uniqWith',\n      'words',\n      'xor',\n      'xorBy',\n      'xorWith'\n    ];\n\n    lodashStable.each(funcs, function(methodName) {\n      QUnit.test('`_(...).' + methodName + '` should return a new wrapped value', function(assert) {\n        assert.expect(2);\n\n        if (!isNpm) {\n          var value = methodName == 'split' ? 'abc' : [1, 2, 3],\n              wrapped = _(value),\n              actual = wrapped[methodName]();\n\n          assert.ok(actual instanceof _);\n          assert.notStrictEqual(actual, wrapped);\n        }\n        else {\n          skipAssert(assert, 2);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash(...) methods that return unwrapped values');\n\n  (function() {\n    var funcs = [\n      'add',\n      'camelCase',\n      'capitalize',\n      'ceil',\n      'clone',\n      'deburr',\n      'defaultTo',\n      'divide',\n      'endsWith',\n      'escape',\n      'escapeRegExp',\n      'every',\n      'find',\n      'floor',\n      'has',\n      'hasIn',\n      'head',\n      'includes',\n      'isArguments',\n      'isArray',\n      'isArrayBuffer',\n      'isArrayLike',\n      'isBoolean',\n      'isBuffer',\n      'isDate',\n      'isElement',\n      'isEmpty',\n      'isEqual',\n      'isError',\n      'isFinite',\n      'isFunction',\n      'isInteger',\n      'isMap',\n      'isNaN',\n      'isNative',\n      'isNil',\n      'isNull',\n      'isNumber',\n      'isObject',\n      'isObjectLike',\n      'isPlainObject',\n      'isRegExp',\n      'isSafeInteger',\n      'isSet',\n      'isString',\n      'isUndefined',\n      'isWeakMap',\n      'isWeakSet',\n      'join',\n      'kebabCase',\n      'last',\n      'lowerCase',\n      'lowerFirst',\n      'max',\n      'maxBy',\n      'min',\n      'minBy',\n      'multiply',\n      'nth',\n      'pad',\n      'padEnd',\n      'padStart',\n      'parseInt',\n      'pop',\n      'random',\n      'reduce',\n      'reduceRight',\n      'repeat',\n      'replace',\n      'round',\n      'sample',\n      'shift',\n      'size',\n      'snakeCase',\n      'some',\n      'startCase',\n      'startsWith',\n      'subtract',\n      'sum',\n      'toFinite',\n      'toInteger',\n      'toLower',\n      'toNumber',\n      'toSafeInteger',\n      'toString',\n      'toUpper',\n      'trim',\n      'trimEnd',\n      'trimStart',\n      'truncate',\n      'unescape',\n      'upperCase',\n      'upperFirst'\n    ];\n\n    lodashStable.each(funcs, function(methodName) {\n      QUnit.test('`_(...).' + methodName + '` should return an unwrapped value when implicitly chaining', function(assert) {\n        assert.expect(1);\n\n        if (!isNpm) {\n          var actual = _()[methodName]();\n          assert.notOk(actual instanceof _);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n\n      QUnit.test('`_(...).' + methodName + '` should return a wrapped value when explicitly chaining', function(assert) {\n        assert.expect(1);\n\n        if (!isNpm) {\n          var actual = _().chain()[methodName]();\n          assert.ok(actual instanceof _);\n        }\n        else {\n          skipAssert(assert);\n        }\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('\"Arrays\" category methods');\n\n  (function() {\n    var args = toArgs([1, null, [3], null, 5]),\n        sortedArgs = toArgs([1, [3], 5, null, null]),\n        array = [1, 2, 3, 4, 5, 6];\n\n    QUnit.test('should work with `arguments` objects', function(assert) {\n      assert.expect(30);\n\n      function message(methodName) {\n        return '`_.' + methodName + '` should work with `arguments` objects';\n      }\n\n      assert.deepEqual(_.difference(args, [null]), [1, [3], 5], message('difference'));\n      assert.deepEqual(_.difference(array, args), [2, 3, 4, 6], '_.difference should work with `arguments` objects as secondary arguments');\n\n      assert.deepEqual(_.union(args, [null, 6]), [1, null, [3], 5, 6], message('union'));\n      assert.deepEqual(_.union(array, args), array.concat([null, [3]]), '_.union should work with `arguments` objects as secondary arguments');\n\n      assert.deepEqual(_.compact(args), [1, [3], 5], message('compact'));\n      assert.deepEqual(_.drop(args, 3), [null, 5], message('drop'));\n      assert.deepEqual(_.dropRight(args, 3), [1, null], message('dropRight'));\n      assert.deepEqual(_.dropRightWhile(args,identity), [1, null, [3], null], message('dropRightWhile'));\n      assert.deepEqual(_.dropWhile(args,identity), [null, [3], null, 5], message('dropWhile'));\n      assert.deepEqual(_.findIndex(args, identity), 0, message('findIndex'));\n      assert.deepEqual(_.findLastIndex(args, identity), 4, message('findLastIndex'));\n      assert.deepEqual(_.flatten(args), [1, null, 3, null, 5], message('flatten'));\n      assert.deepEqual(_.head(args), 1, message('head'));\n      assert.deepEqual(_.indexOf(args, 5), 4, message('indexOf'));\n      assert.deepEqual(_.initial(args), [1, null, [3], null], message('initial'));\n      assert.deepEqual(_.intersection(args, [1]), [1], message('intersection'));\n      assert.deepEqual(_.last(args), 5, message('last'));\n      assert.deepEqual(_.lastIndexOf(args, 1), 0, message('lastIndexOf'));\n      assert.deepEqual(_.sortedIndex(sortedArgs, 6), 3, message('sortedIndex'));\n      assert.deepEqual(_.sortedIndexOf(sortedArgs, 5), 2, message('sortedIndexOf'));\n      assert.deepEqual(_.sortedLastIndex(sortedArgs, 5), 3, message('sortedLastIndex'));\n      assert.deepEqual(_.sortedLastIndexOf(sortedArgs, 1), 0, message('sortedLastIndexOf'));\n      assert.deepEqual(_.tail(args, 4), [null, [3], null, 5], message('tail'));\n      assert.deepEqual(_.take(args, 2), [1, null], message('take'));\n      assert.deepEqual(_.takeRight(args, 1), [5], message('takeRight'));\n      assert.deepEqual(_.takeRightWhile(args, identity), [5], message('takeRightWhile'));\n      assert.deepEqual(_.takeWhile(args, identity), [1], message('takeWhile'));\n      assert.deepEqual(_.uniq(args), [1, null, [3], 5], message('uniq'));\n      assert.deepEqual(_.without(args, null), [1, [3], 5], message('without'));\n      assert.deepEqual(_.zip(args, args), [[1, 1], [null, null], [[3], [3]], [null, null], [5, 5]], message('zip'));\n    });\n\n    QUnit.test('should accept falsey primary arguments', function(assert) {\n      assert.expect(4);\n\n      function message(methodName) {\n        return '`_.' + methodName + '` should accept falsey primary arguments';\n      }\n\n      assert.deepEqual(_.difference(null, array), [], message('difference'));\n      assert.deepEqual(_.intersection(null, array), [], message('intersection'));\n      assert.deepEqual(_.union(null, array), array, message('union'));\n      assert.deepEqual(_.xor(null, array), array, message('xor'));\n    });\n\n    QUnit.test('should accept falsey secondary arguments', function(assert) {\n      assert.expect(3);\n\n      function message(methodName) {\n        return '`_.' + methodName + '` should accept falsey secondary arguments';\n      }\n\n      assert.deepEqual(_.difference(array, null), array, message('difference'));\n      assert.deepEqual(_.intersection(array, null), [], message('intersection'));\n      assert.deepEqual(_.union(array, null), array, message('union'));\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('\"Strings\" category methods');\n\n  (function() {\n    var stringMethods = [\n      'camelCase',\n      'capitalize',\n      'escape',\n      'kebabCase',\n      'lowerCase',\n      'lowerFirst',\n      'pad',\n      'padEnd',\n      'padStart',\n      'repeat',\n      'snakeCase',\n      'toLower',\n      'toUpper',\n      'trim',\n      'trimEnd',\n      'trimStart',\n      'truncate',\n      'unescape',\n      'upperCase',\n      'upperFirst'\n    ];\n\n    lodashStable.each(stringMethods, function(methodName) {\n      var func = _[methodName];\n\n      QUnit.test('`_.' + methodName + '` should return an empty string for empty values', function(assert) {\n        assert.expect(1);\n\n        var values = [, null, undefined, ''],\n            expected = lodashStable.map(values, stubString);\n\n        var actual = lodashStable.map(values, function(value, index) {\n          return index ? func(value) : func();\n        });\n\n        assert.deepEqual(actual, expected);\n      });\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.module('lodash methods');\n\n  (function() {\n    var allMethods = lodashStable.reject(_.functions(_).sort(), function(methodName) {\n      return lodashStable.startsWith(methodName, '_');\n    });\n\n    var checkFuncs = [\n      'after',\n      'ary',\n      'before',\n      'bind',\n      'curry',\n      'curryRight',\n      'debounce',\n      'defer',\n      'delay',\n      'flip',\n      'flow',\n      'flowRight',\n      'memoize',\n      'negate',\n      'once',\n      'partial',\n      'partialRight',\n      'rearg',\n      'rest',\n      'spread',\n      'throttle',\n      'unary'\n    ];\n\n    var noBinding = [\n      'flip',\n      'memoize',\n      'negate',\n      'once',\n      'overArgs',\n      'partial',\n      'partialRight',\n      'rearg',\n      'rest',\n      'spread'\n    ];\n\n    var rejectFalsey = [\n      'tap',\n      'thru'\n    ].concat(checkFuncs);\n\n    var returnArrays = [\n      'at',\n      'chunk',\n      'compact',\n      'difference',\n      'drop',\n      'filter',\n      'flatten',\n      'functions',\n      'initial',\n      'intersection',\n      'invokeMap',\n      'keys',\n      'map',\n      'orderBy',\n      'pull',\n      'pullAll',\n      'pullAt',\n      'range',\n      'rangeRight',\n      'reject',\n      'remove',\n      'shuffle',\n      'sortBy',\n      'tail',\n      'take',\n      'times',\n      'toArray',\n      'toPairs',\n      'toPairsIn',\n      'union',\n      'uniq',\n      'values',\n      'without',\n      'xor',\n      'zip'\n    ];\n\n    var acceptFalsey = lodashStable.difference(allMethods, rejectFalsey);\n\n    QUnit.test('should accept falsey arguments', function(assert) {\n      assert.expect(316);\n\n      var arrays = lodashStable.map(falsey, stubArray);\n\n      lodashStable.each(acceptFalsey, function(methodName) {\n        var expected = arrays,\n            func = _[methodName];\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          return index ? func(value) : func();\n        });\n\n        if (methodName == 'noConflict') {\n          root._ = oldDash;\n        }\n        else if (methodName == 'pull' || methodName == 'pullAll') {\n          expected = falsey;\n        }\n        if (lodashStable.includes(returnArrays, methodName) && methodName != 'sample') {\n          assert.deepEqual(actual, expected, '_.' + methodName + ' returns an array');\n        }\n        assert.ok(true, '`_.' + methodName + '` accepts falsey arguments');\n      });\n\n      // Skip tests for missing methods of modularized builds.\n      lodashStable.each(['chain', 'noConflict', 'runInContext'], function(methodName) {\n        if (!_[methodName]) {\n          skipAssert(assert);\n        }\n      });\n    });\n\n    QUnit.test('should return an array', function(assert) {\n      assert.expect(70);\n\n      var array = [1, 2, 3];\n\n      lodashStable.each(returnArrays, function(methodName) {\n        var actual,\n            func = _[methodName];\n\n        switch (methodName) {\n          case 'invokeMap':\n            actual = func(array, 'toFixed');\n            break;\n          case 'sample':\n            actual = func(array, 1);\n            break;\n          default:\n            actual = func(array);\n        }\n        assert.ok(lodashStable.isArray(actual), '_.' + methodName + ' returns an array');\n\n        var isPull = methodName == 'pull' || methodName == 'pullAll';\n        assert.strictEqual(actual === array, isPull, '_.' + methodName + ' should ' + (isPull ? '' : 'not ') + 'return the given array');\n      });\n    });\n\n    QUnit.test('should throw an error for falsey arguments', function(assert) {\n      assert.expect(24);\n\n      lodashStable.each(rejectFalsey, function(methodName) {\n        var expected = lodashStable.map(falsey, stubTrue),\n            func = _[methodName];\n\n        var actual = lodashStable.map(falsey, function(value, index) {\n          var pass = !index && /^(?:backflow|compose|cond|flow(Right)?|over(?:Every|Some)?)$/.test(methodName);\n\n          try {\n            index ? func(value) : func();\n          } catch (e) {\n            pass = !pass && (e instanceof TypeError) &&\n              (!lodashStable.includes(checkFuncs, methodName) || (e.message == FUNC_ERROR_TEXT));\n          }\n          return pass;\n        });\n\n        assert.deepEqual(actual, expected, '`_.' + methodName + '` rejects falsey arguments');\n      });\n    });\n\n    QUnit.test('should use `this` binding of function', function(assert) {\n      assert.expect(30);\n\n      lodashStable.each(noBinding, function(methodName) {\n        var fn = function() { return this.a; },\n            func = _[methodName],\n            isNegate = methodName == 'negate',\n            object = { 'a': 1 },\n            expected = isNegate ? false : 1;\n\n        var wrapper = func(_.bind(fn, object));\n        assert.strictEqual(wrapper(), expected, '`_.' + methodName + '` can consume a bound function');\n\n        wrapper = _.bind(func(fn), object);\n        assert.strictEqual(wrapper(), expected, '`_.' + methodName + '` can be bound');\n\n        object.wrapper = func(fn);\n        assert.strictEqual(object.wrapper(), expected, '`_.' + methodName + '` uses the `this` of its parent object');\n      });\n    });\n\n    QUnit.test('should not contain minified method names (test production builds)', function(assert) {\n      assert.expect(1);\n\n      var shortNames = ['_', 'at', 'eq', 'gt', 'lt'];\n      assert.ok(lodashStable.every(_.functions(_), function(methodName) {\n        return methodName.length > 2 || lodashStable.includes(shortNames, methodName);\n      }));\n    });\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  QUnit.config.asyncRetries = 10;\n  QUnit.config.hidepassed = true;\n\n  if (!document) {\n    QUnit.config.noglobals = true;\n    QUnit.load();\n    QUnit.start();\n  }\n}.call(this));\n",
            language: 'javascript',
            size: 806098,
            tokens: 90721,
            lastModified: '2025-07-02T12:28:22.855Z',
          },
          {
            name: 'underscore.html',
            path: 'test/underscore.html',
            type: 'file',
            content:
              "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Underscore Test Suite</title>\n    <link rel=\"stylesheet\" href=\"../node_modules/qunitjs/qunit/qunit.css\">\n  </head>\n  <body>\n    <div id=\"qunit\"></div>\n    <script>\n      // Avoid reporting tests to Sauce Labs when script errors occur.\n      if (location.port == '9001') {\n        window.onerror = function(message) {\n          if (window.QUnit) {\n            QUnit.config.done.length = 0;\n          }\n          global_test_results = { 'message': message };\n        };\n      }\n    </script>\n    <script src=\"../node_modules/qunitjs/qunit/qunit.js\"></script>\n    <script src=\"../node_modules/qunit-extras/qunit-extras.js\"></script>\n    <script src=\"../node_modules/jquery/dist/jquery.js\"></script>\n    <script src=\"../node_modules/platform/platform.js\"></script>\n    <script src=\"./asset/test-ui.js\"></script>\n    <script src=\"../lodash.js\"></script>\n    <script>\n      QUnit.config.asyncRetries = 10;\n      QUnit.config.hidepassed = true;\n      QUnit.config.excused = {\n        'Arrays': {\n          'chunk': [\n            'defaults to empty array (chunk size 0)'\n          ],\n          'difference': [\n            'can perform an OO-style difference'\n          ],\n          'drop': [\n            'is an alias for rest'\n          ],\n          'first': [\n            'returns an empty array when n <= 0 (0 case)',\n            'returns an empty array when n <= 0 (negative case)',\n            'can fetch the first n elements',\n            'returns the whole array if n > length'\n          ],\n          'findIndex': [\n            'called with context'\n          ],\n          'findLastIndex': [\n            'called with context'\n          ],\n          'flatten': [\n            'supports empty arrays',\n            'can flatten nested arrays',\n            'works on an arguments object',\n            'can handle very deep arrays'\n          ],\n          'indexOf': [\n            \"sorted indexOf doesn't uses binary search\",\n            '0'\n          ],\n          'initial': [\n            'returns all but the last n elements',\n            'returns an empty array when n > length',\n            'works on an arguments object'\n          ],\n          'intersection': [\n            'can perform an OO-style intersection'\n          ],\n          'last': [\n            'returns an empty array when n <= 0 (0 case)',\n            'returns an empty array when n <= 0 (negative case)',\n            'can fetch the last n elements',\n            'returns the whole array if n > length'\n          ],\n          'lastIndexOf': [\n            'should treat falsey `fromIndex` values, except `0` and `NaN`, as `array.length`',\n            'should treat non-number `fromIndex` values as `array.length`',\n            '[0,-1,-1]'\n          ],\n          'object': [\n            'an array of pairs zipped together into an object',\n            'an object converted to pairs and back to an object'\n          ],\n          'rest': [\n            'returns the whole array when index is 0',\n            'returns elements starting at the given index',\n            'works on an arguments object'\n          ],\n          'sortedIndex': [\n            '2',\n            '3'\n          ],\n          'tail': [\n            'is an alias for rest'\n          ],\n          'take': [\n            'is an alias for first'\n          ],\n          'uniq': [\n            'uses the result of `iterator` for uniqueness comparisons (unsorted case)',\n            '`sorted` argument defaults to false when omitted',\n            'when `iterator` is a string, uses that key for comparisons (unsorted case)',\n            'uses the result of `iterator` for uniqueness comparisons (sorted case)',\n            'when `iterator` is a string, uses that key for comparisons (sorted case)',\n            'can use falsey pluck like iterator'\n          ],\n          'union': [\n            'can perform an OO-style union'\n          ]\n        },\n        'Chaining': {\n          'pop': true,\n          'shift': true,\n          'splice': true,\n          'reverse/concat/unshift/pop/map': [\n            'can chain together array functions.'\n          ]\n        },\n        'Collections': {\n          'lookupIterator with contexts': true,\n          'Iterating objects with sketchy length properties': true,\n          'Resistant to collection length and properties changing while iterating': true,\n          'countBy': [\n            '{}',\n            '[{}]'\n          ],\n          'each': [\n            'context object property accessed'\n          ],\n          'every': [\n            'Can be called with object',\n            'Died on test #15',\n            'context works'\n          ],\n          'filter': [\n            'given context',\n            'OO-filter'\n          ],\n          'find': [\n            'called with context'\n          ],\n          'findWhere': [\n            'checks properties given function'\n          ],\n          'groupBy': [\n            '{}',\n            '[{}]'\n          ],\n          'includes': [\n            \"doesn't delegate to binary search\"\n          ],\n          'invoke': [\n            'handles null & undefined'\n          ],\n          'map': [\n            'tripled numbers with context',\n            'OO-style doubled numbers'\n          ],\n          'max': [\n            'can handle null/undefined',\n            'can perform a computation-based max',\n            'Maximum value of an empty object',\n            'Maximum value of an empty array',\n            'Maximum value of a non-numeric collection',\n            'Finds correct max in array starting with num and containing a NaN',\n            'Finds correct max in array starting with NaN',\n            'Respects iterator return value of -Infinity',\n            'String keys use property iterator',\n            'Iterator context',\n            'Lookup falsy iterator'\n          ],\n          'min': [\n            'can handle null/undefined',\n            'can perform a computation-based min',\n            'Minimum value of an empty object',\n            'Minimum value of an empty array',\n            'Minimum value of a non-numeric collection',\n            'Finds correct min in array starting with NaN',\n            'Respects iterator return value of Infinity',\n            'String keys use property iterator',\n            'Iterator context',\n            'Lookup falsy iterator'\n          ],\n          'partition': [\n            'can reference the array index',\n            'Died on test #8',\n            'partition takes a context argument'\n          ],\n          'pluck': [\n            '[1]'\n          ],\n          'reduce': [\n            'can reduce with a context object'\n          ],\n          'reject': [\n            'Returns empty list given empty array'\n          ],\n          'sample': [\n            'behaves correctly on negative n',\n            'Died on test #3'\n          ],\n          'some': [\n            'Can be called with object',\n            'Died on test #17',\n            'context works'\n          ],\n          'where': [\n            'checks properties given function'\n          ],\n          'Can use various collection methods on NodeLists': [\n            '<span id=\"id2\"></span>'\n          ]\n        },\n        'Functions': {\n          'debounce asap': true,\n          'debounce asap cancel': true,\n          'debounce asap recursively': true,\n          'debounce after system time is set backwards': true,\n          'debounce re-entrant': true,\n          'throttle repeatedly with results': true,\n          'more throttle does not trigger leading call when leading is set to false': true,\n          'throttle does not trigger trailing call when trailing is set to false': true,\n          'before': true,\n          'bind': [\n            'Died on test #2'\n          ],\n          'bindAll': [\n            'throws an error for bindAll with no functions named'\n          ],\n          'debounce': [\n            'incr was debounced'\n          ],\n          'iteratee': [\n            '\"bbiz\"',\n            '\"foo\"',\n            '1'\n          ],\n          'memoize': [\n            '{\"bar\":\"BAR\",\"foo\":\"FOO\"}',\n            'Died on test #8'\n          ]\n        },\n        'Objects': {\n          '#1929 Typed Array constructors are functions': true,\n          'allKeys': [\n            'is not fooled by sparse arrays; see issue #95',\n            'is not fooled by sparse arrays with additional properties',\n            '[]'\n          ],\n          'extend': [\n            'extending null results in null',\n            'extending undefined results in undefined'\n          ],\n          'extendOwn': [\n            'extending non-objects results in returning the non-object value',\n            'extending undefined results in undefined'\n          ],\n          'functions': [\n            'also looks up functions on the prototype'\n          ],\n          'isEqual': [\n            '`0` is not equal to `-0`',\n            'Commutative equality is implemented for `0` and `-0`',\n            '`new Number(0)` and `-0` are not equal',\n            'Commutative equality is implemented for `new Number(0)` and `-0`',\n            'Invalid dates are not equal',\n            'false'\n          ],\n          'isFinite': [\n            'Numeric strings are numbers',\n            'Number instances can be finite'\n          ],\n          'isSet': [\n            'Died on test #9'\n          ],\n          'findKey': [\n            'called with context'\n          ],\n          'keys': [\n            'is not fooled by sparse arrays; see issue #95',\n            '[]'\n          ],\n          'mapObject': [\n            'keep context',\n            'called with context',\n            'mapValue identity'\n          ],\n          'omit': [\n            'can accept a predicate',\n            'function is given context'\n          ],\n          'pick': [\n            'can accept a predicate and context',\n            'function is given context'\n          ]\n        },\n        'Utility': {\n          '_.escape & unescape': [\n            '` is escaped',\n            '` can be unescaped',\n            'can escape multiple occurances of `',\n            'multiple occurrences of ` can be unescaped'\n          ],\n          'now': [\n            'Produces the correct time in milliseconds'\n          ],\n          'times': [\n            'works as a wrapper'\n          ]\n        }\n      };\n\n      var mixinPrereqs = (function() {\n        var aliasToReal = {\n          'all': 'every',\n          'allKeys': 'keysIn',\n          'any': 'some',\n          'collect': 'map',\n          'compose': 'flowRight',\n          'contains': 'includes',\n          'detect': 'find',\n          'extendOwn': 'assign',\n          'findWhere': 'find',\n          'foldl': 'reduce',\n          'foldr': 'reduceRight',\n          'include': 'includes',\n          'indexBy': 'keyBy',\n          'inject': 'reduce',\n          'invoke': 'invokeMap',\n          'mapObject': 'mapValues',\n          'matcher': 'matches',\n          'methods': 'functions',\n          'object': 'zipObject',\n          'pairs': 'toPairs',\n          'pluck': 'map',\n          'restParam': 'restArgs',\n          'select': 'filter',\n          'unique': 'uniq',\n          'where': 'filter'\n        };\n\n        var keyMap = {\n          'rest': 'tail',\n          'restArgs': 'rest'\n        };\n\n        var lodash = _.noConflict();\n\n        return function(_) {\n          lodash(_)\n            .defaultsDeep({ 'templateSettings': lodash.templateSettings })\n            .mixin(lodash.pick(lodash, lodash.difference(lodash.functions(lodash), lodash.functions(_))))\n            .value();\n\n          lodash.forOwn(keyMap, function(realName, otherName) {\n            _[otherName] = lodash[realName];\n            _.prototype[otherName] = lodash.prototype[realName];\n          });\n          lodash.forOwn(aliasToReal, function(realName, alias) {\n            _[alias] = _[realName];\n            _.prototype[alias] = _.prototype[realName];\n          });\n          return _;\n        };\n      }());\n\n      // Only excuse in Sauce Labs.\n      if (!ui.isSauceLabs) {\n        delete QUnit.config.excused.Functions['throttle does not trigger trailing call when trailing is set to false'];\n        delete QUnit.config.excused.Utility.now;\n      }\n      // Load prerequisite scripts.\n      document.write(ui.urlParams.loader == 'none'\n        ? '<script src=\"' + ui.buildPath + '\"><\\/script>'\n        : '<script data-dojo-config=\"async:1\" src=\"' + ui.loaderPath + '\"><\\/script>'\n      );\n    </script>\n    <script>\n      if (ui.urlParams.loader == 'none') {\n        mixinPrereqs(_);\n        document.write([\n          '<script src=\"../vendor/underscore/test/collections.js\"><\\/script>',\n          '<script src=\"../vendor/underscore/test/arrays.js\"><\\/script>',\n          '<script src=\"../vendor/underscore/test/functions.js\"><\\/script>',\n          '<script src=\"../vendor/underscore/test/objects.js\"><\\/script>',\n          '<script src=\"../vendor/underscore/test/cross-document.js\"><\\/script>',\n          '<script src=\"../vendor/underscore/test/utility.js\"><\\/script>',\n          '<script src=\"../vendor/underscore/test/chaining.js\"><\\/script>'\n        ].join('\\n'));\n      }\n    </script>\n    <script>\n      (function() {\n        if (window.curl) {\n          curl.config({ 'apiName': 'require' });\n        }\n        if (!window.require) {\n          return;\n        }\n        // Wrap to work around tests assuming Node `require` use.\n        require = (function(func) {\n          return function() {\n            return arguments[0] === '..' ? window._ : func.apply(null, arguments);\n          };\n        }(require));\n\n        var reBasename = /[\\w.-]+$/,\n            basePath = ('//' + location.host + location.pathname.replace(reBasename, '')).replace(/\\btest\\/$/, ''),\n            modulePath = ui.buildPath.replace(/\\.js$/, ''),\n            locationPath = modulePath.replace(reBasename, '').replace(/^\\/|\\/$/g, ''),\n            moduleId = /\\bunderscore\\b/i.test(ui.buildPath) ? 'underscore' : 'lodash',\n            moduleMain = modulePath.match(reBasename)[0],\n            uid = +new Date;\n\n        function getConfig() {\n          var result = {\n            'baseUrl': './',\n            'urlArgs': 't=' + uid++,\n            'waitSeconds': 0,\n            'paths': {},\n            'packages': [{\n              'name': 'test',\n              'location': '../vendor/underscore/test',\n              'config': {\n                // Work around no global being exported.\n                'exports': 'QUnit',\n                'loader': 'curl/loader/legacy'\n              }\n            }]\n          };\n\n          if (ui.isModularize) {\n            result.packages.push({\n              'name': moduleId,\n              'location': locationPath,\n              'main': moduleMain\n            });\n          } else {\n            result.paths[moduleId] = modulePath;\n          }\n          return result;\n        }\n\n        QUnit.config.autostart = false;\n        QUnit.config.excused.Functions.iteratee = true;\n        QUnit.config.excused.Utility.noConflict = true;\n        QUnit.config.excused.Utility['noConflict (node vm)'] = true;\n\n        require(getConfig(), [moduleId], function(lodash) {\n          _ = mixinPrereqs(lodash);\n          require(getConfig(), [\n            'test/collections',\n            'test/arrays',\n            'test/functions',\n            'test/objects',\n            'test/cross-document',\n            'test/utility',\n            'test/chaining'\n          ], QUnit.start);\n        });\n      }());\n    </script>\n  </body>\n</html>\n",
            language: 'html',
            size: 15493,
            tokens: 1481,
            lastModified: '2025-07-02T12:28:22.856Z',
          },
        ],
      },
      {
        name: 'vendor',
        path: 'vendor',
        type: 'directory',
        children: [
          {
            name: 'backbone',
            path: 'vendor/backbone',
            type: 'directory',
            children: [
              {
                name: 'test',
                path: 'vendor/backbone/test',
                type: 'directory',
                children: [
                  {
                    name: 'setup',
                    path: 'vendor/backbone/test/setup',
                    type: 'directory',
                    children: [
                      {
                        name: 'dom-setup.js',
                        path: 'vendor/backbone/test/setup/dom-setup.js',
                        type: 'file',
                        content:
                          "$('body').append(\n    '<div id=\"qunit\"></div>' +\n    '<div id=\"qunit-fixture\"></div>'\n);\n",
                        language: 'javascript',
                        size: 89,
                        tokens: 15,
                        lastModified: '2025-07-02T12:28:22.860Z',
                      },
                      {
                        name: 'environment.js',
                        path: 'vendor/backbone/test/setup/environment.js',
                        type: 'file',
                        content:
                          '(function(QUnit) {\n\n  var sync = Backbone.sync;\n  var ajax = Backbone.ajax;\n  var emulateHTTP = Backbone.emulateHTTP;\n  var emulateJSON = Backbone.emulateJSON;\n  var history = window.history;\n  var pushState = history.pushState;\n  var replaceState = history.replaceState;\n\n  QUnit.config.noglobals = true;\n\n  QUnit.testStart(function() {\n    var env = QUnit.config.current.testEnvironment;\n\n    // We never want to actually call these during tests.\n    history.pushState = history.replaceState = function() {};\n\n    // Capture ajax settings for comparison.\n    Backbone.ajax = function(settings) {\n      env.ajaxSettings = settings;\n    };\n\n    // Capture the arguments to Backbone.sync for comparison.\n    Backbone.sync = function(method, model, options) {\n      env.syncArgs = {\n        method: method,\n        model: model,\n        options: options\n      };\n      sync.apply(this, arguments);\n    };\n\n  });\n\n  QUnit.testDone(function() {\n    Backbone.sync = sync;\n    Backbone.ajax = ajax;\n    Backbone.emulateHTTP = emulateHTTP;\n    Backbone.emulateJSON = emulateJSON;\n    history.pushState = pushState;\n    history.replaceState = replaceState;\n  });\n\n})(QUnit);\n',
                        language: 'javascript',
                        size: 1167,
                        tokens: 138,
                        lastModified: '2025-07-02T12:28:22.860Z',
                      },
                    ],
                  },
                  {
                    name: 'collection.js',
                    path: 'vendor/backbone/test/collection.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  var a, b, c, d, e, col, otherCol;\n\n  QUnit.module('Backbone.Collection', {\n\n    beforeEach: function(assert) {\n      a         = new Backbone.Model({id: 3, label: 'a'});\n      b         = new Backbone.Model({id: 2, label: 'b'});\n      c         = new Backbone.Model({id: 1, label: 'c'});\n      d         = new Backbone.Model({id: 0, label: 'd'});\n      e         = null;\n      col       = new Backbone.Collection([a, b, c, d]);\n      otherCol  = new Backbone.Collection();\n    }\n\n  });\n\n  QUnit.test('new and sort', function(assert) {\n    assert.expect(6);\n    var counter = 0;\n    col.on('sort', function(){ counter++; });\n    assert.deepEqual(col.pluck('label'), ['a', 'b', 'c', 'd']);\n    col.comparator = function(m1, m2) {\n      return m1.id > m2.id ? -1 : 1;\n    };\n    col.sort();\n    assert.equal(counter, 1);\n    assert.deepEqual(col.pluck('label'), ['a', 'b', 'c', 'd']);\n    col.comparator = function(model) { return model.id; };\n    col.sort();\n    assert.equal(counter, 2);\n    assert.deepEqual(col.pluck('label'), ['d', 'c', 'b', 'a']);\n    assert.equal(col.length, 4);\n  });\n\n  QUnit.test('String comparator.', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([\n      {id: 3},\n      {id: 1},\n      {id: 2}\n    ], {comparator: 'id'});\n    assert.deepEqual(collection.pluck('id'), [1, 2, 3]);\n  });\n\n  QUnit.test('new and parse', function(assert) {\n    assert.expect(3);\n    var Collection = Backbone.Collection.extend({\n      parse: function(data) {\n        return _.filter(data, function(datum) {\n          return datum.a % 2 === 0;\n        });\n      }\n    });\n    var models = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n    var collection = new Collection(models, {parse: true});\n    assert.strictEqual(collection.length, 2);\n    assert.strictEqual(collection.first().get('a'), 2);\n    assert.strictEqual(collection.last().get('a'), 4);\n  });\n\n  QUnit.test('clone preserves model and comparator', function(assert) {\n    assert.expect(3);\n    var Model = Backbone.Model.extend();\n    var comparator = function(model){ return model.id; };\n\n    var collection = new Backbone.Collection([{id: 1}], {\n      model: Model,\n      comparator: comparator\n    }).clone();\n    collection.add({id: 2});\n    assert.ok(collection.at(0) instanceof Model);\n    assert.ok(collection.at(1) instanceof Model);\n    assert.strictEqual(collection.comparator, comparator);\n  });\n\n  QUnit.test('get', function(assert) {\n    assert.expect(6);\n    assert.equal(col.get(0), d);\n    assert.equal(col.get(d.clone()), d);\n    assert.equal(col.get(2), b);\n    assert.equal(col.get({id: 1}), c);\n    assert.equal(col.get(c.clone()), c);\n    assert.equal(col.get(col.first().cid), col.first());\n  });\n\n  QUnit.test('get with non-default ids', function(assert) {\n    assert.expect(5);\n    var MongoModel = Backbone.Model.extend({idAttribute: '_id'});\n    var model = new MongoModel({_id: 100});\n    var collection = new Backbone.Collection([model], {model: MongoModel});\n    assert.equal(collection.get(100), model);\n    assert.equal(collection.get(model.cid), model);\n    assert.equal(collection.get(model), model);\n    assert.equal(collection.get(101), void 0);\n\n    var collection2 = new Backbone.Collection();\n    collection2.model = MongoModel;\n    collection2.add(model.attributes);\n    assert.equal(collection2.get(model.clone()), collection2.first());\n  });\n\n  QUnit.test('has', function(assert) {\n    assert.expect(15);\n    assert.ok(col.has(a));\n    assert.ok(col.has(b));\n    assert.ok(col.has(c));\n    assert.ok(col.has(d));\n    assert.ok(col.has(a.id));\n    assert.ok(col.has(b.id));\n    assert.ok(col.has(c.id));\n    assert.ok(col.has(d.id));\n    assert.ok(col.has(a.cid));\n    assert.ok(col.has(b.cid));\n    assert.ok(col.has(c.cid));\n    assert.ok(col.has(d.cid));\n    var outsider = new Backbone.Model({id: 4});\n    assert.notOk(col.has(outsider));\n    assert.notOk(col.has(outsider.id));\n    assert.notOk(col.has(outsider.cid));\n  });\n\n  QUnit.test('update index when id changes', function(assert) {\n    assert.expect(4);\n    var collection = new Backbone.Collection();\n    collection.add([\n      {id: 0, name: 'one'},\n      {id: 1, name: 'two'}\n    ]);\n    var one = collection.get(0);\n    assert.equal(one.get('name'), 'one');\n    collection.on('change:name', function(model) { assert.ok(this.get(model)); });\n    one.set({name: 'dalmatians', id: 101});\n    assert.equal(collection.get(0), null);\n    assert.equal(collection.get(101).get('name'), 'dalmatians');\n  });\n\n  QUnit.test('at', function(assert) {\n    assert.expect(2);\n    assert.equal(col.at(2), c);\n    assert.equal(col.at(-2), c);\n  });\n\n  QUnit.test('pluck', function(assert) {\n    assert.expect(1);\n    assert.equal(col.pluck('label').join(' '), 'a b c d');\n  });\n\n  QUnit.test('add', function(assert) {\n    assert.expect(14);\n    var added, opts, secondAdded;\n    added = opts = secondAdded = null;\n    e = new Backbone.Model({id: 10, label: 'e'});\n    otherCol.add(e);\n    otherCol.on('add', function() {\n      secondAdded = true;\n    });\n    col.on('add', function(model, collection, options){\n      added = model.get('label');\n      opts = options;\n    });\n    col.add(e, {amazing: true});\n    assert.equal(added, 'e');\n    assert.equal(col.length, 5);\n    assert.equal(col.last(), e);\n    assert.equal(otherCol.length, 1);\n    assert.equal(secondAdded, null);\n    assert.ok(opts.amazing);\n\n    var f = new Backbone.Model({id: 20, label: 'f'});\n    var g = new Backbone.Model({id: 21, label: 'g'});\n    var h = new Backbone.Model({id: 22, label: 'h'});\n    var atCol = new Backbone.Collection([f, g, h]);\n    assert.equal(atCol.length, 3);\n    atCol.add(e, {at: 1});\n    assert.equal(atCol.length, 4);\n    assert.equal(atCol.at(1), e);\n    assert.equal(atCol.last(), h);\n\n    var coll = new Backbone.Collection(new Array(2));\n    var addCount = 0;\n    coll.on('add', function(){\n      addCount += 1;\n    });\n    coll.add([undefined, f, g]);\n    assert.equal(coll.length, 5);\n    assert.equal(addCount, 3);\n    coll.add(new Array(4));\n    assert.equal(coll.length, 9);\n    assert.equal(addCount, 7);\n  });\n\n  QUnit.test('add multiple models', function(assert) {\n    assert.expect(6);\n    var collection = new Backbone.Collection([{at: 0}, {at: 1}, {at: 9}]);\n    collection.add([{at: 2}, {at: 3}, {at: 4}, {at: 5}, {at: 6}, {at: 7}, {at: 8}], {at: 2});\n    for (var i = 0; i <= 5; i++) {\n      assert.equal(collection.at(i).get('at'), i);\n    }\n  });\n\n  QUnit.test('add; at should have preference over comparator', function(assert) {\n    assert.expect(1);\n    var Col = Backbone.Collection.extend({\n      comparator: function(m1, m2) {\n        return m1.id > m2.id ? -1 : 1;\n      }\n    });\n\n    var collection = new Col([{id: 2}, {id: 3}]);\n    collection.add(new Backbone.Model({id: 1}), {at: 1});\n\n    assert.equal(collection.pluck('id').join(' '), '3 1 2');\n  });\n\n  QUnit.test('add; at should add to the end if the index is out of bounds', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 2}, {id: 3}]);\n    collection.add(new Backbone.Model({id: 1}), {at: 5});\n\n    assert.equal(collection.pluck('id').join(' '), '2 3 1');\n  });\n\n  QUnit.test(\"can't add model to collection twice\", function(assert) {\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}, {id: 1}, {id: 2}, {id: 3}]);\n    assert.equal(collection.pluck('id').join(' '), '1 2 3');\n  });\n\n  QUnit.test(\"can't add different model with same id to collection twice\", function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection;\n    collection.unshift({id: 101});\n    collection.add({id: 101});\n    assert.equal(collection.length, 1);\n  });\n\n  QUnit.test('merge in duplicate models with {merge: true}', function(assert) {\n    assert.expect(3);\n    var collection = new Backbone.Collection;\n    collection.add([{id: 1, name: 'Moe'}, {id: 2, name: 'Curly'}, {id: 3, name: 'Larry'}]);\n    collection.add({id: 1, name: 'Moses'});\n    assert.equal(collection.first().get('name'), 'Moe');\n    collection.add({id: 1, name: 'Moses'}, {merge: true});\n    assert.equal(collection.first().get('name'), 'Moses');\n    collection.add({id: 1, name: 'Tim'}, {merge: true, silent: true});\n    assert.equal(collection.first().get('name'), 'Tim');\n  });\n\n  QUnit.test('add model to multiple collections', function(assert) {\n    assert.expect(10);\n    var counter = 0;\n    var m = new Backbone.Model({id: 10, label: 'm'});\n    m.on('add', function(model, collection) {\n      counter++;\n      assert.equal(m, model);\n      if (counter > 1) {\n        assert.equal(collection, col2);\n      } else {\n        assert.equal(collection, col1);\n      }\n    });\n    var col1 = new Backbone.Collection([]);\n    col1.on('add', function(model, collection) {\n      assert.equal(m, model);\n      assert.equal(col1, collection);\n    });\n    var col2 = new Backbone.Collection([]);\n    col2.on('add', function(model, collection) {\n      assert.equal(m, model);\n      assert.equal(col2, collection);\n    });\n    col1.add(m);\n    assert.equal(m.collection, col1);\n    col2.add(m);\n    assert.equal(m.collection, col1);\n  });\n\n  QUnit.test('add model with parse', function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      parse: function(obj) {\n        obj.value += 1;\n        return obj;\n      }\n    });\n\n    var Col = Backbone.Collection.extend({model: Model});\n    var collection = new Col;\n    collection.add({value: 1}, {parse: true});\n    assert.equal(collection.at(0).get('value'), 2);\n  });\n\n  QUnit.test('add with parse and merge', function(assert) {\n    var collection = new Backbone.Collection();\n    collection.parse = function(attrs) {\n      return _.map(attrs, function(model) {\n        if (model.model) return model.model;\n        return model;\n      });\n    };\n    collection.add({id: 1});\n    collection.add({model: {id: 1, name: 'Alf'}}, {parse: true, merge: true});\n    assert.equal(collection.first().get('name'), 'Alf');\n  });\n\n  QUnit.test('add model to collection with sort()-style comparator', function(assert) {\n    assert.expect(3);\n    var collection = new Backbone.Collection;\n    collection.comparator = function(m1, m2) {\n      return m1.get('name') < m2.get('name') ? -1 : 1;\n    };\n    var tom = new Backbone.Model({name: 'Tom'});\n    var rob = new Backbone.Model({name: 'Rob'});\n    var tim = new Backbone.Model({name: 'Tim'});\n    collection.add(tom);\n    collection.add(rob);\n    collection.add(tim);\n    assert.equal(collection.indexOf(rob), 0);\n    assert.equal(collection.indexOf(tim), 1);\n    assert.equal(collection.indexOf(tom), 2);\n  });\n\n  QUnit.test('comparator that depends on `this`', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection;\n    collection.negative = function(num) {\n      return -num;\n    };\n    collection.comparator = function(model) {\n      return this.negative(model.id);\n    };\n    collection.add([{id: 1}, {id: 2}, {id: 3}]);\n    assert.deepEqual(collection.pluck('id'), [3, 2, 1]);\n    collection.comparator = function(m1, m2) {\n      return this.negative(m2.id) - this.negative(m1.id);\n    };\n    collection.sort();\n    assert.deepEqual(collection.pluck('id'), [1, 2, 3]);\n  });\n\n  QUnit.test('remove', function(assert) {\n    assert.expect(12);\n    var removed = null;\n    var result = null;\n    col.on('remove', function(model, collection, options) {\n      removed = model.get('label');\n      assert.equal(options.index, 3);\n      assert.equal(collection.get(model), undefined, '#3693: model cannot be fetched from collection');\n    });\n    result = col.remove(d);\n    assert.equal(removed, 'd');\n    assert.strictEqual(result, d);\n    //if we try to remove d again, it's not going to actually get removed\n    result = col.remove(d);\n    assert.strictEqual(result, undefined);\n    assert.equal(col.length, 3);\n    assert.equal(col.first(), a);\n    col.off();\n    result = col.remove([c, d]);\n    assert.equal(result.length, 1, 'only returns removed models');\n    assert.equal(result[0], c, 'only returns removed models');\n    result = col.remove([c, b]);\n    assert.equal(result.length, 1, 'only returns removed models');\n    assert.equal(result[0], b, 'only returns removed models');\n    result = col.remove([]);\n    assert.deepEqual(result, [], 'returns empty array when nothing removed');\n  });\n\n  QUnit.test('add and remove return values', function(assert) {\n    assert.expect(13);\n    var Even = Backbone.Model.extend({\n      validate: function(attrs) {\n        if (attrs.id % 2 !== 0) return 'odd';\n      }\n    });\n    var collection = new Backbone.Collection;\n    collection.model = Even;\n\n    var list = collection.add([{id: 2}, {id: 4}], {validate: true});\n    assert.equal(list.length, 2);\n    assert.ok(list[0] instanceof Backbone.Model);\n    assert.equal(list[1], collection.last());\n    assert.equal(list[1].get('id'), 4);\n\n    list = collection.add([{id: 3}, {id: 6}], {validate: true});\n    assert.equal(collection.length, 3);\n    assert.equal(list[0], false);\n    assert.equal(list[1].get('id'), 6);\n\n    var result = collection.add({id: 6});\n    assert.equal(result.cid, list[1].cid);\n\n    result = collection.remove({id: 6});\n    assert.equal(collection.length, 2);\n    assert.equal(result.id, 6);\n\n    list = collection.remove([{id: 2}, {id: 8}]);\n    assert.equal(collection.length, 1);\n    assert.equal(list[0].get('id'), 2);\n    assert.equal(list[1], null);\n  });\n\n  QUnit.test('shift and pop', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection([{a: 'a'}, {b: 'b'}, {c: 'c'}]);\n    assert.equal(collection.shift().get('a'), 'a');\n    assert.equal(collection.pop().get('c'), 'c');\n  });\n\n  QUnit.test('slice', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection([{a: 'a'}, {b: 'b'}, {c: 'c'}]);\n    var array = collection.slice(1, 3);\n    assert.equal(array.length, 2);\n    assert.equal(array[0].get('b'), 'b');\n  });\n\n  QUnit.test('events are unbound on remove', function(assert) {\n    assert.expect(3);\n    var counter = 0;\n    var dj = new Backbone.Model();\n    var emcees = new Backbone.Collection([dj]);\n    emcees.on('change', function(){ counter++; });\n    dj.set({name: 'Kool'});\n    assert.equal(counter, 1);\n    emcees.reset([]);\n    assert.equal(dj.collection, undefined);\n    dj.set({name: 'Shadow'});\n    assert.equal(counter, 1);\n  });\n\n  QUnit.test('remove in multiple collections', function(assert) {\n    assert.expect(7);\n    var modelData = {\n      id: 5,\n      title: 'Othello'\n    };\n    var passed = false;\n    var m1 = new Backbone.Model(modelData);\n    var m2 = new Backbone.Model(modelData);\n    m2.on('remove', function() {\n      passed = true;\n    });\n    var col1 = new Backbone.Collection([m1]);\n    var col2 = new Backbone.Collection([m2]);\n    assert.notEqual(m1, m2);\n    assert.ok(col1.length === 1);\n    assert.ok(col2.length === 1);\n    col1.remove(m1);\n    assert.equal(passed, false);\n    assert.ok(col1.length === 0);\n    col2.remove(m1);\n    assert.ok(col2.length === 0);\n    assert.equal(passed, true);\n  });\n\n  QUnit.test('remove same model in multiple collection', function(assert) {\n    assert.expect(16);\n    var counter = 0;\n    var m = new Backbone.Model({id: 5, title: 'Othello'});\n    m.on('remove', function(model, collection) {\n      counter++;\n      assert.equal(m, model);\n      if (counter > 1) {\n        assert.equal(collection, col1);\n      } else {\n        assert.equal(collection, col2);\n      }\n    });\n    var col1 = new Backbone.Collection([m]);\n    col1.on('remove', function(model, collection) {\n      assert.equal(m, model);\n      assert.equal(col1, collection);\n    });\n    var col2 = new Backbone.Collection([m]);\n    col2.on('remove', function(model, collection) {\n      assert.equal(m, model);\n      assert.equal(col2, collection);\n    });\n    assert.equal(col1, m.collection);\n    col2.remove(m);\n    assert.ok(col2.length === 0);\n    assert.ok(col1.length === 1);\n    assert.equal(counter, 1);\n    assert.equal(col1, m.collection);\n    col1.remove(m);\n    assert.equal(null, m.collection);\n    assert.ok(col1.length === 0);\n    assert.equal(counter, 2);\n  });\n\n  QUnit.test('model destroy removes from all collections', function(assert) {\n    assert.expect(3);\n    var m = new Backbone.Model({id: 5, title: 'Othello'});\n    m.sync = function(method, model, options) { options.success(); };\n    var col1 = new Backbone.Collection([m]);\n    var col2 = new Backbone.Collection([m]);\n    m.destroy();\n    assert.ok(col1.length === 0);\n    assert.ok(col2.length === 0);\n    assert.equal(undefined, m.collection);\n  });\n\n  QUnit.test('Collection: non-persisted model destroy removes from all collections', function(assert) {\n    assert.expect(3);\n    var m = new Backbone.Model({title: 'Othello'});\n    m.sync = function(method, model, options) { throw 'should not be called'; };\n    var col1 = new Backbone.Collection([m]);\n    var col2 = new Backbone.Collection([m]);\n    m.destroy();\n    assert.ok(col1.length === 0);\n    assert.ok(col2.length === 0);\n    assert.equal(undefined, m.collection);\n  });\n\n  QUnit.test('fetch', function(assert) {\n    assert.expect(4);\n    var collection = new Backbone.Collection;\n    collection.url = '/test';\n    collection.fetch();\n    assert.equal(this.syncArgs.method, 'read');\n    assert.equal(this.syncArgs.model, collection);\n    assert.equal(this.syncArgs.options.parse, true);\n\n    collection.fetch({parse: false});\n    assert.equal(this.syncArgs.options.parse, false);\n  });\n\n  QUnit.test('fetch with an error response triggers an error event', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection();\n    collection.on('error', function() {\n      assert.ok(true);\n    });\n    collection.sync = function(method, model, options) { options.error(); };\n    collection.fetch();\n  });\n\n  QUnit.test('#3283 - fetch with an error response calls error with context', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection();\n    var obj = {};\n    var options = {\n      context: obj,\n      error: function() {\n        assert.equal(this, obj);\n      }\n    };\n    collection.sync = function(method, model, opts) {\n      opts.error.call(opts.context);\n    };\n    collection.fetch(options);\n  });\n\n  QUnit.test('ensure fetch only parses once', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection;\n    var counter = 0;\n    collection.parse = function(models) {\n      counter++;\n      return models;\n    };\n    collection.url = '/test';\n    collection.fetch();\n    this.syncArgs.options.success([]);\n    assert.equal(counter, 1);\n  });\n\n  QUnit.test('create', function(assert) {\n    assert.expect(4);\n    var collection = new Backbone.Collection;\n    collection.url = '/test';\n    var model = collection.create({label: 'f'}, {wait: true});\n    assert.equal(this.syncArgs.method, 'create');\n    assert.equal(this.syncArgs.model, model);\n    assert.equal(model.get('label'), 'f');\n    assert.equal(model.collection, collection);\n  });\n\n  QUnit.test('create with validate:true enforces validation', function(assert) {\n    assert.expect(3);\n    var ValidatingModel = Backbone.Model.extend({\n      validate: function(attrs) {\n        return 'fail';\n      }\n    });\n    var ValidatingCollection = Backbone.Collection.extend({\n      model: ValidatingModel\n    });\n    var collection = new ValidatingCollection();\n    collection.on('invalid', function(coll, error, options) {\n      assert.equal(error, 'fail');\n      assert.equal(options.validationError, 'fail');\n    });\n    assert.equal(collection.create({foo: 'bar'}, {validate: true}), false);\n  });\n\n  QUnit.test('create will pass extra options to success callback', function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      sync: function(method, model, options) {\n        _.extend(options, {specialSync: true});\n        return Backbone.Model.prototype.sync.call(this, method, model, options);\n      }\n    });\n\n    var Collection = Backbone.Collection.extend({\n      model: Model,\n      url: '/test'\n    });\n\n    var collection = new Collection;\n\n    var success = function(model, response, options) {\n      assert.ok(options.specialSync, 'Options were passed correctly to callback');\n    };\n\n    collection.create({}, {success: success});\n    this.ajaxSettings.success();\n  });\n\n  QUnit.test('create with wait:true should not call collection.parse', function(assert) {\n    assert.expect(0);\n    var Collection = Backbone.Collection.extend({\n      url: '/test',\n      parse: function() {\n        assert.ok(false);\n      }\n    });\n\n    var collection = new Collection;\n\n    collection.create({}, {wait: true});\n    this.ajaxSettings.success();\n  });\n\n  QUnit.test('a failing create returns model with errors', function(assert) {\n    var ValidatingModel = Backbone.Model.extend({\n      validate: function(attrs) {\n        return 'fail';\n      }\n    });\n    var ValidatingCollection = Backbone.Collection.extend({\n      model: ValidatingModel\n    });\n    var collection = new ValidatingCollection();\n    var m = collection.create({foo: 'bar'});\n    assert.equal(m.validationError, 'fail');\n    assert.equal(collection.length, 1);\n  });\n\n  QUnit.test('initialize', function(assert) {\n    assert.expect(1);\n    var Collection = Backbone.Collection.extend({\n      initialize: function() {\n        this.one = 1;\n      }\n    });\n    var coll = new Collection;\n    assert.equal(coll.one, 1);\n  });\n\n  QUnit.test('preinitialize', function(assert) {\n    assert.expect(1);\n    var Collection = Backbone.Collection.extend({\n      preinitialize: function() {\n        this.one = 1;\n      }\n    });\n    var coll = new Collection;\n    assert.equal(coll.one, 1);\n  });\n\n  QUnit.test('preinitialize occurs before the collection is set up', function(assert) {\n    assert.expect(2);\n    var Collection = Backbone.Collection.extend({\n      preinitialize: function() {\n        assert.notEqual(this.model, FooModel);\n      }\n    });\n    var FooModel = Backbone.Model.extend({id: 'foo'});\n    var coll = new Collection({}, {\n      model: FooModel\n    });\n    assert.equal(coll.model, FooModel);\n  });\n\n  QUnit.test('toJSON', function(assert) {\n    assert.expect(1);\n    assert.equal(JSON.stringify(col), '[{\"id\":3,\"label\":\"a\"},{\"id\":2,\"label\":\"b\"},{\"id\":1,\"label\":\"c\"},{\"id\":0,\"label\":\"d\"}]');\n  });\n\n  QUnit.test('where and findWhere', function(assert) {\n    assert.expect(8);\n    var model = new Backbone.Model({a: 1});\n    var coll = new Backbone.Collection([\n      model,\n      {a: 1},\n      {a: 1, b: 2},\n      {a: 2, b: 2},\n      {a: 3}\n    ]);\n    assert.equal(coll.where({a: 1}).length, 3);\n    assert.equal(coll.where({a: 2}).length, 1);\n    assert.equal(coll.where({a: 3}).length, 1);\n    assert.equal(coll.where({b: 1}).length, 0);\n    assert.equal(coll.where({b: 2}).length, 2);\n    assert.equal(coll.where({a: 1, b: 2}).length, 1);\n    assert.equal(coll.findWhere({a: 1}), model);\n    assert.equal(coll.findWhere({a: 4}), void 0);\n  });\n\n  QUnit.test('Underscore methods', function(assert) {\n    assert.expect(21);\n    assert.equal(col.map(function(model){ return model.get('label'); }).join(' '), 'a b c d');\n    assert.equal(col.some(function(model){ return model.id === 100; }), false);\n    assert.equal(col.some(function(model){ return model.id === 0; }), true);\n    assert.equal(col.reduce(function(m1, m2) {return m1.id > m2.id ? m1 : m2;}).id, 3);\n    assert.equal(col.reduceRight(function(m1, m2) {return m1.id > m2.id ? m1 : m2;}).id, 3);\n    assert.equal(col.indexOf(b), 1);\n    assert.equal(col.size(), 4);\n    assert.equal(col.rest().length, 3);\n    assert.ok(!_.includes(col.rest(), a));\n    assert.ok(_.includes(col.rest(), d));\n    assert.ok(!col.isEmpty());\n    assert.ok(!_.includes(col.without(d), d));\n\n    var wrapped = col.chain();\n    assert.equal(wrapped.map('id').max().value(), 3);\n    assert.equal(wrapped.map('id').min().value(), 0);\n    assert.deepEqual(wrapped\n      .filter(function(o){ return o.id % 2 === 0; })\n      .map(function(o){ return o.id * 2; })\n      .value(),\n      [4, 0]);\n    assert.deepEqual(col.difference([c, d]), [a, b]);\n    assert.ok(col.includes(col.sample()));\n\n    var first = col.first();\n    assert.deepEqual(col.groupBy(function(model){ return model.id; })[first.id], [first]);\n    assert.deepEqual(col.countBy(function(model){ return model.id; }), {0: 1, 1: 1, 2: 1, 3: 1});\n    assert.deepEqual(col.sortBy(function(model){ return model.id; })[0], col.at(3));\n    assert.ok(col.indexBy('id')[first.id] === first);\n  });\n\n  QUnit.test('Underscore methods with object-style and property-style iteratee', function(assert) {\n    assert.expect(26);\n    var model = new Backbone.Model({a: 4, b: 1, e: 3});\n    var coll = new Backbone.Collection([\n      {a: 1, b: 1},\n      {a: 2, b: 1, c: 1},\n      {a: 3, b: 1},\n      model\n    ]);\n    assert.equal(coll.find({a: 0}), undefined);\n    assert.deepEqual(coll.find({a: 4}), model);\n    assert.equal(coll.find('d'), undefined);\n    assert.deepEqual(coll.find('e'), model);\n    assert.equal(coll.filter({a: 0}), false);\n    assert.deepEqual(coll.filter({a: 4}), [model]);\n    assert.equal(coll.some({a: 0}), false);\n    assert.equal(coll.some({a: 1}), true);\n    assert.equal(coll.reject({a: 0}).length, 4);\n    assert.deepEqual(coll.reject({a: 4}), _.without(coll.models, model));\n    assert.equal(coll.every({a: 0}), false);\n    assert.equal(coll.every({b: 1}), true);\n    assert.deepEqual(coll.partition({a: 0})[0], []);\n    assert.deepEqual(coll.partition({a: 0})[1], coll.models);\n    assert.deepEqual(coll.partition({a: 4})[0], [model]);\n    assert.deepEqual(coll.partition({a: 4})[1], _.without(coll.models, model));\n    assert.deepEqual(coll.map({a: 2}), [false, true, false, false]);\n    assert.deepEqual(coll.map('a'), [1, 2, 3, 4]);\n    assert.deepEqual(coll.sortBy('a')[3], model);\n    assert.deepEqual(coll.sortBy('e')[0], model);\n    assert.deepEqual(coll.countBy({a: 4}), {'false': 3, 'true': 1});\n    assert.deepEqual(coll.countBy('d'), {'undefined': 4});\n    assert.equal(coll.findIndex({b: 1}), 0);\n    assert.equal(coll.findIndex({b: 9}), -1);\n    assert.equal(coll.findLastIndex({b: 1}), 3);\n    assert.equal(coll.findLastIndex({b: 9}), -1);\n  });\n\n  QUnit.test('reset', function(assert) {\n    assert.expect(16);\n\n    var resetCount = 0;\n    var models = col.models;\n    col.on('reset', function() { resetCount += 1; });\n    col.reset([]);\n    assert.equal(resetCount, 1);\n    assert.equal(col.length, 0);\n    assert.equal(col.last(), null);\n    col.reset(models);\n    assert.equal(resetCount, 2);\n    assert.equal(col.length, 4);\n    assert.equal(col.last(), d);\n    col.reset(_.map(models, function(m){ return m.attributes; }));\n    assert.equal(resetCount, 3);\n    assert.equal(col.length, 4);\n    assert.ok(col.last() !== d);\n    assert.ok(_.isEqual(col.last().attributes, d.attributes));\n    col.reset();\n    assert.equal(col.length, 0);\n    assert.equal(resetCount, 4);\n\n    var f = new Backbone.Model({id: 20, label: 'f'});\n    col.reset([undefined, f]);\n    assert.equal(col.length, 2);\n    assert.equal(resetCount, 5);\n\n    col.reset(new Array(4));\n    assert.equal(col.length, 4);\n    assert.equal(resetCount, 6);\n  });\n\n  QUnit.test('reset with different values', function(assert) {\n    var collection = new Backbone.Collection({id: 1});\n    collection.reset({id: 1, a: 1});\n    assert.equal(collection.get(1).get('a'), 1);\n  });\n\n  QUnit.test('same references in reset', function(assert) {\n    var model = new Backbone.Model({id: 1});\n    var collection = new Backbone.Collection({id: 1});\n    collection.reset(model);\n    assert.equal(collection.get(1), model);\n  });\n\n  QUnit.test('reset passes caller options', function(assert) {\n    assert.expect(3);\n    var Model = Backbone.Model.extend({\n      initialize: function(attrs, options) {\n        this.modelParameter = options.modelParameter;\n      }\n    });\n    var collection = new (Backbone.Collection.extend({model: Model}))();\n    collection.reset([{astring: 'green', anumber: 1}, {astring: 'blue', anumber: 2}], {modelParameter: 'model parameter'});\n    assert.equal(collection.length, 2);\n    collection.each(function(model) {\n      assert.equal(model.modelParameter, 'model parameter');\n    });\n  });\n\n  QUnit.test('reset does not alter options by reference', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection([{id: 1}]);\n    var origOpts = {};\n    collection.on('reset', function(coll, opts){\n      assert.equal(origOpts.previousModels, undefined);\n      assert.equal(opts.previousModels[0].id, 1);\n    });\n    collection.reset([], origOpts);\n  });\n\n  QUnit.test('trigger custom events on models', function(assert) {\n    assert.expect(1);\n    var fired = null;\n    a.on('custom', function() { fired = true; });\n    a.trigger('custom');\n    assert.equal(fired, true);\n  });\n\n  QUnit.test('add does not alter arguments', function(assert) {\n    assert.expect(2);\n    var attrs = {};\n    var models = [attrs];\n    new Backbone.Collection().add(models);\n    assert.equal(models.length, 1);\n    assert.ok(attrs === models[0]);\n  });\n\n  QUnit.test('#714: access `model.collection` in a brand new model.', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection;\n    collection.url = '/test';\n    var Model = Backbone.Model.extend({\n      set: function(attrs) {\n        assert.equal(attrs.prop, 'value');\n        assert.equal(this.collection, collection);\n        return this;\n      }\n    });\n    collection.model = Model;\n    collection.create({prop: 'value'});\n  });\n\n  QUnit.test('#574, remove its own reference to the .models array.', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection([\n      {id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}\n    ]);\n    assert.equal(collection.length, 6);\n    collection.remove(collection.models);\n    assert.equal(collection.length, 0);\n  });\n\n  QUnit.test('#861, adding models to a collection which do not pass validation, with validate:true', function(assert) {\n    assert.expect(2);\n    var Model = Backbone.Model.extend({\n      validate: function(attrs) {\n        if (attrs.id === 3) return \"id can't be 3\";\n      }\n    });\n\n    var Collection = Backbone.Collection.extend({\n      model: Model\n    });\n\n    var collection = new Collection;\n    collection.on('invalid', function() { assert.ok(true); });\n\n    collection.add([{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}], {validate: true});\n    assert.deepEqual(collection.pluck('id'), [1, 2, 4, 5, 6]);\n  });\n\n  QUnit.test('Invalid models are discarded with validate:true.', function(assert) {\n    assert.expect(5);\n    var collection = new Backbone.Collection;\n    collection.on('test', function() { assert.ok(true); });\n    collection.model = Backbone.Model.extend({\n      validate: function(attrs){ if (!attrs.valid) return 'invalid'; }\n    });\n    var model = new collection.model({id: 1, valid: true});\n    collection.add([model, {id: 2}], {validate: true});\n    model.trigger('test');\n    assert.ok(collection.get(model.cid));\n    assert.ok(collection.get(1));\n    assert.ok(!collection.get(2));\n    assert.equal(collection.length, 1);\n  });\n\n  QUnit.test('multiple copies of the same model', function(assert) {\n    assert.expect(3);\n    var collection = new Backbone.Collection();\n    var model = new Backbone.Model();\n    collection.add([model, model]);\n    assert.equal(collection.length, 1);\n    collection.add([{id: 1}, {id: 1}]);\n    assert.equal(collection.length, 2);\n    assert.equal(collection.last().id, 1);\n  });\n\n  QUnit.test('#964 - collection.get return inconsistent', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection();\n    assert.ok(collection.get(null) === undefined);\n    assert.ok(collection.get() === undefined);\n  });\n\n  QUnit.test('#1112 - passing options.model sets collection.model', function(assert) {\n    assert.expect(2);\n    var Model = Backbone.Model.extend({});\n    var collection = new Backbone.Collection([{id: 1}], {model: Model});\n    assert.ok(collection.model === Model);\n    assert.ok(collection.at(0) instanceof Model);\n  });\n\n  QUnit.test('null and undefined are invalid ids.', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model({id: 1});\n    var collection = new Backbone.Collection([model]);\n    model.set({id: null});\n    assert.ok(!collection.get('null'));\n    model.set({id: 1});\n    model.set({id: undefined});\n    assert.ok(!collection.get('undefined'));\n  });\n\n  QUnit.test('falsy comparator', function(assert) {\n    assert.expect(4);\n    var Col = Backbone.Collection.extend({\n      comparator: function(model){ return model.id; }\n    });\n    var collection = new Col();\n    var colFalse = new Col(null, {comparator: false});\n    var colNull = new Col(null, {comparator: null});\n    var colUndefined = new Col(null, {comparator: undefined});\n    assert.ok(collection.comparator);\n    assert.ok(!colFalse.comparator);\n    assert.ok(!colNull.comparator);\n    assert.ok(colUndefined.comparator);\n  });\n\n  QUnit.test('#1355 - `options` is passed to success callbacks', function(assert) {\n    assert.expect(2);\n    var m = new Backbone.Model({x: 1});\n    var collection = new Backbone.Collection();\n    var opts = {\n      opts: true,\n      success: function(coll, resp, options) {\n        assert.ok(options.opts);\n      }\n    };\n    collection.sync = m.sync = function( method, coll, options ){\n      options.success({});\n    };\n    collection.fetch(opts);\n    collection.create(m, opts);\n  });\n\n  QUnit.test(\"#1412 - Trigger 'request' and 'sync' events.\", function(assert) {\n    assert.expect(4);\n    var collection = new Backbone.Collection;\n    collection.url = '/test';\n    Backbone.ajax = function(settings){ settings.success(); };\n\n    collection.on('request', function(obj, xhr, options) {\n      assert.ok(obj === collection, \"collection has correct 'request' event after fetching\");\n    });\n    collection.on('sync', function(obj, response, options) {\n      assert.ok(obj === collection, \"collection has correct 'sync' event after fetching\");\n    });\n    collection.fetch();\n    collection.off();\n\n    collection.on('request', function(obj, xhr, options) {\n      assert.ok(obj === collection.get(1), \"collection has correct 'request' event after one of its models save\");\n    });\n    collection.on('sync', function(obj, response, options) {\n      assert.ok(obj === collection.get(1), \"collection has correct 'sync' event after one of its models save\");\n    });\n    collection.create({id: 1});\n    collection.off();\n  });\n\n  QUnit.test('#3283 - fetch, create calls success with context', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection;\n    collection.url = '/test';\n    Backbone.ajax = function(settings) {\n      settings.success.call(settings.context);\n    };\n    var obj = {};\n    var options = {\n      context: obj,\n      success: function() {\n        assert.equal(this, obj);\n      }\n    };\n\n    collection.fetch(options);\n    collection.create({id: 1}, options);\n  });\n\n  QUnit.test('#1447 - create with wait adds model.', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection;\n    var model = new Backbone.Model;\n    model.sync = function(method, m, options){ options.success(); };\n    collection.on('add', function(){ assert.ok(true); });\n    collection.create(model, {wait: true});\n  });\n\n  QUnit.test('#1448 - add sorts collection after merge.', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([\n      {id: 1, x: 1},\n      {id: 2, x: 2}\n    ]);\n    collection.comparator = function(model){ return model.get('x'); };\n    collection.add({id: 1, x: 3}, {merge: true});\n    assert.deepEqual(collection.pluck('id'), [2, 1]);\n  });\n\n  QUnit.test('#1655 - groupBy can be used with a string argument.', function(assert) {\n    assert.expect(3);\n    var collection = new Backbone.Collection([{x: 1}, {x: 2}]);\n    var grouped = collection.groupBy('x');\n    assert.strictEqual(_.keys(grouped).length, 2);\n    assert.strictEqual(grouped[1][0].get('x'), 1);\n    assert.strictEqual(grouped[2][0].get('x'), 2);\n  });\n\n  QUnit.test('#1655 - sortBy can be used with a string argument.', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{x: 3}, {x: 1}, {x: 2}]);\n    var values = _.map(collection.sortBy('x'), function(model) {\n      return model.get('x');\n    });\n    assert.deepEqual(values, [1, 2, 3]);\n  });\n\n  QUnit.test('#1604 - Removal during iteration.', function(assert) {\n    assert.expect(0);\n    var collection = new Backbone.Collection([{}, {}]);\n    collection.on('add', function() {\n      collection.at(0).destroy();\n    });\n    collection.add({}, {at: 0});\n  });\n\n  QUnit.test('#1638 - `sort` during `add` triggers correctly.', function(assert) {\n    var collection = new Backbone.Collection;\n    collection.comparator = function(model) { return model.get('x'); };\n    var added = [];\n    collection.on('add', function(model) {\n      model.set({x: 3});\n      collection.sort();\n      added.push(model.id);\n    });\n    collection.add([{id: 1, x: 1}, {id: 2, x: 2}]);\n    assert.deepEqual(added, [1, 2]);\n  });\n\n  QUnit.test('fetch parses models by default', function(assert) {\n    assert.expect(1);\n    var model = {};\n    var Collection = Backbone.Collection.extend({\n      url: 'test',\n      model: Backbone.Model.extend({\n        parse: function(resp) {\n          assert.strictEqual(resp, model);\n        }\n      })\n    });\n    new Collection().fetch();\n    this.ajaxSettings.success([model]);\n  });\n\n  QUnit.test(\"`sort` shouldn't always fire on `add`\", function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}, {id: 3}], {\n      comparator: 'id'\n    });\n    collection.sort = function(){ assert.ok(true); };\n    collection.add([]);\n    collection.add({id: 1});\n    collection.add([{id: 2}, {id: 3}]);\n    collection.add({id: 4});\n  });\n\n  QUnit.test('#1407 parse option on constructor parses collection and models', function(assert) {\n    assert.expect(2);\n    var model = {\n      namespace: [{id: 1}, {id: 2}]\n    };\n    var Collection = Backbone.Collection.extend({\n      model: Backbone.Model.extend({\n        parse: function(m) {\n          m.name = 'test';\n          return m;\n        }\n      }),\n      parse: function(m) {\n        return m.namespace;\n      }\n    });\n    var collection = new Collection(model, {parse: true});\n\n    assert.equal(collection.length, 2);\n    assert.equal(collection.at(0).get('name'), 'test');\n  });\n\n  QUnit.test('#1407 parse option on reset parses collection and models', function(assert) {\n    assert.expect(2);\n    var model = {\n      namespace: [{id: 1}, {id: 2}]\n    };\n    var Collection = Backbone.Collection.extend({\n      model: Backbone.Model.extend({\n        parse: function(m) {\n          m.name = 'test';\n          return m;\n        }\n      }),\n      parse: function(m) {\n        return m.namespace;\n      }\n    });\n    var collection = new Collection();\n    collection.reset(model, {parse: true});\n\n    assert.equal(collection.length, 2);\n    assert.equal(collection.at(0).get('name'), 'test');\n  });\n\n\n  QUnit.test('Reset includes previous models in triggered event.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    var collection = new Backbone.Collection([model]);\n    collection.on('reset', function(coll, options) {\n      assert.deepEqual(options.previousModels, [model]);\n    });\n    collection.reset([]);\n  });\n\n  QUnit.test('set', function(assert) {\n    var m1 = new Backbone.Model();\n    var m2 = new Backbone.Model({id: 2});\n    var m3 = new Backbone.Model();\n    var collection = new Backbone.Collection([m1, m2]);\n\n    // Test add/change/remove events\n    collection.on('add', function(model) {\n      assert.strictEqual(model, m3);\n    });\n    collection.on('change', function(model) {\n      assert.strictEqual(model, m2);\n    });\n    collection.on('remove', function(model) {\n      assert.strictEqual(model, m1);\n    });\n\n    // remove: false doesn't remove any models\n    collection.set([], {remove: false});\n    assert.strictEqual(collection.length, 2);\n\n    // add: false doesn't add any models\n    collection.set([m1, m2, m3], {add: false});\n    assert.strictEqual(collection.length, 2);\n\n    // merge: false doesn't change any models\n    collection.set([m1, {id: 2, a: 1}], {merge: false});\n    assert.strictEqual(m2.get('a'), void 0);\n\n    // add: false, remove: false only merges existing models\n    collection.set([m1, {id: 2, a: 0}, m3, {id: 4}], {add: false, remove: false});\n    assert.strictEqual(collection.length, 2);\n    assert.strictEqual(m2.get('a'), 0);\n\n    // default options add/remove/merge as appropriate\n    collection.set([{id: 2, a: 1}, m3]);\n    assert.strictEqual(collection.length, 2);\n    assert.strictEqual(m2.get('a'), 1);\n\n    // Test removing models not passing an argument\n    collection.off('remove').on('remove', function(model) {\n      assert.ok(model === m2 || model === m3);\n    });\n    collection.set([]);\n    assert.strictEqual(collection.length, 0);\n\n    // Test null models on set doesn't clear collection\n    collection.off();\n    collection.set([{id: 1}]);\n    collection.set();\n    assert.strictEqual(collection.length, 1);\n  });\n\n  QUnit.test('set with only cids', function(assert) {\n    assert.expect(3);\n    var m1 = new Backbone.Model;\n    var m2 = new Backbone.Model;\n    var collection = new Backbone.Collection;\n    collection.set([m1, m2]);\n    assert.equal(collection.length, 2);\n    collection.set([m1]);\n    assert.equal(collection.length, 1);\n    collection.set([m1, m1, m1, m2, m2], {remove: false});\n    assert.equal(collection.length, 2);\n  });\n\n  QUnit.test('set with only idAttribute', function(assert) {\n    assert.expect(3);\n    var m1 = {_id: 1};\n    var m2 = {_id: 2};\n    var Col = Backbone.Collection.extend({\n      model: Backbone.Model.extend({\n        idAttribute: '_id'\n      })\n    });\n    var collection = new Col;\n    collection.set([m1, m2]);\n    assert.equal(collection.length, 2);\n    collection.set([m1]);\n    assert.equal(collection.length, 1);\n    collection.set([m1, m1, m1, m2, m2], {remove: false});\n    assert.equal(collection.length, 2);\n  });\n\n  QUnit.test('set + merge with default values defined', function(assert) {\n    var Model = Backbone.Model.extend({\n      defaults: {\n        key: 'value'\n      }\n    });\n    var m = new Model({id: 1});\n    var collection = new Backbone.Collection([m], {model: Model});\n    assert.equal(collection.first().get('key'), 'value');\n\n    collection.set({id: 1, key: 'other'});\n    assert.equal(collection.first().get('key'), 'other');\n\n    collection.set({id: 1, other: 'value'});\n    assert.equal(collection.first().get('key'), 'other');\n    assert.equal(collection.length, 1);\n  });\n\n  QUnit.test('merge without mutation', function(assert) {\n    var Model = Backbone.Model.extend({\n      initialize: function(attrs, options) {\n        if (attrs.child) {\n          this.set('child', new Model(attrs.child, options), options);\n        }\n      }\n    });\n    var Collection = Backbone.Collection.extend({model: Model});\n    var data = [{id: 1, child: {id: 2}}];\n    var collection = new Collection(data);\n    assert.equal(collection.first().id, 1);\n    collection.set(data);\n    assert.equal(collection.first().id, 1);\n    collection.set([{id: 2, child: {id: 2}}].concat(data));\n    assert.deepEqual(collection.pluck('id'), [2, 1]);\n  });\n\n  QUnit.test('`set` and model level `parse`', function(assert) {\n    var Model = Backbone.Model.extend({});\n    var Collection = Backbone.Collection.extend({\n      model: Model,\n      parse: function(res) { return _.map(res.models, 'model'); }\n    });\n    var model = new Model({id: 1});\n    var collection = new Collection(model);\n    collection.set({models: [\n      {model: {id: 1}},\n      {model: {id: 2}}\n    ]}, {parse: true});\n    assert.equal(collection.first(), model);\n  });\n\n  QUnit.test('`set` data is only parsed once', function(assert) {\n    var collection = new Backbone.Collection();\n    collection.model = Backbone.Model.extend({\n      parse: function(data) {\n        assert.equal(data.parsed, void 0);\n        data.parsed = true;\n        return data;\n      }\n    });\n    collection.set({}, {parse: true});\n  });\n\n  QUnit.test('`set` matches input order in the absence of a comparator', function(assert) {\n    var one = new Backbone.Model({id: 1});\n    var two = new Backbone.Model({id: 2});\n    var three = new Backbone.Model({id: 3});\n    var collection = new Backbone.Collection([one, two, three]);\n    collection.set([{id: 3}, {id: 2}, {id: 1}]);\n    assert.deepEqual(collection.models, [three, two, one]);\n    collection.set([{id: 1}, {id: 2}]);\n    assert.deepEqual(collection.models, [one, two]);\n    collection.set([two, three, one]);\n    assert.deepEqual(collection.models, [two, three, one]);\n    collection.set([{id: 1}, {id: 2}], {remove: false});\n    assert.deepEqual(collection.models, [two, three, one]);\n    collection.set([{id: 1}, {id: 2}, {id: 3}], {merge: false});\n    assert.deepEqual(collection.models, [one, two, three]);\n    collection.set([three, two, one, {id: 4}], {add: false});\n    assert.deepEqual(collection.models, [one, two, three]);\n  });\n\n  QUnit.test('#1894 - Push should not trigger a sort', function(assert) {\n    assert.expect(0);\n    var Collection = Backbone.Collection.extend({\n      comparator: 'id',\n      sort: function() { assert.ok(false); }\n    });\n    new Collection().push({id: 1});\n  });\n\n  QUnit.test('#2428 - push duplicate models, return the correct one', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection;\n    var model1 = collection.push({id: 101});\n    var model2 = collection.push({id: 101});\n    assert.ok(model2.cid === model1.cid);\n  });\n\n  QUnit.test('`set` with non-normal id', function(assert) {\n    var Collection = Backbone.Collection.extend({\n      model: Backbone.Model.extend({idAttribute: '_id'})\n    });\n    var collection = new Collection({_id: 1});\n    collection.set([{_id: 1, a: 1}], {add: false});\n    assert.equal(collection.first().get('a'), 1);\n  });\n\n  QUnit.test('#1894 - `sort` can optionally be turned off', function(assert) {\n    assert.expect(0);\n    var Collection = Backbone.Collection.extend({\n      comparator: 'id',\n      sort: function() { assert.ok(false); }\n    });\n    new Collection().add({id: 1}, {sort: false});\n  });\n\n  QUnit.test('#1915 - `parse` data in the right order in `set`', function(assert) {\n    var collection = new (Backbone.Collection.extend({\n      parse: function(data) {\n        assert.strictEqual(data.status, 'ok');\n        return data.data;\n      }\n    }));\n    var res = {status: 'ok', data: [{id: 1}]};\n    collection.set(res, {parse: true});\n  });\n\n  QUnit.test('#1939 - `parse` is passed `options`', function(assert) {\n    var done = assert.async();\n    assert.expect(1);\n    var collection = new (Backbone.Collection.extend({\n      url: '/',\n      parse: function(data, options) {\n        assert.strictEqual(options.xhr.someHeader, 'headerValue');\n        return data;\n      }\n    }));\n    var ajax = Backbone.ajax;\n    Backbone.ajax = function(params) {\n      _.defer(params.success, []);\n      return {someHeader: 'headerValue'};\n    };\n    collection.fetch({\n      success: function() { done(); }\n    });\n    Backbone.ajax = ajax;\n  });\n\n  QUnit.test('fetch will pass extra options to success callback', function(assert) {\n    assert.expect(1);\n    var SpecialSyncCollection = Backbone.Collection.extend({\n      url: '/test',\n      sync: function(method, collection, options) {\n        _.extend(options, {specialSync: true});\n        return Backbone.Collection.prototype.sync.call(this, method, collection, options);\n      }\n    });\n\n    var collection = new SpecialSyncCollection();\n\n    var onSuccess = function(coll, resp, options) {\n      assert.ok(options.specialSync, 'Options were passed correctly to callback');\n    };\n\n    collection.fetch({success: onSuccess});\n    this.ajaxSettings.success();\n  });\n\n  QUnit.test('`add` only `sort`s when necessary', function(assert) {\n    assert.expect(2);\n    var collection = new (Backbone.Collection.extend({\n      comparator: 'a'\n    }))([{id: 1}, {id: 2}, {id: 3}]);\n    collection.on('sort', function() { assert.ok(true); });\n    collection.add({id: 4}); // do sort, new model\n    collection.add({id: 1, a: 1}, {merge: true}); // do sort, comparator change\n    collection.add({id: 1, b: 1}, {merge: true}); // don't sort, no comparator change\n    collection.add({id: 1, a: 1}, {merge: true}); // don't sort, no comparator change\n    collection.add(collection.models); // don't sort, nothing new\n    collection.add(collection.models, {merge: true}); // don't sort\n  });\n\n  QUnit.test('`add` only `sort`s when necessary with comparator function', function(assert) {\n    assert.expect(3);\n    var collection = new (Backbone.Collection.extend({\n      comparator: function(m1, m2) {\n        return m1.get('a') > m2.get('a') ? 1 : (m1.get('a') < m2.get('a') ? -1 : 0);\n      }\n    }))([{id: 1}, {id: 2}, {id: 3}]);\n    collection.on('sort', function() { assert.ok(true); });\n    collection.add({id: 4}); // do sort, new model\n    collection.add({id: 1, a: 1}, {merge: true}); // do sort, model change\n    collection.add({id: 1, b: 1}, {merge: true}); // do sort, model change\n    collection.add({id: 1, a: 1}, {merge: true}); // don't sort, no model change\n    collection.add(collection.models); // don't sort, nothing new\n    collection.add(collection.models, {merge: true}); // don't sort\n  });\n\n  QUnit.test('Attach options to collection.', function(assert) {\n    assert.expect(2);\n    var Model = Backbone.Model;\n    var comparator = function(){};\n\n    var collection = new Backbone.Collection([], {\n      model: Model,\n      comparator: comparator\n    });\n\n    assert.ok(collection.model === Model);\n    assert.ok(collection.comparator === comparator);\n  });\n\n  QUnit.test('Pass falsey for `models` for empty Col with `options`', function(assert) {\n    assert.expect(9);\n    var opts = {a: 1, b: 2};\n    _.forEach([undefined, null, false], function(falsey) {\n      var Collection = Backbone.Collection.extend({\n        initialize: function(models, options) {\n          assert.strictEqual(models, falsey);\n          assert.strictEqual(options, opts);\n        }\n      });\n\n      var collection = new Collection(falsey, opts);\n      assert.strictEqual(collection.length, 0);\n    });\n  });\n\n  QUnit.test('`add` overrides `set` flags', function(assert) {\n    var collection = new Backbone.Collection();\n    collection.once('add', function(model, coll, options) {\n      coll.add({id: 2}, options);\n    });\n    collection.set({id: 1});\n    assert.equal(collection.length, 2);\n  });\n\n  QUnit.test('#2606 - Collection#create, success arguments', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection;\n    collection.url = 'test';\n    collection.create({}, {\n      success: function(model, resp, options) {\n        assert.strictEqual(resp, 'response');\n      }\n    });\n    this.ajaxSettings.success('response');\n  });\n\n  QUnit.test('#2612 - nested `parse` works with `Collection#set`', function(assert) {\n\n    var Job = Backbone.Model.extend({\n      constructor: function() {\n        this.items = new Items();\n        Backbone.Model.apply(this, arguments);\n      },\n      parse: function(attrs) {\n        this.items.set(attrs.items, {parse: true});\n        return _.omit(attrs, 'items');\n      }\n    });\n\n    var Item = Backbone.Model.extend({\n      constructor: function() {\n        this.subItems = new Backbone.Collection();\n        Backbone.Model.apply(this, arguments);\n      },\n      parse: function(attrs) {\n        this.subItems.set(attrs.subItems, {parse: true});\n        return _.omit(attrs, 'subItems');\n      }\n    });\n\n    var Items = Backbone.Collection.extend({\n      model: Item\n    });\n\n    var data = {\n      name: 'JobName',\n      id: 1,\n      items: [{\n        id: 1,\n        name: 'Sub1',\n        subItems: [\n          {id: 1, subName: 'One'},\n          {id: 2, subName: 'Two'}\n        ]\n      }, {\n        id: 2,\n        name: 'Sub2',\n        subItems: [\n          {id: 3, subName: 'Three'},\n          {id: 4, subName: 'Four'}\n        ]\n      }]\n    };\n\n    var newData = {\n      name: 'NewJobName',\n      id: 1,\n      items: [{\n        id: 1,\n        name: 'NewSub1',\n        subItems: [\n          {id: 1, subName: 'NewOne'},\n          {id: 2, subName: 'NewTwo'}\n        ]\n      }, {\n        id: 2,\n        name: 'NewSub2',\n        subItems: [\n          {id: 3, subName: 'NewThree'},\n          {id: 4, subName: 'NewFour'}\n        ]\n      }]\n    };\n\n    var job = new Job(data, {parse: true});\n    assert.equal(job.get('name'), 'JobName');\n    assert.equal(job.items.at(0).get('name'), 'Sub1');\n    assert.equal(job.items.length, 2);\n    assert.equal(job.items.get(1).subItems.get(1).get('subName'), 'One');\n    assert.equal(job.items.get(2).subItems.get(3).get('subName'), 'Three');\n    job.set(job.parse(newData, {parse: true}));\n    assert.equal(job.get('name'), 'NewJobName');\n    assert.equal(job.items.at(0).get('name'), 'NewSub1');\n    assert.equal(job.items.length, 2);\n    assert.equal(job.items.get(1).subItems.get(1).get('subName'), 'NewOne');\n    assert.equal(job.items.get(2).subItems.get(3).get('subName'), 'NewThree');\n  });\n\n  QUnit.test('_addReference binds all collection events & adds to the lookup hashes', function(assert) {\n    assert.expect(8);\n\n    var calls = {add: 0, remove: 0};\n\n    var Collection = Backbone.Collection.extend({\n\n      _addReference: function(model) {\n        Backbone.Collection.prototype._addReference.apply(this, arguments);\n        calls.add++;\n        assert.equal(model, this._byId[model.id]);\n        assert.equal(model, this._byId[model.cid]);\n        assert.equal(model._events.all.length, 1);\n      },\n\n      _removeReference: function(model) {\n        Backbone.Collection.prototype._removeReference.apply(this, arguments);\n        calls.remove++;\n        assert.equal(this._byId[model.id], void 0);\n        assert.equal(this._byId[model.cid], void 0);\n        assert.equal(model.collection, void 0);\n      }\n\n    });\n\n    var collection = new Collection();\n    var model = collection.add({id: 1});\n    collection.remove(model);\n\n    assert.equal(calls.add, 1);\n    assert.equal(calls.remove, 1);\n  });\n\n  QUnit.test('Do not allow duplicate models to be `add`ed or `set`', function(assert) {\n    var collection = new Backbone.Collection();\n\n    collection.add([{id: 1}, {id: 1}]);\n    assert.equal(collection.length, 1);\n    assert.equal(collection.models.length, 1);\n\n    collection.set([{id: 1}, {id: 1}]);\n    assert.equal(collection.length, 1);\n    assert.equal(collection.models.length, 1);\n  });\n\n  QUnit.test('#3020: #set with {add: false} should not throw.', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection;\n    collection.set([{id: 1}], {add: false});\n    assert.strictEqual(collection.length, 0);\n    assert.strictEqual(collection.models.length, 0);\n  });\n\n  QUnit.test('create with wait, model instance, #3028', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection();\n    var model = new Backbone.Model({id: 1});\n    model.sync = function(){\n      assert.equal(this.collection, collection);\n    };\n    collection.create(model, {wait: true});\n  });\n\n  QUnit.test('modelId', function(assert) {\n    var Stooge = Backbone.Model.extend();\n    var StoogeCollection = Backbone.Collection.extend({model: Stooge});\n\n    // Default to using `Collection::model::idAttribute`.\n    assert.equal(StoogeCollection.prototype.modelId({id: 1}), 1);\n    Stooge.prototype.idAttribute = '_id';\n    assert.equal(StoogeCollection.prototype.modelId({_id: 1}), 1);\n  });\n\n  QUnit.test('Polymorphic models work with \"simple\" constructors', function(assert) {\n    var A = Backbone.Model.extend();\n    var B = Backbone.Model.extend();\n    var C = Backbone.Collection.extend({\n      model: function(attrs) {\n        return attrs.type === 'a' ? new A(attrs) : new B(attrs);\n      }\n    });\n    var collection = new C([{id: 1, type: 'a'}, {id: 2, type: 'b'}]);\n    assert.equal(collection.length, 2);\n    assert.ok(collection.at(0) instanceof A);\n    assert.equal(collection.at(0).id, 1);\n    assert.ok(collection.at(1) instanceof B);\n    assert.equal(collection.at(1).id, 2);\n  });\n\n  QUnit.test('Polymorphic models work with \"advanced\" constructors', function(assert) {\n    var A = Backbone.Model.extend({idAttribute: '_id'});\n    var B = Backbone.Model.extend({idAttribute: '_id'});\n    var C = Backbone.Collection.extend({\n      model: Backbone.Model.extend({\n        constructor: function(attrs) {\n          return attrs.type === 'a' ? new A(attrs) : new B(attrs);\n        },\n\n        idAttribute: '_id'\n      })\n    });\n    var collection = new C([{_id: 1, type: 'a'}, {_id: 2, type: 'b'}]);\n    assert.equal(collection.length, 2);\n    assert.ok(collection.at(0) instanceof A);\n    assert.equal(collection.at(0), collection.get(1));\n    assert.ok(collection.at(1) instanceof B);\n    assert.equal(collection.at(1), collection.get(2));\n\n    C = Backbone.Collection.extend({\n      model: function(attrs) {\n        return attrs.type === 'a' ? new A(attrs) : new B(attrs);\n      },\n\n      modelId: function(attrs) {\n        return attrs.type + '-' + attrs.id;\n      }\n    });\n    collection = new C([{id: 1, type: 'a'}, {id: 1, type: 'b'}]);\n    assert.equal(collection.length, 2);\n    assert.ok(collection.at(0) instanceof A);\n    assert.equal(collection.at(0), collection.get('a-1'));\n    assert.ok(collection.at(1) instanceof B);\n    assert.equal(collection.at(1), collection.get('b-1'));\n  });\n\n  QUnit.test('Collection with polymorphic models receives default id from modelId', function(assert) {\n    assert.expect(6);\n    // When the polymorphic models use 'id' for the idAttribute, all is fine.\n    var C1 = Backbone.Collection.extend({\n      model: function(attrs) {\n        return new Backbone.Model(attrs);\n      }\n    });\n    var c1 = new C1({id: 1});\n    assert.equal(c1.get(1).id, 1);\n    assert.equal(c1.modelId({id: 1}), 1);\n\n    // If the polymorphic models define their own idAttribute,\n    // the modelId method should be overridden, for the reason below.\n    var M = Backbone.Model.extend({\n      idAttribute: '_id'\n    });\n    var C2 = Backbone.Collection.extend({\n      model: function(attrs) {\n        return new M(attrs);\n      }\n    });\n    var c2 = new C2({_id: 1});\n    assert.equal(c2.get(1), void 0);\n    assert.equal(c2.modelId(c2.at(0).attributes), void 0);\n    var m = new M({_id: 2});\n    c2.add(m);\n    assert.equal(c2.get(2), void 0);\n    assert.equal(c2.modelId(m.attributes), void 0);\n  });\n\n  QUnit.test('#3039 #3951: adding at index fires with correct at', function(assert) {\n    assert.expect(4);\n    var collection = new Backbone.Collection([{val: 0}, {val: 4}]);\n    collection.on('add', function(model, coll, options) {\n      assert.equal(model.get('val'), options.index);\n    });\n    collection.add([{val: 1}, {val: 2}, {val: 3}], {at: 1});\n    collection.add({val: 5}, {at: 10});\n  });\n\n  QUnit.test('#3039: index is not sent when at is not specified', function(assert) {\n    assert.expect(2);\n    var collection = new Backbone.Collection([{at: 0}]);\n    collection.on('add', function(model, coll, options) {\n      assert.equal(undefined, options.index);\n    });\n    collection.add([{at: 1}, {at: 2}]);\n  });\n\n  QUnit.test('#3199 - Order changing should trigger a sort', function(assert) {\n    assert.expect(1);\n    var one = new Backbone.Model({id: 1});\n    var two = new Backbone.Model({id: 2});\n    var three = new Backbone.Model({id: 3});\n    var collection = new Backbone.Collection([one, two, three]);\n    collection.on('sort', function() {\n      assert.ok(true);\n    });\n    collection.set([{id: 3}, {id: 2}, {id: 1}]);\n  });\n\n  QUnit.test('#3199 - Adding a model should trigger a sort', function(assert) {\n    assert.expect(1);\n    var one = new Backbone.Model({id: 1});\n    var two = new Backbone.Model({id: 2});\n    var three = new Backbone.Model({id: 3});\n    var collection = new Backbone.Collection([one, two, three]);\n    collection.on('sort', function() {\n      assert.ok(true);\n    });\n    collection.set([{id: 1}, {id: 2}, {id: 3}, {id: 0}]);\n  });\n\n  QUnit.test('#3199 - Order not changing should not trigger a sort', function(assert) {\n    assert.expect(0);\n    var one = new Backbone.Model({id: 1});\n    var two = new Backbone.Model({id: 2});\n    var three = new Backbone.Model({id: 3});\n    var collection = new Backbone.Collection([one, two, three]);\n    collection.on('sort', function() {\n      assert.ok(false);\n    });\n    collection.set([{id: 1}, {id: 2}, {id: 3}]);\n  });\n\n  QUnit.test('add supports negative indexes', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 1}]);\n    collection.add([{id: 2}, {id: 3}], {at: -1});\n    collection.add([{id: 2.5}], {at: -2});\n    collection.add([{id: 0.5}], {at: -6});\n    assert.equal(collection.pluck('id').join(','), '0.5,1,2,2.5,3');\n  });\n\n  QUnit.test('#set accepts options.at as a string', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}]);\n    collection.add([{id: 3}], {at: '1'});\n    assert.deepEqual(collection.pluck('id'), [1, 3, 2]);\n  });\n\n  QUnit.test('adding multiple models triggers `update` event once', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection;\n    collection.on('update', function() { assert.ok(true); });\n    collection.add([{id: 1}, {id: 2}, {id: 3}]);\n  });\n\n  QUnit.test('removing models triggers `update` event once', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}, {id: 3}]);\n    collection.on('update', function() { assert.ok(true); });\n    collection.remove([{id: 1}, {id: 2}]);\n  });\n\n  QUnit.test('remove does not trigger `update` when nothing removed', function(assert) {\n    assert.expect(0);\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}]);\n    collection.on('update', function() { assert.ok(false); });\n    collection.remove([{id: 3}]);\n  });\n\n  QUnit.test('set triggers `set` event once', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}]);\n    collection.on('update', function() { assert.ok(true); });\n    collection.set([{id: 1}, {id: 3}]);\n  });\n\n  QUnit.test('set does not trigger `update` event when nothing added nor removed', function(assert) {\n    var collection = new Backbone.Collection([{id: 1}, {id: 2}]);\n    collection.on('update', function(coll, options) {\n      assert.equal(options.changes.added.length, 0);\n      assert.equal(options.changes.removed.length, 0);\n      assert.equal(options.changes.merged.length, 2);\n    });\n    collection.set([{id: 1}, {id: 2}]);\n  });\n\n  QUnit.test('#3610 - invoke collects arguments', function(assert) {\n    assert.expect(3);\n    var Model = Backbone.Model.extend({\n      method: function(x, y, z) {\n        assert.equal(x, 1);\n        assert.equal(y, 2);\n        assert.equal(z, 3);\n      }\n    });\n    var Collection = Backbone.Collection.extend({\n      model: Model\n    });\n    var collection = new Collection([{id: 1}]);\n    collection.invoke('method', 1, 2, 3);\n  });\n\n  QUnit.test('#3662 - triggering change without model will not error', function(assert) {\n    assert.expect(1);\n    var collection = new Backbone.Collection([{id: 1}]);\n    var model = collection.first();\n    collection.on('change', function(m) {\n      assert.equal(m, undefined);\n    });\n    model.trigger('change');\n  });\n\n  QUnit.test('#3871 - falsy parse result creates empty collection', function(assert) {\n    var collection = new (Backbone.Collection.extend({\n      parse: function(data, options) {}\n    }));\n    collection.set('', {parse: true});\n    assert.equal(collection.length, 0);\n  });\n\n  QUnit.test(\"#3711 - remove's `update` event returns one removed model\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var collection = new Backbone.Collection([model]);\n    collection.on('update', function(context, options) {\n      var changed = options.changes;\n      assert.deepEqual(changed.added, []);\n      assert.deepEqual(changed.merged, []);\n      assert.strictEqual(changed.removed[0], model);\n    });\n    collection.remove(model);\n  });\n\n  QUnit.test(\"#3711 - remove's `update` event returns multiple removed models\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var model2 = new Backbone.Model({id: 2, title: 'Second Post'});\n    var collection = new Backbone.Collection([model, model2]);\n    collection.on('update', function(context, options) {\n      var changed = options.changes;\n      assert.deepEqual(changed.added, []);\n      assert.deepEqual(changed.merged, []);\n      assert.ok(changed.removed.length === 2);\n\n      assert.ok(_.indexOf(changed.removed, model) > -1 && _.indexOf(changed.removed, model2) > -1);\n    });\n    collection.remove([model, model2]);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event returns one added model\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var collection = new Backbone.Collection();\n    collection.on('update', function(context, options) {\n      var addedModels = options.changes.added;\n      assert.ok(addedModels.length === 1);\n      assert.strictEqual(addedModels[0], model);\n    });\n    collection.set(model);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event returns multiple added models\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var model2 = new Backbone.Model({id: 2, title: 'Second Post'});\n    var collection = new Backbone.Collection();\n    collection.on('update', function(context, options) {\n      var addedModels = options.changes.added;\n      assert.ok(addedModels.length === 2);\n      assert.strictEqual(addedModels[0], model);\n      assert.strictEqual(addedModels[1], model2);\n    });\n    collection.set([model, model2]);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event returns one removed model\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var model2 = new Backbone.Model({id: 2, title: 'Second Post'});\n    var model3 = new Backbone.Model({id: 3, title: 'My Last Post'});\n    var collection = new Backbone.Collection([model]);\n    collection.on('update', function(context, options) {\n      var changed = options.changes;\n      assert.equal(changed.added.length, 2);\n      assert.equal(changed.merged.length, 0);\n      assert.ok(changed.removed.length === 1);\n      assert.strictEqual(changed.removed[0], model);\n    });\n    collection.set([model2, model3]);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event returns multiple removed models\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var model2 = new Backbone.Model({id: 2, title: 'Second Post'});\n    var model3 = new Backbone.Model({id: 3, title: 'My Last Post'});\n    var collection = new Backbone.Collection([model, model2]);\n    collection.on('update', function(context, options) {\n      var removedModels = options.changes.removed;\n      assert.ok(removedModels.length === 2);\n      assert.strictEqual(removedModels[0], model);\n      assert.strictEqual(removedModels[1], model2);\n    });\n    collection.set([model3]);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event returns one merged model\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var model2 = new Backbone.Model({id: 2, title: 'Second Post'});\n    var model2Update = new Backbone.Model({id: 2, title: 'Second Post V2'});\n    var collection = new Backbone.Collection([model, model2]);\n    collection.on('update', function(context, options) {\n      var mergedModels = options.changes.merged;\n      assert.ok(mergedModels.length === 1);\n      assert.strictEqual(mergedModels[0].get('title'), model2Update.get('title'));\n    });\n    collection.set([model2Update]);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event returns multiple merged models\", function(assert) {\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var modelUpdate = new Backbone.Model({id: 1, title: 'First Post V2'});\n    var model2 = new Backbone.Model({id: 2, title: 'Second Post'});\n    var model2Update = new Backbone.Model({id: 2, title: 'Second Post V2'});\n    var collection = new Backbone.Collection([model, model2]);\n    collection.on('update', function(context, options) {\n      var mergedModels = options.changes.merged;\n      assert.ok(mergedModels.length === 2);\n      assert.strictEqual(mergedModels[0].get('title'), model2Update.get('title'));\n      assert.strictEqual(mergedModels[1].get('title'), modelUpdate.get('title'));\n    });\n    collection.set([model2Update, modelUpdate]);\n  });\n\n  QUnit.test(\"#3711 - set's `update` event should not be triggered adding a model which already exists exactly alike\", function(assert) {\n    var fired = false;\n    var model = new Backbone.Model({id: 1, title: 'First Post'});\n    var collection = new Backbone.Collection([model]);\n    collection.on('update', function(context, options) {\n      fired = true;\n    });\n    collection.set([model]);\n    assert.equal(fired, false);\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 69555,
                    tokens: 9121,
                    lastModified: '2025-07-02T12:28:22.857Z',
                  },
                  {
                    name: 'events.js',
                    path: 'vendor/backbone/test/events.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  QUnit.module('Backbone.Events');\n\n  QUnit.test('on and trigger', function(assert) {\n    assert.expect(2);\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n    obj.on('event', function() { obj.counter += 1; });\n    obj.trigger('event');\n    assert.equal(obj.counter, 1, 'counter should be incremented.');\n    obj.trigger('event');\n    obj.trigger('event');\n    obj.trigger('event');\n    obj.trigger('event');\n    assert.equal(obj.counter, 5, 'counter should be incremented five times.');\n  });\n\n  QUnit.test('binding and triggering multiple events', function(assert) {\n    assert.expect(4);\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n\n    obj.on('a b c', function() { obj.counter += 1; });\n\n    obj.trigger('a');\n    assert.equal(obj.counter, 1);\n\n    obj.trigger('a b');\n    assert.equal(obj.counter, 3);\n\n    obj.trigger('c');\n    assert.equal(obj.counter, 4);\n\n    obj.off('a c');\n    obj.trigger('a b c');\n    assert.equal(obj.counter, 5);\n  });\n\n  QUnit.test('binding and triggering with event maps', function(assert) {\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n\n    var increment = function() {\n      this.counter += 1;\n    };\n\n    obj.on({\n      a: increment,\n      b: increment,\n      c: increment\n    }, obj);\n\n    obj.trigger('a');\n    assert.equal(obj.counter, 1);\n\n    obj.trigger('a b');\n    assert.equal(obj.counter, 3);\n\n    obj.trigger('c');\n    assert.equal(obj.counter, 4);\n\n    obj.off({\n      a: increment,\n      c: increment\n    }, obj);\n    obj.trigger('a b c');\n    assert.equal(obj.counter, 5);\n  });\n\n  QUnit.test('binding and triggering multiple event names with event maps', function(assert) {\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n\n    var increment = function() {\n      this.counter += 1;\n    };\n\n    obj.on({\n      'a b c': increment\n    });\n\n    obj.trigger('a');\n    assert.equal(obj.counter, 1);\n\n    obj.trigger('a b');\n    assert.equal(obj.counter, 3);\n\n    obj.trigger('c');\n    assert.equal(obj.counter, 4);\n\n    obj.off({\n      'a c': increment\n    });\n    obj.trigger('a b c');\n    assert.equal(obj.counter, 5);\n  });\n\n  QUnit.test('binding and trigger with event maps context', function(assert) {\n    assert.expect(2);\n    var obj = {counter: 0};\n    var context = {};\n    _.extend(obj, Backbone.Events);\n\n    obj.on({\n      a: function() {\n        assert.strictEqual(this, context, 'defaults `context` to `callback` param');\n      }\n    }, context).trigger('a');\n\n    obj.off().on({\n      a: function() {\n        assert.strictEqual(this, context, 'will not override explicit `context` param');\n      }\n    }, this, context).trigger('a');\n  });\n\n  QUnit.test('listenTo and stopListening', function(assert) {\n    assert.expect(1);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenTo(b, 'all', function(){ assert.ok(true); });\n    b.trigger('anything');\n    a.listenTo(b, 'all', function(){ assert.ok(false); });\n    a.stopListening();\n    b.trigger('anything');\n  });\n\n  QUnit.test('listenTo and stopListening with event maps', function(assert) {\n    assert.expect(4);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    var cb = function(){ assert.ok(true); };\n    a.listenTo(b, {event: cb});\n    b.trigger('event');\n    a.listenTo(b, {event2: cb});\n    b.on('event2', cb);\n    a.stopListening(b, {event2: cb});\n    b.trigger('event event2');\n    a.stopListening();\n    b.trigger('event event2');\n  });\n\n  QUnit.test('stopListening with omitted args', function(assert) {\n    assert.expect(2);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    var cb = function() { assert.ok(true); };\n    a.listenTo(b, 'event', cb);\n    b.on('event', cb);\n    a.listenTo(b, 'event2', cb);\n    a.stopListening(null, {event: cb});\n    b.trigger('event event2');\n    b.off();\n    a.listenTo(b, 'event event2', cb);\n    a.stopListening(null, 'event');\n    a.stopListening();\n    b.trigger('event2');\n  });\n\n  QUnit.test('listenToOnce', function(assert) {\n    assert.expect(2);\n    // Same as the previous test, but we use once rather than having to explicitly unbind\n    var obj = {counterA: 0, counterB: 0};\n    _.extend(obj, Backbone.Events);\n    var incrA = function(){ obj.counterA += 1; obj.trigger('event'); };\n    var incrB = function(){ obj.counterB += 1; };\n    obj.listenToOnce(obj, 'event', incrA);\n    obj.listenToOnce(obj, 'event', incrB);\n    obj.trigger('event');\n    assert.equal(obj.counterA, 1, 'counterA should have only been incremented once.');\n    assert.equal(obj.counterB, 1, 'counterB should have only been incremented once.');\n  });\n\n  QUnit.test('listenToOnce and stopListening', function(assert) {\n    assert.expect(1);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenToOnce(b, 'all', function() { assert.ok(true); });\n    b.trigger('anything');\n    b.trigger('anything');\n    a.listenToOnce(b, 'all', function() { assert.ok(false); });\n    a.stopListening();\n    b.trigger('anything');\n  });\n\n  QUnit.test('listenTo, listenToOnce and stopListening', function(assert) {\n    assert.expect(1);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenToOnce(b, 'all', function() { assert.ok(true); });\n    b.trigger('anything');\n    b.trigger('anything');\n    a.listenTo(b, 'all', function() { assert.ok(false); });\n    a.stopListening();\n    b.trigger('anything');\n  });\n\n  QUnit.test('listenTo and stopListening with event maps', function(assert) {\n    assert.expect(1);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenTo(b, {change: function(){ assert.ok(true); }});\n    b.trigger('change');\n    a.listenTo(b, {change: function(){ assert.ok(false); }});\n    a.stopListening();\n    b.trigger('change');\n  });\n\n  QUnit.test('listenTo yourself', function(assert) {\n    assert.expect(1);\n    var e = _.extend({}, Backbone.Events);\n    e.listenTo(e, 'foo', function(){ assert.ok(true); });\n    e.trigger('foo');\n  });\n\n  QUnit.test('listenTo yourself cleans yourself up with stopListening', function(assert) {\n    assert.expect(1);\n    var e = _.extend({}, Backbone.Events);\n    e.listenTo(e, 'foo', function(){ assert.ok(true); });\n    e.trigger('foo');\n    e.stopListening();\n    e.trigger('foo');\n  });\n\n  QUnit.test('stopListening cleans up references', function(assert) {\n    assert.expect(12);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    var fn = function() {};\n    b.on('event', fn);\n    a.listenTo(b, 'event', fn).stopListening();\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenTo(b, 'event', fn).stopListening(b);\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenTo(b, 'event', fn).stopListening(b, 'event');\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenTo(b, 'event', fn).stopListening(b, 'event', fn);\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n  });\n\n  QUnit.test('stopListening cleans up references from listenToOnce', function(assert) {\n    assert.expect(12);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    var fn = function() {};\n    b.on('event', fn);\n    a.listenToOnce(b, 'event', fn).stopListening();\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenToOnce(b, 'event', fn).stopListening(b);\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenToOnce(b, 'event', fn).stopListening(b, 'event');\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenToOnce(b, 'event', fn).stopListening(b, 'event', fn);\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._events.event), 1);\n    assert.equal(_.size(b._listeners), 0);\n  });\n\n  QUnit.test('listenTo and off cleaning up references', function(assert) {\n    assert.expect(8);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    var fn = function() {};\n    a.listenTo(b, 'event', fn);\n    b.off();\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenTo(b, 'event', fn);\n    b.off('event');\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenTo(b, 'event', fn);\n    b.off(null, fn);\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._listeners), 0);\n    a.listenTo(b, 'event', fn);\n    b.off(null, null, a);\n    assert.equal(_.size(a._listeningTo), 0);\n    assert.equal(_.size(b._listeners), 0);\n  });\n\n  QUnit.test('listenTo and stopListening cleaning up references', function(assert) {\n    assert.expect(2);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenTo(b, 'all', function(){ assert.ok(true); });\n    b.trigger('anything');\n    a.listenTo(b, 'other', function(){ assert.ok(false); });\n    a.stopListening(b, 'other');\n    a.stopListening(b, 'all');\n    assert.equal(_.size(a._listeningTo), 0);\n  });\n\n  QUnit.test('listenToOnce without context cleans up references after the event has fired', function(assert) {\n    assert.expect(2);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenToOnce(b, 'all', function(){ assert.ok(true); });\n    b.trigger('anything');\n    assert.equal(_.size(a._listeningTo), 0);\n  });\n\n  QUnit.test('listenToOnce with event maps cleans up references', function(assert) {\n    assert.expect(2);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenToOnce(b, {\n      one: function() { assert.ok(true); },\n      two: function() { assert.ok(false); }\n    });\n    b.trigger('one');\n    assert.equal(_.size(a._listeningTo), 1);\n  });\n\n  QUnit.test('listenToOnce with event maps binds the correct `this`', function(assert) {\n    assert.expect(1);\n    var a = _.extend({}, Backbone.Events);\n    var b = _.extend({}, Backbone.Events);\n    a.listenToOnce(b, {\n      one: function() { assert.ok(this === a); },\n      two: function() { assert.ok(false); }\n    });\n    b.trigger('one');\n  });\n\n  QUnit.test(\"listenTo with empty callback doesn't throw an error\", function(assert) {\n    assert.expect(1);\n    var e = _.extend({}, Backbone.Events);\n    e.listenTo(e, 'foo', null);\n    e.trigger('foo');\n    assert.ok(true);\n  });\n\n  QUnit.test('trigger all for each event', function(assert) {\n    assert.expect(3);\n    var a, b, obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n    obj.on('all', function(event) {\n      obj.counter++;\n      if (event === 'a') a = true;\n      if (event === 'b') b = true;\n    })\n    .trigger('a b');\n    assert.ok(a);\n    assert.ok(b);\n    assert.equal(obj.counter, 2);\n  });\n\n  QUnit.test('on, then unbind all functions', function(assert) {\n    assert.expect(1);\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n    var callback = function() { obj.counter += 1; };\n    obj.on('event', callback);\n    obj.trigger('event');\n    obj.off('event');\n    obj.trigger('event');\n    assert.equal(obj.counter, 1, 'counter should have only been incremented once.');\n  });\n\n  QUnit.test('bind two callbacks, unbind only one', function(assert) {\n    assert.expect(2);\n    var obj = {counterA: 0, counterB: 0};\n    _.extend(obj, Backbone.Events);\n    var callback = function() { obj.counterA += 1; };\n    obj.on('event', callback);\n    obj.on('event', function() { obj.counterB += 1; });\n    obj.trigger('event');\n    obj.off('event', callback);\n    obj.trigger('event');\n    assert.equal(obj.counterA, 1, 'counterA should have only been incremented once.');\n    assert.equal(obj.counterB, 2, 'counterB should have been incremented twice.');\n  });\n\n  QUnit.test('unbind a callback in the midst of it firing', function(assert) {\n    assert.expect(1);\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n    var callback = function() {\n      obj.counter += 1;\n      obj.off('event', callback);\n    };\n    obj.on('event', callback);\n    obj.trigger('event');\n    obj.trigger('event');\n    obj.trigger('event');\n    assert.equal(obj.counter, 1, 'the callback should have been unbound.');\n  });\n\n  QUnit.test('two binds that unbind themeselves', function(assert) {\n    assert.expect(2);\n    var obj = {counterA: 0, counterB: 0};\n    _.extend(obj, Backbone.Events);\n    var incrA = function(){ obj.counterA += 1; obj.off('event', incrA); };\n    var incrB = function(){ obj.counterB += 1; obj.off('event', incrB); };\n    obj.on('event', incrA);\n    obj.on('event', incrB);\n    obj.trigger('event');\n    obj.trigger('event');\n    obj.trigger('event');\n    assert.equal(obj.counterA, 1, 'counterA should have only been incremented once.');\n    assert.equal(obj.counterB, 1, 'counterB should have only been incremented once.');\n  });\n\n  QUnit.test('bind a callback with a default context when none supplied', function(assert) {\n    assert.expect(1);\n    var obj = _.extend({\n      assertTrue: function() {\n        assert.equal(this, obj, '`this` was bound to the callback');\n      }\n    }, Backbone.Events);\n\n    obj.once('event', obj.assertTrue);\n    obj.trigger('event');\n  });\n\n  QUnit.test('bind a callback with a supplied context', function(assert) {\n    assert.expect(1);\n    var TestClass = function() {\n      return this;\n    };\n    TestClass.prototype.assertTrue = function() {\n      assert.ok(true, '`this` was bound to the callback');\n    };\n\n    var obj = _.extend({}, Backbone.Events);\n    obj.on('event', function() { this.assertTrue(); }, new TestClass);\n    obj.trigger('event');\n  });\n\n  QUnit.test('nested trigger with unbind', function(assert) {\n    assert.expect(1);\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n    var incr1 = function(){ obj.counter += 1; obj.off('event', incr1); obj.trigger('event'); };\n    var incr2 = function(){ obj.counter += 1; };\n    obj.on('event', incr1);\n    obj.on('event', incr2);\n    obj.trigger('event');\n    assert.equal(obj.counter, 3, 'counter should have been incremented three times');\n  });\n\n  QUnit.test('callback list is not altered during trigger', function(assert) {\n    assert.expect(2);\n    var counter = 0, obj = _.extend({}, Backbone.Events);\n    var incr = function(){ counter++; };\n    var incrOn = function(){ obj.on('event all', incr); };\n    var incrOff = function(){ obj.off('event all', incr); };\n\n    obj.on('event all', incrOn).trigger('event');\n    assert.equal(counter, 0, 'on does not alter callback list');\n\n    obj.off().on('event', incrOff).on('event all', incr).trigger('event');\n    assert.equal(counter, 2, 'off does not alter callback list');\n  });\n\n  QUnit.test(\"#1282 - 'all' callback list is retrieved after each event.\", function(assert) {\n    assert.expect(1);\n    var counter = 0;\n    var obj = _.extend({}, Backbone.Events);\n    var incr = function(){ counter++; };\n    obj.on('x', function() {\n      obj.on('y', incr).on('all', incr);\n    })\n    .trigger('x y');\n    assert.strictEqual(counter, 2);\n  });\n\n  QUnit.test('if no callback is provided, `on` is a noop', function(assert) {\n    assert.expect(0);\n    _.extend({}, Backbone.Events).on('test').trigger('test');\n  });\n\n  QUnit.test('if callback is truthy but not a function, `on` should throw an error just like jQuery', function(assert) {\n    assert.expect(1);\n    var view = _.extend({}, Backbone.Events).on('test', 'noop');\n    assert.raises(function() {\n      view.trigger('test');\n    });\n  });\n\n  QUnit.test('remove all events for a specific context', function(assert) {\n    assert.expect(4);\n    var obj = _.extend({}, Backbone.Events);\n    obj.on('x y all', function() { assert.ok(true); });\n    obj.on('x y all', function() { assert.ok(false); }, obj);\n    obj.off(null, null, obj);\n    obj.trigger('x y');\n  });\n\n  QUnit.test('remove all events for a specific callback', function(assert) {\n    assert.expect(4);\n    var obj = _.extend({}, Backbone.Events);\n    var success = function() { assert.ok(true); };\n    var fail = function() { assert.ok(false); };\n    obj.on('x y all', success);\n    obj.on('x y all', fail);\n    obj.off(null, fail);\n    obj.trigger('x y');\n  });\n\n  QUnit.test('#1310 - off does not skip consecutive events', function(assert) {\n    assert.expect(0);\n    var obj = _.extend({}, Backbone.Events);\n    obj.on('event', function() { assert.ok(false); }, obj);\n    obj.on('event', function() { assert.ok(false); }, obj);\n    obj.off(null, null, obj);\n    obj.trigger('event');\n  });\n\n  QUnit.test('once', function(assert) {\n    assert.expect(2);\n    // Same as the previous test, but we use once rather than having to explicitly unbind\n    var obj = {counterA: 0, counterB: 0};\n    _.extend(obj, Backbone.Events);\n    var incrA = function(){ obj.counterA += 1; obj.trigger('event'); };\n    var incrB = function(){ obj.counterB += 1; };\n    obj.once('event', incrA);\n    obj.once('event', incrB);\n    obj.trigger('event');\n    assert.equal(obj.counterA, 1, 'counterA should have only been incremented once.');\n    assert.equal(obj.counterB, 1, 'counterB should have only been incremented once.');\n  });\n\n  QUnit.test('once variant one', function(assert) {\n    assert.expect(3);\n    var f = function(){ assert.ok(true); };\n\n    var a = _.extend({}, Backbone.Events).once('event', f);\n    var b = _.extend({}, Backbone.Events).on('event', f);\n\n    a.trigger('event');\n\n    b.trigger('event');\n    b.trigger('event');\n  });\n\n  QUnit.test('once variant two', function(assert) {\n    assert.expect(3);\n    var f = function(){ assert.ok(true); };\n    var obj = _.extend({}, Backbone.Events);\n\n    obj\n      .once('event', f)\n      .on('event', f)\n      .trigger('event')\n      .trigger('event');\n  });\n\n  QUnit.test('once with off', function(assert) {\n    assert.expect(0);\n    var f = function(){ assert.ok(true); };\n    var obj = _.extend({}, Backbone.Events);\n\n    obj.once('event', f);\n    obj.off('event', f);\n    obj.trigger('event');\n  });\n\n  QUnit.test('once with event maps', function(assert) {\n    var obj = {counter: 0};\n    _.extend(obj, Backbone.Events);\n\n    var increment = function() {\n      this.counter += 1;\n    };\n\n    obj.once({\n      a: increment,\n      b: increment,\n      c: increment\n    }, obj);\n\n    obj.trigger('a');\n    assert.equal(obj.counter, 1);\n\n    obj.trigger('a b');\n    assert.equal(obj.counter, 2);\n\n    obj.trigger('c');\n    assert.equal(obj.counter, 3);\n\n    obj.trigger('a b c');\n    assert.equal(obj.counter, 3);\n  });\n\n  QUnit.test('bind a callback with a supplied context using once with object notation', function(assert) {\n    assert.expect(1);\n    var obj = {counter: 0};\n    var context = {};\n    _.extend(obj, Backbone.Events);\n\n    obj.once({\n      a: function() {\n        assert.strictEqual(this, context, 'defaults `context` to `callback` param');\n      }\n    }, context).trigger('a');\n  });\n\n  QUnit.test('once with off only by context', function(assert) {\n    assert.expect(0);\n    var context = {};\n    var obj = _.extend({}, Backbone.Events);\n    obj.once('event', function(){ assert.ok(false); }, context);\n    obj.off(null, null, context);\n    obj.trigger('event');\n  });\n\n  QUnit.test('Backbone object inherits Events', function(assert) {\n    assert.ok(Backbone.on === Backbone.Events.on);\n  });\n\n  QUnit.test('once with asynchronous events', function(assert) {\n    var done = assert.async();\n    assert.expect(1);\n    var func = _.debounce(function() { assert.ok(true); done(); }, 50);\n    var obj = _.extend({}, Backbone.Events).once('async', func);\n\n    obj.trigger('async');\n    obj.trigger('async');\n  });\n\n  QUnit.test('once with multiple events.', function(assert) {\n    assert.expect(2);\n    var obj = _.extend({}, Backbone.Events);\n    obj.once('x y', function() { assert.ok(true); });\n    obj.trigger('x y');\n  });\n\n  QUnit.test('Off during iteration with once.', function(assert) {\n    assert.expect(2);\n    var obj = _.extend({}, Backbone.Events);\n    var f = function(){ this.off('event', f); };\n    obj.on('event', f);\n    obj.once('event', function(){});\n    obj.on('event', function(){ assert.ok(true); });\n\n    obj.trigger('event');\n    obj.trigger('event');\n  });\n\n  QUnit.test('`once` on `all` should work as expected', function(assert) {\n    assert.expect(1);\n    Backbone.once('all', function() {\n      assert.ok(true);\n      Backbone.trigger('all');\n    });\n    Backbone.trigger('all');\n  });\n\n  QUnit.test('once without a callback is a noop', function(assert) {\n    assert.expect(0);\n    _.extend({}, Backbone.Events).once('event').trigger('event');\n  });\n\n  QUnit.test('listenToOnce without a callback is a noop', function(assert) {\n    assert.expect(0);\n    var obj = _.extend({}, Backbone.Events);\n    obj.listenToOnce(obj, 'event').trigger('event');\n  });\n\n  QUnit.test('event functions are chainable', function(assert) {\n    var obj = _.extend({}, Backbone.Events);\n    var obj2 = _.extend({}, Backbone.Events);\n    var fn = function() {};\n    assert.equal(obj, obj.trigger('noeventssetyet'));\n    assert.equal(obj, obj.off('noeventssetyet'));\n    assert.equal(obj, obj.stopListening('noeventssetyet'));\n    assert.equal(obj, obj.on('a', fn));\n    assert.equal(obj, obj.once('c', fn));\n    assert.equal(obj, obj.trigger('a'));\n    assert.equal(obj, obj.listenTo(obj2, 'a', fn));\n    assert.equal(obj, obj.listenToOnce(obj2, 'b', fn));\n    assert.equal(obj, obj.off('a c'));\n    assert.equal(obj, obj.stopListening(obj2, 'a'));\n    assert.equal(obj, obj.stopListening());\n  });\n\n  QUnit.test('#3448 - listenToOnce with space-separated events', function(assert) {\n    assert.expect(2);\n    var one = _.extend({}, Backbone.Events);\n    var two = _.extend({}, Backbone.Events);\n    var count = 1;\n    one.listenToOnce(two, 'x y', function(n) { assert.ok(n === count++); });\n    two.trigger('x', 1);\n    two.trigger('x', 1);\n    two.trigger('y', 2);\n    two.trigger('y', 2);\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 22485,
                    tokens: 3005,
                    lastModified: '2025-07-02T12:28:22.858Z',
                  },
                  {
                    name: 'model.js',
                    path: 'vendor/backbone/test/model.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  var ProxyModel = Backbone.Model.extend();\n  var Klass = Backbone.Collection.extend({\n    url: function() { return '/collection'; }\n  });\n  var doc, collection;\n\n  QUnit.module('Backbone.Model', {\n\n    beforeEach: function(assert) {\n      doc = new ProxyModel({\n        id: '1-the-tempest',\n        title: 'The Tempest',\n        author: 'Bill Shakespeare',\n        length: 123\n      });\n      collection = new Klass();\n      collection.add(doc);\n    }\n\n  });\n\n  QUnit.test('initialize', function(assert) {\n    assert.expect(3);\n    var Model = Backbone.Model.extend({\n      initialize: function() {\n        this.one = 1;\n        assert.equal(this.collection, collection);\n      }\n    });\n    var model = new Model({}, {collection: collection});\n    assert.equal(model.one, 1);\n    assert.equal(model.collection, collection);\n  });\n\n  QUnit.test('Object.prototype properties are overridden by attributes', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({hasOwnProperty: true});\n    assert.equal(model.get('hasOwnProperty'), true);\n  });\n\n  QUnit.test('initialize with attributes and options', function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      initialize: function(attributes, options) {\n        this.one = options.one;\n      }\n    });\n    var model = new Model({}, {one: 1});\n    assert.equal(model.one, 1);\n  });\n\n  QUnit.test('initialize with parsed attributes', function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      parse: function(attrs) {\n        attrs.value += 1;\n        return attrs;\n      }\n    });\n    var model = new Model({value: 1}, {parse: true});\n    assert.equal(model.get('value'), 2);\n  });\n\n\n  QUnit.test('preinitialize', function(assert) {\n    assert.expect(2);\n    var Model = Backbone.Model.extend({\n\n      preinitialize: function() {\n        this.one = 1;\n      }\n    });\n    var model = new Model({}, {collection: collection});\n    assert.equal(model.one, 1);\n    assert.equal(model.collection, collection);\n  });\n\n  QUnit.test('preinitialize occurs before the model is set up', function(assert) {\n    assert.expect(6);\n    var Model = Backbone.Model.extend({\n\n      preinitialize: function() {\n        assert.equal(this.collection, undefined);\n        assert.equal(this.cid, undefined);\n        assert.equal(this.id, undefined);\n      }\n    });\n    var model = new Model({id: 'foo'}, {collection: collection});\n    assert.equal(model.collection, collection);\n    assert.equal(model.id, 'foo');\n    assert.notEqual(model.cid, undefined);\n  });\n\n  QUnit.test('parse can return null', function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      parse: function(attrs) {\n        attrs.value += 1;\n        return null;\n      }\n    });\n    var model = new Model({value: 1}, {parse: true});\n    assert.equal(JSON.stringify(model.toJSON()), '{}');\n  });\n\n  QUnit.test('url', function(assert) {\n    assert.expect(3);\n    doc.urlRoot = null;\n    assert.equal(doc.url(), '/collection/1-the-tempest');\n    doc.collection.url = '/collection/';\n    assert.equal(doc.url(), '/collection/1-the-tempest');\n    doc.collection = null;\n    assert.raises(function() { doc.url(); });\n    doc.collection = collection;\n  });\n\n  QUnit.test('url when using urlRoot, and uri encoding', function(assert) {\n    assert.expect(2);\n    var Model = Backbone.Model.extend({\n      urlRoot: '/collection'\n    });\n    var model = new Model();\n    assert.equal(model.url(), '/collection');\n    model.set({id: '+1+'});\n    assert.equal(model.url(), '/collection/%2B1%2B');\n  });\n\n  QUnit.test('url when using urlRoot as a function to determine urlRoot at runtime', function(assert) {\n    assert.expect(2);\n    var Model = Backbone.Model.extend({\n      urlRoot: function() {\n        return '/nested/' + this.get('parentId') + '/collection';\n      }\n    });\n\n    var model = new Model({parentId: 1});\n    assert.equal(model.url(), '/nested/1/collection');\n    model.set({id: 2});\n    assert.equal(model.url(), '/nested/1/collection/2');\n  });\n\n  QUnit.test('underscore methods', function(assert) {\n    assert.expect(5);\n    var model = new Backbone.Model({foo: 'a', bar: 'b', baz: 'c'});\n    var model2 = model.clone();\n    assert.deepEqual(model.keys(), ['foo', 'bar', 'baz']);\n    assert.deepEqual(model.values(), ['a', 'b', 'c']);\n    assert.deepEqual(model.invert(), {a: 'foo', b: 'bar', c: 'baz'});\n    assert.deepEqual(model.pick('foo', 'baz'), {foo: 'a', baz: 'c'});\n    assert.deepEqual(model.omit('foo', 'bar'), {baz: 'c'});\n  });\n\n  QUnit.test('chain', function(assert) {\n    var model = new Backbone.Model({a: 0, b: 1, c: 2});\n    assert.deepEqual(model.chain().pick('a', 'b', 'c').values().compact().value(), [1, 2]);\n  });\n\n  QUnit.test('clone', function(assert) {\n    assert.expect(10);\n    var a = new Backbone.Model({foo: 1, bar: 2, baz: 3});\n    var b = a.clone();\n    assert.equal(a.get('foo'), 1);\n    assert.equal(a.get('bar'), 2);\n    assert.equal(a.get('baz'), 3);\n    assert.equal(b.get('foo'), a.get('foo'), 'Foo should be the same on the clone.');\n    assert.equal(b.get('bar'), a.get('bar'), 'Bar should be the same on the clone.');\n    assert.equal(b.get('baz'), a.get('baz'), 'Baz should be the same on the clone.');\n    a.set({foo: 100});\n    assert.equal(a.get('foo'), 100);\n    assert.equal(b.get('foo'), 1, 'Changing a parent attribute does not change the clone.');\n\n    var foo = new Backbone.Model({p: 1});\n    var bar = new Backbone.Model({p: 2});\n    bar.set(foo.clone().attributes, {unset: true});\n    assert.equal(foo.get('p'), 1);\n    assert.equal(bar.get('p'), undefined);\n  });\n\n  QUnit.test('isNew', function(assert) {\n    assert.expect(6);\n    var a = new Backbone.Model({foo: 1, bar: 2, baz: 3});\n    assert.ok(a.isNew(), 'it should be new');\n    a = new Backbone.Model({foo: 1, bar: 2, baz: 3, id: -5});\n    assert.ok(!a.isNew(), 'any defined ID is legal, negative or positive');\n    a = new Backbone.Model({foo: 1, bar: 2, baz: 3, id: 0});\n    assert.ok(!a.isNew(), 'any defined ID is legal, including zero');\n    assert.ok(new Backbone.Model().isNew(), 'is true when there is no id');\n    assert.ok(!new Backbone.Model({id: 2}).isNew(), 'is false for a positive integer');\n    assert.ok(!new Backbone.Model({id: -5}).isNew(), 'is false for a negative integer');\n  });\n\n  QUnit.test('get', function(assert) {\n    assert.expect(2);\n    assert.equal(doc.get('title'), 'The Tempest');\n    assert.equal(doc.get('author'), 'Bill Shakespeare');\n  });\n\n  QUnit.test('escape', function(assert) {\n    assert.expect(5);\n    assert.equal(doc.escape('title'), 'The Tempest');\n    doc.set({audience: 'Bill & Bob'});\n    assert.equal(doc.escape('audience'), 'Bill &amp; Bob');\n    doc.set({audience: 'Tim > Joan'});\n    assert.equal(doc.escape('audience'), 'Tim &gt; Joan');\n    doc.set({audience: 10101});\n    assert.equal(doc.escape('audience'), '10101');\n    doc.unset('audience');\n    assert.equal(doc.escape('audience'), '');\n  });\n\n  QUnit.test('has', function(assert) {\n    assert.expect(10);\n    var model = new Backbone.Model();\n\n    assert.strictEqual(model.has('name'), false);\n\n    model.set({\n      '0': 0,\n      '1': 1,\n      'true': true,\n      'false': false,\n      'empty': '',\n      'name': 'name',\n      'null': null,\n      'undefined': undefined\n    });\n\n    assert.strictEqual(model.has('0'), true);\n    assert.strictEqual(model.has('1'), true);\n    assert.strictEqual(model.has('true'), true);\n    assert.strictEqual(model.has('false'), true);\n    assert.strictEqual(model.has('empty'), true);\n    assert.strictEqual(model.has('name'), true);\n\n    model.unset('name');\n\n    assert.strictEqual(model.has('name'), false);\n    assert.strictEqual(model.has('null'), false);\n    assert.strictEqual(model.has('undefined'), false);\n  });\n\n  QUnit.test('matches', function(assert) {\n    assert.expect(4);\n    var model = new Backbone.Model();\n\n    assert.strictEqual(model.matches({name: 'Jonas', cool: true}), false);\n\n    model.set({name: 'Jonas', cool: true});\n\n    assert.strictEqual(model.matches({name: 'Jonas'}), true);\n    assert.strictEqual(model.matches({name: 'Jonas', cool: true}), true);\n    assert.strictEqual(model.matches({name: 'Jonas', cool: false}), false);\n  });\n\n  QUnit.test('matches with predicate', function(assert) {\n    var model = new Backbone.Model({a: 0});\n\n    assert.strictEqual(model.matches(function(attr) {\n      return attr.a > 1 && attr.b != null;\n    }), false);\n\n    model.set({a: 3, b: true});\n\n    assert.strictEqual(model.matches(function(attr) {\n      return attr.a > 1 && attr.b != null;\n    }), true);\n  });\n\n  QUnit.test('set and unset', function(assert) {\n    assert.expect(8);\n    var a = new Backbone.Model({id: 'id', foo: 1, bar: 2, baz: 3});\n    var changeCount = 0;\n    a.on('change:foo', function() { changeCount += 1; });\n    a.set({foo: 2});\n    assert.equal(a.get('foo'), 2, 'Foo should have changed.');\n    assert.equal(changeCount, 1, 'Change count should have incremented.');\n    // set with value that is not new shouldn't fire change event\n    a.set({foo: 2});\n    assert.equal(a.get('foo'), 2, 'Foo should NOT have changed, still 2');\n    assert.equal(changeCount, 1, 'Change count should NOT have incremented.');\n\n    a.validate = function(attrs) {\n      assert.equal(attrs.foo, void 0, 'validate:true passed while unsetting');\n    };\n    a.unset('foo', {validate: true});\n    assert.equal(a.get('foo'), void 0, 'Foo should have changed');\n    delete a.validate;\n    assert.equal(changeCount, 2, 'Change count should have incremented for unset.');\n\n    a.unset('id');\n    assert.equal(a.id, undefined, 'Unsetting the id should remove the id property.');\n  });\n\n  QUnit.test('#2030 - set with failed validate, followed by another set triggers change', function(assert) {\n    var attr = 0, main = 0, error = 0;\n    var Model = Backbone.Model.extend({\n      validate: function(attrs) {\n        if (attrs.x > 1) {\n          error++;\n          return 'this is an error';\n        }\n      }\n    });\n    var model = new Model({x: 0});\n    model.on('change:x', function() { attr++; });\n    model.on('change', function() { main++; });\n    model.set({x: 2}, {validate: true});\n    model.set({x: 1}, {validate: true});\n    assert.deepEqual([attr, main, error], [1, 1, 1]);\n  });\n\n  QUnit.test('set triggers changes in the correct order', function(assert) {\n    var value = null;\n    var model = new Backbone.Model;\n    model.on('last', function(){ value = 'last'; });\n    model.on('first', function(){ value = 'first'; });\n    model.trigger('first');\n    model.trigger('last');\n    assert.equal(value, 'last');\n  });\n\n  QUnit.test('set falsy values in the correct order', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model({result: 'result'});\n    model.on('change', function() {\n      assert.equal(model.changed.result, void 0);\n      assert.equal(model.previous('result'), false);\n    });\n    model.set({result: void 0}, {silent: true});\n    model.set({result: null}, {silent: true});\n    model.set({result: false}, {silent: true});\n    model.set({result: void 0});\n  });\n\n  QUnit.test('nested set triggers with the correct options', function(assert) {\n    var model = new Backbone.Model();\n    var o1 = {};\n    var o2 = {};\n    var o3 = {};\n    model.on('change', function(__, options) {\n      switch (model.get('a')) {\n        case 1:\n          assert.equal(options, o1);\n          return model.set('a', 2, o2);\n        case 2:\n          assert.equal(options, o2);\n          return model.set('a', 3, o3);\n        case 3:\n          assert.equal(options, o3);\n      }\n    });\n    model.set('a', 1, o1);\n  });\n\n  QUnit.test('multiple unsets', function(assert) {\n    assert.expect(1);\n    var i = 0;\n    var counter = function(){ i++; };\n    var model = new Backbone.Model({a: 1});\n    model.on('change:a', counter);\n    model.set({a: 2});\n    model.unset('a');\n    model.unset('a');\n    assert.equal(i, 2, 'Unset does not fire an event for missing attributes.');\n  });\n\n  QUnit.test('unset and changedAttributes', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({a: 1});\n    model.on('change', function() {\n      assert.ok('a' in model.changedAttributes(), 'changedAttributes should contain unset properties');\n    });\n    model.unset('a');\n  });\n\n  QUnit.test('using a non-default id attribute.', function(assert) {\n    assert.expect(5);\n    var MongoModel = Backbone.Model.extend({idAttribute: '_id'});\n    var model = new MongoModel({id: 'eye-dee', _id: 25, title: 'Model'});\n    assert.equal(model.get('id'), 'eye-dee');\n    assert.equal(model.id, 25);\n    assert.equal(model.isNew(), false);\n    model.unset('_id');\n    assert.equal(model.id, undefined);\n    assert.equal(model.isNew(), true);\n  });\n\n  QUnit.test('setting an alternative cid prefix', function(assert) {\n    assert.expect(4);\n    var Model = Backbone.Model.extend({\n      cidPrefix: 'm'\n    });\n    var model = new Model();\n\n    assert.equal(model.cid.charAt(0), 'm');\n\n    model = new Backbone.Model();\n    assert.equal(model.cid.charAt(0), 'c');\n\n    var Collection = Backbone.Collection.extend({\n      model: Model\n    });\n    var col = new Collection([{id: 'c5'}, {id: 'c6'}, {id: 'c7'}]);\n\n    assert.equal(col.get('c6').cid.charAt(0), 'm');\n    col.set([{id: 'c6', value: 'test'}], {\n      merge: true,\n      add: true,\n      remove: false\n    });\n    assert.ok(col.get('c6').has('value'));\n  });\n\n  QUnit.test('set an empty string', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({name: 'Model'});\n    model.set({name: ''});\n    assert.equal(model.get('name'), '');\n  });\n\n  QUnit.test('setting an object', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({\n      custom: {foo: 1}\n    });\n    model.on('change', function() {\n      assert.ok(1);\n    });\n    model.set({\n      custom: {foo: 1} // no change should be fired\n    });\n    model.set({\n      custom: {foo: 2} // change event should be fired\n    });\n  });\n\n  QUnit.test('clear', function(assert) {\n    assert.expect(3);\n    var changed;\n    var model = new Backbone.Model({id: 1, name: 'Model'});\n    model.on('change:name', function(){ changed = true; });\n    model.on('change', function() {\n      var changedAttrs = model.changedAttributes();\n      assert.ok('name' in changedAttrs);\n    });\n    model.clear();\n    assert.equal(changed, true);\n    assert.equal(model.get('name'), undefined);\n  });\n\n  QUnit.test('defaults', function(assert) {\n    assert.expect(9);\n    var Defaulted = Backbone.Model.extend({\n      defaults: {\n        one: 1,\n        two: 2\n      }\n    });\n    var model = new Defaulted({two: undefined});\n    assert.equal(model.get('one'), 1);\n    assert.equal(model.get('two'), 2);\n    model = new Defaulted({two: 3});\n    assert.equal(model.get('one'), 1);\n    assert.equal(model.get('two'), 3);\n    Defaulted = Backbone.Model.extend({\n      defaults: function() {\n        return {\n          one: 3,\n          two: 4\n        };\n      }\n    });\n    model = new Defaulted({two: undefined});\n    assert.equal(model.get('one'), 3);\n    assert.equal(model.get('two'), 4);\n    Defaulted = Backbone.Model.extend({\n      defaults: {hasOwnProperty: true}\n    });\n    model = new Defaulted();\n    assert.equal(model.get('hasOwnProperty'), true);\n    model = new Defaulted({hasOwnProperty: undefined});\n    assert.equal(model.get('hasOwnProperty'), true);\n    model = new Defaulted({hasOwnProperty: false});\n    assert.equal(model.get('hasOwnProperty'), false);\n  });\n\n  QUnit.test('change, hasChanged, changedAttributes, previous, previousAttributes', function(assert) {\n    assert.expect(9);\n    var model = new Backbone.Model({name: 'Tim', age: 10});\n    assert.deepEqual(model.changedAttributes(), false);\n    model.on('change', function() {\n      assert.ok(model.hasChanged('name'), 'name changed');\n      assert.ok(!model.hasChanged('age'), 'age did not');\n      assert.ok(_.isEqual(model.changedAttributes(), {name: 'Rob'}), 'changedAttributes returns the changed attrs');\n      assert.equal(model.previous('name'), 'Tim');\n      assert.ok(_.isEqual(model.previousAttributes(), {name: 'Tim', age: 10}), 'previousAttributes is correct');\n    });\n    assert.equal(model.hasChanged(), false);\n    assert.equal(model.hasChanged(undefined), false);\n    model.set({name: 'Rob'});\n    assert.equal(model.get('name'), 'Rob');\n  });\n\n  QUnit.test('changedAttributes', function(assert) {\n    assert.expect(3);\n    var model = new Backbone.Model({a: 'a', b: 'b'});\n    assert.deepEqual(model.changedAttributes(), false);\n    assert.equal(model.changedAttributes({a: 'a'}), false);\n    assert.equal(model.changedAttributes({a: 'b'}).a, 'b');\n  });\n\n  QUnit.test('change with options', function(assert) {\n    assert.expect(2);\n    var value;\n    var model = new Backbone.Model({name: 'Rob'});\n    model.on('change', function(m, options) {\n      value = options.prefix + m.get('name');\n    });\n    model.set({name: 'Bob'}, {prefix: 'Mr. '});\n    assert.equal(value, 'Mr. Bob');\n    model.set({name: 'Sue'}, {prefix: 'Ms. '});\n    assert.equal(value, 'Ms. Sue');\n  });\n\n  QUnit.test('change after initialize', function(assert) {\n    assert.expect(1);\n    var changed = 0;\n    var attrs = {id: 1, label: 'c'};\n    var obj = new Backbone.Model(attrs);\n    obj.on('change', function() { changed += 1; });\n    obj.set(attrs);\n    assert.equal(changed, 0);\n  });\n\n  QUnit.test('save within change event', function(assert) {\n    assert.expect(1);\n    var env = this;\n    var model = new Backbone.Model({firstName: 'Taylor', lastName: 'Swift'});\n    model.url = '/test';\n    model.on('change', function() {\n      model.save();\n      assert.ok(_.isEqual(env.syncArgs.model, model));\n    });\n    model.set({lastName: 'Hicks'});\n  });\n\n  QUnit.test('validate after save', function(assert) {\n    assert.expect(2);\n    var lastError, model = new Backbone.Model();\n    model.validate = function(attrs) {\n      if (attrs.admin) return \"Can't change admin status.\";\n    };\n    model.sync = function(method, m, options) {\n      options.success.call(this, {admin: true});\n    };\n    model.on('invalid', function(m, error) {\n      lastError = error;\n    });\n    model.save(null);\n\n    assert.equal(lastError, \"Can't change admin status.\");\n    assert.equal(model.validationError, \"Can't change admin status.\");\n  });\n\n  QUnit.test('save', function(assert) {\n    assert.expect(2);\n    doc.save({title: 'Henry V'});\n    assert.equal(this.syncArgs.method, 'update');\n    assert.ok(_.isEqual(this.syncArgs.model, doc));\n  });\n\n  QUnit.test('save, fetch, destroy triggers error event when an error occurs', function(assert) {\n    assert.expect(3);\n    var model = new Backbone.Model();\n    model.on('error', function() {\n      assert.ok(true);\n    });\n    model.sync = function(method, m, options) {\n      options.error();\n    };\n    model.save({data: 2, id: 1});\n    model.fetch();\n    model.destroy();\n  });\n\n  QUnit.test('#3283 - save, fetch, destroy calls success with context', function(assert) {\n    assert.expect(3);\n    var model = new Backbone.Model();\n    var obj = {};\n    var options = {\n      context: obj,\n      success: function() {\n        assert.equal(this, obj);\n      }\n    };\n    model.sync = function(method, m, opts) {\n      opts.success.call(opts.context);\n    };\n    model.save({data: 2, id: 1}, options);\n    model.fetch(options);\n    model.destroy(options);\n  });\n\n  QUnit.test('#3283 - save, fetch, destroy calls error with context', function(assert) {\n    assert.expect(3);\n    var model = new Backbone.Model();\n    var obj = {};\n    var options = {\n      context: obj,\n      error: function() {\n        assert.equal(this, obj);\n      }\n    };\n    model.sync = function(method, m, opts) {\n      opts.error.call(opts.context);\n    };\n    model.save({data: 2, id: 1}, options);\n    model.fetch(options);\n    model.destroy(options);\n  });\n\n  QUnit.test('#3470 - save and fetch with parse false', function(assert) {\n    assert.expect(2);\n    var i = 0;\n    var model = new Backbone.Model();\n    model.parse = function() {\n      assert.ok(false);\n    };\n    model.sync = function(method, m, options) {\n      options.success({i: ++i});\n    };\n    model.fetch({parse: false});\n    assert.equal(model.get('i'), i);\n    model.save(null, {parse: false});\n    assert.equal(model.get('i'), i);\n  });\n\n  QUnit.test('save with PATCH', function(assert) {\n    doc.clear().set({id: 1, a: 1, b: 2, c: 3, d: 4});\n    doc.save();\n    assert.equal(this.syncArgs.method, 'update');\n    assert.equal(this.syncArgs.options.attrs, undefined);\n\n    doc.save({b: 2, d: 4}, {patch: true});\n    assert.equal(this.syncArgs.method, 'patch');\n    assert.equal(_.size(this.syncArgs.options.attrs), 2);\n    assert.equal(this.syncArgs.options.attrs.d, 4);\n    assert.equal(this.syncArgs.options.attrs.a, undefined);\n    assert.equal(this.ajaxSettings.data, '{\"b\":2,\"d\":4}');\n  });\n\n  QUnit.test('save with PATCH and different attrs', function(assert) {\n    doc.clear().save({b: 2, d: 4}, {patch: true, attrs: {B: 1, D: 3}});\n    assert.equal(this.syncArgs.options.attrs.D, 3);\n    assert.equal(this.syncArgs.options.attrs.d, undefined);\n    assert.equal(this.ajaxSettings.data, '{\"B\":1,\"D\":3}');\n    assert.deepEqual(doc.attributes, {b: 2, d: 4});\n  });\n\n  QUnit.test('save in positional style', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.sync = function(method, m, options) {\n      options.success();\n    };\n    model.save('title', 'Twelfth Night');\n    assert.equal(model.get('title'), 'Twelfth Night');\n  });\n\n  QUnit.test('save with non-object success response', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model();\n    model.sync = function(method, m, options) {\n      options.success('', options);\n      options.success(null, options);\n    };\n    model.save({testing: 'empty'}, {\n      success: function(m) {\n        assert.deepEqual(m.attributes, {testing: 'empty'});\n      }\n    });\n  });\n\n  QUnit.test('save with wait and supplied id', function(assert) {\n    var Model = Backbone.Model.extend({\n      urlRoot: '/collection'\n    });\n    var model = new Model();\n    model.save({id: 42}, {wait: true});\n    assert.equal(this.ajaxSettings.url, '/collection/42');\n  });\n\n  QUnit.test('save will pass extra options to success callback', function(assert) {\n    assert.expect(1);\n    var SpecialSyncModel = Backbone.Model.extend({\n      sync: function(method, m, options) {\n        _.extend(options, {specialSync: true});\n        return Backbone.Model.prototype.sync.call(this, method, m, options);\n      },\n      urlRoot: '/test'\n    });\n\n    var model = new SpecialSyncModel();\n\n    var onSuccess = function(m, response, options) {\n      assert.ok(options.specialSync, 'Options were passed correctly to callback');\n    };\n\n    model.save(null, {success: onSuccess});\n    this.ajaxSettings.success();\n  });\n\n  QUnit.test('fetch', function(assert) {\n    assert.expect(2);\n    doc.fetch();\n    assert.equal(this.syncArgs.method, 'read');\n    assert.ok(_.isEqual(this.syncArgs.model, doc));\n  });\n\n  QUnit.test('fetch will pass extra options to success callback', function(assert) {\n    assert.expect(1);\n    var SpecialSyncModel = Backbone.Model.extend({\n      sync: function(method, m, options) {\n        _.extend(options, {specialSync: true});\n        return Backbone.Model.prototype.sync.call(this, method, m, options);\n      },\n      urlRoot: '/test'\n    });\n\n    var model = new SpecialSyncModel();\n\n    var onSuccess = function(m, response, options) {\n      assert.ok(options.specialSync, 'Options were passed correctly to callback');\n    };\n\n    model.fetch({success: onSuccess});\n    this.ajaxSettings.success();\n  });\n\n  QUnit.test('destroy', function(assert) {\n    assert.expect(3);\n    doc.destroy();\n    assert.equal(this.syncArgs.method, 'delete');\n    assert.ok(_.isEqual(this.syncArgs.model, doc));\n\n    var newModel = new Backbone.Model;\n    assert.equal(newModel.destroy(), false);\n  });\n\n  QUnit.test('destroy will pass extra options to success callback', function(assert) {\n    assert.expect(1);\n    var SpecialSyncModel = Backbone.Model.extend({\n      sync: function(method, m, options) {\n        _.extend(options, {specialSync: true});\n        return Backbone.Model.prototype.sync.call(this, method, m, options);\n      },\n      urlRoot: '/test'\n    });\n\n    var model = new SpecialSyncModel({id: 'id'});\n\n    var onSuccess = function(m, response, options) {\n      assert.ok(options.specialSync, 'Options were passed correctly to callback');\n    };\n\n    model.destroy({success: onSuccess});\n    this.ajaxSettings.success();\n  });\n\n  QUnit.test('non-persisted destroy', function(assert) {\n    assert.expect(1);\n    var a = new Backbone.Model({foo: 1, bar: 2, baz: 3});\n    a.sync = function() { throw 'should not be called'; };\n    a.destroy();\n    assert.ok(true, 'non-persisted model should not call sync');\n  });\n\n  QUnit.test('validate', function(assert) {\n    var lastError;\n    var model = new Backbone.Model();\n    model.validate = function(attrs) {\n      if (attrs.admin !== this.get('admin')) return \"Can't change admin status.\";\n    };\n    model.on('invalid', function(m, error) {\n      lastError = error;\n    });\n    var result = model.set({a: 100});\n    assert.equal(result, model);\n    assert.equal(model.get('a'), 100);\n    assert.equal(lastError, undefined);\n    result = model.set({admin: true});\n    assert.equal(model.get('admin'), true);\n    result = model.set({a: 200, admin: false}, {validate: true});\n    assert.equal(lastError, \"Can't change admin status.\");\n    assert.equal(result, false);\n    assert.equal(model.get('a'), 100);\n  });\n\n  QUnit.test('validate on unset and clear', function(assert) {\n    assert.expect(6);\n    var error;\n    var model = new Backbone.Model({name: 'One'});\n    model.validate = function(attrs) {\n      if (!attrs.name) {\n        error = true;\n        return 'No thanks.';\n      }\n    };\n    model.set({name: 'Two'});\n    assert.equal(model.get('name'), 'Two');\n    assert.equal(error, undefined);\n    model.unset('name', {validate: true});\n    assert.equal(error, true);\n    assert.equal(model.get('name'), 'Two');\n    model.clear({validate: true});\n    assert.equal(model.get('name'), 'Two');\n    delete model.validate;\n    model.clear();\n    assert.equal(model.get('name'), undefined);\n  });\n\n  QUnit.test('validate with error callback', function(assert) {\n    assert.expect(8);\n    var lastError, boundError;\n    var model = new Backbone.Model();\n    model.validate = function(attrs) {\n      if (attrs.admin) return \"Can't change admin status.\";\n    };\n    model.on('invalid', function(m, error) {\n      boundError = true;\n    });\n    var result = model.set({a: 100}, {validate: true});\n    assert.equal(result, model);\n    assert.equal(model.get('a'), 100);\n    assert.equal(model.validationError, null);\n    assert.equal(boundError, undefined);\n    result = model.set({a: 200, admin: true}, {validate: true});\n    assert.equal(result, false);\n    assert.equal(model.get('a'), 100);\n    assert.equal(model.validationError, \"Can't change admin status.\");\n    assert.equal(boundError, true);\n  });\n\n  QUnit.test('defaults always extend attrs (#459)', function(assert) {\n    assert.expect(2);\n    var Defaulted = Backbone.Model.extend({\n      defaults: {one: 1},\n      initialize: function(attrs, opts) {\n        assert.equal(this.attributes.one, 1);\n      }\n    });\n    var providedattrs = new Defaulted({});\n    var emptyattrs = new Defaulted();\n  });\n\n  QUnit.test('Inherit class properties', function(assert) {\n    assert.expect(6);\n    var Parent = Backbone.Model.extend({\n      instancePropSame: function() {},\n      instancePropDiff: function() {}\n    }, {\n      classProp: function() {}\n    });\n    var Child = Parent.extend({\n      instancePropDiff: function() {}\n    });\n\n    var adult = new Parent;\n    var kid   = new Child;\n\n    assert.equal(Child.classProp, Parent.classProp);\n    assert.notEqual(Child.classProp, undefined);\n\n    assert.equal(kid.instancePropSame, adult.instancePropSame);\n    assert.notEqual(kid.instancePropSame, undefined);\n\n    assert.notEqual(Child.prototype.instancePropDiff, Parent.prototype.instancePropDiff);\n    assert.notEqual(Child.prototype.instancePropDiff, undefined);\n  });\n\n  QUnit.test(\"Nested change events don't clobber previous attributes\", function(assert) {\n    assert.expect(4);\n    new Backbone.Model()\n    .on('change:state', function(m, newState) {\n      assert.equal(m.previous('state'), undefined);\n      assert.equal(newState, 'hello');\n      // Fire a nested change event.\n      m.set({other: 'whatever'});\n    })\n    .on('change:state', function(m, newState) {\n      assert.equal(m.previous('state'), undefined);\n      assert.equal(newState, 'hello');\n    })\n    .set({state: 'hello'});\n  });\n\n  QUnit.test('hasChanged/set should use same comparison', function(assert) {\n    assert.expect(2);\n    var changed = 0, model = new Backbone.Model({a: null});\n    model.on('change', function() {\n      assert.ok(this.hasChanged('a'));\n    })\n    .on('change:a', function() {\n      changed++;\n    })\n    .set({a: undefined});\n    assert.equal(changed, 1);\n  });\n\n  QUnit.test('#582, #425, change:attribute callbacks should fire after all changes have occurred', function(assert) {\n    assert.expect(9);\n    var model = new Backbone.Model;\n\n    var assertion = function() {\n      assert.equal(model.get('a'), 'a');\n      assert.equal(model.get('b'), 'b');\n      assert.equal(model.get('c'), 'c');\n    };\n\n    model.on('change:a', assertion);\n    model.on('change:b', assertion);\n    model.on('change:c', assertion);\n\n    model.set({a: 'a', b: 'b', c: 'c'});\n  });\n\n  QUnit.test('#871, set with attributes property', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.set({attributes: true});\n    assert.ok(model.has('attributes'));\n  });\n\n  QUnit.test('set value regardless of equality/change', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({x: []});\n    var a = [];\n    model.set({x: a});\n    assert.ok(model.get('x') === a);\n  });\n\n  QUnit.test('set same value does not trigger change', function(assert) {\n    assert.expect(0);\n    var model = new Backbone.Model({x: 1});\n    model.on('change change:x', function() { assert.ok(false); });\n    model.set({x: 1});\n    model.set({x: 1});\n  });\n\n  QUnit.test('unset does not fire a change for undefined attributes', function(assert) {\n    assert.expect(0);\n    var model = new Backbone.Model({x: undefined});\n    model.on('change:x', function(){ assert.ok(false); });\n    model.unset('x');\n  });\n\n  QUnit.test('set: undefined values', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({x: undefined});\n    assert.ok('x' in model.attributes);\n  });\n\n  QUnit.test('hasChanged works outside of change events, and true within', function(assert) {\n    assert.expect(6);\n    var model = new Backbone.Model({x: 1});\n    model.on('change:x', function() {\n      assert.ok(model.hasChanged('x'));\n      assert.equal(model.get('x'), 1);\n    });\n    model.set({x: 2}, {silent: true});\n    assert.ok(model.hasChanged());\n    assert.equal(model.hasChanged('x'), true);\n    model.set({x: 1});\n    assert.ok(model.hasChanged());\n    assert.equal(model.hasChanged('x'), true);\n  });\n\n  QUnit.test('hasChanged gets cleared on the following set', function(assert) {\n    assert.expect(4);\n    var model = new Backbone.Model;\n    model.set({x: 1});\n    assert.ok(model.hasChanged());\n    model.set({x: 1});\n    assert.ok(!model.hasChanged());\n    model.set({x: 2});\n    assert.ok(model.hasChanged());\n    model.set({});\n    assert.ok(!model.hasChanged());\n  });\n\n  QUnit.test('save with `wait` succeeds without `validate`', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.url = '/test';\n    model.save({x: 1}, {wait: true});\n    assert.ok(this.syncArgs.model === model);\n  });\n\n  QUnit.test(\"save without `wait` doesn't set invalid attributes\", function(assert) {\n    var model = new Backbone.Model();\n    model.validate = function() { return 1; };\n    model.save({a: 1});\n    assert.equal(model.get('a'), void 0);\n  });\n\n  QUnit.test(\"save doesn't validate twice\", function(assert) {\n    var model = new Backbone.Model();\n    var times = 0;\n    model.sync = function() {};\n    model.validate = function() { ++times; };\n    model.save({});\n    assert.equal(times, 1);\n  });\n\n  QUnit.test('`hasChanged` for falsey keys', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model();\n    model.set({x: true}, {silent: true});\n    assert.ok(!model.hasChanged(0));\n    assert.ok(!model.hasChanged(''));\n  });\n\n  QUnit.test('`previous` for falsey keys', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model({'0': true, '': true});\n    model.set({'0': false, '': false}, {silent: true});\n    assert.equal(model.previous(0), true);\n    assert.equal(model.previous(''), true);\n  });\n\n  QUnit.test('`save` with `wait` sends correct attributes', function(assert) {\n    assert.expect(5);\n    var changed = 0;\n    var model = new Backbone.Model({x: 1, y: 2});\n    model.url = '/test';\n    model.on('change:x', function() { changed++; });\n    model.save({x: 3}, {wait: true});\n    assert.deepEqual(JSON.parse(this.ajaxSettings.data), {x: 3, y: 2});\n    assert.equal(model.get('x'), 1);\n    assert.equal(changed, 0);\n    this.syncArgs.options.success({});\n    assert.equal(model.get('x'), 3);\n    assert.equal(changed, 1);\n  });\n\n  QUnit.test(\"a failed `save` with `wait` doesn't leave attributes behind\", function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model;\n    model.url = '/test';\n    model.save({x: 1}, {wait: true});\n    assert.equal(model.get('x'), void 0);\n  });\n\n  QUnit.test('#1030 - `save` with `wait` results in correct attributes if success is called during sync', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model({x: 1, y: 2});\n    model.sync = function(method, m, options) {\n      options.success();\n    };\n    model.on('change:x', function() { assert.ok(true); });\n    model.save({x: 3}, {wait: true});\n    assert.equal(model.get('x'), 3);\n  });\n\n  QUnit.test('save with wait validates attributes', function(assert) {\n    var model = new Backbone.Model();\n    model.url = '/test';\n    model.validate = function() { assert.ok(true); };\n    model.save({x: 1}, {wait: true});\n  });\n\n  QUnit.test('save turns on parse flag', function(assert) {\n    var Model = Backbone.Model.extend({\n      sync: function(method, m, options) { assert.ok(options.parse); }\n    });\n    new Model().save();\n  });\n\n  QUnit.test(\"nested `set` during `'change:attr'`\", function(assert) {\n    assert.expect(2);\n    var events = [];\n    var model = new Backbone.Model();\n    model.on('all', function(event) { events.push(event); });\n    model.on('change', function() {\n      model.set({z: true}, {silent: true});\n    });\n    model.on('change:x', function() {\n      model.set({y: true});\n    });\n    model.set({x: true});\n    assert.deepEqual(events, ['change:y', 'change:x', 'change']);\n    events = [];\n    model.set({z: true});\n    assert.deepEqual(events, []);\n  });\n\n  QUnit.test('nested `change` only fires once', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.on('change', function() {\n      assert.ok(true);\n      model.set({x: true});\n    });\n    model.set({x: true});\n  });\n\n  QUnit.test(\"nested `set` during `'change'`\", function(assert) {\n    assert.expect(6);\n    var count = 0;\n    var model = new Backbone.Model();\n    model.on('change', function() {\n      switch (count++) {\n        case 0:\n          assert.deepEqual(this.changedAttributes(), {x: true});\n          assert.equal(model.previous('x'), undefined);\n          model.set({y: true});\n          break;\n        case 1:\n          assert.deepEqual(this.changedAttributes(), {x: true, y: true});\n          assert.equal(model.previous('x'), undefined);\n          model.set({z: true});\n          break;\n        case 2:\n          assert.deepEqual(this.changedAttributes(), {x: true, y: true, z: true});\n          assert.equal(model.previous('y'), undefined);\n          break;\n        default:\n          assert.ok(false);\n      }\n    });\n    model.set({x: true});\n  });\n\n  QUnit.test('nested `change` with silent', function(assert) {\n    assert.expect(3);\n    var count = 0;\n    var model = new Backbone.Model();\n    model.on('change:y', function() { assert.ok(false); });\n    model.on('change', function() {\n      switch (count++) {\n        case 0:\n          assert.deepEqual(this.changedAttributes(), {x: true});\n          model.set({y: true}, {silent: true});\n          model.set({z: true});\n          break;\n        case 1:\n          assert.deepEqual(this.changedAttributes(), {x: true, y: true, z: true});\n          break;\n        case 2:\n          assert.deepEqual(this.changedAttributes(), {z: false});\n          break;\n        default:\n          assert.ok(false);\n      }\n    });\n    model.set({x: true});\n    model.set({z: false});\n  });\n\n  QUnit.test('nested `change:attr` with silent', function(assert) {\n    assert.expect(0);\n    var model = new Backbone.Model();\n    model.on('change:y', function(){ assert.ok(false); });\n    model.on('change', function() {\n      model.set({y: true}, {silent: true});\n      model.set({z: true});\n    });\n    model.set({x: true});\n  });\n\n  QUnit.test('multiple nested changes with silent', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.on('change:x', function() {\n      model.set({y: 1}, {silent: true});\n      model.set({y: 2});\n    });\n    model.on('change:y', function(m, val) {\n      assert.equal(val, 2);\n    });\n    model.set({x: true});\n  });\n\n  QUnit.test('multiple nested changes with silent', function(assert) {\n    assert.expect(1);\n    var changes = [];\n    var model = new Backbone.Model();\n    model.on('change:b', function(m, val) { changes.push(val); });\n    model.on('change', function() {\n      model.set({b: 1});\n    });\n    model.set({b: 0});\n    assert.deepEqual(changes, [0, 1]);\n  });\n\n  QUnit.test('basic silent change semantics', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model;\n    model.set({x: 1});\n    model.on('change', function(){ assert.ok(true); });\n    model.set({x: 2}, {silent: true});\n    model.set({x: 1});\n  });\n\n  QUnit.test('nested set multiple times', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.on('change:b', function() {\n      assert.ok(true);\n    });\n    model.on('change:a', function() {\n      model.set({b: true});\n      model.set({b: true});\n    });\n    model.set({a: true});\n  });\n\n  QUnit.test('#1122 - clear does not alter options.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    var options = {};\n    model.clear(options);\n    assert.ok(!options.unset);\n  });\n\n  QUnit.test('#1122 - unset does not alter options.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    var options = {};\n    model.unset('x', options);\n    assert.ok(!options.unset);\n  });\n\n  QUnit.test('#1355 - `options` is passed to success callbacks', function(assert) {\n    assert.expect(3);\n    var model = new Backbone.Model();\n    var opts = {\n      success: function( m, resp, options ) {\n        assert.ok(options);\n      }\n    };\n    model.sync = function(method, m, options) {\n      options.success();\n    };\n    model.save({id: 1}, opts);\n    model.fetch(opts);\n    model.destroy(opts);\n  });\n\n  QUnit.test(\"#1412 - Trigger 'sync' event.\", function(assert) {\n    assert.expect(3);\n    var model = new Backbone.Model({id: 1});\n    model.sync = function(method, m, options) { options.success(); };\n    model.on('sync', function(){ assert.ok(true); });\n    model.fetch();\n    model.save();\n    model.destroy();\n  });\n\n  QUnit.test('#1365 - Destroy: New models execute success callback.', function(assert) {\n    var done = assert.async();\n    assert.expect(2);\n    new Backbone.Model()\n    .on('sync', function() { assert.ok(false); })\n    .on('destroy', function(){ assert.ok(true); })\n    .destroy({success: function(){\n      assert.ok(true);\n      done();\n    }});\n  });\n\n  QUnit.test('#1433 - Save: An invalid model cannot be persisted.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model;\n    model.validate = function(){ return 'invalid'; };\n    model.sync = function(){ assert.ok(false); };\n    assert.strictEqual(model.save(), false);\n  });\n\n  QUnit.test(\"#1377 - Save without attrs triggers 'error'.\", function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      url: '/test/',\n      sync: function(method, m, options){ options.success(); },\n      validate: function(){ return 'invalid'; }\n    });\n    var model = new Model({id: 1});\n    model.on('invalid', function(){ assert.ok(true); });\n    model.save();\n  });\n\n  QUnit.test('#1545 - `undefined` can be passed to a model constructor without coersion', function(assert) {\n    var Model = Backbone.Model.extend({\n      defaults: {one: 1},\n      initialize: function(attrs, opts) {\n        assert.equal(attrs, undefined);\n      }\n    });\n    var emptyattrs = new Model();\n    var undefinedattrs = new Model(undefined);\n  });\n\n  QUnit.test('#1478 - Model `save` does not trigger change on unchanged attributes', function(assert) {\n    var done = assert.async();\n    assert.expect(0);\n    var Model = Backbone.Model.extend({\n      sync: function(method, m, options) {\n        setTimeout(function(){\n          options.success();\n          done();\n        }, 0);\n      }\n    });\n    new Model({x: true})\n    .on('change:x', function(){ assert.ok(false); })\n    .save(null, {wait: true});\n  });\n\n  QUnit.test('#1664 - Changing from one value, silently to another, back to original triggers a change.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model({x: 1});\n    model.on('change:x', function() { assert.ok(true); });\n    model.set({x: 2}, {silent: true});\n    model.set({x: 3}, {silent: true});\n    model.set({x: 1});\n  });\n\n  QUnit.test('#1664 - multiple silent changes nested inside a change event', function(assert) {\n    assert.expect(2);\n    var changes = [];\n    var model = new Backbone.Model();\n    model.on('change', function() {\n      model.set({a: 'c'}, {silent: true});\n      model.set({b: 2}, {silent: true});\n      model.unset('c', {silent: true});\n    });\n    model.on('change:a change:b change:c', function(m, val) { changes.push(val); });\n    model.set({a: 'a', b: 1, c: 'item'});\n    assert.deepEqual(changes, ['a', 1, 'item']);\n    assert.deepEqual(model.attributes, {a: 'c', b: 2});\n  });\n\n  QUnit.test('#1791 - `attributes` is available for `parse`', function(assert) {\n    var Model = Backbone.Model.extend({\n      parse: function() { this.has('a'); } // shouldn't throw an error\n    });\n    var model = new Model(null, {parse: true});\n    assert.expect(0);\n  });\n\n  QUnit.test('silent changes in last `change` event back to original triggers change', function(assert) {\n    assert.expect(2);\n    var changes = [];\n    var model = new Backbone.Model();\n    model.on('change:a change:b change:c', function(m, val) { changes.push(val); });\n    model.on('change', function() {\n      model.set({a: 'c'}, {silent: true});\n    });\n    model.set({a: 'a'});\n    assert.deepEqual(changes, ['a']);\n    model.set({a: 'a'});\n    assert.deepEqual(changes, ['a', 'a']);\n  });\n\n  QUnit.test('#1943 change calculations should use _.isEqual', function(assert) {\n    var model = new Backbone.Model({a: {key: 'value'}});\n    model.set('a', {key: 'value'}, {silent: true});\n    assert.equal(model.changedAttributes(), false);\n  });\n\n  QUnit.test('#1964 - final `change` event is always fired, regardless of interim changes', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.on('change:property', function() {\n      model.set('property', 'bar');\n    });\n    model.on('change', function() {\n      assert.ok(true);\n    });\n    model.set('property', 'foo');\n  });\n\n  QUnit.test('isValid', function(assert) {\n    var model = new Backbone.Model({valid: true});\n    model.validate = function(attrs) {\n      if (!attrs.valid) return 'invalid';\n    };\n    assert.equal(model.isValid(), true);\n    assert.equal(model.set({valid: false}, {validate: true}), false);\n    assert.equal(model.isValid(), true);\n    model.set({valid: false});\n    assert.equal(model.isValid(), false);\n    assert.ok(!model.set('valid', false, {validate: true}));\n  });\n\n  QUnit.test('#1179 - isValid returns true in the absence of validate.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.validate = null;\n    assert.ok(model.isValid());\n  });\n\n  QUnit.test('#1961 - Creating a model with {validate:true} will call validate and use the error callback', function(assert) {\n    var Model = Backbone.Model.extend({\n      validate: function(attrs) {\n        if (attrs.id === 1) return \"This shouldn't happen\";\n      }\n    });\n    var model = new Model({id: 1}, {validate: true});\n    assert.equal(model.validationError, \"This shouldn't happen\");\n  });\n\n  QUnit.test('toJSON receives attrs during save(..., {wait: true})', function(assert) {\n    assert.expect(1);\n    var Model = Backbone.Model.extend({\n      url: '/test',\n      toJSON: function() {\n        assert.strictEqual(this.attributes.x, 1);\n        return _.clone(this.attributes);\n      }\n    });\n    var model = new Model;\n    model.save({x: 1}, {wait: true});\n  });\n\n  QUnit.test('#2034 - nested set with silent only triggers one change', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model();\n    model.on('change', function() {\n      model.set({b: true}, {silent: true});\n      assert.ok(true);\n    });\n    model.set({a: true});\n  });\n\n  QUnit.test('#3778 - id will only be updated if it is set', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model({id: 1});\n    model.id = 2;\n    model.set({foo: 'bar'});\n    assert.equal(model.id, 2);\n    model.set({id: 3});\n    assert.equal(model.id, 3);\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 46241,
                    tokens: 5996,
                    lastModified: '2025-07-02T12:28:22.859Z',
                  },
                  {
                    name: 'noconflict.js',
                    path: 'vendor/backbone/test/noconflict.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  QUnit.module('Backbone.noConflict');\n\n  QUnit.test('noConflict', function(assert) {\n    assert.expect(2);\n    var noconflictBackbone = Backbone.noConflict();\n    assert.equal(window.Backbone, undefined, 'Returned window.Backbone');\n    window.Backbone = noconflictBackbone;\n    assert.equal(window.Backbone, noconflictBackbone, 'Backbone is still pointing to the original Backbone');\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 424,
                    tokens: 45,
                    lastModified: '2025-07-02T12:28:22.859Z',
                  },
                  {
                    name: 'router.js',
                    path: 'vendor/backbone/test/router.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  var router = null;\n  var location = null;\n  var lastRoute = null;\n  var lastArgs = [];\n\n  var onRoute = function(routerParam, route, args) {\n    lastRoute = route;\n    lastArgs = args;\n  };\n\n  var Location = function(href) {\n    this.replace(href);\n  };\n\n  _.extend(Location.prototype, {\n\n    parser: document.createElement('a'),\n\n    replace: function(href) {\n      this.parser.href = href;\n      _.extend(this, _.pick(this.parser,\n        'href',\n        'hash',\n        'host',\n        'search',\n        'fragment',\n        'pathname',\n        'protocol'\n     ));\n\n      // In IE, anchor.pathname does not contain a leading slash though\n      // window.location.pathname does.\n      if (!/^\\//.test(this.pathname)) this.pathname = '/' + this.pathname;\n    },\n\n    toString: function() {\n      return this.href;\n    }\n\n  });\n\n  QUnit.module('Backbone.Router', {\n\n    beforeEach: function() {\n      location = new Location('http://example.com');\n      Backbone.history = _.extend(new Backbone.History, {location: location});\n      router = new Router({testing: 101});\n      Backbone.history.interval = 9;\n      Backbone.history.start({pushState: false});\n      lastRoute = null;\n      lastArgs = [];\n      Backbone.history.on('route', onRoute);\n    },\n\n    afterEach: function() {\n      Backbone.history.stop();\n      Backbone.history.off('route', onRoute);\n    }\n\n  });\n\n  var ExternalObject = {\n    value: 'unset',\n\n    routingFunction: function(value) {\n      this.value = value;\n    }\n  };\n  ExternalObject.routingFunction = _.bind(ExternalObject.routingFunction, ExternalObject);\n\n  var Router = Backbone.Router.extend({\n\n    count: 0,\n\n    routes: {\n      'noCallback': 'noCallback',\n      'counter': 'counter',\n      'search/:query': 'search',\n      'search/:query/p:page': 'search',\n      'charñ': 'charUTF',\n      'char%C3%B1': 'charEscaped',\n      'contacts': 'contacts',\n      'contacts/new': 'newContact',\n      'contacts/:id': 'loadContact',\n      'route-event/:arg': 'routeEvent',\n      'optional(/:item)': 'optionalItem',\n      'named/optional/(y:z)': 'namedOptional',\n      'splat/*args/end': 'splat',\n      ':repo/compare/*from...*to': 'github',\n      'decode/:named/*splat': 'decode',\n      '*first/complex-*part/*rest': 'complex',\n      'query/:entity': 'query',\n      'function/:value': ExternalObject.routingFunction,\n      '*anything': 'anything'\n    },\n\n    preinitialize: function(options) {\n      this.testpreinit = 'foo';\n    },\n\n    initialize: function(options) {\n      this.testing = options.testing;\n      this.route('implicit', 'implicit');\n    },\n\n    counter: function() {\n      this.count++;\n    },\n\n    implicit: function() {\n      this.count++;\n    },\n\n    search: function(query, page) {\n      this.query = query;\n      this.page = page;\n    },\n\n    charUTF: function() {\n      this.charType = 'UTF';\n    },\n\n    charEscaped: function() {\n      this.charType = 'escaped';\n    },\n\n    contacts: function() {\n      this.contact = 'index';\n    },\n\n    newContact: function() {\n      this.contact = 'new';\n    },\n\n    loadContact: function() {\n      this.contact = 'load';\n    },\n\n    optionalItem: function(arg) {\n      this.arg = arg !== void 0 ? arg : null;\n    },\n\n    splat: function(args) {\n      this.args = args;\n    },\n\n    github: function(repo, from, to) {\n      this.repo = repo;\n      this.from = from;\n      this.to = to;\n    },\n\n    complex: function(first, part, rest) {\n      this.first = first;\n      this.part = part;\n      this.rest = rest;\n    },\n\n    query: function(entity, args) {\n      this.entity    = entity;\n      this.queryArgs = args;\n    },\n\n    anything: function(whatever) {\n      this.anything = whatever;\n    },\n\n    namedOptional: function(z) {\n      this.z = z;\n    },\n\n    decode: function(named, path) {\n      this.named = named;\n      this.path = path;\n    },\n\n    routeEvent: function(arg) {\n    }\n\n  });\n\n  QUnit.test('initialize', function(assert) {\n    assert.expect(1);\n    assert.equal(router.testing, 101);\n  });\n\n  QUnit.test('preinitialize', function(assert) {\n    assert.expect(1);\n    assert.equal(router.testpreinit, 'foo');\n  });\n\n  QUnit.test('routes (simple)', function(assert) {\n    assert.expect(4);\n    location.replace('http://example.com#search/news');\n    Backbone.history.checkUrl();\n    assert.equal(router.query, 'news');\n    assert.equal(router.page, void 0);\n    assert.equal(lastRoute, 'search');\n    assert.equal(lastArgs[0], 'news');\n  });\n\n  QUnit.test('routes (simple, but unicode)', function(assert) {\n    assert.expect(4);\n    location.replace('http://example.com#search/тест');\n    Backbone.history.checkUrl();\n    assert.equal(router.query, 'тест');\n    assert.equal(router.page, void 0);\n    assert.equal(lastRoute, 'search');\n    assert.equal(lastArgs[0], 'тест');\n  });\n\n  QUnit.test('routes (two part)', function(assert) {\n    assert.expect(2);\n    location.replace('http://example.com#search/nyc/p10');\n    Backbone.history.checkUrl();\n    assert.equal(router.query, 'nyc');\n    assert.equal(router.page, '10');\n  });\n\n  QUnit.test('routes via navigate', function(assert) {\n    assert.expect(2);\n    Backbone.history.navigate('search/manhattan/p20', {trigger: true});\n    assert.equal(router.query, 'manhattan');\n    assert.equal(router.page, '20');\n  });\n\n  QUnit.test('routes via navigate with params', function(assert) {\n    assert.expect(1);\n    Backbone.history.navigate('query/test?a=b', {trigger: true});\n    assert.equal(router.queryArgs, 'a=b');\n  });\n\n  QUnit.test('routes via navigate for backwards-compatibility', function(assert) {\n    assert.expect(2);\n    Backbone.history.navigate('search/manhattan/p20', true);\n    assert.equal(router.query, 'manhattan');\n    assert.equal(router.page, '20');\n  });\n\n  QUnit.test('reports matched route via nagivate', function(assert) {\n    assert.expect(1);\n    assert.ok(Backbone.history.navigate('search/manhattan/p20', true));\n  });\n\n  QUnit.test('route precedence via navigate', function(assert) {\n    assert.expect(6);\n\n    // Check both 0.9.x and backwards-compatibility options\n    _.each([{trigger: true}, true], function(options) {\n      Backbone.history.navigate('contacts', options);\n      assert.equal(router.contact, 'index');\n      Backbone.history.navigate('contacts/new', options);\n      assert.equal(router.contact, 'new');\n      Backbone.history.navigate('contacts/foo', options);\n      assert.equal(router.contact, 'load');\n    });\n  });\n\n  QUnit.test('loadUrl is not called for identical routes.', function(assert) {\n    assert.expect(0);\n    Backbone.history.loadUrl = function() { assert.ok(false); };\n    location.replace('http://example.com#route');\n    Backbone.history.navigate('route');\n    Backbone.history.navigate('/route');\n    Backbone.history.navigate('/route');\n  });\n\n  QUnit.test('use implicit callback if none provided', function(assert) {\n    assert.expect(1);\n    router.count = 0;\n    router.navigate('implicit', {trigger: true});\n    assert.equal(router.count, 1);\n  });\n\n  QUnit.test('routes via navigate with {replace: true}', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com#start_here');\n    Backbone.history.checkUrl();\n    location.replace = function(href) {\n      assert.strictEqual(href, new Location('http://example.com#end_here').href);\n    };\n    Backbone.history.navigate('end_here', {replace: true});\n  });\n\n  QUnit.test('routes (splats)', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com#splat/long-list/of/splatted_99args/end');\n    Backbone.history.checkUrl();\n    assert.equal(router.args, 'long-list/of/splatted_99args');\n  });\n\n  QUnit.test('routes (github)', function(assert) {\n    assert.expect(3);\n    location.replace('http://example.com#backbone/compare/1.0...braddunbar:with/slash');\n    Backbone.history.checkUrl();\n    assert.equal(router.repo, 'backbone');\n    assert.equal(router.from, '1.0');\n    assert.equal(router.to, 'braddunbar:with/slash');\n  });\n\n  QUnit.test('routes (optional)', function(assert) {\n    assert.expect(2);\n    location.replace('http://example.com#optional');\n    Backbone.history.checkUrl();\n    assert.ok(!router.arg);\n    location.replace('http://example.com#optional/thing');\n    Backbone.history.checkUrl();\n    assert.equal(router.arg, 'thing');\n  });\n\n  QUnit.test('routes (complex)', function(assert) {\n    assert.expect(3);\n    location.replace('http://example.com#one/two/three/complex-part/four/five/six/seven');\n    Backbone.history.checkUrl();\n    assert.equal(router.first, 'one/two/three');\n    assert.equal(router.part, 'part');\n    assert.equal(router.rest, 'four/five/six/seven');\n  });\n\n  QUnit.test('routes (query)', function(assert) {\n    assert.expect(5);\n    location.replace('http://example.com#query/mandel?a=b&c=d');\n    Backbone.history.checkUrl();\n    assert.equal(router.entity, 'mandel');\n    assert.equal(router.queryArgs, 'a=b&c=d');\n    assert.equal(lastRoute, 'query');\n    assert.equal(lastArgs[0], 'mandel');\n    assert.equal(lastArgs[1], 'a=b&c=d');\n  });\n\n  QUnit.test('routes (anything)', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com#doesnt-match-a-route');\n    Backbone.history.checkUrl();\n    assert.equal(router.anything, 'doesnt-match-a-route');\n  });\n\n  QUnit.test('routes (function)', function(assert) {\n    assert.expect(3);\n    router.on('route', function(name) {\n      assert.ok(name === '');\n    });\n    assert.equal(ExternalObject.value, 'unset');\n    location.replace('http://example.com#function/set');\n    Backbone.history.checkUrl();\n    assert.equal(ExternalObject.value, 'set');\n  });\n\n  QUnit.test('Decode named parameters, not splats.', function(assert) {\n    assert.expect(2);\n    location.replace('http://example.com#decode/a%2Fb/c%2Fd/e');\n    Backbone.history.checkUrl();\n    assert.strictEqual(router.named, 'a/b');\n    assert.strictEqual(router.path, 'c/d/e');\n  });\n\n  QUnit.test('fires event when router doesn\\'t have callback on it', function(assert) {\n    assert.expect(1);\n    router.on('route:noCallback', function() { assert.ok(true); });\n    location.replace('http://example.com#noCallback');\n    Backbone.history.checkUrl();\n  });\n\n  QUnit.test('No events are triggered if #execute returns false.', function(assert) {\n    assert.expect(1);\n    var MyRouter = Backbone.Router.extend({\n\n      routes: {\n        foo: function() {\n          assert.ok(true);\n        }\n      },\n\n      execute: function(callback, args) {\n        callback.apply(this, args);\n        return false;\n      }\n\n    });\n\n    var myRouter = new MyRouter;\n\n    myRouter.on('route route:foo', function() {\n      assert.ok(false);\n    });\n\n    Backbone.history.on('route', function() {\n      assert.ok(false);\n    });\n\n    location.replace('http://example.com#foo');\n    Backbone.history.checkUrl();\n  });\n\n  QUnit.test('#933, #908 - leading slash', function(assert) {\n    assert.expect(2);\n    location.replace('http://example.com/root/foo');\n\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({root: '/root', hashChange: false, silent: true});\n    assert.strictEqual(Backbone.history.getFragment(), 'foo');\n\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({root: '/root/', hashChange: false, silent: true});\n    assert.strictEqual(Backbone.history.getFragment(), 'foo');\n  });\n\n  QUnit.test('#967 - Route callback gets passed encoded values.', function(assert) {\n    assert.expect(3);\n    var route = 'has%2Fslash/complex-has%23hash/has%20space';\n    Backbone.history.navigate(route, {trigger: true});\n    assert.strictEqual(router.first, 'has/slash');\n    assert.strictEqual(router.part, 'has#hash');\n    assert.strictEqual(router.rest, 'has space');\n  });\n\n  QUnit.test('correctly handles URLs with % (#868)', function(assert) {\n    assert.expect(3);\n    location.replace('http://example.com#search/fat%3A1.5%25');\n    Backbone.history.checkUrl();\n    location.replace('http://example.com#search/fat');\n    Backbone.history.checkUrl();\n    assert.equal(router.query, 'fat');\n    assert.equal(router.page, void 0);\n    assert.equal(lastRoute, 'search');\n  });\n\n  QUnit.test('#2666 - Hashes with UTF8 in them.', function(assert) {\n    assert.expect(2);\n    Backbone.history.navigate('charñ', {trigger: true});\n    assert.equal(router.charType, 'UTF');\n    Backbone.history.navigate('char%C3%B1', {trigger: true});\n    assert.equal(router.charType, 'UTF');\n  });\n\n  QUnit.test('#1185 - Use pathname when hashChange is not wanted.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/path/name#hash');\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({hashChange: false});\n    var fragment = Backbone.history.getFragment();\n    assert.strictEqual(fragment, location.pathname.replace(/^\\//, ''));\n  });\n\n  QUnit.test('#1206 - Strip leading slash before location.assign.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root/');\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({hashChange: false, root: '/root/'});\n    location.assign = function(pathname) {\n      assert.strictEqual(pathname, '/root/fragment');\n    };\n    Backbone.history.navigate('/fragment');\n  });\n\n  QUnit.test('#1387 - Root fragment without trailing slash.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root');\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({hashChange: false, root: '/root/', silent: true});\n    assert.strictEqual(Backbone.history.getFragment(), '');\n  });\n\n  QUnit.test('#1366 - History does not prepend root to fragment.', function(assert) {\n    assert.expect(2);\n    Backbone.history.stop();\n    location.replace('http://example.com/root/');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/root/x');\n        }\n      }\n    });\n    Backbone.history.start({\n      root: '/root/',\n      pushState: true,\n      hashChange: false\n    });\n    Backbone.history.navigate('x');\n    assert.strictEqual(Backbone.history.fragment, 'x');\n  });\n\n  QUnit.test('Normalize root.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/root/fragment');\n        }\n      }\n    });\n    Backbone.history.start({\n      pushState: true,\n      root: '/root',\n      hashChange: false\n    });\n    Backbone.history.navigate('fragment');\n  });\n\n  QUnit.test('Normalize root.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root#fragment');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {},\n        replaceState: function(state, title, url) {\n          assert.strictEqual(url, '/root/fragment');\n        }\n      }\n    });\n    Backbone.history.start({\n      pushState: true,\n      root: '/root'\n    });\n  });\n\n  QUnit.test('Normalize root.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root');\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.loadUrl = function() { assert.ok(true); };\n    Backbone.history.start({\n      pushState: true,\n      root: '/root'\n    });\n  });\n\n  QUnit.test('Normalize root - leading slash.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() {},\n        replaceState: function() {}\n      }\n    });\n    Backbone.history.start({root: 'root'});\n    assert.strictEqual(Backbone.history.root, '/root/');\n  });\n\n  QUnit.test('Transition from hashChange to pushState.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root#x/y');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() {},\n        replaceState: function(state, title, url) {\n          assert.strictEqual(url, '/root/x/y');\n        }\n      }\n    });\n    Backbone.history.start({\n      root: 'root',\n      pushState: true\n    });\n  });\n\n  QUnit.test('#1619: Router: Normalize empty root', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() {},\n        replaceState: function() {}\n      }\n    });\n    Backbone.history.start({root: ''});\n    assert.strictEqual(Backbone.history.root, '/');\n  });\n\n  QUnit.test('#1619: Router: nagivate with empty root', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/fragment');\n        }\n      }\n    });\n    Backbone.history.start({\n      pushState: true,\n      root: '',\n      hashChange: false\n    });\n    Backbone.history.navigate('fragment');\n  });\n\n  QUnit.test('Transition from pushState to hashChange.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root/x/y?a=b');\n    location.replace = function(url) {\n      assert.strictEqual(url, '/root#x/y?a=b');\n    };\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: null,\n        replaceState: null\n      }\n    });\n    Backbone.history.start({\n      root: 'root',\n      pushState: true\n    });\n  });\n\n  QUnit.test('#1695 - hashChange to pushState with search.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root#x/y?a=b');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() {},\n        replaceState: function(state, title, url) {\n          assert.strictEqual(url, '/root/x/y?a=b');\n        }\n      }\n    });\n    Backbone.history.start({\n      root: 'root',\n      pushState: true\n    });\n  });\n\n  QUnit.test('#1746 - Router allows empty route.', function(assert) {\n    assert.expect(1);\n    var MyRouter = Backbone.Router.extend({\n      routes: {'': 'empty'},\n      empty: function() {},\n      route: function(route) {\n        assert.strictEqual(route, '');\n      }\n    });\n    new MyRouter;\n  });\n\n  QUnit.test('#1794 - Trailing space in fragments.', function(assert) {\n    assert.expect(1);\n    var history = new Backbone.History;\n    assert.strictEqual(history.getFragment('fragment   '), 'fragment');\n  });\n\n  QUnit.test('#1820 - Leading slash and trailing space.', function(assert) {\n    assert.expect(1);\n    var history = new Backbone.History;\n    assert.strictEqual(history.getFragment('/fragment '), 'fragment');\n  });\n\n  QUnit.test('#1980 - Optional parameters.', function(assert) {\n    assert.expect(2);\n    location.replace('http://example.com#named/optional/y');\n    Backbone.history.checkUrl();\n    assert.strictEqual(router.z, undefined);\n    location.replace('http://example.com#named/optional/y123');\n    Backbone.history.checkUrl();\n    assert.strictEqual(router.z, '123');\n  });\n\n  QUnit.test('#2062 - Trigger \"route\" event on router instance.', function(assert) {\n    assert.expect(2);\n    router.on('route', function(name, args) {\n      assert.strictEqual(name, 'routeEvent');\n      assert.deepEqual(args, ['x', null]);\n    });\n    location.replace('http://example.com#route-event/x');\n    Backbone.history.checkUrl();\n  });\n\n  QUnit.test('#2255 - Extend routes by making routes a function.', function(assert) {\n    assert.expect(1);\n    var RouterBase = Backbone.Router.extend({\n      routes: function() {\n        return {\n          home: 'root',\n          index: 'index.html'\n        };\n      }\n    });\n\n    var RouterExtended = RouterBase.extend({\n      routes: function() {\n        var _super = RouterExtended.__super__.routes;\n        return _.extend(_super(), {show: 'show', search: 'search'});\n      }\n    });\n\n    var myRouter = new RouterExtended();\n    assert.deepEqual({home: 'root', index: 'index.html', show: 'show', search: 'search'}, myRouter.routes);\n  });\n\n  QUnit.test('#2538 - hashChange to pushState only if both requested.', function(assert) {\n    assert.expect(0);\n    Backbone.history.stop();\n    location.replace('http://example.com/root?a=b#x/y');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() {},\n        replaceState: function() { assert.ok(false); }\n      }\n    });\n    Backbone.history.start({\n      root: 'root',\n      pushState: true,\n      hashChange: false\n    });\n  });\n\n  QUnit.test('No hash fallback.', function(assert) {\n    assert.expect(0);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() {},\n        replaceState: function() {}\n      }\n    });\n\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        hash: function() { assert.ok(false); }\n      }\n    });\n    var myRouter = new MyRouter;\n\n    location.replace('http://example.com/');\n    Backbone.history.start({\n      pushState: true,\n      hashChange: false\n    });\n    location.replace('http://example.com/nomatch#hash');\n    Backbone.history.checkUrl();\n  });\n\n  QUnit.test('#2656 - No trailing slash on root.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/root');\n        }\n      }\n    });\n    location.replace('http://example.com/root/path');\n    Backbone.history.start({pushState: true, hashChange: false, root: 'root'});\n    Backbone.history.navigate('');\n  });\n\n  QUnit.test('#2656 - No trailing slash on root.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/');\n        }\n      }\n    });\n    location.replace('http://example.com/path');\n    Backbone.history.start({pushState: true, hashChange: false});\n    Backbone.history.navigate('');\n  });\n\n  QUnit.test('#2656 - No trailing slash on root.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/root?x=1');\n        }\n      }\n    });\n    location.replace('http://example.com/root/path');\n    Backbone.history.start({pushState: true, hashChange: false, root: 'root'});\n    Backbone.history.navigate('?x=1');\n  });\n\n  QUnit.test('#2765 - Fragment matching sans query/hash.', function(assert) {\n    assert.expect(2);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function(state, title, url) {\n          assert.strictEqual(url, '/path?query#hash');\n        }\n      }\n    });\n\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        path: function() { assert.ok(true); }\n      }\n    });\n    var myRouter = new MyRouter;\n\n    location.replace('http://example.com/');\n    Backbone.history.start({pushState: true, hashChange: false});\n    Backbone.history.navigate('path?query#hash', true);\n  });\n\n  QUnit.test('Do not decode the search params.', function(assert) {\n    assert.expect(1);\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        path: function(params) {\n          assert.strictEqual(params, 'x=y%3Fz');\n        }\n      }\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.navigate('path?x=y%3Fz', true);\n  });\n\n  QUnit.test('Navigate to a hash url.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({pushState: true});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        path: function(params) {\n          assert.strictEqual(params, 'x=y');\n        }\n      }\n    });\n    var myRouter = new MyRouter;\n    location.replace('http://example.com/path?x=y#hash');\n    Backbone.history.checkUrl();\n  });\n\n  QUnit.test('#navigate to a hash url.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    Backbone.history.start({pushState: true});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        path: function(params) {\n          assert.strictEqual(params, 'x=y');\n        }\n      }\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.navigate('path?x=y#hash', true);\n  });\n\n  QUnit.test('unicode pathname', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com/myyjä');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        myyjä: function() {\n          assert.ok(true);\n        }\n      }\n    });\n    new MyRouter;\n    Backbone.history.start({pushState: true});\n  });\n\n  QUnit.test('unicode pathname with % in a parameter', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com/myyjä/foo%20%25%3F%2f%40%25%20bar');\n    location.pathname = '/myyj%C3%A4/foo%20%25%3F%2f%40%25%20bar';\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        'myyjä/:query': function(query) {\n          assert.strictEqual(query, 'foo %?/@% bar');\n        }\n      }\n    });\n    new MyRouter;\n    Backbone.history.start({pushState: true});\n  });\n\n  QUnit.test('newline in route', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com/stuff%0Anonsense?param=foo%0Abar');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        'stuff\\nnonsense': function() {\n          assert.ok(true);\n        }\n      }\n    });\n    new MyRouter;\n    Backbone.history.start({pushState: true});\n  });\n\n  QUnit.test('Router#execute receives callback, args, name.', function(assert) {\n    assert.expect(3);\n    location.replace('http://example.com#foo/123/bar?x=y');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {'foo/:id/bar': 'foo'},\n      foo: function() {},\n      execute: function(callback, args, name) {\n        assert.strictEqual(callback, this.foo);\n        assert.deepEqual(args, ['123', 'x=y']);\n        assert.strictEqual(name, 'foo');\n      }\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.start();\n  });\n\n  QUnit.test('pushState to hashChange with only search params.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com?a=b');\n    location.replace = function(url) {\n      assert.strictEqual(url, '/#?a=b');\n    };\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: null\n    });\n    Backbone.history.start({pushState: true});\n  });\n\n  QUnit.test('#3123 - History#navigate decodes before comparison.', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/shop/search?keyword=short%20dress');\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: function() { assert.ok(false); },\n        replaceState: function() { assert.ok(false); }\n      }\n    });\n    Backbone.history.start({pushState: true});\n    Backbone.history.navigate('shop/search?keyword=short%20dress', true);\n    assert.strictEqual(Backbone.history.fragment, 'shop/search?keyword=short dress');\n  });\n\n  QUnit.test('#3175 - Urls in the params', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com#login?a=value&backUrl=https%3A%2F%2Fwww.msn.com%2Fidp%2Fidpdemo%3Fspid%3Dspdemo%26target%3Db');\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var myRouter = new Backbone.Router;\n    myRouter.route('login', function(params) {\n      assert.strictEqual(params, 'a=value&backUrl=https%3A%2F%2Fwww.msn.com%2Fidp%2Fidpdemo%3Fspid%3Dspdemo%26target%3Db');\n    });\n    Backbone.history.start();\n  });\n\n  QUnit.test('#3358 - pushState to hashChange transition with search params', function(assert) {\n    assert.expect(1);\n    Backbone.history.stop();\n    location.replace('http://example.com/root?foo=bar');\n    location.replace = function(url) {\n      assert.strictEqual(url, '/root#?foo=bar');\n    };\n    Backbone.history = _.extend(new Backbone.History, {\n      location: location,\n      history: {\n        pushState: undefined,\n        replaceState: undefined\n      }\n    });\n    Backbone.history.start({root: '/root', pushState: true});\n  });\n\n  QUnit.test('Paths that don\\'t match the root should not match no root', function(assert) {\n    assert.expect(0);\n    location.replace('http://example.com/foo');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        foo: function() {\n          assert.ok(false, 'should not match unless root matches');\n        }\n      }\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.start({root: 'root', pushState: true});\n  });\n\n  QUnit.test('Paths that don\\'t match the root should not match roots of the same length', function(assert) {\n    assert.expect(0);\n    location.replace('http://example.com/xxxx/foo');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {\n        foo: function() {\n          assert.ok(false, 'should not match unless root matches');\n        }\n      }\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.start({root: 'root', pushState: true});\n  });\n\n  QUnit.test('roots with regex characters', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com/x+y.z/foo');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {foo: function() { assert.ok(true); }}\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.start({root: 'x+y.z', pushState: true});\n  });\n\n  QUnit.test('roots with unicode characters', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com/®ooτ/foo');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {foo: function() { assert.ok(true); }}\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.start({root: '®ooτ', pushState: true});\n  });\n\n  QUnit.test('roots without slash', function(assert) {\n    assert.expect(1);\n    location.replace('http://example.com/®ooτ');\n    Backbone.history.stop();\n    Backbone.history = _.extend(new Backbone.History, {location: location});\n    var MyRouter = Backbone.Router.extend({\n      routes: {'': function() { assert.ok(true); }}\n    });\n    var myRouter = new MyRouter;\n    Backbone.history.start({root: '®ooτ', pushState: true});\n  });\n\n  QUnit.test('#4025 - navigate updates URL hash as is', function(assert) {\n    assert.expect(1);\n    var route = 'search/has%20space';\n    Backbone.history.navigate(route);\n    assert.strictEqual(location.hash, '#' + route);\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 32998,
                    tokens: 3661,
                    lastModified: '2025-07-02T12:28:22.860Z',
                  },
                  {
                    name: 'sync.js',
                    path: 'vendor/backbone/test/sync.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  var Library = Backbone.Collection.extend({\n    url: function() { return '/library'; }\n  });\n  var library;\n\n  var attrs = {\n    title: 'The Tempest',\n    author: 'Bill Shakespeare',\n    length: 123\n  };\n\n  QUnit.module('Backbone.sync', {\n\n    beforeEach: function(assert) {\n      library = new Library;\n      library.create(attrs, {wait: false});\n    },\n\n    afterEach: function(assert) {\n      Backbone.emulateHTTP = false;\n    }\n\n  });\n\n  QUnit.test('read', function(assert) {\n    assert.expect(4);\n    library.fetch();\n    assert.equal(this.ajaxSettings.url, '/library');\n    assert.equal(this.ajaxSettings.type, 'GET');\n    assert.equal(this.ajaxSettings.dataType, 'json');\n    assert.ok(_.isEmpty(this.ajaxSettings.data));\n  });\n\n  QUnit.test('passing data', function(assert) {\n    assert.expect(3);\n    library.fetch({data: {a: 'a', one: 1}});\n    assert.equal(this.ajaxSettings.url, '/library');\n    assert.equal(this.ajaxSettings.data.a, 'a');\n    assert.equal(this.ajaxSettings.data.one, 1);\n  });\n\n  QUnit.test('create', function(assert) {\n    assert.expect(6);\n    assert.equal(this.ajaxSettings.url, '/library');\n    assert.equal(this.ajaxSettings.type, 'POST');\n    assert.equal(this.ajaxSettings.dataType, 'json');\n    var data = JSON.parse(this.ajaxSettings.data);\n    assert.equal(data.title, 'The Tempest');\n    assert.equal(data.author, 'Bill Shakespeare');\n    assert.equal(data.length, 123);\n  });\n\n  QUnit.test('update', function(assert) {\n    assert.expect(7);\n    library.first().save({id: '1-the-tempest', author: 'William Shakespeare'});\n    assert.equal(this.ajaxSettings.url, '/library/1-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'PUT');\n    assert.equal(this.ajaxSettings.dataType, 'json');\n    var data = JSON.parse(this.ajaxSettings.data);\n    assert.equal(data.id, '1-the-tempest');\n    assert.equal(data.title, 'The Tempest');\n    assert.equal(data.author, 'William Shakespeare');\n    assert.equal(data.length, 123);\n  });\n\n  QUnit.test('update with emulateHTTP and emulateJSON', function(assert) {\n    assert.expect(7);\n    library.first().save({id: '2-the-tempest', author: 'Tim Shakespeare'}, {\n      emulateHTTP: true,\n      emulateJSON: true\n    });\n    assert.equal(this.ajaxSettings.url, '/library/2-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'POST');\n    assert.equal(this.ajaxSettings.dataType, 'json');\n    assert.equal(this.ajaxSettings.data._method, 'PUT');\n    var data = JSON.parse(this.ajaxSettings.data.model);\n    assert.equal(data.id, '2-the-tempest');\n    assert.equal(data.author, 'Tim Shakespeare');\n    assert.equal(data.length, 123);\n  });\n\n  QUnit.test('update with just emulateHTTP', function(assert) {\n    assert.expect(6);\n    library.first().save({id: '2-the-tempest', author: 'Tim Shakespeare'}, {\n      emulateHTTP: true\n    });\n    assert.equal(this.ajaxSettings.url, '/library/2-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'POST');\n    assert.equal(this.ajaxSettings.contentType, 'application/json');\n    var data = JSON.parse(this.ajaxSettings.data);\n    assert.equal(data.id, '2-the-tempest');\n    assert.equal(data.author, 'Tim Shakespeare');\n    assert.equal(data.length, 123);\n  });\n\n  QUnit.test('update with just emulateJSON', function(assert) {\n    assert.expect(6);\n    library.first().save({id: '2-the-tempest', author: 'Tim Shakespeare'}, {\n      emulateJSON: true\n    });\n    assert.equal(this.ajaxSettings.url, '/library/2-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'PUT');\n    assert.equal(this.ajaxSettings.contentType, 'application/x-www-form-urlencoded');\n    var data = JSON.parse(this.ajaxSettings.data.model);\n    assert.equal(data.id, '2-the-tempest');\n    assert.equal(data.author, 'Tim Shakespeare');\n    assert.equal(data.length, 123);\n  });\n\n  QUnit.test('read model', function(assert) {\n    assert.expect(3);\n    library.first().save({id: '2-the-tempest', author: 'Tim Shakespeare'});\n    library.first().fetch();\n    assert.equal(this.ajaxSettings.url, '/library/2-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'GET');\n    assert.ok(_.isEmpty(this.ajaxSettings.data));\n  });\n\n  QUnit.test('destroy', function(assert) {\n    assert.expect(3);\n    library.first().save({id: '2-the-tempest', author: 'Tim Shakespeare'});\n    library.first().destroy({wait: true});\n    assert.equal(this.ajaxSettings.url, '/library/2-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'DELETE');\n    assert.equal(this.ajaxSettings.data, null);\n  });\n\n  QUnit.test('destroy with emulateHTTP', function(assert) {\n    assert.expect(3);\n    library.first().save({id: '2-the-tempest', author: 'Tim Shakespeare'});\n    library.first().destroy({\n      emulateHTTP: true,\n      emulateJSON: true\n    });\n    assert.equal(this.ajaxSettings.url, '/library/2-the-tempest');\n    assert.equal(this.ajaxSettings.type, 'POST');\n    assert.equal(JSON.stringify(this.ajaxSettings.data), '{\"_method\":\"DELETE\"}');\n  });\n\n  QUnit.test('urlError', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model();\n    assert.raises(function() {\n      model.fetch();\n    });\n    model.fetch({url: '/one/two'});\n    assert.equal(this.ajaxSettings.url, '/one/two');\n  });\n\n  QUnit.test('#1052 - `options` is optional.', function(assert) {\n    assert.expect(0);\n    var model = new Backbone.Model();\n    model.url = '/test';\n    Backbone.sync('create', model);\n  });\n\n  QUnit.test('Backbone.ajax', function(assert) {\n    assert.expect(1);\n    Backbone.ajax = function(settings) {\n      assert.strictEqual(settings.url, '/test');\n    };\n    var model = new Backbone.Model();\n    model.url = '/test';\n    Backbone.sync('create', model);\n  });\n\n  QUnit.test('Call provided error callback on error.', function(assert) {\n    assert.expect(1);\n    var model = new Backbone.Model;\n    model.url = '/test';\n    Backbone.sync('read', model, {\n      error: function() { assert.ok(true); }\n    });\n    this.ajaxSettings.error();\n  });\n\n  QUnit.test('Use Backbone.emulateHTTP as default.', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model;\n    model.url = '/test';\n\n    Backbone.emulateHTTP = true;\n    model.sync('create', model);\n    assert.strictEqual(this.ajaxSettings.emulateHTTP, true);\n\n    Backbone.emulateHTTP = false;\n    model.sync('create', model);\n    assert.strictEqual(this.ajaxSettings.emulateHTTP, false);\n  });\n\n  QUnit.test('Use Backbone.emulateJSON as default.', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model;\n    model.url = '/test';\n\n    Backbone.emulateJSON = true;\n    model.sync('create', model);\n    assert.strictEqual(this.ajaxSettings.emulateJSON, true);\n\n    Backbone.emulateJSON = false;\n    model.sync('create', model);\n    assert.strictEqual(this.ajaxSettings.emulateJSON, false);\n  });\n\n  QUnit.test('#1756 - Call user provided beforeSend function.', function(assert) {\n    assert.expect(4);\n    Backbone.emulateHTTP = true;\n    var model = new Backbone.Model;\n    model.url = '/test';\n    var xhr = {\n      setRequestHeader: function(header, value) {\n        assert.strictEqual(header, 'X-HTTP-Method-Override');\n        assert.strictEqual(value, 'DELETE');\n      }\n    };\n    model.sync('delete', model, {\n      beforeSend: function(_xhr) {\n        assert.ok(_xhr === xhr);\n        return false;\n      }\n    });\n    assert.strictEqual(this.ajaxSettings.beforeSend(xhr), false);\n  });\n\n  QUnit.test('#2928 - Pass along `textStatus` and `errorThrown`.', function(assert) {\n    assert.expect(2);\n    var model = new Backbone.Model;\n    model.url = '/test';\n    model.on('error', function(m, xhr, options) {\n      assert.strictEqual(options.textStatus, 'textStatus');\n      assert.strictEqual(options.errorThrown, 'errorThrown');\n    });\n    model.fetch();\n    this.ajaxSettings.error({}, 'textStatus', 'errorThrown');\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 7859,
                    tokens: 943,
                    lastModified: '2025-07-02T12:28:22.860Z',
                  },
                  {
                    name: 'view.js',
                    path: 'vendor/backbone/test/view.js',
                    type: 'file',
                    content:
                      "(function(QUnit) {\n\n  var view;\n\n  QUnit.module('Backbone.View', {\n\n    beforeEach: function() {\n      $('#qunit-fixture').append(\n        '<div id=\"testElement\"><h1>Test</h1></div>'\n     );\n\n      view = new Backbone.View({\n        id: 'test-view',\n        className: 'test-view',\n        other: 'non-special-option'\n      });\n    },\n\n    afterEach: function() {\n      $('#testElement').remove();\n      $('#test-view').remove();\n    }\n\n  });\n\n  QUnit.test('constructor', function(assert) {\n    assert.expect(3);\n    assert.equal(view.el.id, 'test-view');\n    assert.equal(view.el.className, 'test-view');\n    assert.equal(view.el.other, void 0);\n  });\n\n  QUnit.test('$', function(assert) {\n    assert.expect(2);\n    var myView = new Backbone.View;\n    myView.setElement('<p><a><b>test</b></a></p>');\n    var result = myView.$('a b');\n\n    assert.strictEqual(result[0].innerHTML, 'test');\n    assert.ok(result.length === +result.length);\n  });\n\n  QUnit.test('$el', function(assert) {\n    assert.expect(3);\n    var myView = new Backbone.View;\n    myView.setElement('<p><a><b>test</b></a></p>');\n    assert.strictEqual(myView.el.nodeType, 1);\n\n    assert.ok(myView.$el instanceof Backbone.$);\n    assert.strictEqual(myView.$el[0], myView.el);\n  });\n\n  QUnit.test('initialize', function(assert) {\n    assert.expect(1);\n    var View = Backbone.View.extend({\n      initialize: function() {\n        this.one = 1;\n      }\n    });\n\n    assert.strictEqual(new View().one, 1);\n  });\n\n  QUnit.test('preinitialize', function(assert) {\n    assert.expect(1);\n    var View = Backbone.View.extend({\n      preinitialize: function() {\n        this.one = 1;\n      }\n    });\n\n    assert.strictEqual(new View().one, 1);\n  });\n\n  QUnit.test('preinitialize occurs before the view is set up', function(assert) {\n    assert.expect(2);\n    var View = Backbone.View.extend({\n      preinitialize: function() {\n        assert.equal(this.el, undefined);\n      }\n    });\n    var _view = new View({});\n    assert.notEqual(_view.el, undefined);\n  });\n\n  QUnit.test('render', function(assert) {\n    assert.expect(1);\n    var myView = new Backbone.View;\n    assert.equal(myView.render(), myView, '#render returns the view instance');\n  });\n\n  QUnit.test('delegateEvents', function(assert) {\n    assert.expect(6);\n    var counter1 = 0, counter2 = 0;\n\n    var myView = new Backbone.View({el: '#testElement'});\n    myView.increment = function() { counter1++; };\n    myView.$el.on('click', function() { counter2++; });\n\n    var events = {'click h1': 'increment'};\n\n    myView.delegateEvents(events);\n    myView.$('h1').trigger('click');\n    assert.equal(counter1, 1);\n    assert.equal(counter2, 1);\n\n    myView.$('h1').trigger('click');\n    assert.equal(counter1, 2);\n    assert.equal(counter2, 2);\n\n    myView.delegateEvents(events);\n    myView.$('h1').trigger('click');\n    assert.equal(counter1, 3);\n    assert.equal(counter2, 3);\n  });\n\n  QUnit.test('delegate', function(assert) {\n    assert.expect(3);\n    var myView = new Backbone.View({el: '#testElement'});\n    myView.delegate('click', 'h1', function() {\n      assert.ok(true);\n    });\n    myView.delegate('click', function() {\n      assert.ok(true);\n    });\n    myView.$('h1').trigger('click');\n\n    assert.equal(myView.delegate(), myView, '#delegate returns the view instance');\n  });\n\n  QUnit.test('delegateEvents allows functions for callbacks', function(assert) {\n    assert.expect(3);\n    var myView = new Backbone.View({el: '<p></p>'});\n    myView.counter = 0;\n\n    var events = {\n      click: function() {\n        this.counter++;\n      }\n    };\n\n    myView.delegateEvents(events);\n    myView.$el.trigger('click');\n    assert.equal(myView.counter, 1);\n\n    myView.$el.trigger('click');\n    assert.equal(myView.counter, 2);\n\n    myView.delegateEvents(events);\n    myView.$el.trigger('click');\n    assert.equal(myView.counter, 3);\n  });\n\n  QUnit.test('delegateEvents ignore undefined methods', function(assert) {\n    assert.expect(0);\n    var myView = new Backbone.View({el: '<p></p>'});\n    myView.delegateEvents({click: 'undefinedMethod'});\n    myView.$el.trigger('click');\n  });\n\n  QUnit.test('undelegateEvents', function(assert) {\n    assert.expect(7);\n    var counter1 = 0, counter2 = 0;\n\n    var myView = new Backbone.View({el: '#testElement'});\n    myView.increment = function() { counter1++; };\n    myView.$el.on('click', function() { counter2++; });\n\n    var events = {'click h1': 'increment'};\n\n    myView.delegateEvents(events);\n    myView.$('h1').trigger('click');\n    assert.equal(counter1, 1);\n    assert.equal(counter2, 1);\n\n    myView.undelegateEvents();\n    myView.$('h1').trigger('click');\n    assert.equal(counter1, 1);\n    assert.equal(counter2, 2);\n\n    myView.delegateEvents(events);\n    myView.$('h1').trigger('click');\n    assert.equal(counter1, 2);\n    assert.equal(counter2, 3);\n\n    assert.equal(myView.undelegateEvents(), myView, '#undelegateEvents returns the view instance');\n  });\n\n  QUnit.test('undelegate', function(assert) {\n    assert.expect(1);\n    var myView = new Backbone.View({el: '#testElement'});\n    myView.delegate('click', function() { assert.ok(false); });\n    myView.delegate('click', 'h1', function() { assert.ok(false); });\n\n    myView.undelegate('click');\n\n    myView.$('h1').trigger('click');\n    myView.$el.trigger('click');\n\n    assert.equal(myView.undelegate(), myView, '#undelegate returns the view instance');\n  });\n\n  QUnit.test('undelegate with passed handler', function(assert) {\n    assert.expect(1);\n    var myView = new Backbone.View({el: '#testElement'});\n    var listener = function() { assert.ok(false); };\n    myView.delegate('click', listener);\n    myView.delegate('click', function() { assert.ok(true); });\n    myView.undelegate('click', listener);\n    myView.$el.trigger('click');\n  });\n\n  QUnit.test('undelegate with selector', function(assert) {\n    assert.expect(2);\n    var myView = new Backbone.View({el: '#testElement'});\n    myView.delegate('click', function() { assert.ok(true); });\n    myView.delegate('click', 'h1', function() { assert.ok(false); });\n    myView.undelegate('click', 'h1');\n    myView.$('h1').trigger('click');\n    myView.$el.trigger('click');\n  });\n\n  QUnit.test('undelegate with handler and selector', function(assert) {\n    assert.expect(2);\n    var myView = new Backbone.View({el: '#testElement'});\n    myView.delegate('click', function() { assert.ok(true); });\n    var handler = function() { assert.ok(false); };\n    myView.delegate('click', 'h1', handler);\n    myView.undelegate('click', 'h1', handler);\n    myView.$('h1').trigger('click');\n    myView.$el.trigger('click');\n  });\n\n  QUnit.test('tagName can be provided as a string', function(assert) {\n    assert.expect(1);\n    var View = Backbone.View.extend({\n      tagName: 'span'\n    });\n\n    assert.equal(new View().el.tagName, 'SPAN');\n  });\n\n  QUnit.test('tagName can be provided as a function', function(assert) {\n    assert.expect(1);\n    var View = Backbone.View.extend({\n      tagName: function() {\n        return 'p';\n      }\n    });\n\n    assert.ok(new View().$el.is('p'));\n  });\n\n  QUnit.test('_ensureElement with DOM node el', function(assert) {\n    assert.expect(1);\n    var View = Backbone.View.extend({\n      el: document.body\n    });\n\n    assert.equal(new View().el, document.body);\n  });\n\n  QUnit.test('_ensureElement with string el', function(assert) {\n    assert.expect(3);\n    var View = Backbone.View.extend({\n      el: 'body'\n    });\n    assert.strictEqual(new View().el, document.body);\n\n    View = Backbone.View.extend({\n      el: '#testElement > h1'\n    });\n    assert.strictEqual(new View().el, $('#testElement > h1').get(0));\n\n    View = Backbone.View.extend({\n      el: '#nonexistent'\n    });\n    assert.ok(!new View().el);\n  });\n\n  QUnit.test('with className and id functions', function(assert) {\n    assert.expect(2);\n    var View = Backbone.View.extend({\n      className: function() {\n        return 'className';\n      },\n      id: function() {\n        return 'id';\n      }\n    });\n\n    assert.strictEqual(new View().el.className, 'className');\n    assert.strictEqual(new View().el.id, 'id');\n  });\n\n  QUnit.test('with attributes', function(assert) {\n    assert.expect(2);\n    var View = Backbone.View.extend({\n      attributes: {\n        'id': 'id',\n        'class': 'class'\n      }\n    });\n\n    assert.strictEqual(new View().el.className, 'class');\n    assert.strictEqual(new View().el.id, 'id');\n  });\n\n  QUnit.test('with attributes as a function', function(assert) {\n    assert.expect(1);\n    var View = Backbone.View.extend({\n      attributes: function() {\n        return {'class': 'dynamic'};\n      }\n    });\n\n    assert.strictEqual(new View().el.className, 'dynamic');\n  });\n\n  QUnit.test('should default to className/id properties', function(assert) {\n    assert.expect(4);\n    var View = Backbone.View.extend({\n      className: 'backboneClass',\n      id: 'backboneId',\n      attributes: {\n        'class': 'attributeClass',\n        'id': 'attributeId'\n      }\n    });\n\n    var myView = new View;\n    assert.strictEqual(myView.el.className, 'backboneClass');\n    assert.strictEqual(myView.el.id, 'backboneId');\n    assert.strictEqual(myView.$el.attr('class'), 'backboneClass');\n    assert.strictEqual(myView.$el.attr('id'), 'backboneId');\n  });\n\n  QUnit.test('multiple views per element', function(assert) {\n    assert.expect(3);\n    var count = 0;\n    var $el = $('<p></p>');\n\n    var View = Backbone.View.extend({\n      el: $el,\n      events: {\n        click: function() {\n          count++;\n        }\n      }\n    });\n\n    var view1 = new View;\n    $el.trigger('click');\n    assert.equal(1, count);\n\n    var view2 = new View;\n    $el.trigger('click');\n    assert.equal(3, count);\n\n    view1.delegateEvents();\n    $el.trigger('click');\n    assert.equal(5, count);\n  });\n\n  QUnit.test('custom events', function(assert) {\n    assert.expect(2);\n    var View = Backbone.View.extend({\n      el: $('body'),\n      events: {\n        fake$event: function() { assert.ok(true); }\n      }\n    });\n\n    var myView = new View;\n    $('body').trigger('fake$event').trigger('fake$event');\n\n    $('body').off('fake$event');\n    $('body').trigger('fake$event');\n  });\n\n  QUnit.test('#1048 - setElement uses provided object.', function(assert) {\n    assert.expect(2);\n    var $el = $('body');\n\n    var myView = new Backbone.View({el: $el});\n    assert.ok(myView.$el === $el);\n\n    myView.setElement($el = $($el));\n    assert.ok(myView.$el === $el);\n  });\n\n  QUnit.test('#986 - Undelegate before changing element.', function(assert) {\n    assert.expect(1);\n    var button1 = $('<button></button>');\n    var button2 = $('<button></button>');\n\n    var View = Backbone.View.extend({\n      events: {\n        click: function(e) {\n          assert.ok(myView.el === e.target);\n        }\n      }\n    });\n\n    var myView = new View({el: button1});\n    myView.setElement(button2);\n\n    button1.trigger('click');\n    button2.trigger('click');\n  });\n\n  QUnit.test('#1172 - Clone attributes object', function(assert) {\n    assert.expect(2);\n    var View = Backbone.View.extend({\n      attributes: {foo: 'bar'}\n    });\n\n    var view1 = new View({id: 'foo'});\n    assert.strictEqual(view1.el.id, 'foo');\n\n    var view2 = new View();\n    assert.ok(!view2.el.id);\n  });\n\n  QUnit.test('views stopListening', function(assert) {\n    assert.expect(0);\n    var View = Backbone.View.extend({\n      initialize: function() {\n        this.listenTo(this.model, 'all x', function() { assert.ok(false); });\n        this.listenTo(this.collection, 'all x', function() { assert.ok(false); });\n      }\n    });\n\n    var myView = new View({\n      model: new Backbone.Model,\n      collection: new Backbone.Collection\n    });\n\n    myView.stopListening();\n    myView.model.trigger('x');\n    myView.collection.trigger('x');\n  });\n\n  QUnit.test('Provide function for el.', function(assert) {\n    assert.expect(2);\n    var View = Backbone.View.extend({\n      el: function() {\n        return '<p><a></a></p>';\n      }\n    });\n\n    var myView = new View;\n    assert.ok(myView.$el.is('p'));\n    assert.ok(myView.$el.has('a'));\n  });\n\n  QUnit.test('events passed in options', function(assert) {\n    assert.expect(1);\n    var counter = 0;\n\n    var View = Backbone.View.extend({\n      el: '#testElement',\n      increment: function() {\n        counter++;\n      }\n    });\n\n    var myView = new View({\n      events: {\n        'click h1': 'increment'\n      }\n    });\n\n    myView.$('h1').trigger('click').trigger('click');\n    assert.equal(counter, 2);\n  });\n\n  QUnit.test('remove', function(assert) {\n    assert.expect(2);\n    var myView = new Backbone.View;\n    document.body.appendChild(view.el);\n\n    myView.delegate('click', function() { assert.ok(false); });\n    myView.listenTo(myView, 'all x', function() { assert.ok(false); });\n\n    assert.equal(myView.remove(), myView, '#remove returns the view instance');\n    myView.$el.trigger('click');\n    myView.trigger('x');\n\n    // In IE8 and below, parentNode still exists but is not document.body.\n    assert.notEqual(myView.el.parentNode, document.body);\n  });\n\n  QUnit.test('setElement', function(assert) {\n    assert.expect(3);\n    var myView = new Backbone.View({\n      events: {\n        click: function() { assert.ok(false); }\n      }\n    });\n    myView.events = {\n      click: function() { assert.ok(true); }\n    };\n    var oldEl = myView.el;\n    var $oldEl = myView.$el;\n\n    myView.setElement(document.createElement('div'));\n\n    $oldEl.click();\n    myView.$el.click();\n\n    assert.notEqual(oldEl, myView.el);\n    assert.notEqual($oldEl, myView.$el);\n  });\n\n})(QUnit);\n",
                    language: 'javascript',
                    size: 13574,
                    tokens: 1622,
                    lastModified: '2025-07-02T12:28:22.861Z',
                  },
                ],
              },
              {
                name: 'backbone.js',
                path: 'vendor/backbone/backbone.js',
                type: 'file',
                content:
                  "//     Backbone.js 1.3.3\n\n//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(factory) {\n\n  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\n  // We use `self` instead of `window` for `WebWorker` support.\n  var root = (typeof self == 'object' && self.self === self && self) ||\n            (typeof global == 'object' && global.global === global && global);\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore'), $;\n    try { $ = require('jquery'); } catch (e) {}\n    factory(root, exports, _, $);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n})(function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create a local reference to a common array method we'll want to use later.\n  var slice = Array.prototype.slice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.3.3';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... this will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Proxy Backbone class methods to Underscore functions, wrapping the model's\n  // `attributes` object or collection's `models` array behind the scenes.\n  //\n  // collection.filter(function(model) { return model.get('age') > 10 });\n  // collection.each(this.addView);\n  //\n  // `Function#apply` can be slow so we use the method's arg count, if we know it.\n  var addMethod = function(length, method, attribute) {\n    switch (length) {\n      case 1: return function() {\n        return _[method](this[attribute]);\n      };\n      case 2: return function(value) {\n        return _[method](this[attribute], value);\n      };\n      case 3: return function(iteratee, context) {\n        return _[method](this[attribute], cb(iteratee, this), context);\n      };\n      case 4: return function(iteratee, defaultVal, context) {\n        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);\n      };\n      default: return function() {\n        var args = slice.call(arguments);\n        args.unshift(this[attribute]);\n        return _[method].apply(_, args);\n      };\n    }\n  };\n  var addUnderscoreMethods = function(Class, methods, attribute) {\n    _.each(methods, function(length, method) {\n      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);\n    });\n  };\n\n  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\n  var cb = function(iteratee, instance) {\n    if (_.isFunction(iteratee)) return iteratee;\n    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n  };\n  var modelMatcher = function(attrs) {\n    var matcher = _.matches(attrs);\n    return function(model) {\n      return matcher(model.attributes);\n    };\n  };\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // a custom event channel. You may bind a callback to an event with `on` or\n  // remove with `off`; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {};\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Iterates over the standard `event, callback` (as well as the fancy multiple\n  // space-separated events `\"change blur\", callback` and jQuery-style event\n  // maps `{event: callback}`).\n  var eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n      for (names = _.keys(name); i < names.length ; i++) {\n        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n      }\n    } else if (name && eventSplitter.test(name)) {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++) {\n        events = iteratee(events, names[i], callback, opts);\n      }\n    } else {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n    }\n    return events;\n  };\n\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  Events.on = function(name, callback, context) {\n    return internalOn(this, name, callback, context);\n  };\n\n  // Guard the `listening` argument from the public API.\n  var internalOn = function(obj, name, callback, context, listening) {\n    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\n      context: context,\n      ctx: obj,\n      listening: listening\n    });\n\n    if (listening) {\n      var listeners = obj._listeners || (obj._listeners = {});\n      listeners[listening.id] = listening;\n    }\n\n    return obj;\n  };\n\n  // Inversion-of-control versions of `on`. Tell *this* object to listen to\n  // an event in another object... keeping track of what it's listening to\n  // for easier unbinding later.\n  Events.listenTo = function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));\n      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};\n    }\n\n    // Bind callbacks on obj, and keep track of them on listening.\n    internalOn(obj, name, callback, this, listening);\n    return this;\n  };\n\n  // The reducing API that adds a callback to the `events` object.\n  var onApi = function(events, name, callback, options) {\n    if (callback) {\n      var handlers = events[name] || (events[name] = []);\n      var context = options.context, ctx = options.ctx, listening = options.listening;\n      if (listening) listening.count++;\n\n      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});\n    }\n    return events;\n  };\n\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  Events.off = function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n      context: context,\n      listeners: this._listeners\n    });\n    return this;\n  };\n\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  Events.stopListening = function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : _.keys(listeningTo);\n\n    for (var i = 0; i < ids.length; i++) {\n      var listening = listeningTo[ids[i]];\n\n      // If listening doesn't exist, this object is not currently\n      // listening to obj. Break out early.\n      if (!listening) break;\n\n      listening.obj.off(name, callback, this);\n    }\n\n    return this;\n  };\n\n  // The reducing API that removes a callback from the `events` object.\n  var offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var i = 0, listening;\n    var context = options.context, listeners = options.listeners;\n\n    // Delete all events listeners and \"drop\" events.\n    if (!name && !callback && !context) {\n      var ids = _.keys(listeners);\n      for (; i < ids.length; i++) {\n        listening = listeners[ids[i]];\n        delete listeners[listening.id];\n        delete listening.listeningTo[listening.objId];\n      }\n      return;\n    }\n\n    var names = name ? [name] : _.keys(events);\n    for (; i < names.length; i++) {\n      name = names[i];\n      var handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) break;\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      var remaining = [];\n      for (var j = 0; j < handlers.length; j++) {\n        var handler = handlers[j];\n        if (\n          callback && callback !== handler.callback &&\n            callback !== handler.callback._callback ||\n              context && context !== handler.context\n        ) {\n          remaining.push(handler);\n        } else {\n          listening = handler.listening;\n          if (listening && --listening.count === 0) {\n            delete listeners[listening.id];\n            delete listening.listeningTo[listening.objId];\n          }\n        }\n      }\n\n      // Update tail event if the list has any events.  Otherwise, clean up.\n      if (remaining.length) {\n        events[name] = remaining;\n      } else {\n        delete events[name];\n      }\n    }\n    return events;\n  };\n\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, its listener will be removed. If multiple events\n  // are passed in using the space-separated syntax, the handler will fire\n  // once for each event, not once for a combination of all events.\n  Events.once = function(name, callback, context) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));\n    if (typeof name === 'string' && context == null) callback = void 0;\n    return this.on(events, callback, context);\n  };\n\n  // Inversion-of-control versions of `once`.\n  Events.listenToOnce = function(obj, name, callback) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));\n    return this.listenTo(obj, events);\n  };\n\n  // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n  // `offer` unbinds the `onceWrapper` after it has been called.\n  var onceMap = function(map, name, callback, offer) {\n    if (callback) {\n      var once = map[name] = _.once(function() {\n        offer(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n    }\n    return map;\n  };\n\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  Events.trigger = function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n  };\n\n  // Handles triggering the appropriate event callbacks.\n  var triggerApi = function(objEvents, name, callback, args) {\n    if (objEvents) {\n      var events = objEvents[name];\n      var allEvents = objEvents.all;\n      if (events && allEvents) allEvents = allEvents.slice();\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    this.cid = _.uniqueId(this.cidPrefix);\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    var defaults = _.result(this, 'defaults');\n    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // The prefix is used to create the client id which is used to identify models locally.\n    // You may want to override this if you're experiencing name clashes with model ids.\n    cidPrefix: 'c',\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Model.\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Special-cased proxy to underscore's `_.matches` method.\n    matches: function(attrs) {\n      return !!_.iteratee(attrs, this)(this.attributes);\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      var attrs;\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      var unset      = options.unset;\n      var silent     = options.silent;\n      var changes    = [];\n      var changing   = this._changing;\n      this._changing = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n\n      var current = this.attributes;\n      var changed = this.changed;\n      var prev    = this._previousAttributes;\n\n      // For each `set` attribute, update or delete the current value.\n      for (var attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          changed[attr] = val;\n        } else {\n          delete changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Update the `id`.\n      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0; i < changes.length; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      var changed = {};\n      var hasChanged;\n      for (var attr in diff) {\n        var val = diff[attr];\n        if (_.isEqual(old[attr], val)) continue;\n        changed[attr] = val;\n        hasChanged = true;\n      }\n      return hasChanged ? changed : false;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server, merging the response with the model's\n    // local attributes. Any changed attributes will trigger a \"change\" event.\n    fetch: function(options) {\n      options = _.extend({parse: true}, options);\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n        if (!model.set(serverAttrs, options)) return false;\n        if (success) success.call(options.context, model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      var attrs;\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true, parse: true}, options);\n      var wait = options.wait;\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !wait) {\n        if (!this.set(attrs, options)) return false;\n      } else if (!this._validate(attrs, options)) {\n        return false;\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      var model = this;\n      var success = options.success;\n      var attributes = this.attributes;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\n        if (serverAttrs && !model.set(serverAttrs, options)) return false;\n        if (success) success.call(options.context, model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\n      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\n\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\n      var xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n      var wait = options.wait;\n\n      var destroy = function() {\n        model.stopListening();\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (wait) destroy();\n        if (success) success.call(options.context, model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      var xhr = false;\n      if (this.isNew()) {\n        _.defer(options.success);\n      } else {\n        wrapError(this, options);\n        xhr = this.sync('delete', this, options);\n      }\n      if (!wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      var id = this.get(this.idAttribute);\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend({}, options, {validate: true}));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model, mapped to the\n  // number of arguments they take.\n  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,\n      omit: 0, chain: 1, isEmpty: 1};\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  addUnderscoreMethods(Model, modelMethods, 'attributes');\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analogous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Splices `insert` into `array` at index `at`.\n  var splice = function(array, insert, at) {\n    at = Math.min(Math.max(at, 0), array.length);\n    var tail = Array(array.length - at);\n    var length = insert.length;\n    var i;\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n  };\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model) { return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set. `models` may be Backbone\n    // Models or raw JavaScript objects to be converted to Models, or any\n    // combination of the two.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      options = _.extend({}, options);\n      var singular = !_.isArray(models);\n      models = singular ? [models] : models.slice();\n      var removed = this._removeModels(models, options);\n      if (!options.silent && removed.length) {\n        options.changes = {added: [], merged: [], removed: removed};\n        this.trigger('update', this, options);\n      }\n      return singular ? removed[0] : removed;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      if (models == null) return;\n\n      options = _.extend({}, setOptions, options);\n      if (options.parse && !this._isModel(models)) {\n        models = this.parse(models, options) || [];\n      }\n\n      var singular = !_.isArray(models);\n      models = singular ? [models] : models.slice();\n\n      var at = options.at;\n      if (at != null) at = +at;\n      if (at > this.length) at = this.length;\n      if (at < 0) at += this.length + 1;\n\n      var set = [];\n      var toAdd = [];\n      var toMerge = [];\n      var toRemove = [];\n      var modelMap = {};\n\n      var add = options.add;\n      var merge = options.merge;\n      var remove = options.remove;\n\n      var sort = false;\n      var sortable = this.comparator && at == null && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      var model, i;\n      for (i = 0; i < models.length; i++) {\n        model = models[i];\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        var existing = this.get(model);\n        if (existing) {\n          if (merge && model !== existing) {\n            var attrs = this._isModel(model) ? model.attributes : model;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            toMerge.push(existing);\n            if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n          }\n          if (!modelMap[existing.cid]) {\n            modelMap[existing.cid] = true;\n            set.push(existing);\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(model, options);\n          if (model) {\n            toAdd.push(model);\n            this._addReference(model, options);\n            modelMap[model.cid] = true;\n            set.push(model);\n          }\n        }\n      }\n\n      // Remove stale models.\n      if (remove) {\n        for (i = 0; i < this.length; i++) {\n          model = this.models[i];\n          if (!modelMap[model.cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this._removeModels(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      var orderChanged = false;\n      var replace = !sortable && add && remove;\n      if (set.length && replace) {\n        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {\n          return m !== set[index];\n        });\n        this.models.length = 0;\n        splice(this.models, set, 0);\n        this.length = this.models.length;\n      } else if (toAdd.length) {\n        if (sortable) sort = true;\n        splice(this.models, toAdd, at == null ? this.length : at);\n        this.length = this.models.length;\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort/update events.\n      if (!options.silent) {\n        for (i = 0; i < toAdd.length; i++) {\n          if (at != null) options.index = at + i;\n          model = toAdd[i];\n          model.trigger('add', model, this, options);\n        }\n        if (sort || orderChanged) this.trigger('sort', this, options);\n        if (toAdd.length || toRemove.length || toMerge.length) {\n          options.changes = {\n            added: toAdd,\n            removed: toRemove,\n            merged: toMerge\n          };\n          this.trigger('update', this, options);\n        }\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options = options ? _.clone(options) : {};\n      for (var i = 0; i < this.models.length; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      return this.remove(model, options);\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      return this.remove(model, options);\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id, cid, model object with id or cid\n    // properties, or an attributes object that is transformed through modelId.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj] ||\n        this._byId[this.modelId(obj.attributes || obj)] ||\n        obj.cid && this._byId[obj.cid];\n    },\n\n    // Returns `true` if the model is in the collection.\n    has: function(obj) {\n      return this.get(obj) != null;\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      if (index < 0) index += this.length;\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      return this[first ? 'find' : 'filter'](attrs);\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      var comparator = this.comparator;\n      if (!comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      var length = comparator.length;\n      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);\n\n      // Run sort based on type of `comparator`.\n      if (length === 1 || _.isString(comparator)) {\n        this.models = this.sortBy(comparator);\n      } else {\n        this.models.sort(comparator);\n      }\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return this.map(attr + '');\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = _.extend({parse: true}, options);\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success.call(options.context, collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      var wait = options.wait;\n      model = this._prepareModel(model, options);\n      if (!model) return false;\n      if (!wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(m, resp, callbackOpts) {\n        if (wait) collection.add(m, callbackOpts);\n        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models, {\n        model: this.model,\n        comparator: this.comparator\n      });\n    },\n\n    // Define how to uniquely identify models in the collection.\n    modelId: function(attrs) {\n      return attrs[this.model.prototype.idAttribute || 'id'];\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (this._isModel(attrs)) {\n        if (!attrs.collection) attrs.collection = this;\n        return attrs;\n      }\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method called by both remove and set.\n    _removeModels: function(models, options) {\n      var removed = [];\n      for (var i = 0; i < models.length; i++) {\n        var model = this.get(models[i]);\n        if (!model) continue;\n\n        var index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n\n        // Remove references before triggering 'remove' event to prevent an\n        // infinite loop. #3693\n        delete this._byId[model.cid];\n        var id = this.modelId(model.attributes);\n        if (id != null) delete this._byId[id];\n\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n\n        removed.push(model);\n        this._removeReference(model, options);\n      }\n      return removed;\n    },\n\n    // Method for checking whether an object should be considered a model for\n    // the purposes of adding to the collection.\n    _isModel: function(model) {\n      return model instanceof Model;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      var id = this.modelId(model.attributes);\n      if (id != null) this._byId[id] = model;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      delete this._byId[model.cid];\n      var id = this.modelId(model.attributes);\n      if (id != null) delete this._byId[id];\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if (model) {\n        if ((event === 'add' || event === 'remove') && collection !== this) return;\n        if (event === 'destroy') this.remove(model, options);\n        if (event === 'change') {\n          var prevId = this.modelId(model.previousAttributes());\n          var id = this.modelId(model.attributes);\n          if (prevId !== id) {\n            if (prevId != null) delete this._byId[prevId];\n            if (id != null) this._byId[id] = model;\n          }\n        }\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,\n      foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,\n      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,\n      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,\n      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,\n      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,\n      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,\n      sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  addUnderscoreMethods(Collection, collectionMethods, 'models');\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    this.preinitialize.apply(this, arguments);\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be set as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the View\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this._removeElement();\n      this.stopListening();\n      return this;\n    },\n\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function() {\n      this.$el.remove();\n    },\n\n    // Change the view's element (`this.el` property) and re-delegate the\n    // view's events on the new element.\n    setElement: function(element) {\n      this.undelegateEvents();\n      this._setElement(element);\n      this.delegateEvents();\n      return this;\n    },\n\n    // Creates the `this.el` and `this.$el` references for this view using the\n    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n    // context or an element. Subclasses can override this to utilize an\n    // alternative DOM manipulation API and are only required to set the\n    // `this.el` property.\n    _setElement: function(el) {\n      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n      this.el = this.$el[0];\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    delegateEvents: function(events) {\n      events || (events = _.result(this, 'events'));\n      if (!events) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[method];\n        if (!method) continue;\n        var match = key.match(delegateEventSplitter);\n        this.delegate(match[1], match[2], _.bind(method, this));\n      }\n      return this;\n    },\n\n    // Add a single event listener to the view's element (or a child element\n    // using `selector`). This only works for delegate-able events: not `focus`,\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n    delegate: function(eventName, selector, listener) {\n      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\n    // `selector` and `listener` are both optional.\n    undelegate: function(eventName, selector, listener) {\n      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n      return this;\n    },\n\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function(tagName) {\n      return document.createElement(tagName);\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        this.setElement(this._createElement(_.result(this, 'tagName')));\n        this._setAttributes(attrs);\n      } else {\n        this.setElement(_.result(this, 'el'));\n      }\n    },\n\n    // Set attributes from a hash on this view's element.  Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _setAttributes: function(attributes) {\n      this.$el.attr(attributes);\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // Pass along `textStatus` and `errorThrown` from jQuery.\n    var error = options.error;\n    options.error = function(xhr, textStatus, errorThrown) {\n      options.textStatus = textStatus;\n      options.errorThrown = errorThrown;\n      if (error) error.call(options.context, xhr, textStatus, errorThrown);\n    };\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch': 'PATCH',\n    'delete': 'DELETE',\n    'read': 'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Router.\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        if (router.execute(callback, args, name) !== false) {\n          router.trigger.apply(router, ['route:' + name].concat(args));\n          router.trigger('route', name, args);\n          Backbone.history.trigger('route', router, name, args);\n        }\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args, name) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional) {\n                     return optional ? match : '([^/?]+)';\n                   })\n                   .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    this.checkUrl = _.bind(this.checkUrl, this);\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      var path = this.location.pathname.replace(/[^\\/]$/, '$&/');\n      return path === this.root && !this.getSearch();\n    },\n\n    // Does the pathname match the root?\n    matchRoot: function() {\n      var path = this.decodeFragment(this.location.pathname);\n      var rootPath = path.slice(0, this.root.length - 1) + '/';\n      return rootPath === this.root;\n    },\n\n    // Unicode characters in `location.pathname` are percent encoded so they're\n    // decoded for comparison. `%25` should not be decoded since it may be part\n    // of an encoded parameter.\n    decodeFragment: function(fragment) {\n      return decodeURI(fragment.replace(/%25/g, '%2525'));\n    },\n\n    // In IE6, the hash fragment and search params are incorrect if the\n    // fragment contains `?`.\n    getSearch: function() {\n      var match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\n      return match ? match[0] : '';\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the pathname and search params, without the root.\n    getPath: function() {\n      var path = this.decodeFragment(\n        this.location.pathname + this.getSearch()\n      ).slice(this.root.length - 1);\n      return path.charAt(0) === '/' ? path.slice(1) : path;\n    },\n\n    // Get the cross-browser normalized URL fragment from the path or hash.\n    getFragment: function(fragment) {\n      if (fragment == null) {\n        if (this._usePushState || !this._wantsHashChange) {\n          fragment = this.getPath();\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error('Backbone.history has already been started');\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\n      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.history && this.history.pushState);\n      this._usePushState    = this._wantsPushState && this._hasPushState;\n      this.fragment         = this.getFragment();\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          var rootPath = this.root.slice(0, -1) || '/';\n          this.location.replace(rootPath + '#' + this.getPath());\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot()) {\n          this.navigate(this.getHash(), {replace: true});\n        }\n\n      }\n\n      // Proxy an iframe to handle location events if the browser doesn't\n      // support the `hashchange` event, HTML5 history, or the user wants\n      // `hashChange` but not `pushState`.\n      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n        this.iframe = document.createElement('iframe');\n        this.iframe.src = 'javascript:0';\n        this.iframe.style.display = 'none';\n        this.iframe.tabIndex = -1;\n        var body = document.body;\n        // Using `appendChild` will throw on IE < 9 if the document is not ready.\n        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n        iWindow.document.open();\n        iWindow.document.close();\n        iWindow.location.hash = '#' + this.fragment;\n      }\n\n      // Add a cross-platform `addEventListener` shim for older browsers.\n      var addEventListener = window.addEventListener || function(eventName, listener) {\n        return attachEvent('on' + eventName, listener);\n      };\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._usePushState) {\n        addEventListener('popstate', this.checkUrl, false);\n      } else if (this._useHashChange && !this.iframe) {\n        addEventListener('hashchange', this.checkUrl, false);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      // Add a cross-platform `removeEventListener` shim for older browsers.\n      var removeEventListener = window.removeEventListener || function(eventName, listener) {\n        return detachEvent('on' + eventName, listener);\n      };\n\n      // Remove window listeners.\n      if (this._usePushState) {\n        removeEventListener('popstate', this.checkUrl, false);\n      } else if (this._useHashChange && !this.iframe) {\n        removeEventListener('hashchange', this.checkUrl, false);\n      }\n\n      // Clean up the iframe if necessary.\n      if (this.iframe) {\n        document.body.removeChild(this.iframe);\n        this.iframe = null;\n      }\n\n      // Some environments will throw when clearing an undefined interval.\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n\n      // If the user pressed the back button, the iframe's hash will have\n      // changed and we should use that for comparison.\n      if (current === this.fragment && this.iframe) {\n        current = this.getHash(this.iframe.contentWindow);\n      }\n\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      // If the root doesn't match, no routes can match either.\n      if (!this.matchRoot()) return false;\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.some(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      // Normalize the fragment.\n      fragment = this.getFragment(fragment || '');\n\n      // Don't include a trailing slash on the root.\n      var rootPath = this.root;\n      if (fragment === '' || fragment.charAt(0) === '?') {\n        rootPath = rootPath.slice(0, -1) || '/';\n      }\n      var url = rootPath + fragment;\n\n      // Strip the fragment of the query and hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      // Decode for matching.\n      var decodedFragment = this.decodeFragment(fragment);\n\n      if (this.fragment === decodedFragment) return;\n      this.fragment = decodedFragment;\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._usePushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\n          var iWindow = this.iframe.contentWindow;\n\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if (!options.replace) {\n            iWindow.document.open();\n            iWindow.document.close();\n          }\n\n          this._updateHash(iWindow.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function and add the prototype properties.\n    child.prototype = _.create(parent.prototype, protoProps);\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error.call(options.context, model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n});\n",
                language: 'javascript',
                size: 73443,
                tokens: 9598,
                lastModified: '2025-07-02T12:28:22.857Z',
              },
            ],
          },
          {
            name: 'firebug-lite',
            path: 'vendor/firebug-lite',
            type: 'directory',
            children: [
              {
                name: 'skin',
                path: 'vendor/firebug-lite/skin',
                type: 'directory',
                children: [
                  {
                    name: 'xp',
                    path: 'vendor/firebug-lite/skin/xp',
                    type: 'directory',
                    children: [
                      {
                        name: 'debugger.css',
                        path: 'vendor/firebug-lite/skin/xp/debugger.css',
                        type: 'file',
                        content:
                          '/* See license.txt for terms of usage */\n\n.panelNode-script {\n    overflow: hidden;\n    font-family: monospace;\n}\n\n/************************************************************************************************/\n\n.scriptTooltip {\n    position: fixed;\n    z-index: 2147483647;\n    padding: 2px 3px;\n    border: 1px solid #CBE087;\n    background: LightYellow;\n    font-family: monospace;\n    color: #000000;\n}\n\n/************************************************************************************************/\n\n.sourceBox {\n    /* TODO: xxxpedro problem with sourceBox and scrolling elements */\n    /*overflow: scroll; /* see issue 1479 */\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.sourceRow {\n    white-space: nowrap;\n    -moz-user-select: text;\n}\n\n.sourceRow.hovered {\n    background-color: #EEEEEE;\n}\n\n/************************************************************************************************/\n\n.sourceLine {\n    -moz-user-select: none;\n    margin-right: 10px;\n    border-right: 1px solid #CCCCCC;\n    padding: 0px 4px 0 20px;\n    background: #EEEEEE no-repeat 2px 0px;\n    color: #888888;\n    white-space: pre;\n    font-family: monospace; /* see issue 2953 */\n}\n\n.noteInToolTip { /* below sourceLine, so it overrides it */\n    background-color: #FFD472;\n}\n\n.useA11y .sourceBox .sourceViewport:focus .sourceLine {\n    background-color: #FFFFC0;\n    color: navy;\n    border-right: 1px solid black;\n}\n\n.useA11y .sourceBox .sourceViewport:focus {\n    outline: none;\n}\n\n.a11y1emSize {\n    width: 1em;\n    height: 1em;\n    position: absolute;\n}\n\n.useA11y .panelStatusLabel:focus {\n    outline-offset: -2px !important;\n }\n\n.sourceBox > .sourceRow > .sourceLine {\n    cursor: pointer;\n}\n\n.sourceLine:hover {\n    text-decoration: none;\n}\n\n.sourceRowText {\n    white-space: pre;\n}\n\n.sourceRow[exe_line="true"] {\n    outline: 1px solid #D9D9B6;\n    margin-right: 1px;\n    background-color: lightgoldenrodyellow;\n}\n\n.sourceRow[executable="true"] > .sourceLine {\n    content: "-";\n    color: #4AA02C;  /* Spring Green */\n    font-weight: bold;\n}\n\n.sourceRow[exe_line="true"] > .sourceLine {\n    background-image: url(chrome://firebug/skin/exe.png);\n    color: #000000;\n}\n\n.sourceRow[breakpoint="true"] > .sourceLine {\n    background-image: url(chrome://firebug/skin/breakpoint.png);\n}\n\n.sourceRow[breakpoint="true"][condition="true"] > .sourceLine {\n    background-image: url(chrome://firebug/skin/breakpointCondition.png);\n}\n\n.sourceRow[breakpoint="true"][disabledBreakpoint="true"] > .sourceLine {\n    background-image: url(chrome://firebug/skin/breakpointDisabled.png);\n}\n\n.sourceRow[breakpoint="true"][exe_line="true"] > .sourceLine {\n    background-image: url(chrome://firebug/skin/breakpointExe.png);\n}\n\n.sourceRow[breakpoint="true"][exe_line="true"][disabledBreakpoint="true"] > .sourceLine {\n    background-image: url(chrome://firebug/skin/breakpointDisabledExe.png);\n}\n\n.sourceLine.editing {\n    background-image: url(chrome://firebug/skin/breakpoint.png);\n}\n\n/************************************************************************************************/\n\n.conditionEditor {\n    z-index: 2147483647;\n    position: absolute;\n    margin-top: 0;\n    left: 2px;\n    width: 90%;\n}\n\n.conditionEditorInner {\n    position: relative;\n    top: -26px;\n    height: 0;\n}\n\n.conditionCaption {\n    margin-bottom: 2px;\n    font-family: Lucida Grande, sans-serif;\n    font-weight: bold;\n    font-size: 11px;\n    color: #226679;\n}\n\n.conditionInput {\n    width: 100%;\n    border: 1px solid #0096C0;\n    font-family: monospace;\n    font-size: inherit;\n}\n\n.conditionEditorInner1 {\n    padding-left: 37px;\n    background: url(condBorders.png) repeat-y;\n}\n\n.conditionEditorInner2 {\n    padding-right: 25px;\n    background: url(condBorders.png) repeat-y 100% 0;\n}\n\n.conditionEditorTop1 {\n    background: url(condCorners.png) no-repeat 100% 0;\n    margin-left: 37px;\n    height: 35px;\n}\n\n.conditionEditorTop2 {\n    position: relative;\n    left: -37px;\n    width: 37px;\n    height: 35px;\n    background: url(condCorners.png) no-repeat;\n}\n\n.conditionEditorBottom1 {\n    background: url(condCorners.png) no-repeat 100% 100%;\n    margin-left: 37px;\n    height: 33px;\n}\n\n.conditionEditorBottom2 {\n    position: relative;    left: -37px;\n    width: 37px;\n    height: 33px;\n    background: url(condCorners.png) no-repeat 0 100%;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.upsideDown {\n    margin-top: 2px;\n}\n\n.upsideDown .conditionEditorInner {\n    top: -8px;\n}\n\n.upsideDown .conditionEditorInner1 {\n    padding-left: 33px;\n    background: url(condBordersUps.png) repeat-y;\n}\n\n.upsideDown .conditionEditorInner2 {\n    padding-right: 25px;\n    background: url(condBordersUps.png) repeat-y 100% 0;\n}\n\n.upsideDown .conditionEditorTop1 {\n    background: url(condCornersUps.png) no-repeat 100% 0;\n    margin-left: 33px;\n    height: 25px;\n}\n\n.upsideDown .conditionEditorTop2 {\n    position: relative;\n    left: -33px;\n    width: 33px;\n    height: 25px;\n    background: url(condCornersUps.png) no-repeat;\n}\n\n.upsideDown .conditionEditorBottom1 {\n    background: url(condCornersUps.png) no-repeat 100% 100%;\n    margin-left: 33px;\n    height: 43px;\n}\n\n.upsideDown .conditionEditorBottom2 {\n    position: relative;\n    left: -33px;\n    width: 33px;\n    height: 43px;\n    background: url(condCornersUps.png) no-repeat 0 100%;\n}\n\n/************************************************************************************************/\n\n.breakpointsGroupListBox {\n  overflow: hidden;\n}\n\n.breakpointBlockHead {\n    position: relative;\n    padding-top: 4px;\n}\n\n.breakpointBlockHead > .checkbox {\n    margin-right: 4px;\n}\n\n.breakpointBlockHead > .objectLink-sourceLink {\n    top: 4px;\n    right: 20px;\n    background-color: #FFFFFF; /* issue 3308 */\n}\n\n.breakpointBlockHead > .closeButton {\n    position: absolute;\n    top: 2px;\n    right: 2px;\n}\n\n.breakpointCheckbox {\n    margin-top: 0;\n    vertical-align: top;\n}\n\n.breakpointName {\n    margin-left: 4px;\n    font-weight: bold;\n}\n\n.breakpointRow[aria-checked="false"] > .breakpointBlockHead > *,\n.breakpointRow[aria-checked="false"] > .breakpointCode {\n    opacity: 0.5;\n}\n\n.breakpointRow[aria-checked="false"] .breakpointCheckbox,\n.breakpointRow[aria-checked="false"] .objectLink-sourceLink,\n.breakpointRow[aria-checked="false"] .closeButton,\n.breakpointRow[aria-checked="false"] .breakpointMutationType {\n    opacity: 1.0 !important;\n}\n\n.breakpointCode {\n    overflow: hidden;\n    white-space: nowrap;\n    padding-left: 24px;\n    padding-bottom: 2px;\n    border-bottom: 1px solid #D7D7D7;\n    font-family: monospace;\n    color: DarkGreen;\n}\n\n.breakpointCondition {\n    white-space: nowrap;\n    padding-left: 24px;\n    padding-bottom: 2px;\n    border-bottom: 1px solid #D7D7D7;\n    font-family: monospace;\n    color: Gray;\n}\n\n.breakpointBlock-breakpoints > .groupHeader {\n    display: none;\n}\n\n.breakpointBlock-monitors > .breakpointCode {\n    padding: 0;\n}\n\n.breakpointBlock-errorBreakpoints .breakpointCheckbox,\n.breakpointBlock-monitors .breakpointCheckbox {\n    display: none;\n}\n\n.breakpointHeader {\n    margin: 0 !important;\n    border-top: none !important;\n}\n',
                        language: 'css',
                        size: 7184,
                        tokens: 688,
                        lastModified: '2025-07-02T12:28:22.862Z',
                      },
                      {
                        name: 'firebug-1.3a2.css',
                        path: 'vendor/firebug-lite/skin/xp/firebug-1.3a2.css',
                        type: 'file',
                        content:
                          '.fbBtnPressed {\n    background: #ECEBE3;\n    padding: 3px 6px 2px 7px !important;\n    margin: 1px 0 0 1px;\n    _margin: 1px -1px 0 1px;\n    border: 1px solid #ACA899 !important;\n    border-color: #ACA899 #ECEBE3 #ECEBE3 #ACA899 !important;\n}\n\n.fbToolbarButtons {\n    display: none;\n}\n\n#fbStatusBarBox {\n    display: none;\n}\n\n/************************************************************************************************\n Error Popup\n*************************************************************************************************/\n#fbErrorPopup {\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    height: 19px;\n    width: 75px;\n    background: url(sprite.png) #f1f2ee 0 0;\n    z-index: 999;\n}\n\n#fbErrorPopupContent {\n    position: absolute;\n    right: 0;\n    top: 1px;\n    height: 18px;\n    width: 75px;\n    _width: 74px;\n    border-left: 1px solid #aca899;\n}\n\n#fbErrorIndicator {\n    position: absolute;\n    top: 2px;\n    right: 5px;\n}\n\n\n\n\n\n\n\n\n\n\n.fbBtnInspectActive {\n    background: #aaa;\n    color: #fff !important;\n}\n\n/************************************************************************************************\n General\n*************************************************************************************************/\nhtml, body {\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n}\n\nbody {\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-size: 11px;\n    background: #fff;    \n}\n\n.clear {\n    clear: both;\n}\n\n/************************************************************************************************\n Mini Chrome\n*************************************************************************************************/\n#fbMiniChrome {\n    display: none;\n    right: 0;\n    height: 27px;\n    background: url(sprite.png) #f1f2ee 0 0;\n    margin-left: 1px;\n}\n\n#fbMiniContent {\n    display: block;\n    position: relative;\n    left: -1px;\n    right: 0;\n    top: 1px;\n    height: 25px;\n    border-left: 1px solid #aca899;\n}\n\n#fbToolbarSearch {\n    float: right;\n    border: 1px solid #ccc;\n    margin: 0 5px 0 0;\n    background: #fff url(search.png) no-repeat 4px 2px;\n    padding-left: 20px;    \n    font-size: 11px;\n}\n\n#fbToolbarErrors {\n    float: right;\n    margin: 1px 4px 0 0;\n    font-size: 11px;\n}\n\n#fbLeftToolbarErrors {\n    float: left;\n    margin: 7px 0px 0 5px;\n    font-size: 11px;\n}\n\n.fbErrors {\n    padding-left: 20px;\n    height: 14px;\n    background: url(errorIcon.png) no-repeat;\n    color: #f00;\n    font-weight: bold;    \n}\n\n#fbMiniErrors {\n    display: inline;\n    display: none;\n    float: right;\n    margin: 5px 2px 0 5px;\n}\n\n#fbMiniIcon {\n    float: right;\n    margin: 3px 4px 0;\n    height: 20px;\n    width: 20px;\n    float: right;    \n    background: url(sprite.png) 0 -135px;\n    cursor: pointer;\n}\n\n\n/************************************************************************************************\n Master Layout\n*************************************************************************************************/\n#fbChrome {\n    position: fixed;\n    overflow: hidden;\n    height: 100%;\n    width: 100%;\n    border-collapse: collapse;\n    background: #fff;\n}\n\n#fbTop {\n    height: 49px;\n}\n\n#fbToolbar {\n    position: absolute;\n    z-index: 5;\n    width: 100%;\n    top: 0;\n    background: url(sprite.png) #f1f2ee 0 0;\n    height: 27px;\n    font-size: 11px;\n    overflow: hidden;\n}\n\n#fbPanelBarBox {\n    top: 27px;\n    position: absolute;\n    z-index: 8;\n    width: 100%;\n    background: url(sprite.png) #dbd9c9 0 -27px;\n    height: 22px;\n}\n\n#fbContent {\n    height: 100%;\n    vertical-align: top;\n}\n\n#fbBottom {\n    height: 18px;\n    background: #fff;\n}\n\n/************************************************************************************************\n Sub-Layout \n*************************************************************************************************/\n\n/* fbToolbar \n*************************************************************************************************/\n#fbToolbarIcon {\n    float: left;\n    padding: 4px 5px 0;\n}\n\n#fbToolbarIcon a {\n    display: block;\n    height: 20px;\n    width: 20px;\n    background: url(sprite.png) 0 -135px;\n    text-decoration: none;\n    cursor: default;\n}\n\n#fbToolbarButtons {\n    float: left;\n    padding: 4px 2px 0 5px;\n}\n\n#fbToolbarButtons a {\n    text-decoration: none;\n    display: block;\n    float: left;\n    color: #000;\n    padding: 4px 8px 4px;\n    cursor: default;\n}\n\n#fbToolbarButtons a:hover {\n    color: #333;\n    padding: 3px 7px 3px;\n    border: 1px solid #fff;\n    border-bottom: 1px solid #bbb;\n    border-right: 1px solid #bbb;\n}\n\n#fbStatusBarBox {\n    position: relative;\n    top: 5px;\n    line-height: 19px;\n    cursor: default;    \n}\n\n.fbToolbarSeparator{\n    overflow: hidden;\n    border: 1px solid;\n    border-color: transparent #fff transparent #777;\n    _border-color: #eee #fff #eee #777;\n    height: 7px;\n    margin: 10px 6px 0 0;\n    float: left;\n}\n\n.fbStatusBar span {\n    color: #808080;\n    padding: 0 4px 0 0;\n}\n\n.fbStatusBar span a {\n    text-decoration: none;\n    color: black;\n}\n\n.fbStatusBar span a:hover {\n    color: blue;\n    cursor: pointer;    \n}\n\n\n#fbWindowButtons {\n    position: absolute;\n    white-space: nowrap;\n    right: 0;\n    top: 0;\n    height: 17px;\n    _width: 50px;\n    padding: 5px 0 5px 5px;\n    z-index: 6;\n    background: url(sprite.png) #f1f2ee 0 0;\n}\n\n/* fbPanelBarBox\n*************************************************************************************************/\n\n#fbPanelBar1 {\n    width: 255px; /* fixed width to avoid tabs breaking line */\n    z-index: 8;\n    left: 0;\n    white-space: nowrap;\n    background: url(sprite.png) #dbd9c9 0 -27px;\n    position: absolute;\n    left: 4px;\n}\n\n#fbPanelBar2Box {\n    background: url(sprite.png) #dbd9c9 0 -27px;\n    position: absolute;\n    height: 22px;\n    width: 300px; /* fixed width to avoid tabs breaking line */\n    z-index: 9;\n    right: 0;\n}\n\n#fbPanelBar2 {\n    position: absolute;\n    width: 290px; /* fixed width to avoid tabs breaking line */\n    height: 22px;\n    padding-left: 10px;\n}\n\n/* body \n*************************************************************************************************/\n.fbPanel {\n    display: none;\n}\n\n#fbPanelBox1, #fbPanelBox2 {\n    max-height: inherit;\n    height: 100%;\n    font-size: 11px;\n}\n\n#fbPanelBox2 {\n    background: #fff;\n}\n\n#fbPanelBox2 {\n    width: 300px;\n    background: #fff;\n}\n\n#fbPanel2 {\n    padding-left: 6px;\n    background: #fff;\n}\n\n.hide {\n    overflow: hidden !important;\n    position: fixed !important;\n    display: none !important;\n    visibility: hidden !important;\n}\n\n/* fbBottom \n*************************************************************************************************/\n\n#fbCommand {\n    height: 18px;\n}\n\n#fbCommandBox {\n    position: absolute;\n    width: 100%;\n    height: 18px;\n    bottom: 0;\n    overflow: hidden;\n    z-index: 9;\n    background: #fff;\n    border: 0;\n    border-top: 1px solid #ccc;\n}\n\n#fbCommandIcon {\n    position: absolute;\n    color: #00f;\n    top: 2px;\n    left: 7px;\n    display: inline;\n    font: 11px Monaco, monospace;\n    z-index: 10;\n}\n\n#fbCommandLine {\n    position: absolute;\n    width: 100%;\n    top: 0;\n    left: 0;\n    border: 0;\n    margin: 0;\n    padding: 2px 0 2px 32px;\n    font: 11px Monaco, monospace;\n    z-index: 9;\n}\n\ndiv.fbFitHeight {\n    overflow: auto;\n    _position: absolute;\n}\n\n\n/************************************************************************************************\n Layout Controls\n*************************************************************************************************/\n\n/* fbToolbar buttons \n*************************************************************************************************/\n#fbWindowButtons a {\n    font-size: 1px;\n    width: 16px;\n    height: 16px;\n    display: block;\n    float: right;\n    margin-right: 4px;\n    text-decoration: none;\n    cursor: default;\n}\n\n#fbWindow_btClose {\n    background: url(sprite.png) 0 -119px;\n}\n\n#fbWindow_btClose:hover {\n    background: url(sprite.png) -16px -119px;\n}\n\n#fbWindow_btDetach {\n    background: url(sprite.png) -32px -119px;\n}\n\n#fbWindow_btDetach:hover {\n    background: url(sprite.png) -48px -119px;\n}\n\n/* fbPanelBarBox tabs \n*************************************************************************************************/\n.fbTab {\n    text-decoration: none;\n    display: none;\n    float: left;\n    width: auto;\n    float: left;\n    cursor: default;\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-size: 11px;\n    font-weight: bold;\n    height: 22px;\n    color: #565656;\n}\n\n.fbPanelBar span {\n    display: block;\n    float: left;\n}\n\n.fbPanelBar .fbTabL,.fbPanelBar .fbTabR {\n    height: 22px;\n    width: 8px;\n}\n\n.fbPanelBar .fbTabText {\n    padding: 4px 1px 0;\n}\n\na.fbTab:hover {\n    background: url(sprite.png) 0 -73px;\n}\n\na.fbTab:hover .fbTabL {\n    background: url(sprite.png) -16px -96px;\n}\n\na.fbTab:hover .fbTabR {\n    background: url(sprite.png) -24px -96px;\n}\n\n.fbSelectedTab {\n    background: url(sprite.png) #f1f2ee 0 -50px !important;\n    color: #000;\n}\n\n.fbSelectedTab .fbTabL {\n    background: url(sprite.png) 0 -96px !important;\n}\n\n.fbSelectedTab .fbTabR {\n    background: url(sprite.png) -8px -96px !important;\n}\n\n/* splitters \n*************************************************************************************************/\n#fbHSplitter {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 5px;\n    overflow: hidden;\n    cursor: n-resize !important;\n    background: url(pixel_transparent.gif);\n    z-index: 9;\n}\n\n#fbHSplitter.fbOnMovingHSplitter {\n    height: 100%;\n    z-index: 100;\n}\n\n.fbVSplitter {\n    background: #ece9d8;\n    color: #000;\n    border: 1px solid #716f64;\n    border-width: 0 1px;\n    border-left-color: #aca899;\n    width: 4px;\n    cursor: e-resize;\n    overflow: hidden;\n    right: 294px;\n    text-decoration: none;\n    z-index: 9;\n    position: absolute;\n    height: 100%;\n    top: 27px;\n    _width: 6px;\n}\n\n/************************************************************************************************/\ndiv.lineNo {\n    font: 11px Monaco, monospace;\n    float: left;\n    display: inline;\n    position: relative;\n    margin: 0;\n    padding: 0 5px 0 20px;\n    background: #eee;\n    color: #888;\n    border-right: 1px solid #ccc;\n    text-align: right;\n}\n\npre.nodeCode {\n    font: 11px Monaco, monospace;\n    margin: 0;\n    padding-left: 10px;\n    overflow: hidden;\n    /*\n    _width: 100%;\n    /**/\n}\n\n/************************************************************************************************/\n.nodeControl {\n    margin-top: 3px;\n    margin-left: -14px;\n    float: left;\n    width: 9px;\n    height: 9px;\n    overflow: hidden;\n    cursor: default;\n    background: url(tree_open.gif);\n    _float: none;\n    _display: inline;\n    _position: absolute;\n}\n\ndiv.nodeMaximized {\n    background: url(tree_close.gif);\n}\n\ndiv.objectBox-element {\n    padding: 1px 3px;\n}\n.objectBox-selector{\n    cursor: default;\n}\n\n.selectedElement{\n    background: highlight;\n    /* background: url(roundCorner.svg); Opera */\n    color: #fff !important;\n}\n.selectedElement span{\n    color: #fff !important;\n}\n\n/* Webkit CSS Hack - bug in "highlight" named color */ \n@media screen and (-webkit-min-device-pixel-ratio:0) {\n    .selectedElement{\n      background: #316AC5;\n      color: #fff !important;\n    }\n}\n\n/************************************************************************************************/\n/************************************************************************************************/\n.logRow * {\n    font-size: 11px;\n}\n\n.logRow {\n    position: relative;\n    border-bottom: 1px solid #D7D7D7;\n    padding: 2px 4px 1px 6px;\n    background-color: #FFFFFF;\n}\n\n.logRow-command {\n    font-family: Monaco, monospace;\n    color: blue;\n}\n\n.objectBox-string,\n.objectBox-text,\n.objectBox-number,\n.objectBox-function,\n.objectLink-element,\n.objectLink-textNode,\n.objectLink-function,\n.objectBox-stackTrace,\n.objectLink-profile {\n    font-family: Monaco, monospace;\n}\n\n.objectBox-null {\n    padding: 0 2px;\n    border: 1px solid #666666;\n    background-color: #888888;\n    color: #FFFFFF;\n}\n\n.objectBox-string {\n    color: red;\n    white-space: pre;\n}\n\n.objectBox-number {\n    color: #000088;\n}\n\n.objectBox-function {\n    color: DarkGreen;\n}\n\n.objectBox-object {\n    color: DarkGreen;\n    font-weight: bold;\n    font-family: Lucida Grande, sans-serif;\n}\n\n.objectBox-array {\n    color: #000;\n}\n\n/************************************************************************************************/\n.logRow-info,.logRow-error,.logRow-warning {\n    background: #fff no-repeat 2px 2px;\n    padding-left: 20px;\n    padding-bottom: 3px;\n}\n\n.logRow-info {\n    background-image: url(infoIcon.png);\n}\n\n.logRow-warning {\n    background-color: cyan;\n    background-image: url(warningIcon.png);\n}\n\n.logRow-error {\n    background-color: LightYellow;\n    background-image: url(errorIcon.png);\n    color: #f00;\n}\n\n.errorMessage {\n    vertical-align: top;\n    color: #f00;\n}\n\n.objectBox-sourceLink {\n    position: absolute;\n    right: 4px;\n    top: 2px;\n    padding-left: 8px;\n    font-family: Lucida Grande, sans-serif;\n    font-weight: bold;\n    color: #0000FF;\n}\n\n/************************************************************************************************/\n.logRow-group {\n    background: #EEEEEE;\n    border-bottom: none;\n}\n\n.logGroup {\n    background: #EEEEEE;\n}\n\n.logGroupBox {\n    margin-left: 24px;\n    border-top: 1px solid #D7D7D7;\n    border-left: 1px solid #D7D7D7;\n}\n\n/************************************************************************************************/\n.selectorTag,.selectorId,.selectorClass {\n    font-family: Monaco, monospace;\n    font-weight: normal;\n}\n\n.selectorTag {\n    color: #0000FF;\n}\n\n.selectorId {\n    color: DarkBlue;\n}\n\n.selectorClass {\n    color: red;\n}\n\n/************************************************************************************************/\n.objectBox-element {\n    font-family: Monaco, monospace;\n    color: #000088;\n}\n\n.nodeChildren {\n    padding-left: 26px;\n}\n\n.nodeTag {\n    color: blue;\n    cursor: pointer;\n}\n\n.nodeValue {\n    color: #FF0000;\n    font-weight: normal;\n}\n\n.nodeText,.nodeComment {\n    margin: 0 2px;\n    vertical-align: top;\n}\n\n.nodeText {\n    color: #333333;\n    font-family: Monaco, monospace;\n}\n\n.nodeComment {\n    color: DarkGreen;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeHidden, .nodeHidden * {\n    color: #888888;\n}\n\n.nodeHidden .nodeTag {\n    color: #5F82D9;\n}\n\n.nodeHidden .nodeValue {\n    color: #D86060;\n}\n\n.selectedElement .nodeHidden, .selectedElement .nodeHidden * {\n    color: SkyBlue !important;\n}\n\n\n/************************************************************************************************/\n.log-object {\n    /*\n    _position: relative;\n    _height: 100%;\n    /**/\n}\n\n.property {\n    position: relative;\n    clear: both;\n    height: 15px;\n}\n\n.propertyNameCell {\n    vertical-align: top;\n    float: left;\n    width: 28%;\n    position: absolute;\n    left: 0;\n    z-index: 0;\n}\n\n.propertyValueCell {\n    float: right;\n    width: 68%;\n    background: #fff;\n    position: absolute;\n    padding-left: 5px;\n    display: table-cell;\n    right: 0;\n    z-index: 1;\n    /*\n    _position: relative;\n    /**/\n}\n\n.propertyName {\n    font-weight: bold;\n}\n\n.FirebugPopup {\n    height: 100% !important;\n}\n\n.FirebugPopup #fbWindowButtons {\n    display: none !important;\n}\n\n.FirebugPopup #fbHSplitter {\n    display: none !important;\n}\n',
                        language: 'css',
                        size: 15468,
                        tokens: 1398,
                        lastModified: '2025-07-02T12:28:22.867Z',
                      },
                      {
                        name: 'firebug.css',
                        path: 'vendor/firebug-lite/skin/xp/firebug.css',
                        type: 'file',
                        content:
                          '/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* Loose */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*\n.netInfoResponseHeadersTitle, netInfoResponseHeadersBody {\n    display: none;\n}\n/**/\n\n.obscured {\n    left: -999999px !important;\n}\n\n/* IE6 need a separated rule, otherwise it will not recognize it */\n.collapsed {\n    display: none;\n}\n\n[collapsed="true"] {\n    display: none;\n}\n\n#fbCSS {\n    padding: 0 !important;\n}\n\n.cssPropDisable {\n    float: left;\n    display: block;\n    width: 2em;\n    cursor: default;\n}\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* panelBase */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n\n/************************************************************************************************/\n\n.infoTip {\n    z-index: 2147483647;\n    position: fixed;\n    padding: 2px 3px;\n    border: 1px solid #CBE087;\n    background: LightYellow;\n    font-family: Monaco, monospace;\n    color: #000000;\n    display: none;\n    white-space: nowrap;\n    pointer-events: none;\n}\n\n.infoTip[active="true"] {\n    display: block;\n}\n\n.infoTipLoading {\n    width: 16px;\n    height: 16px;\n    background: url(chrome://firebug/skin/loading_16.gif) no-repeat;\n}\n\n.infoTipImageBox {\n\tfont-size: 11px;\n    min-width: 100px;\n    text-align: center;\n}\n\n.infoTipCaption {\n\tfont-size: 11px;\n    font: Monaco, monospace;\n}\n\n.infoTipLoading > .infoTipImage,\n.infoTipLoading > .infoTipCaption {\n    display: none;\n}\n\n/************************************************************************************************/\n\nh1.groupHeader {\n    padding: 2px 4px;\n    margin: 0 0 4px 0;\n    border-top: 1px solid #CCCCCC;\n    border-bottom: 1px solid #CCCCCC;\n    background: #eee url(group.gif) repeat-x;\n    font-size: 11px;\n    font-weight: bold;\n    _position: relative;\n}\n\n/************************************************************************************************/\n\n.inlineEditor,\n.fixedWidthEditor {\n    z-index: 2147483647;\n    position: absolute;\n    display: none;\n}\n\n.inlineEditor {\n    margin-left: -6px;\n    margin-top: -3px;\n    /*\n    _margin-left: -7px;\n    _margin-top: -5px;\n    /**/\n}\n\n.textEditorInner,\n.fixedWidthEditor {\n    margin: 0 0 0 0 !important;\n    padding: 0;\n    border: none !important;\n    font: inherit;\n    text-decoration: inherit;\n    background-color: #FFFFFF;\n}\n\n.fixedWidthEditor {\n    border-top: 1px solid #888888 !important;\n    border-bottom: 1px solid #888888 !important;\n}\n\n.textEditorInner {\n    position: relative;\n    top: -7px;\n    left: -5px;\n    \n    outline: none;\n    resize: none;\n    \n    /*\n    _border: 1px solid #999 !important;\n    _padding: 1px !important;\n    _filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="#55404040");\n    /**/\n}\n\n.textEditorInner1 {\n    padding-left: 11px;\n    background: url(textEditorBorders.png) repeat-y;\n    _background: url(textEditorBorders.gif) repeat-y;\n    _overflow: hidden;\n}\n\n.textEditorInner2 {\n    position: relative;\n    padding-right: 2px;\n    background: url(textEditorBorders.png) repeat-y 100% 0;\n    _background: url(textEditorBorders.gif) repeat-y 100% 0;\n    _position: fixed;\n}\n\n.textEditorTop1 {\n    background: url(textEditorCorners.png) no-repeat 100% 0;\n    margin-left: 11px;\n    height: 10px;\n    _background: url(textEditorCorners.gif) no-repeat 100% 0;\n    _overflow: hidden;\n}\n\n.textEditorTop2 {\n    position: relative;\n    left: -11px;\n    width: 11px;\n    height: 10px;\n    background: url(textEditorCorners.png) no-repeat;\n    _background: url(textEditorCorners.gif) no-repeat;\n}\n\n.textEditorBottom1 {\n    position: relative;\n    background: url(textEditorCorners.png) no-repeat 100% 100%;\n    margin-left: 11px;\n    height: 12px;\n    _background: url(textEditorCorners.gif) no-repeat 100% 100%;\n}\n\n.textEditorBottom2 {\n    position: relative;\n    left: -11px;\n    width: 11px;\n    height: 12px;\n    background: url(textEditorCorners.png) no-repeat 0 100%;\n    _background: url(textEditorCorners.gif) no-repeat 0 100%;\n}\n\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* CSS */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n\n/* See license.txt for terms of usage */\n\n.panelNode-css {\n    overflow-x: hidden;\n}\n\n.cssSheet > .insertBefore {\n    height: 1.5em;\n}\n\n.cssRule {\n    position: relative;\n    margin: 0;\n    padding: 1em 0 0 6px;\n    font-family: Monaco, monospace;\n    color: #000000;\n}\n\n.cssRule:first-child {\n    padding-top: 6px;\n}\n\n.cssElementRuleContainer {\n    position: relative;\n}\n\n.cssHead {\n    padding-right: 150px;\n}\n\n.cssProp {\n    /*padding-left: 2em;*/\n}\n\n.cssPropName {\n    color: DarkGreen;\n}\n\n.cssPropValue {\n    margin-left: 8px;\n    color: DarkBlue;\n}\n\n.cssOverridden span {\n    text-decoration: line-through;\n}\n\n.cssInheritedRule {\n}\n\n.cssInheritLabel {\n    margin-right: 0.5em;\n    font-weight: bold;\n}\n\n.cssRule .objectLink-sourceLink {\n    top: 0;\n}\n\n.cssProp.editGroup:hover {\n    background: url(disable.png) no-repeat 2px 1px;\n    _background: url(disable.gif) no-repeat 2px 1px;\n}\n\n.cssProp.editGroup.editing {\n    background: none;\n}\n\n.cssProp.disabledStyle {\n    background: url(disableHover.png) no-repeat 2px 1px;\n    _background: url(disableHover.gif) no-repeat 2px 1px;\n    opacity: 1;\n    color: #CCCCCC;\n}\n\n.disabledStyle .cssPropName,\n.disabledStyle .cssPropValue {\n    color: #CCCCCC;\n}\n\n.cssPropValue.editing + .cssSemi,\n.inlineExpander + .cssSemi {\n    display: none;\n}\n\n.cssPropValue.editing {\n    white-space: nowrap;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.stylePropName {\n    font-weight: bold;\n    padding: 0 4px 4px 4px;\n    width: 50%;\n}\n\n.stylePropValue {\n    width: 50%;\n}\n/*\n.useA11y .a11yCSSView .focusRow:focus {\n    outline: none;\n    background-color: transparent\n }\n \n .useA11y .a11yCSSView .focusRow:focus .cssSelector, \n .useA11y .a11yCSSView .focusRow:focus .cssPropName, \n .useA11y .a11yCSSView .focusRow:focus .cssPropValue,\n .useA11y .a11yCSSView .computedStyleRow:focus, \n .useA11y .a11yCSSView .groupHeader:focus {\n    outline: 2px solid #FF9933;\n    outline-offset: -2px;\n    background-color: #FFFFD6;\n }\n \n .useA11y .a11yCSSView .groupHeader:focus {\n    outline-offset: -2px;\n }\n/**/\n\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* Net */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n\n/* See license.txt for terms of usage */\n\n.panelNode-net {\n    overflow-x: hidden;\n}\n\n.netTable {\n    width: 100%;\n}\n\n/************************************************************************************************/\n\n.hideCategory-undefined .category-undefined,\n.hideCategory-html .category-html,\n.hideCategory-css .category-css,\n.hideCategory-js .category-js,\n.hideCategory-image .category-image,\n.hideCategory-xhr .category-xhr,\n.hideCategory-flash .category-flash,\n.hideCategory-txt .category-txt,\n.hideCategory-bin .category-bin {\n    display: none;\n}\n\n/************************************************************************************************/\n\n.netHeadRow {\n    background: url(chrome://firebug/skin/group.gif) repeat-x #FFFFFF;\n}\n\n.netHeadCol {\n    border-bottom: 1px solid #CCCCCC;\n    padding: 2px 4px 2px 18px;\n    font-weight: bold;\n}\n\n.netHeadLabel {\n    white-space: nowrap;\n    overflow: hidden;\n}\n\n/************************************************************************************************/\n/* Header for Net panel table */\n\n.netHeaderRow {\n    height: 16px;\n}\n\n.netHeaderCell {\n    cursor: pointer;\n    -moz-user-select: none;\n    border-bottom: 1px solid #9C9C9C;\n    padding: 0 !important;\n    font-weight: bold;\n    background: #BBBBBB url(chrome://firebug/skin/tableHeader.gif) repeat-x;\n    white-space: nowrap;\n}\n\n.netHeaderRow > .netHeaderCell:first-child > .netHeaderCellBox {\n    padding: 2px 14px 2px 18px;\n}\n\n.netHeaderCellBox {\n    padding: 2px 14px 2px 10px;\n    border-left: 1px solid #D9D9D9;\n    border-right: 1px solid #9C9C9C;\n}\n\n.netHeaderCell:hover:active {\n    background: #959595 url(chrome://firebug/skin/tableHeaderActive.gif) repeat-x;\n}\n\n.netHeaderSorted {\n    background: #7D93B2 url(chrome://firebug/skin/tableHeaderSorted.gif) repeat-x;\n}\n\n.netHeaderSorted > .netHeaderCellBox {\n    border-right-color: #6B7C93;\n    background: url(chrome://firebug/skin/arrowDown.png) no-repeat right;\n}\n\n.netHeaderSorted.sortedAscending > .netHeaderCellBox {\n    background-image: url(chrome://firebug/skin/arrowUp.png);\n}\n\n.netHeaderSorted:hover:active {\n    background: #536B90 url(chrome://firebug/skin/tableHeaderSortedActive.gif) repeat-x;\n}\n\n/************************************************************************************************/\n/* Breakpoints */\n\n.panelNode-net .netRowHeader {\n    display: block;\n}\n\n.netRowHeader {\n    cursor: pointer;\n    display: none;\n    height: 15px;\n    margin-right: 0 !important;\n}\n\n/* Display brekpoint disc */\n.netRow .netRowHeader {\n    background-position: 5px 1px;\n}\n\n.netRow[breakpoint="true"] .netRowHeader {\n    background-image: url(chrome://firebug/skin/breakpoint.png);\n}\n\n.netRow[breakpoint="true"][disabledBreakpoint="true"] .netRowHeader {\n    background-image: url(chrome://firebug/skin/breakpointDisabled.png);\n}\n\n.netRow.category-xhr:hover .netRowHeader {\n    background-color: #F6F6F6;\n}\n\n#netBreakpointBar {\n    max-width: 38px;\n}\n\n#netHrefCol > .netHeaderCellBox {\n    border-left: 0px;\n}\n\n.netRow .netRowHeader {\n    width: 3px;\n}\n\n.netInfoRow .netRowHeader {\n    display: table-cell;\n}\n\n/************************************************************************************************/\n/* Column visibility */\n\n.netTable[hiddenCols~=netHrefCol] TD[id="netHrefCol"],\n.netTable[hiddenCols~=netHrefCol] TD.netHrefCol,\n.netTable[hiddenCols~=netStatusCol] TD[id="netStatusCol"],\n.netTable[hiddenCols~=netStatusCol] TD.netStatusCol,\n.netTable[hiddenCols~=netDomainCol] TD[id="netDomainCol"],\n.netTable[hiddenCols~=netDomainCol] TD.netDomainCol,\n.netTable[hiddenCols~=netSizeCol] TD[id="netSizeCol"],\n.netTable[hiddenCols~=netSizeCol] TD.netSizeCol,\n.netTable[hiddenCols~=netTimeCol] TD[id="netTimeCol"],\n.netTable[hiddenCols~=netTimeCol] TD.netTimeCol {\n    display: none;\n}\n\n/************************************************************************************************/\n\n.netRow {\n    background: LightYellow;\n}\n\n.netRow.loaded {\n    background: #FFFFFF;\n}\n\n.netRow.loaded:hover {\n    background: #EFEFEF;\n}\n\n.netCol {\n    padding: 0;\n    vertical-align: top;\n    border-bottom: 1px solid #EFEFEF;\n    white-space: nowrap;\n    height: 17px;\n}\n\n.netLabel {\n    width: 100%;\n}\n\n.netStatusCol {\n    padding-left: 10px;\n    color: rgb(128, 128, 128);\n}\n\n.responseError > .netStatusCol {\n    color: red;\n}\n\n.netDomainCol {\n    padding-left: 5px;\n}\n\n.netSizeCol {\n    text-align: right;\n    padding-right: 10px;\n}\n\n.netHrefLabel {\n    -moz-box-sizing: padding-box;\n    overflow: hidden;\n    z-index: 10;\n    position: absolute;\n    padding-left: 18px;\n    padding-top: 1px;\n    max-width: 15%;\n    font-weight: bold;\n}\n\n.netFullHrefLabel {\n    display: none;\n    -moz-user-select: none;\n    padding-right: 10px;\n    padding-bottom: 3px;\n    max-width: 100%;\n    background: #FFFFFF;\n    z-index: 200;\n}\n\n.netHrefCol:hover > .netFullHrefLabel {\n    display: block;\n}\n\n.netRow.loaded:hover .netCol > .netFullHrefLabel {\n    background-color: #EFEFEF;\n}\n\n.useA11y .a11yShowFullLabel {\n    display: block;\n    background-image: none !important;\n    border: 1px solid #CBE087;\n    background-color: LightYellow;\n    font-family: Monaco, monospace;\n    color: #000000;\n    font-size: 10px;\n    z-index: 2147483647;\n}\n\n.netSizeLabel {\n    padding-left: 6px;\n}\n\n.netStatusLabel,\n.netDomainLabel,\n.netSizeLabel,\n.netBar {\n    padding: 1px 0 2px 0 !important;\n}\n\n.responseError {\n    color: red;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.hasHeaders .netHrefLabel:hover {\n    cursor: pointer;\n    color: blue;\n    text-decoration: underline;\n}\n\n/************************************************************************************************/\n\n.netLoadingIcon {\n    position: absolute;\n    border: 0;\n    margin-left: 14px;\n    width: 16px;\n    height: 16px;\n    background: transparent no-repeat 0 0;\n    background-image: url(chrome://firebug/skin/loading_16.gif);\n    display:inline-block;\n}\n\n.loaded .netLoadingIcon {\n    display: none;\n}\n\n/************************************************************************************************/\n\n.netBar, .netSummaryBar {\n    position: relative;\n    border-right: 50px solid transparent;\n}\n\n.netResolvingBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    background: #FFFFFF url(chrome://firebug/skin/netBarResolving.gif) repeat-x;\n    z-index:60;\n}\n\n.netConnectingBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    background: #FFFFFF url(chrome://firebug/skin/netBarConnecting.gif) repeat-x;\n    z-index:50;\n}\n\n.netBlockingBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    background: #FFFFFF url(chrome://firebug/skin/netBarWaiting.gif) repeat-x;\n    z-index:40;\n}\n\n.netSendingBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    background: #FFFFFF url(chrome://firebug/skin/netBarSending.gif) repeat-x;\n    z-index:30;\n}\n\n.netWaitingBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    background: #FFFFFF url(chrome://firebug/skin/netBarResponded.gif) repeat-x;\n    z-index:20;\n    min-width: 1px;\n}\n\n.netReceivingBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    background: #38D63B url(chrome://firebug/skin/netBarLoading.gif) repeat-x;\n    z-index:10;\n}\n\n.netWindowLoadBar,\n.netContentLoadBar {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: red;\n    z-index: 70;\n    opacity: 0.5;\n    display: none;\n    margin-bottom:-1px;\n}\n\n.netContentLoadBar {\n    background-color: Blue;\n}\n\n.netTimeLabel {\n    -moz-box-sizing: padding-box;\n    position: absolute;\n    top: 1px;\n    left: 100%;\n    padding-left: 6px;\n    color: #444444;\n    min-width: 16px;\n}\n\n/*\n * Timing info tip is reusing net timeline styles to display the same\n * colors for individual request phases. Notice that the info tip must\n * respect also loaded and fromCache styles that also modify the\n * actual color. These are used both on the same element in case\n * of the tooltip.\n */\n.loaded .netReceivingBar,\n.loaded.netReceivingBar {\n    background: #B6B6B6 url(chrome://firebug/skin/netBarLoaded.gif) repeat-x;\n    border-color: #B6B6B6;\n}\n\n.fromCache .netReceivingBar,\n.fromCache.netReceivingBar {\n    background: #D6D6D6 url(chrome://firebug/skin/netBarCached.gif) repeat-x;\n    border-color: #D6D6D6;\n}\n\n.netSummaryRow .netTimeLabel,\n.loaded .netTimeLabel {\n    background: transparent;\n}\n\n/************************************************************************************************/\n/* Time Info tip */\n\n.timeInfoTip {\n    width: 150px; \n    height: 40px\n}\n\n.timeInfoTipBar,\n.timeInfoTipEventBar {\n    position: relative;\n    display: block;\n    margin: 0;\n    opacity: 1;\n    height: 15px;\n    width: 4px;\n}\n\n.timeInfoTipEventBar {\n    width: 1px !important;\n}\n\n.timeInfoTipCell.startTime {\n    padding-right: 8px;\n}\n\n.timeInfoTipCell.elapsedTime {\n    text-align: right;\n    padding-right: 8px;\n}\n\n/************************************************************************************************/\n/* Size Info tip */\n\n.sizeInfoLabelCol {\n    font-weight: bold;\n    padding-right: 10px;\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-size: 11px;\n}\n\n.sizeInfoSizeCol {\n    font-weight: bold;\n}\n\n.sizeInfoDetailCol {\n    color: gray;\n    text-align: right;\n}\n\n.sizeInfoDescCol {\n    font-style: italic;\n}\n\n/************************************************************************************************/\n/* Summary */\n\n.netSummaryRow .netReceivingBar {\n    background: #BBBBBB;\n    border: none;\n}\n\n.netSummaryLabel {\n    color: #222222;\n}\n\n.netSummaryRow {\n    background: #BBBBBB !important;\n    font-weight: bold;\n}\n\n.netSummaryRow .netBar {\n    border-right-color: #BBBBBB;\n}\n\n.netSummaryRow > .netCol {\n    border-top: 1px solid #999999;\n    border-bottom: 2px solid;\n    -moz-border-bottom-colors: #EFEFEF #999999;\n    padding-top: 1px;\n    padding-bottom: 2px;\n}\n\n.netSummaryRow > .netHrefCol:hover {\n    background: transparent !important;\n}\n\n.netCountLabel {\n    padding-left: 18px;\n}\n\n.netTotalSizeCol {\n    text-align: right;\n    padding-right: 10px;\n}\n\n.netTotalTimeCol {\n    text-align: right;\n}\n\n.netCacheSizeLabel {\n    position: absolute;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n}\n\n/************************************************************************************************/\n\n.netLimitRow {\n    background: rgb(255, 255, 225) !important;\n    font-weight:normal;\n    color: black;\n    font-weight:normal;\n}\n\n.netLimitLabel {\n    padding-left: 18px;\n}\n\n.netLimitRow > .netCol {\n    border-bottom: 2px solid;\n    -moz-border-bottom-colors: #EFEFEF #999999;\n    vertical-align: middle !important;\n    padding-top: 2px;\n    padding-bottom: 2px;\n}\n\n.netLimitButton {\n    font-size: 11px;\n    padding-top: 1px;\n    padding-bottom: 1px;\n}\n\n/************************************************************************************************/\n\n.netInfoCol {\n    border-top: 1px solid #EEEEEE;\n    background: url(chrome://firebug/skin/group.gif) repeat-x #FFFFFF;\n}\n\n.netInfoBody {\n    margin: 10px 0 4px 10px;\n}\n\n.netInfoTabs {\n    position: relative;\n    padding-left: 17px;\n}\n\n.netInfoTab {\n    position: relative;\n    top: -3px;\n    margin-top: 10px;\n    padding: 4px 6px;\n    border: 1px solid transparent;\n    border-bottom: none;\n    _border: none;\n    font-weight: bold;\n    color: #565656;\n    cursor: pointer;\n}\n\n/*.netInfoTab:hover {\n    cursor: pointer;\n}*/\n\n/* replaced by .netInfoTabSelected for IE6 support\n.netInfoTab[selected="true"] {\n    cursor: default !important;\n    border: 1px solid #D7D7D7 !important;\n    border-bottom: none !important;\n    -moz-border-radius: 4px 4px 0 0;\n    background-color: #FFFFFF;\n}\n/**/\n.netInfoTabSelected {\n    cursor: default !important;\n    border: 1px solid #D7D7D7 !important;\n    border-bottom: none !important;\n    -moz-border-radius: 4px 4px 0 0;\n    -webkit-border-radius: 4px 4px 0 0;\n    border-radius: 4px 4px 0 0;\n    background-color: #FFFFFF;\n}\n\n.logRow-netInfo.error .netInfoTitle {\n    color: red;\n}\n\n.logRow-netInfo.loading .netInfoResponseText {\n    font-style: italic;\n    color: #888888;\n}\n\n.loading .netInfoResponseHeadersTitle {\n    display: none;\n}\n\n.netInfoResponseSizeLimit {\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    padding-top: 10px;\n    font-size: 11px;\n}\n\n.netInfoText {\n    display: none;\n    margin: 0;\n    border: 1px solid #D7D7D7;\n    border-right: none;\n    padding: 8px;\n    background-color: #FFFFFF;\n    font-family: Monaco, monospace;\n    white-space: pre-wrap;\n    /*overflow-x: auto; HTML is damaged in case of big (2-3MB) responses */\n}\n\n/* replaced by .netInfoTextSelected for IE6 support \n.netInfoText[selected="true"] {\n    display: block;\n}\n/**/\n.netInfoTextSelected {\n    display: block;\n}\n\n.netInfoParamName {\n    padding-right: 10px;\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-weight: bold;\n    vertical-align: top;\n    text-align: right;\n    white-space: nowrap;\n}\n\n.netInfoPostText .netInfoParamName {\n    width: 1px; /* Google Chrome need this otherwise the first column of \n                   the post variables table will be larger than expected */\n}\n\n.netInfoParamValue {\n    width: 100%;\n}\n\n.netInfoHeadersText,\n.netInfoPostText,\n.netInfoPutText {\n    padding-top: 0;\n}\n\n.netInfoHeadersGroup,\n.netInfoPostParams,\n.netInfoPostSource {\n    margin-bottom: 4px;\n    border-bottom: 1px solid #D7D7D7;\n    padding-top: 8px;\n    padding-bottom: 2px;\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-weight: bold;\n    color: #565656;\n}\n\n.netInfoPostParamsTable,\n.netInfoPostPartsTable,\n.netInfoPostJSONTable,\n.netInfoPostXMLTable,\n.netInfoPostSourceTable {\n    margin-bottom: 10px;\n    width: 100%;\n}\n\n.netInfoPostContentType {\n    color: #bdbdbd;\n    padding-left: 50px;\n    font-weight: normal;\n}\n\n.netInfoHtmlPreview {\n    border: 0;\n    width: 100%;\n    height:100%;\n}\n\n/************************************************************************************************/\n/* Request & Response Headers */\n\n.netHeadersViewSource {\n    color: #bdbdbd;\n    margin-left: 200px;\n    font-weight: normal;\n}\n\n.netHeadersViewSource:hover {\n    color: blue;\n    cursor: pointer;\n}\n\n/************************************************************************************************/\n\n.netActivationRow,\n.netPageSeparatorRow {\n    background: rgb(229, 229, 229) !important;\n    font-weight: normal;\n    color: black;\n}\n\n.netActivationLabel {\n    background: url(chrome://firebug/skin/infoIcon.png) no-repeat 3px 2px;\n    padding-left: 22px;\n}\n\n/************************************************************************************************/\n\n.netPageSeparatorRow {\n    height: 5px !important;\n}\n\n.netPageSeparatorLabel {\n    padding-left: 22px;\n    height: 5px !important;\n}\n\n.netPageRow {\n    background-color: rgb(255, 255, 255);\n}\n\n.netPageRow:hover {\n    background: #EFEFEF;\n}\n\n.netPageLabel {\n    padding: 1px 0 2px 18px !important;\n    font-weight: bold;\n}\n\n/************************************************************************************************/\n\n.netActivationRow > .netCol {\n    border-bottom: 2px solid;\n    -moz-border-bottom-colors: #EFEFEF #999999;\n    padding-top: 2px;\n    padding-bottom: 3px;\n}\n/*\n.useA11y .panelNode-net .a11yFocus:focus,\n.useA11y .panelNode-net .focusRow:focus {\n    outline-offset: -2px;\n    background-color: #FFFFD6 !important;\n}\n\n.useA11y .panelNode-net .netHeaderCell:focus,\n.useA11y .panelNode-net :focus .netHeaderCell,\n.useA11y .panelNode-net :focus .netReceivingBar,\n.useA11y .netSummaryRow :focus .netBar,\n.useA11y .netSummaryRow:focus .netBar {\n    background-color: #FFFFD6;\n    background-image: none;\n    border-color: #FFFFD6;\n}\n/**/\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* Windows */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n\n\n/************************************************************************************************/\n/* Twisties */\n\n.twisty,\n.logRow-errorMessage > .hasTwisty > .errorTitle,\n.logRow-log > .objectBox-array.hasTwisty,\n.logRow-spy .spyHead .spyTitle,\n.logGroup > .logRow,\n.memberRow.hasChildren > .memberLabelCell > .memberLabel,\n.hasHeaders .netHrefLabel,\n.netPageRow > .netCol > .netPageTitle {\n    background-image: url(tree_open.gif);\n    background-repeat: no-repeat;\n    background-position: 2px 2px;\n    min-height: 12px;\n}\n\n.logRow-errorMessage > .hasTwisty.opened > .errorTitle,\n.logRow-log > .objectBox-array.hasTwisty.opened,\n.logRow-spy.opened .spyHead .spyTitle,\n.logGroup.opened > .logRow,\n.memberRow.hasChildren.opened > .memberLabelCell > .memberLabel,\n.nodeBox.highlightOpen > .nodeLabel > .twisty,\n.nodeBox.open > .nodeLabel > .twisty,\n.netRow.opened > .netCol > .netHrefLabel,\n.netPageRow.opened > .netCol > .netPageTitle {\n    background-image: url(tree_close.gif);\n}\n\n.twisty {\n    background-position: 4px 4px;\n}\n\n\n\n/************************************************************************************************/\n/* Twisties IE6 */\n\n/* IE6 has problems with > operator, and multiple classes */\n\n* html .logRow-spy .spyHead .spyTitle,\n* html .logGroup .logGroupLabel,\n* html .hasChildren .memberLabelCell .memberLabel,\n* html .hasHeaders .netHrefLabel {\n    background-image: url(tree_open.gif);\n    background-repeat: no-repeat;\n    background-position: 2px 2px;\n}\n\n* html .opened .spyHead .spyTitle,\n* html .opened .logGroupLabel, \n* html .opened .memberLabelCell .memberLabel {\n    background-image: url(tree_close.gif);\n    background-repeat: no-repeat;\n    background-position: 2px 2px;\n}\n\n\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* Console */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n\n\n/* See license.txt for terms of usage */\n\n.panelNode-console {\n    overflow-x: hidden;\n}\n\n.objectLink {\n    text-decoration: none;\n}\n\n.objectLink:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n\n.logRow {\n    position: relative;\n    margin: 0;\n    border-bottom: 1px solid #D7D7D7;\n    padding: 2px 4px 1px 6px;\n    background-color: #FFFFFF;\n    overflow: hidden !important; /* IE need this to avoid disappearing bug with collapsed logs */\n}\n\n.useA11y .logRow:focus {\n    border-bottom: 1px solid #000000 !important;\n    outline: none !important;\n    background-color: #FFFFAD !important;\n}\n\n.useA11y .logRow:focus a.objectLink-sourceLink {\n    background-color: #FFFFAD;\n}\n\n.useA11y .a11yFocus:focus, .useA11y .objectBox:focus {\n    outline: 2px solid #FF9933;\n    background-color: #FFFFAD;\n}\n\n.useA11y .objectBox-null:focus, .useA11y .objectBox-undefined:focus{\n    background-color: #888888 !important;\n}\n\n.useA11y .logGroup.opened > .logRow {\n    border-bottom: 1px solid #ffffff;\n}\n\n.logGroup {\n    background: url(group.gif) repeat-x #FFFFFF;\n    padding: 0 !important;\n    border: none !important;\n}\n\n.logGroupBody {\n    display: none;\n    margin-left: 16px;\n    border-left: 1px solid #D7D7D7;\n    border-top: 1px solid #D7D7D7;\n    background: #FFFFFF;\n}\n\n.logGroup > .logRow {\n    background-color: transparent !important;\n    font-weight: bold;\n}\n\n.logGroup.opened > .logRow {\n    border-bottom: none;\n}\n\n.logGroup.opened > .logGroupBody {\n    display: block;\n}\n\n/*****************************************************************************************/\n\n.logRow-command > .objectBox-text {\n    font-family: Monaco, monospace;\n    color: #0000FF;\n    white-space: pre-wrap;\n}\n\n.logRow-info,\n.logRow-warn,\n.logRow-error,\n.logRow-assert,\n.logRow-warningMessage,\n.logRow-errorMessage {\n    padding-left: 22px;\n    background-repeat: no-repeat;\n    background-position: 4px 2px;\n}\n\n.logRow-assert,\n.logRow-warningMessage,\n.logRow-errorMessage {\n    padding-top: 0;\n    padding-bottom: 0;\n}\n\n.logRow-info,\n.logRow-info .objectLink-sourceLink {\n    background-color: #FFFFFF;\n}\n\n.logRow-warn,\n.logRow-warningMessage,\n.logRow-warn .objectLink-sourceLink,\n.logRow-warningMessage .objectLink-sourceLink {\n    background-color: cyan;\n}\n\n.logRow-error,\n.logRow-assert,\n.logRow-errorMessage,\n.logRow-error .objectLink-sourceLink,\n.logRow-errorMessage .objectLink-sourceLink {\n    background-color: LightYellow;\n}\n\n.logRow-error,\n.logRow-assert,\n.logRow-errorMessage {\n    color: #FF0000;\n}\n\n.logRow-info {\n    /*background-image: url(chrome://firebug/skin/infoIcon.png);*/\n}\n\n.logRow-warn,\n.logRow-warningMessage {\n    /*background-image: url(chrome://firebug/skin/warningIcon.png);*/\n}\n\n.logRow-error,\n.logRow-assert,\n.logRow-errorMessage {\n    /*background-image: url(chrome://firebug/skin/errorIcon.png);*/\n}\n\n/*****************************************************************************************/\n\n.objectBox-string,\n.objectBox-text,\n.objectBox-number,\n.objectLink-element,\n.objectLink-textNode,\n.objectLink-function,\n.objectBox-stackTrace,\n.objectLink-profile {\n    font-family: Monaco, monospace;\n}\n\n.objectBox-string,\n.objectBox-text,\n.objectLink-textNode {\n    white-space: pre-wrap;\n}\n\n.objectBox-number,\n.objectLink-styleRule,\n.objectLink-element,\n.objectLink-textNode {\n    color: #000088;\n}\n\n.objectBox-string {\n    color: #FF0000;\n}\n\n.objectLink-function,\n.objectBox-stackTrace,\n.objectLink-profile  {\n    color: DarkGreen;\n}\n\n.objectBox-null,\n.objectBox-undefined {\n    padding: 0 2px;\n    border: 1px solid #666666;\n    background-color: #888888;\n    color: #FFFFFF;\n}\n\n.objectBox-exception {\n    padding: 0 2px 0 18px;\n    /*background: url(chrome://firebug/skin/errorIcon-sm.png) no-repeat 0 0;*/\n    color: red;\n}\n\n.objectLink-sourceLink {\n    position: absolute;\n    right: 4px;\n    top: 2px;\n    padding-left: 8px;\n    font-family: Lucida Grande, sans-serif;\n    font-weight: bold;\n    color: #0000FF;\n}\n\n/************************************************************************************************/\n\n.errorTitle {\n    margin-top: 0px;\n    margin-bottom: 1px;\n    padding-top: 2px;\n    padding-bottom: 2px;\n}\n\n.errorTrace {\n    margin-left: 17px;\n}\n\n.errorSourceBox {\n    margin: 2px 0;\n}\n\n.errorSource-none {\n    display: none;\n}\n\n.errorSource-syntax > .errorBreak {\n    visibility: hidden;\n}\n\n.errorSource {\n    cursor: pointer;\n    font-family: Monaco, monospace;\n    color: DarkGreen;\n}\n\n.errorSource:hover {\n    text-decoration: underline;\n}\n\n.errorBreak {\n    cursor: pointer;\n    display: none;\n    margin: 0 6px 0 0;\n    width: 13px;\n    height: 14px;\n    vertical-align: bottom;\n    /*background: url(chrome://firebug/skin/breakpoint.png) no-repeat;*/\n    opacity: 0.1;\n}\n\n.hasBreakSwitch .errorBreak {\n    display: inline;\n}\n\n.breakForError .errorBreak {\n    opacity: 1;\n}\n\n.assertDescription {\n    margin: 0;\n}\n\n/************************************************************************************************/\n\n.logRow-profile > .logRow > .objectBox-text {\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    color: #000000;\n}\n\n.logRow-profile > .logRow > .objectBox-text:last-child {\n    color: #555555;\n    font-style: italic;\n}\n\n.logRow-profile.opened > .logRow {\n    padding-bottom: 4px;\n}\n\n.profilerRunning > .logRow {\n    /*background: transparent url(chrome://firebug/skin/loading_16.gif) no-repeat 2px 0 !important;*/\n    padding-left: 22px !important;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.profileSizer {\n    width:100%;\n    overflow-x:auto;\n    overflow-y: scroll;\n}\n\n.profileTable {\n    border-bottom: 1px solid #D7D7D7;\n    padding: 0 0 4px 0;\n}\n\n.profileTable tr[odd="1"] {\n    background-color: #F5F5F5;\n    vertical-align:middle;\n}\n\n.profileTable a {\n    vertical-align:middle;\n}\n\n.profileTable td {\n    padding: 1px 4px 0 4px;\n}\n\n.headerCell {\n    cursor: pointer;\n    -moz-user-select: none;\n    border-bottom: 1px solid #9C9C9C;\n    padding: 0 !important;\n    font-weight: bold;\n    /*background: #BBBBBB url(chrome://firebug/skin/tableHeader.gif) repeat-x;*/\n}\n\n.headerCellBox {\n    padding: 2px 4px;\n    border-left: 1px solid #D9D9D9;\n    border-right: 1px solid #9C9C9C;\n}\n\n.headerCell:hover:active {\n    /*background: #959595 url(chrome://firebug/skin/tableHeaderActive.gif) repeat-x;*/\n}\n\n.headerSorted {\n    /*background: #7D93B2 url(chrome://firebug/skin/tableHeaderSorted.gif) repeat-x;*/\n}\n\n.headerSorted > .headerCellBox {\n    border-right-color: #6B7C93;\n    /*background: url(chrome://firebug/skin/arrowDown.png) no-repeat right;*/\n}\n\n.headerSorted.sortedAscending > .headerCellBox {\n    /*background-image: url(chrome://firebug/skin/arrowUp.png);*/\n}\n\n.headerSorted:hover:active {\n    /*background: #536B90 url(chrome://firebug/skin/tableHeaderSortedActive.gif) repeat-x;*/\n}\n\n.linkCell {\n    text-align: right;\n}\n\n.linkCell > .objectLink-sourceLink {\n    position: static;\n}\n\n/*****************************************************************************************/\n\n.logRow-stackTrace {\n    padding-top: 0;\n    background: #f8f8f8;\n}\n\n.logRow-stackTrace > .objectBox-stackFrame {\n    position: relative;\n    padding-top: 2px;\n}\n\n/************************************************************************************************/\n\n.objectLink-object {\n    font-family: Lucida Grande, sans-serif;\n    font-weight: bold;\n    color: DarkGreen;\n    white-space: pre-wrap;\n}\n\n/* xxxpedro reps object representation .................................... */\n.objectProp-object {\n    color: DarkGreen;\n}\n\n.objectProps {\n    color: #000;\n    font-weight: normal;\n}\n\n.objectPropName {\n    /*font-style: italic;*/\n    color: #777;\n}\n\n/*\n.objectProps .objectProp-string,\n.objectProps .objectProp-number,\n.objectProps .objectProp-object\n{\n    font-style: italic;\n}\n/**/\n\n.objectProps .objectProp-string\n{\n    /*font-family: Monaco, monospace;*/\n    color: #f55;\n}\n.objectProps .objectProp-number\n{\n    /*font-family: Monaco, monospace;*/\n    color: #55a;\n}\n.objectProps .objectProp-object\n{\n    /*font-family: Lucida Grande,sans-serif;*/\n    color: #585;\n}\n/* xxxpedro reps object representation .................................... */\n\n/************************************************************************************************/\n\n.selectorTag,\n.selectorId,\n.selectorClass {\n    font-family: Monaco, monospace;\n    font-weight: normal;\n}\n\n.selectorTag {\n    color: #0000FF;\n}\n\n.selectorId {\n    color: DarkBlue;\n}\n\n.selectorClass {\n    color: red;\n}\n\n.selectorHidden > .selectorTag {\n    color: #5F82D9;\n}\n\n.selectorHidden > .selectorId {\n    color: #888888;\n}\n\n.selectorHidden > .selectorClass {\n    color: #D86060;\n}\n\n.selectorValue {\n    font-family: Lucida Grande, sans-serif;\n    font-style: italic;\n    color: #555555;\n}\n\n/*****************************************************************************************/\n\n.panelNode.searching .logRow {\n    display: none;\n}\n\n.logRow.matched {\n    display: block !important;\n}\n\n.logRow.matching {\n    position: absolute;\n    left: -1000px;\n    top: -1000px;\n    max-width: 0;\n    max-height: 0;\n    overflow: hidden;\n}\n\n/*****************************************************************************************/\n\n.objectLeftBrace,\n.objectRightBrace,\n.objectEqual,\n.objectComma,\n.arrayLeftBracket,\n.arrayRightBracket,\n.arrayComma {\n    font-family: Monaco, monospace;\n}\n\n.objectLeftBrace,\n.objectRightBrace,\n.arrayLeftBracket,\n.arrayRightBracket {\n    font-weight: bold;\n}\n\n.objectLeftBrace,\n.arrayLeftBracket {\n    margin-right: 4px;\n}\n\n.objectRightBrace,\n.arrayRightBracket {\n    margin-left: 4px;\n}\n\n/*****************************************************************************************/\n\n.logRow-dir {\n    padding: 0;\n}\n\n/************************************************************************************************/\n\n/*\n.logRow-errorMessage > .hasTwisty > .errorTitle,\n.logRow-spy .spyHead .spyTitle,\n.logGroup > .logRow \n*/\n.logRow-errorMessage .hasTwisty .errorTitle,\n.logRow-spy .spyHead .spyTitle,\n.logGroup .logRow {\n    cursor: pointer;\n    padding-left: 18px;\n    background-repeat: no-repeat;\n    background-position: 3px 3px;\n}\n\n.logRow-errorMessage > .hasTwisty > .errorTitle {\n    background-position: 2px 3px;\n}\n\n.logRow-errorMessage > .hasTwisty > .errorTitle:hover,\n.logRow-spy .spyHead .spyTitle:hover,\n.logGroup > .logRow:hover {\n    text-decoration: underline;\n}\n\n/*****************************************************************************************/\n\n.logRow-spy {\n    padding: 0 !important;\n}\n\n.logRow-spy,\n.logRow-spy .objectLink-sourceLink {\n    background: url(group.gif) repeat-x #FFFFFF;\n    padding-right: 4px;\n    right: 0;\n}\n\n.logRow-spy.opened {\n    padding-bottom: 4px;\n    border-bottom: none;\n}\n\n.spyTitle {\n    color: #000000;\n    font-weight: bold;\n    -moz-box-sizing: padding-box;\n    overflow: hidden;\n    z-index: 100;\n    padding-left: 18px;\n}\n\n.spyCol {\n    padding: 0;\n    white-space: nowrap;\n    height: 16px;\n}\n\n.spyTitleCol:hover > .objectLink-sourceLink,\n.spyTitleCol:hover > .spyTime,\n.spyTitleCol:hover > .spyStatus,\n.spyTitleCol:hover > .spyTitle {\n    display: none;\n}\n\n.spyFullTitle {\n    display: none;\n    -moz-user-select: none;\n    max-width: 100%;\n    background-color: Transparent;\n}\n\n.spyTitleCol:hover > .spyFullTitle {\n    display: block;\n}\n\n.spyStatus {\n    padding-left: 10px;\n    color: rgb(128, 128, 128);\n}\n\n.spyTime {\n    margin-left:4px;\n    margin-right:4px;\n    color: rgb(128, 128, 128);\n}\n\n.spyIcon {\n    margin-right: 4px;\n    margin-left: 4px;\n    width: 16px;\n    height: 16px;\n    vertical-align: middle;\n    background: transparent no-repeat 0 0;\n    display: none;\n}\n\n.loading .spyHead .spyRow .spyIcon {\n    background-image: url(loading_16.gif);\n    display: block;\n}\n\n.logRow-spy.loaded:not(.error) .spyHead .spyRow .spyIcon {\n    width: 0;\n    margin: 0;\n}\n\n.logRow-spy.error .spyHead .spyRow .spyIcon {\n    background-image: url(errorIcon-sm.png);\n    display: block;\n    background-position: 2px 2px;\n}\n\n.logRow-spy .spyHead .netInfoBody {\n    display: none;\n}\n\n.logRow-spy.opened .spyHead .netInfoBody {\n    margin-top: 10px;\n    display: block;\n}\n\n.logRow-spy.error .spyTitle,\n.logRow-spy.error .spyStatus,\n.logRow-spy.error .spyTime {\n    color: red;\n}\n\n.logRow-spy.loading .spyResponseText {\n    font-style: italic;\n    color: #888888;\n}\n\n/************************************************************************************************/\n\n.caption {\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-weight: bold;\n    color:  #444444;\n}\n\n.warning {\n    padding: 10px;\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-weight: bold;\n    color:  #888888;\n}\n\n\n\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* DOM */\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n\n\n/* See license.txt for terms of usage */\n\n.panelNode-dom {\n    overflow-x: hidden !important;\n}\n\n.domTable {\n    font-size: 1em;\n    width: 100%;\n    table-layout: fixed;\n    background: #fff;\n}\n\n.domTableIE {\n    width: auto;\n}\n\n.memberLabelCell {\n    padding: 2px 0 2px 0;\n    vertical-align: top;\n}\n\n.memberValueCell {\n    padding: 1px 0 1px 5px;\n    display: block;\n    overflow: hidden;\n}\n\n.memberLabel {\n    display: block;\n    cursor: default;\n    -moz-user-select:  none;\n    overflow: hidden;\n    /*position: absolute;*/\n    padding-left: 18px;\n    /*max-width: 30%;*/\n    /*white-space: nowrap;*/\n    background-color: #FFFFFF;\n    text-decoration: none;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.memberRow.hasChildren .memberLabelCell .memberLabel:hover {\n    cursor: pointer;\n    color: blue;\n    text-decoration: underline;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.userLabel {\n    color: #000000;\n    font-weight: bold;\n}\n\n.userClassLabel {\n    color: #E90000;\n    font-weight: bold;\n}\n\n.userFunctionLabel {\n    color: #025E2A;\n    font-weight: bold;\n}\n\n.domLabel {\n    color: #000000;\n}\n\n.domFunctionLabel {\n    color: #025E2A;\n}\n\n.ordinalLabel {\n    color: SlateBlue;\n    font-weight: bold;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n.scopesRow {\n    padding: 2px 18px;\n    background-color: LightYellow;\n    border-bottom: 5px solid #BEBEBE;\n    color: #666666;\n}\n.scopesLabel {\n    background-color:  LightYellow;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.watchEditCell {\n    padding: 2px 18px;\n    background-color: LightYellow;\n    border-bottom: 1px solid #BEBEBE;\n    color: #666666;\n}\n\n.editor-watchNewRow,\n.editor-memberRow {\n    font-family: Monaco, monospace !important;\n}\n\n.editor-memberRow {\n    padding: 1px 0 !important;\n}\n\n.editor-watchRow {\n    padding-bottom: 0 !important;\n}\n\n.watchRow > .memberLabelCell {\n    font-family: Monaco, monospace;\n    padding-top: 1px;\n    padding-bottom: 1px;\n}\n\n.watchRow > .memberLabelCell > .memberLabel {\n    background-color: transparent;\n}\n\n.watchRow > .memberValueCell {\n    padding-top: 2px;\n    padding-bottom: 2px;\n}\n\n.watchRow > .memberLabelCell,\n.watchRow > .memberValueCell {\n    background-color: #F5F5F5;\n    border-bottom: 1px solid #BEBEBE;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.watchToolbox {\n    z-index: 2147483647;\n    position: absolute;\n    right: 0;\n    padding: 1px 2px;\n}\n\n\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/*************************************************************************************************/\n/* FROM ORIGINAL FIREBUG */\n\n\n\n\n/************************************************************************************************\n CSS Not organized\n*************************************************************************************************/\n#fbConsole {\n    overflow-x: hidden !important;\n}\n\n#fbCSS {\n    font: 1em Monaco, monospace;\n    padding: 0 7px;\n}\n\n#fbstylesheetButtons select, #fbScriptButtons select {\n    font: 11px Lucida Grande, Tahoma, sans-serif;\n    margin-top: 1px;\n    padding-left: 3px;\n    background: #fafafa;\n    border: 1px inset #fff;\n    width: 220px;\n    outline: none;\n}\n\n.Selector { margin-top:10px }\n.CSSItem {margin-left: 4% }\n.CSSText { padding-left:20px; }\n.CSSProperty { color:#005500; }\n.CSSValue { padding-left:5px; color:#000088; }\n\n\n/************************************************************************************************\n Not organized\n*************************************************************************************************/\n\n#fbHTMLStatusBar {\n    display: inline;\n}\n\n.fbToolbarButtons {\n    display: none;\n}\n\n.fbStatusSeparator{\n    display: block;\n    float: left;\n    padding-top: 4px;\n}\n\n#fbStatusBarBox {\n    display: none;\n}\n\n#fbToolbarContent {\n    display: block;\n    position: absolute;\n    _position: absolute;\n    top: 0;\n    padding-top: 4px;\n    height: 23px;\n    clip: rect(0, 2048px, 27px, 0);\n}\n\n.fbTabMenuTarget {\n    display: none !important;\n    float: left;\n    width: 10px;\n    height: 10px;\n    margin-top: 6px;\n    background: url(tabMenuTarget.png);   \n}\n\n.fbTabMenuTarget:hover {\n    background: url(tabMenuTargetHover.png);   \n}\n\n.fbShadow {\n    float: left;\n    background: url(shadowAlpha.png) no-repeat bottom right !important;\n    background: url(shadow2.gif) no-repeat bottom right;\n    margin: 10px 0 0 10px !important;\n    margin: 10px 0 0 5px;\n}\n\n.fbShadowContent {\n    display: block;\n    position: relative;\n    background-color: #fff;\n    border: 1px solid #a9a9a9;\n    top: -6px;\n    left: -6px;\n}\n\n.fbMenu {\n    display: none;\n    position: absolute;\n    font-size: 11px;\n    line-height: 13px;\n    z-index: 2147483647;\n}\n\n.fbMenuContent {\n    padding: 2px;\n}\n\n.fbMenuSeparator {\n    display: block;\n    position: relative;\n    padding: 1px 18px 0;\n    text-decoration: none;\n    color: #000;\n    cursor: default;    \n    background: #ACA899;\n    margin: 4px 0;\n}\n\n.fbMenuOption\n{\n    display: block;\n    position: relative;\n    padding: 2px 18px;\n    text-decoration: none;\n    color: #000;\n    cursor: default;\n}\n\n.fbMenuOption:hover\n{\n    color: #fff;\n    background: #316AC5;\n}\n\n.fbMenuGroup {\n    background: transparent url(tabMenuPin.png) no-repeat right 0;\n}\n\n.fbMenuGroup:hover {\n    background: #316AC5 url(tabMenuPin.png) no-repeat right -17px;\n}\n\n.fbMenuGroupSelected {\n    color: #fff;\n    background: #316AC5 url(tabMenuPin.png) no-repeat right -17px;\n}\n\n.fbMenuChecked  {\n    background: transparent url(tabMenuCheckbox.png) no-repeat 4px 0;\n}\n\n.fbMenuChecked:hover {\n    background: #316AC5 url(tabMenuCheckbox.png) no-repeat 4px -17px;\n}\n\n.fbMenuRadioSelected {\n    background: transparent url(tabMenuRadio.png) no-repeat 4px 0;\n}\n\n.fbMenuRadioSelected:hover {\n    background: #316AC5 url(tabMenuRadio.png) no-repeat 4px -17px;\n}\n\n.fbMenuShortcut {\n    padding-right: 85px; \n}\n\n.fbMenuShortcutKey {\n    position: absolute;\n    right: 0;\n    top: 2px;\n    width: 77px;\n}\n\n#fbFirebugMenu {\n    top: 22px;\n    left: 0;\n}\n\n.fbMenuDisabled {\n    color: #ACA899 !important;\n}\n\n#fbFirebugSettingsMenu {\n    left: 245px;\n    top: 99px;\n}\n\n#fbConsoleMenu {\n    top: 42px;\n    left: 48px;\n}\n\n.fbIconButton {\n    display: block;\n}\n\n.fbIconButton {\n    display: block;\n}\n\n.fbIconButton {\n    display: block;\n    float: left;\n    height: 20px;\n    width: 20px;\n    color: #000;\n    margin-right: 2px;\n    text-decoration: none;\n    cursor: default;\n}\n\n.fbIconButton:hover {\n    position: relative;\n    top: -1px;\n    left: -1px;\n    margin-right: 0;\n    _margin-right: 1px;\n    color: #333;\n    border: 1px solid #fff;\n    border-bottom: 1px solid #bbb;\n    border-right: 1px solid #bbb;\n}\n\n.fbIconPressed {\n    position: relative;\n    margin-right: 0;\n    _margin-right: 1px;\n    top: 0 !important;\n    left: 0 !important;\n    height: 19px;\n    color: #333 !important;\n    border: 1px solid #bbb !important;\n    border-bottom: 1px solid #cfcfcf !important;\n    border-right: 1px solid #ddd !important;\n}\n\n\n\n/************************************************************************************************\n Error Popup\n*************************************************************************************************/\n#fbErrorPopup {\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    height: 19px;\n    width: 75px;\n    background: url(sprite.png) #f1f2ee 0 0;\n    z-index: 999;\n}\n\n#fbErrorPopupContent {\n    position: absolute;\n    right: 0;\n    top: 1px;\n    height: 18px;\n    width: 75px;\n    _width: 74px;\n    border-left: 1px solid #aca899;\n}\n\n#fbErrorIndicator {\n    position: absolute;\n    top: 2px;\n    right: 5px;\n}\n\n\n\n\n\n\n\n\n\n\n.fbBtnInspectActive {\n    background: #aaa;\n    color: #fff !important;\n}\n\n/************************************************************************************************\n General\n*************************************************************************************************/\n.fbBody {\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n    \n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-size: 11px;\n    background: #fff;\n}\n\n.clear {\n    clear: both;\n}\n\n/************************************************************************************************\n Mini Chrome\n*************************************************************************************************/\n#fbMiniChrome {\n    display: none;\n    right: 0;\n    height: 27px;\n    background: url(sprite.png) #f1f2ee 0 0;\n    margin-left: 1px;\n}\n\n#fbMiniContent {\n    display: block;\n    position: relative;\n    left: -1px;\n    right: 0;\n    top: 1px;\n    height: 25px;\n    border-left: 1px solid #aca899;\n}\n\n#fbToolbarSearch {\n    float: right;\n    border: 1px solid #ccc;\n    margin: 0 5px 0 0;\n    background: #fff url(search.png) no-repeat 4px 2px !important;\n    background: #fff url(search.gif) no-repeat 4px 2px;\n    padding-left: 20px;    \n    font-size: 11px;\n}\n\n#fbToolbarErrors {\n    float: right;\n    margin: 1px 4px 0 0;\n    font-size: 11px;\n}\n\n#fbLeftToolbarErrors {\n    float: left;\n    margin: 7px 0px 0 5px;\n    font-size: 11px;\n}\n\n.fbErrors {\n    padding-left: 20px;\n    height: 14px;\n    background: url(errorIcon.png) no-repeat !important;\n    background: url(errorIcon.gif) no-repeat;\n    color: #f00;\n    font-weight: bold;    \n}\n\n#fbMiniErrors {\n    display: inline;\n    display: none;\n    float: right;\n    margin: 5px 2px 0 5px;\n}\n\n#fbMiniIcon {\n    float: right;\n    margin: 3px 4px 0;\n    height: 20px;\n    width: 20px;\n    float: right;    \n    background: url(sprite.png) 0 -135px;\n    cursor: pointer;\n}\n\n\n/************************************************************************************************\n Master Layout\n*************************************************************************************************/\n#fbChrome {\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-size: 11px;\n    position: absolute;\n    _position: static;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    border-collapse: collapse;\n    border-spacing: 0;\n    background: #fff;\n    overflow: hidden;\n}\n\n#fbChrome > tbody > tr > td {\n    padding: 0;\n}\n\n#fbTop {\n    height: 49px;\n}\n\n#fbToolbar {\n    background: url(sprite.png) #f1f2ee 0 0;\n    height: 27px;\n    font-size: 11px;\n    line-height: 13px;\n}\n\n#fbPanelBarBox {\n    background: url(sprite.png) #dbd9c9 0 -27px;\n    height: 22px;\n}\n\n#fbContent {\n    height: 100%;\n    vertical-align: top;\n}\n\n#fbBottom {\n    height: 18px;\n    background: #fff;\n}\n\n/************************************************************************************************\n Sub-Layout \n*************************************************************************************************/\n\n/* fbToolbar \n*************************************************************************************************/\n#fbToolbarIcon {\n    float: left;\n    padding: 0 5px 0;\n}\n\n#fbToolbarIcon a {\n    background: url(sprite.png) 0 -135px;\n}\n\n#fbToolbarButtons {\n    padding: 0 2px 0 5px;\n}\n\n#fbToolbarButtons {\n    padding: 0 2px 0 5px;\n}\n/*\n#fbStatusBarBox a {\n    text-decoration: none;\n    display: block;\n    float: left;\n    color: #000;\n    padding: 4px 5px;\n    margin: 0 0 0 1px;\n    cursor: default;\n}\n\n#fbStatusBarBox a:hover {\n    color: #333;\n    padding: 3px 4px;\n    border: 1px solid #fff;\n    border-bottom: 1px solid #bbb;\n    border-right: 1px solid #bbb;\n}\n/**/\n\n.fbButton {\n    text-decoration: none;\n    display: block;\n    float: left;\n    color: #000;\n    padding: 4px 6px 4px 7px;\n    cursor: default;\n}\n\n.fbButton:hover {\n    color: #333;\n    background: #f5f5ef url(buttonBg.png);\n    padding: 3px 5px 3px 6px;\n    border: 1px solid #fff;\n    border-bottom: 1px solid #bbb;\n    border-right: 1px solid #bbb;\n}\n\n.fbBtnPressed {\n    background: #e3e3db url(buttonBgHover.png) !important;\n    padding: 3px 4px 2px 6px !important;\n    margin: 1px 0 0 1px !important;\n    border: 1px solid #ACA899 !important;\n    border-color: #ACA899 #ECEBE3 #ECEBE3 #ACA899 !important;\n}\n\n#fbStatusBarBox {\n    top: 4px;\n    cursor: default;    \n}\n\n.fbToolbarSeparator {\n    overflow: hidden;\n    border: 1px solid;\n    border-color: transparent #fff transparent #777;\n    _border-color: #eee #fff #eee #777;\n    height: 7px;\n    margin: 6px 3px;\n    float: left;\n}\n\n.fbBtnSelected {\n    font-weight: bold;\n}\n\n.fbStatusBar {\n    color: #aca899;\n}\n\n.fbStatusBar a {\n    text-decoration: none;\n    color: black;\n}\n\n.fbStatusBar a:hover {\n    color: blue;\n    cursor: pointer;    \n}\n\n\n#fbWindowButtons {\n    position: absolute;\n    white-space: nowrap;\n    right: 0;\n    top: 0;\n    height: 17px;\n    width: 48px;\n    padding: 5px;\n    z-index: 6;\n    background: url(sprite.png) #f1f2ee 0 0;\n}\n\n/* fbPanelBarBox\n*************************************************************************************************/\n\n#fbPanelBar1 {\n    width: 1024px; /* fixed width to avoid tabs breaking line */\n    z-index: 8;\n    left: 0;\n    white-space: nowrap;\n    background: url(sprite.png) #dbd9c9 0 -27px;\n    position: absolute;\n    left: 4px;\n}\n\n#fbPanelBar2Box {\n    background: url(sprite.png) #dbd9c9 0 -27px;\n    position: absolute;\n    height: 22px;\n    width: 300px; /* fixed width to avoid tabs breaking line */\n    z-index: 9;\n    right: 0;\n}\n\n#fbPanelBar2 {\n    position: absolute;\n    width: 290px; /* fixed width to avoid tabs breaking line */\n    height: 22px;\n    padding-left: 4px;\n}\n\n/* body \n*************************************************************************************************/\n.fbPanel {\n    display: none;\n}\n\n#fbPanelBox1, #fbPanelBox2 {\n    max-height: inherit;\n    height: 100%;\n    font-size: 1em;\n}\n\n#fbPanelBox2 {\n    background: #fff;\n}\n\n#fbPanelBox2 {\n    width: 300px;\n    background: #fff;\n}\n\n#fbPanel2 {\n    margin-left: 6px;\n    background: #fff;\n}\n\n#fbLargeCommandLine {\n    display: none;\n    position: absolute;\n    z-index: 9;\n    top: 27px;\n    right: 0;\n    width: 294px;\n    height: 201px;\n    border-width: 0;\n    margin: 0;\n    padding: 2px 0 0 2px;\n    resize: none;\n    outline: none;\n    font-size: 11px;\n    overflow: auto;\n    border-top: 1px solid #B9B7AF;\n    _right: -1px;\n    _border-left: 1px solid #fff;\n}\n\n#fbLargeCommandButtons {\n    display: none;\n    background: #ECE9D8;\n    bottom: 0;\n    right: 0;\n    width: 294px;\n    height: 21px;\n    padding-top: 1px;\n    position: fixed;\n    border-top: 1px solid #ACA899;\n    z-index: 9;\n}\n\n#fbSmallCommandLineIcon {\n    background: url(down.png) no-repeat;\n    position: absolute;\n    right: 2px;\n    bottom: 3px;\n    \n    z-index: 99;\n}\n\n#fbSmallCommandLineIcon:hover {\n    background: url(downHover.png) no-repeat;\n}\n\n.hide {\n    overflow: hidden !important;\n    position: fixed !important;\n    display: none !important;\n    visibility: hidden !important;\n}\n\n/* fbBottom \n*************************************************************************************************/\n\n#fbCommand {\n    height: 18px;\n}\n\n#fbCommandBox {\n    position: fixed;\n    _position: absolute;\n    width: 100%;\n    height: 18px;\n    bottom: 0;\n    overflow: hidden;\n    z-index: 9;\n    background: #fff;\n    border: 0;\n    border-top: 1px solid #ccc;\n}\n\n#fbCommandIcon {\n    position: absolute;\n    color: #00f;\n    top: 2px;\n    left: 6px;\n    display: inline;\n    font: 11px Monaco, monospace;\n    z-index: 10;\n}\n\n#fbCommandLine {\n    position: absolute;\n    width: 100%;\n    top: 0;\n    left: 0;\n    border: 0;\n    margin: 0;\n    padding: 2px 0 2px 32px;\n    font: 11px Monaco, monospace;\n    z-index: 9;\n    outline: none;\n}\n\n#fbLargeCommandLineIcon {\n    background: url(up.png) no-repeat;\n    position: absolute;\n    right: 1px;\n    bottom: 1px;\n    z-index: 10;\n}\n\n#fbLargeCommandLineIcon:hover {\n    background: url(upHover.png) no-repeat;\n}\n\ndiv.fbFitHeight {\n    overflow: auto;\n    position: relative;\n}\n\n\n/************************************************************************************************\n Layout Controls\n*************************************************************************************************/\n\n/* fbToolbar buttons \n*************************************************************************************************/\n.fbSmallButton {\n    overflow: hidden;\n    width: 16px;\n    height: 16px;\n    display: block;\n    text-decoration: none;\n    cursor: default;\n}\n\n#fbWindowButtons .fbSmallButton {\n    float: right;\n}\n\n#fbWindow_btClose {\n    background: url(min.png);\n}\n\n#fbWindow_btClose:hover {\n    background: url(minHover.png);\n}\n\n#fbWindow_btDetach {\n    background: url(detach.png);\n}\n\n#fbWindow_btDetach:hover {\n    background: url(detachHover.png);\n}\n\n#fbWindow_btDeactivate {\n    background: url(off.png);\n}\n\n#fbWindow_btDeactivate:hover {\n    background: url(offHover.png);\n}\n\n\n/* fbPanelBarBox tabs \n*************************************************************************************************/\n.fbTab {\n    text-decoration: none;\n    display: none;\n    float: left;\n    width: auto;\n    float: left;\n    cursor: default;\n    font-family: Lucida Grande, Tahoma, sans-serif;\n    font-size: 11px;\n    line-height: 13px;\n    font-weight: bold;\n    height: 22px;\n    color: #565656;\n}\n\n.fbPanelBar span {\n    /*display: block; TODO: safe to remove this? */\n    float: left;\n}\n\n.fbPanelBar .fbTabL,.fbPanelBar .fbTabR {\n    height: 22px;\n    width: 8px;\n}\n\n.fbPanelBar .fbTabText {\n    padding: 4px 1px 0;\n}\n\na.fbTab:hover {\n    background: url(sprite.png) 0 -73px;\n}\n\na.fbTab:hover .fbTabL {\n    background: url(sprite.png) -16px -96px;\n}\n\na.fbTab:hover .fbTabR {\n    background: url(sprite.png) -24px -96px;\n}\n\n.fbSelectedTab {\n    background: url(sprite.png) #f1f2ee 0 -50px !important;\n    color: #000;\n}\n\n.fbSelectedTab .fbTabL {\n    background: url(sprite.png) 0 -96px !important;\n}\n\n.fbSelectedTab .fbTabR {\n    background: url(sprite.png) -8px -96px !important;\n}\n\n/* splitters \n*************************************************************************************************/\n#fbHSplitter {\n    position: fixed;\n    _position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 5px;\n    overflow: hidden;\n    cursor: n-resize !important;\n    background: url(pixel_transparent.gif);\n    z-index: 9;\n}\n\n#fbHSplitter.fbOnMovingHSplitter {\n    height: 100%;\n    z-index: 100;\n}\n\n.fbVSplitter {\n    background: #ece9d8;\n    color: #000;\n    border: 1px solid #716f64;\n    border-width: 0 1px;\n    border-left-color: #aca899;\n    width: 4px;\n    cursor: e-resize;\n    overflow: hidden;\n    right: 294px;\n    text-decoration: none;\n    z-index: 10;\n    position: absolute;\n    height: 100%;\n    top: 27px;\n}\n\n/************************************************************************************************/\ndiv.lineNo {\n    font: 1em/1.4545em Monaco, monospace;\n    position: relative;\n    float: left;\n    top: 0;\n    left: 0;\n    margin: 0 5px 0 0;\n    padding: 0 5px 0 10px;\n    background: #eee;\n    color: #888;\n    border-right: 1px solid #ccc;\n    text-align: right;\n}\n\n.sourceBox {\n    position: absolute;\n}\n\n.sourceCode {\n    font: 1em Monaco, monospace;\n    overflow: hidden;\n    white-space: pre;\n    display: inline;\n}\n\n/************************************************************************************************/\n.nodeControl {\n    margin-top: 3px;\n    margin-left: -14px;\n    float: left;\n    width: 9px;\n    height: 9px;\n    overflow: hidden;\n    cursor: default;\n    background: url(tree_open.gif);\n    _float: none;\n    _display: inline;\n    _position: absolute;\n}\n\ndiv.nodeMaximized {\n    background: url(tree_close.gif);\n}\n\ndiv.objectBox-element {\n    padding: 1px 3px;\n}\n.objectBox-selector{\n    cursor: default;\n}\n\n.selectedElement{\n    background: highlight;\n    /* background: url(roundCorner.svg); Opera */\n    color: #fff !important;\n}\n.selectedElement span{\n    color: #fff !important;\n}\n\n/* IE6 need this hack */\n* html .selectedElement {\n    position: relative;\n}\n\n/* Webkit CSS Hack - bug in "highlight" named color */ \n@media screen and (-webkit-min-device-pixel-ratio:0) {\n    .selectedElement{\n      background: #316AC5;\n      color: #fff !important;\n    }\n}\n\n/************************************************************************************************/\n/************************************************************************************************/\n.logRow * {\n    font-size: 1em;\n}\n\n/* TODO: remove this? */\n/* TODO: xxxpedro - IE need this in windowless mode (cnn.com) check if the issue is related to \nposition. if so, override it at chrome.js initialization when creating the div */\n.logRow {\n    position: relative;\n    border-bottom: 1px solid #D7D7D7;\n    padding: 2px 4px 1px 6px;\n    zbackground-color: #FFFFFF;\n}\n/**/\n\n.logRow-command {\n    font-family: Monaco, monospace;\n    color: blue;\n}\n\n.objectBox-string,\n.objectBox-text,\n.objectBox-number,\n.objectBox-function,\n.objectLink-element,\n.objectLink-textNode,\n.objectLink-function,\n.objectBox-stackTrace,\n.objectLink-profile {\n    font-family: Monaco, monospace;\n}\n\n.objectBox-null {\n    padding: 0 2px;\n    border: 1px solid #666666;\n    background-color: #888888;\n    color: #FFFFFF;\n}\n\n.objectBox-string {\n    color: red;\n    \n    /* TODO: xxxpedro make long strings break line */\n    /*white-space: pre; */ \n}\n\n.objectBox-number {\n    color: #000088;\n}\n\n.objectBox-function {\n    color: DarkGreen;\n}\n\n.objectBox-object {\n    color: DarkGreen;\n    font-weight: bold;\n    font-family: Lucida Grande, sans-serif;\n}\n\n.objectBox-array {\n    color: #000;\n}\n\n/************************************************************************************************/\n.logRow-info,.logRow-error,.logRow-warn {\n    background: #fff no-repeat 2px 2px;\n    padding-left: 20px;\n    padding-bottom: 3px;\n}\n\n.logRow-info {\n    background-image: url(infoIcon.png) !important;\n    background-image: url(infoIcon.gif);\n}\n\n.logRow-warn {\n    background-color: cyan;\n    background-image: url(warningIcon.png) !important;\n    background-image: url(warningIcon.gif);\n}\n\n.logRow-error {\n    background-color: LightYellow;\n    background-image: url(errorIcon.png) !important;\n    background-image: url(errorIcon.gif);\n    color: #f00;\n}\n\n.errorMessage {\n    vertical-align: top;\n    color: #f00;\n}\n\n.objectBox-sourceLink {\n    position: absolute;\n    right: 4px;\n    top: 2px;\n    padding-left: 8px;\n    font-family: Lucida Grande, sans-serif;\n    font-weight: bold;\n    color: #0000FF;\n}\n\n/************************************************************************************************/\n/*\n//TODO: remove this when console2 is finished\n*/\n/*\n.logRow-group {\n    background: #EEEEEE;\n    border-bottom: none;\n}\n\n.logGroup {\n    background: #EEEEEE;\n}\n\n.logGroupBox {\n    margin-left: 24px;\n    border-top: 1px solid #D7D7D7;\n    border-left: 1px solid #D7D7D7;\n}/**/\n\n/************************************************************************************************/\n.selectorTag,.selectorId,.selectorClass {\n    font-family: Monaco, monospace;\n    font-weight: normal;\n}\n\n.selectorTag {\n    color: #0000FF;\n}\n\n.selectorId {\n    color: DarkBlue;\n}\n\n.selectorClass {\n    color: red;\n}\n\n/************************************************************************************************/\n.objectBox-element {\n    font-family: Monaco, monospace;\n    color: #000088;\n}\n\n.nodeChildren {\n    padding-left: 26px;\n}\n\n.nodeTag {\n    color: blue;\n    cursor: pointer;\n}\n\n.nodeValue {\n    color: #FF0000;\n    font-weight: normal;\n}\n\n.nodeText,.nodeComment {\n    margin: 0 2px;\n    vertical-align: top;\n}\n\n.nodeText {\n    color: #333333;\n    font-family: Monaco, monospace;\n}\n\n.nodeComment {\n    color: DarkGreen;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeHidden, .nodeHidden * {\n    color: #888888;\n}\n\n.nodeHidden .nodeTag {\n    color: #5F82D9;\n}\n\n.nodeHidden .nodeValue {\n    color: #D86060;\n}\n\n.selectedElement .nodeHidden, .selectedElement .nodeHidden * {\n    color: SkyBlue !important;\n}\n\n\n/************************************************************************************************/\n.log-object {\n    /*\n    _position: relative;\n    _height: 100%;\n    /**/\n}\n\n.property {\n    position: relative;\n    clear: both;\n    height: 15px;\n}\n\n.propertyNameCell {\n    vertical-align: top;\n    float: left;\n    width: 28%;\n    position: absolute;\n    left: 0;\n    z-index: 0;\n}\n\n.propertyValueCell {\n    float: right;\n    width: 68%;\n    background: #fff;\n    position: absolute;\n    padding-left: 5px;\n    display: table-cell;\n    right: 0;\n    z-index: 1;\n    /*\n    _position: relative;\n    /**/\n}\n\n.propertyName {\n    font-weight: bold;\n}\n\n.FirebugPopup {\n    height: 100% !important;\n}\n\n.FirebugPopup #fbWindowButtons {\n    display: none !important;\n}\n\n.FirebugPopup #fbHSplitter {\n    display: none !important;\n}\n',
                        language: 'css',
                        size: 66446,
                        tokens: 5821,
                        lastModified: '2025-07-02T12:28:22.868Z',
                      },
                      {
                        name: 'firebug.html',
                        path: 'vendor/firebug-lite/skin/xp/firebug.html',
                        type: 'file',
                        content:
                          '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/DTD/strict.dtd">\n<html>\n<head>\n<meta http-equiv="content-type" content="text/html; charset=utf-8">\n<title>Firebug Lite</title>\n<!-- An empty script to avoid FOUC when loading the stylesheet -->\n<script type="text/javascript"></script>\n<style type="text/css" media="screen">@import "firebug.css";</style>\n<style>html,body{margin:0;padding:0;overflow:hidden;}</style>\n</head>\n<body class="fbBody">\n<table id="fbChrome" cellpadding="0" cellspacing="0" border="0">\n  <tbody>\n    <tr>\n      <!-- Interface - Top Area -->\n      <td id="fbTop" colspan="2">\n      \n        <!-- \n        <div>\n          --><!-- <span id="fbToolbarErrors" class="fbErrors">2 errors</span> --><!-- \n          <input type="text" id="fbToolbarSearch" />\n        </div>\n        -->\n              \n        <!-- Window Buttons -->\n        <div id="fbWindowButtons">\n          <a id="fbWindow_btDeactivate" class="fbSmallButton fbHover" title="Deactivate Firebug for this web page">&nbsp;</a>\n          <a id="fbWindow_btDetach" class="fbSmallButton fbHover" title="Open Firebug in popup window">&nbsp;</a>\n          <a id="fbWindow_btClose" class="fbSmallButton fbHover" title="Minimize Firebug">&nbsp;</a>\n        </div>\n        \n        <!-- Toolbar buttons and Status Bar -->\n        <div id="fbToolbar">\n          <div id="fbToolbarContent">\n        \n          <!-- Firebug Button -->\n          <span id="fbToolbarIcon">\n            <a id="fbFirebugButton" class="fbIconButton" class="fbHover" target="_blank">&nbsp;</a>\n          </span>\n          \n          <!-- \n          <span id="fbLeftToolbarErrors" class="fbErrors">2 errors</span>\n           -->\n           \n          <!-- Toolbar Buttons -->\n          <span id="fbToolbarButtons">\n            <!-- Fixed Toolbar Buttons -->\n            <span id="fbFixedButtons">\n                <a id="fbChrome_btInspect" class="fbButton fbHover" title="Click an element in the page to inspect">Inspect</a>\n            </span>\n            \n            <!-- Console Panel Toolbar Buttons -->\n            <span id="fbConsoleButtons" class="fbToolbarButtons">\n              <a id="fbConsole_btClear" class="fbButton fbHover" title="Clear the console">Clear</a>\n            </span>\n            \n            <!-- HTML Panel Toolbar Buttons -->\n            <!-- \n            <span id="fbHTMLButtons" class="fbToolbarButtons">\n              <a id="fbHTML_btEdit" class="fbHover" title="Edit this HTML">Edit</a>\n            </span>\n             -->\n          </span>\n          \n          <!-- Status Bar -->\n          <span id="fbStatusBarBox">\n            <span class="fbToolbarSeparator"></span>\n            <!-- HTML Panel Status Bar -->\n            <!-- \n            <span id="fbHTMLStatusBar" class="fbStatusBar fbToolbarButtons">\n            </span>\n             -->\n          </span>\n          \n          </div>\n          \n        </div>\n        \n        <!-- PanelBars -->\n        <div id="fbPanelBarBox">\n        \n          <!-- Main PanelBar -->\n          <div id="fbPanelBar1" class="fbPanelBar">\n            <a id="fbConsoleTab" class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">Console</span>\n                <span class="fbTabMenuTarget"></span>\n                <span class="fbTabR"></span>\n            </a>\n            <a id="fbHTMLTab" class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">HTML</span>\n                <span class="fbTabR"></span>\n            </a>\n            <a class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">CSS</span>\n                <span class="fbTabR"></span>\n            </a>\n            <a class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">Script</span>\n                <span class="fbTabR"></span>\n            </a>\n            <a class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">DOM</span>\n                <span class="fbTabR"></span>\n            </a>\n          </div>\n\n          <!-- Side PanelBars -->\n          <div id="fbPanelBar2Box" class="hide">\n            <div id="fbPanelBar2" class="fbPanelBar">\n            <!-- \n              <a class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">Style</span>\n                <span class="fbTabR"></span>\n              </a>\n              <a class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">Layout</span>\n                <span class="fbTabR"></span>\n              </a>\n              <a class="fbTab fbHover">\n                <span class="fbTabL"></span>\n                <span class="fbTabText">DOM</span>\n                <span class="fbTabR"></span>\n              </a>\n           -->\n            </div>\n          </div>\n          \n        </div>\n        \n        <!-- Horizontal Splitter -->\n        <div id="fbHSplitter">&nbsp;</div>\n        \n      </td>\n    </tr>\n    \n    <!-- Interface - Main Area -->\n    <tr id="fbContent">\n    \n      <!-- Panels  -->\n      <td id="fbPanelBox1">\n        <div id="fbPanel1" class="fbFitHeight">\n          <div id="fbConsole" class="fbPanel"></div>\n          <div id="fbHTML" class="fbPanel"></div>\n        </div>\n      </td>\n      \n      <!-- Side Panel Box -->\n      <td id="fbPanelBox2" class="hide">\n      \n        <!-- VerticalSplitter -->\n        <div id="fbVSplitter" class="fbVSplitter">&nbsp;</div>\n        \n        <!-- Side Panels -->\n        <div id="fbPanel2" class="fbFitHeight">\n        \n          <!-- HTML Side Panels -->\n          <div id="fbHTML_Style" class="fbPanel"></div>\n          <div id="fbHTML_Layout" class="fbPanel"></div>\n          <div id="fbHTML_DOM" class="fbPanel"></div>\n          \n        </div>\n        \n        <!-- Large Command Line -->\n        <textarea id="fbLargeCommandLine" class="fbFitHeight"></textarea>\n        \n        <!-- Large Command Line Buttons -->\n        <div id="fbLargeCommandButtons">\n            <a id="fbCommand_btRun" class="fbButton fbHover">Run</a>\n            <a id="fbCommand_btClear" class="fbButton fbHover">Clear</a>\n            \n            <a id="fbSmallCommandLineIcon" class="fbSmallButton fbHover"></a>\n        </div>\n        \n      </td>\n      \n    </tr>\n    \n    <!-- Interface - Bottom Area -->\n    <tr id="fbBottom" class="hide">\n    \n      <!-- Command Line -->\n      <td id="fbCommand" colspan="2">\n        <div id="fbCommandBox">\n          <div id="fbCommandIcon">&gt;&gt;&gt;</div>\n          <input id="fbCommandLine" name="fbCommandLine" type="text" />\n          <a id="fbLargeCommandLineIcon" class="fbSmallButton fbHover"></a>\n        </div>\n      </td>\n      \n    </tr>\n    \n  </tbody>\n</table> \n<span id="fbMiniChrome">\n  <span id="fbMiniContent">\n    <span id="fbMiniIcon" title="Open Firebug Lite"></span>\n    <span id="fbMiniErrors" class="fbErrors"><!-- 2 errors --></span>\n  </span>\n</span>\n<!-- \n<div id="fbErrorPopup">\n  <div id="fbErrorPopupContent">\n    <div id="fbErrorIndicator" class="fbErrors">2 errors</div>\n  </div>\n</div>\n -->\n</body>\n</html>',
                        language: 'html',
                        size: 7262,
                        tokens: 881,
                        lastModified: '2025-07-02T12:28:22.868Z',
                      },
                      {
                        name: 'firebug.IE6.css',
                        path: 'vendor/firebug-lite/skin/xp/firebug.IE6.css',
                        type: 'file',
                        content:
                          '/************************************************************************************************/\n#fbToolbarSearch {\n    background-image: url(search.gif) !important;\n}\n/************************************************************************************************/\n.fbErrors {\n    background-image: url(errorIcon.gif) !important;\n}\n/************************************************************************************************/\n.logRow-info {\n    background-image: url(infoIcon.gif) !important;\n}\n\n.logRow-warning {\n    background-image: url(warningIcon.gif) !important;\n}\n\n.logRow-error {\n    background-image: url(errorIcon.gif) !important;\n}\n',
                        language: 'css',
                        size: 652,
                        tokens: 38,
                        lastModified: '2025-07-02T12:28:22.867Z',
                      },
                      {
                        name: 'html.css',
                        path: 'vendor/firebug-lite/skin/xp/html.css',
                        type: 'file',
                        content:
                          '/* See license.txt for terms of usage */\n\n.panelNode-html {\n    -moz-box-sizing: padding-box;\n    padding: 4px 0 0 2px;\n}\n\n.nodeBox {\n    position: relative;\n    font-family: Monaco, monospace;\n    padding-left: 13px;\n    -moz-user-select: -moz-none;\n}\n.nodeBox.search-selection {\n    -moz-user-select: text;\n}\n.twisty {\n    position: absolute;\n    left: 0px;\n    top: 0px;\n    width: 14px;\n    height: 14px;\n}\n\n.nodeChildBox {\n    margin-left: 12px;\n    display: none;\n}\n\n.nodeLabel,\n.nodeCloseLabel {\n    margin: -2px 2px 0 2px;\n    border: 2px solid transparent;\n    -moz-border-radius: 3px;\n    padding: 0 2px;\n    color: #000088;\n}\n\n.nodeCloseLabel {\n    display: none;\n}\n\n.nodeTag {\n    cursor: pointer;\n    color: blue;\n}\n\n.nodeValue {\n    color: #FF0000;\n    font-weight: normal;\n}\n\n.nodeText,\n.nodeComment {\n    margin: 0 2px;\n    vertical-align: top;\n}\n\n.nodeText {\n    color: #333333;\n}\n\n.nodeWhiteSpace {\n    border: 1px solid LightGray;\n    white-space: pre; /* otherwise the border will be collapsed around zero pixels */\n    margin-left: 1px;\n    color: gray;\n}\n\n\n.nodeWhiteSpace_Space {\n    border: 1px solid #ddd;\n}\n\n.nodeTextEntity {\n    border: 1px solid gray;\n    white-space: pre; /* otherwise the border will be collapsed around zero pixels */\n    margin-left: 1px;\n}\n\n.nodeComment {\n    color: DarkGreen;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeBox.highlightOpen > .nodeLabel {\n    background-color: #EEEEEE;\n}\n\n.nodeBox.highlightOpen > .nodeCloseLabel,\n.nodeBox.highlightOpen > .nodeChildBox,\n.nodeBox.open > .nodeCloseLabel,\n.nodeBox.open > .nodeChildBox {\n    display: block;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeBox.selected > .nodeLabel > .nodeLabelBox,\n.nodeBox.selected > .nodeLabel {\n    border-color: Highlight;\n    background-color: Highlight;\n    color: HighlightText !important;\n}\n\n.nodeBox.selected > .nodeLabel > .nodeLabelBox,\n.nodeBox.selected > .nodeLabel > .nodeLabelBox > .nodeTag,\n.nodeBox.selected > .nodeLabel > .nodeLabelBox > .nodeAttr > .nodeValue,\n.nodeBox.selected > .nodeLabel > .nodeLabelBox > .nodeText {\n    color: inherit !important;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeBox.highlighted > .nodeLabel {\n    border-color: Highlight !important;\n    background-color: cyan !important;\n    color: #000000 !important;\n}\n\n.nodeBox.highlighted > .nodeLabel > .nodeLabelBox,\n.nodeBox.highlighted > .nodeLabel > .nodeLabelBox > .nodeTag,\n.nodeBox.highlighted > .nodeLabel > .nodeLabelBox > .nodeAttr > .nodeValue,\n.nodeBox.highlighted > .nodeLabel > .nodeLabelBox > .nodeText {\n    color: #000000 !important;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeBox.nodeHidden .nodeLabel > .nodeLabelBox,\n.nodeBox.nodeHidden .nodeCloseLabel,\n.nodeBox.nodeHidden .nodeLabel > .nodeLabelBox > .nodeText,\n.nodeBox.nodeHidden .nodeText {\n    color: #888888;\n}\n\n.nodeBox.nodeHidden .nodeLabel > .nodeLabelBox > .nodeTag,\n.nodeBox.nodeHidden .nodeCloseLabel > .nodeCloseLabelBox > .nodeTag {\n    color: #5F82D9;\n}\n\n.nodeBox.nodeHidden .nodeLabel > .nodeLabelBox > .nodeAttr > .nodeValue {\n    color: #D86060;\n}\n\n.nodeBox.nodeHidden.selected > .nodeLabel > .nodeLabelBox,\n.nodeBox.nodeHidden.selected > .nodeLabel > .nodeLabelBox > .nodeTag,\n.nodeBox.nodeHidden.selected > .nodeLabel > .nodeLabelBox > .nodeAttr > .nodeValue,\n.nodeBox.nodeHidden.selected > .nodeLabel > .nodeLabelBox > .nodeText {\n    color: SkyBlue !important;\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n.nodeBox.mutated > .nodeLabel,\n.nodeAttr.mutated,\n.nodeValue.mutated,\n.nodeText.mutated,\n.nodeBox.mutated > .nodeText {\n    background-color: #EFFF79;\n    color: #FF0000 !important;\n}\n\n.nodeBox.selected.mutated > .nodeLabel,\n.nodeBox.selected.mutated > .nodeLabel > .nodeLabelBox,\n.nodeBox.selected > .nodeLabel > .nodeLabelBox > .nodeAttr.mutated > .nodeValue,\n.nodeBox.selected > .nodeLabel > .nodeLabelBox > .nodeAttr > .nodeValue.mutated,\n.nodeBox.selected > .nodeLabel > .nodeLabelBox > .nodeText.mutated {\n    background-color: #EFFF79;\n    border-color: #EFFF79;\n    color: #FF0000 !important;\n}\n\n/************************************************************************************************/\n\n.logRow-dirxml {\n    padding-left: 0;\n}\n\n.soloElement > .nodeBox  {\n    padding-left: 0;\n}\n\n.useA11y .nodeLabel.focused {\n    outline: 2px solid #FF9933;\n    -moz-outline-radius: 3px;\n    outline-offset: -2px;\n}\n\n.useA11y .nodeLabelBox:focus {\n    outline: none;\n}\n\n/************************************************************************************************/\n\n.breakpointCode .twisty {\n    display: none;\n}\n\n.breakpointCode .nodeBox.containerNodeBox,\n.breakpointCode .nodeLabel {\n    padding-left: 0px;\n    margin-left: 0px;\n    font-family: Monaco, monospace !important;\n}\n\n.breakpointCode .nodeTag,\n.breakpointCode .nodeAttr,\n.breakpointCode .nodeText,\n.breakpointCode .nodeValue,\n.breakpointCode .nodeLabel {\n    color: DarkGreen !important;\n}\n\n.breakpointMutationType {\n    position: absolute;\n    top: 4px;\n    right: 20px;\n    color: gray;\n}\n\n\n\n\n\n\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n/************************************************************************************************/\n\n\n\n/************************************************************************************************/\n/* Twisties */\n\n.twisty,\n.logRow-errorMessage > .hasTwisty > .errorTitle,\n.logRow-log > .objectBox-array.hasTwisty,\n.logRow-spy .spyHead .spyTitle,\n.logGroup > .logRow,\n.memberRow.hasChildren > .memberLabelCell > .memberLabel,\n.hasHeaders .netHrefLabel,\n.netPageRow > .netCol > .netPageTitle {\n    background-image: url(twistyClosed.png);\n    background-repeat: no-repeat;\n    background-position: 2px 2px;\n\tmin-height: 12px;\n}\n\n.logRow-errorMessage > .hasTwisty.opened > .errorTitle,\n.logRow-log > .objectBox-array.hasTwisty.opened,\n.logRow-spy.opened .spyHead .spyTitle,\n.logGroup.opened > .logRow,\n.memberRow.hasChildren.opened > .memberLabelCell > .memberLabel,\n.nodeBox.highlightOpen > .nodeLabel > .twisty,\n.nodeBox.open > .nodeLabel > .twisty,\n.netRow.opened > .netCol > .netHrefLabel,\n.netPageRow.opened > .netCol > .netPageTitle {\n    background-image: url(twistyOpen.png);\n}\n\n.twisty {\n    background-position: 4px 4px;\n}',
                        language: 'css',
                        size: 7327,
                        tokens: 627,
                        lastModified: '2025-07-02T12:28:22.869Z',
                      },
                    ],
                  },
                ],
              },
              {
                name: 'src',
                path: 'vendor/firebug-lite/src',
                type: 'directory',
                children: [
                  {
                    name: 'firebug-lite-debug.js',
                    path: 'vendor/firebug-lite/src/firebug-lite-debug.js',
                    type: 'file',
                    content:
                      '(function(){\n\n/*!*************************************************************\n *\n *    Firebug Lite 1.4.0\n *\n *      Copyright (c) 2007, Parakey Inc.\n *      Released under BSD license.\n *      More information: http://getfirebug.com/firebuglite\n *\n **************************************************************/\n\n/*!\n * CSS selectors powered by:\n *\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\n/** @namespace describe lib */\n\n// FIXME: xxxpedro if we use "var FBL = {}" the FBL won\'t appear in the DOM Panel in IE\nvar FBL = {};\n\n( /** @scope s_lib @this FBL */ function() {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Constants\n\nvar productionDir = "http://getfirebug.com/releases/lite/";\nvar bookmarkletVersion = 4;\n\n// ************************************************************************************************\n\nvar reNotWhitespace = /[^\\s]/;\nvar reSplitFile = /:\\/{1,3}(.*?)\\/([^\\/]*?)\\/?($|\\?.*)/;\n\n// Globals\nthis.reJavascript = /\\s*javascript:\\s*(.*)/;\nthis.reChrome = /chrome:\\/\\/([^\\/]*)\\//;\nthis.reFile = /file:\\/\\/([^\\/]*)\\//;\n\n\n// ************************************************************************************************\n// properties\n\nvar userAgent = navigator.userAgent.toLowerCase();\nthis.isFirefox = /firefox/.test(userAgent);\nthis.isOpera   = /opera/.test(userAgent);\nthis.isSafari  = /webkit/.test(userAgent);\nthis.isIE      = /msie/.test(userAgent) && !/opera/.test(userAgent);\nthis.isIE6     = /msie 6/i.test(navigator.appVersion);\nthis.browserVersion = (userAgent.match( /.+(?:rv|it|ra|ie)[\\/: ]([\\d.]+)/ ) || [0,\'0\'])[1];\nthis.isIElt8   = this.isIE && (this.browserVersion-0 < 8);\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.NS = null;\nthis.pixelsPerInch = null;\n\n\n// ************************************************************************************************\n// Namespaces\n\nvar namespaces = [];\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.ns = function(fn)\n{\n    var ns = {};\n    namespaces.push(fn, ns);\n    return ns;\n};\n\nvar FBTrace = null;\n\nthis.initialize = function()\n{\n    // Firebug Lite is already running in persistent mode so we just quit\n    if (window.firebug && firebug.firebuglite || window.console && console.firebuglite)\n        return;\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // initialize environment\n\n    // point the FBTrace object to the local variable\n    if (FBL.FBTrace)\n        FBTrace = FBL.FBTrace;\n    else\n        FBTrace = FBL.FBTrace = {};\n\n    // check if the actual window is a persisted chrome context\n    var isChromeContext = window.Firebug && typeof window.Firebug.SharedEnv == "object";\n\n    // chrome context of the persistent application\n    if (isChromeContext)\n    {\n        // TODO: xxxpedro persist - make a better synchronization\n        sharedEnv = window.Firebug.SharedEnv;\n        delete window.Firebug.SharedEnv;\n\n        FBL.Env = sharedEnv;\n        FBL.Env.isChromeContext = true;\n        FBTrace.messageQueue = FBL.Env.traceMessageQueue;\n    }\n    // non-persistent application\n    else\n    {\n        FBL.NS = document.documentElement.namespaceURI;\n        FBL.Env.browser = window;\n        FBL.Env.destroy = destroyEnvironment;\n\n        if (document.documentElement.getAttribute("debug") == "true")\n            FBL.Env.Options.startOpened = true;\n\n        // find the URL location of the loaded application\n        findLocation();\n\n        // TODO: get preferences here...\n        // The problem is that we don\'t have the Firebug object yet, so we can\'t use\n        // Firebug.loadPrefs. We\'re using the Store module directly instead.\n        var prefs = FBL.Store.get("FirebugLite") || {};\n        FBL.Env.DefaultOptions = FBL.Env.Options;\n        FBL.Env.Options = FBL.extend(FBL.Env.Options, prefs.options || {});\n\n        if (FBL.isFirefox &&\n            typeof FBL.Env.browser.console == "object" &&\n            FBL.Env.browser.console.firebug &&\n            FBL.Env.Options.disableWhenFirebugActive)\n                return;\n    }\n\n    // exposes the FBL to the global namespace when in debug mode\n    if (FBL.Env.isDebugMode)\n    {\n        FBL.Env.browser.FBL = FBL;\n    }\n\n    // check browser compatibilities\n    this.isQuiksMode = FBL.Env.browser.document.compatMode == "BackCompat";\n    this.isIEQuiksMode = this.isIE && this.isQuiksMode;\n    this.isIEStantandMode = this.isIE && !this.isQuiksMode;\n\n    this.noFixedPosition = this.isIE6 || this.isIEQuiksMode;\n\n    // after creating/synchronizing the environment, initialize the FBTrace module\n    if (FBL.Env.Options.enableTrace) FBTrace.initialize();\n\n    if (FBTrace.DBG_INITIALIZE && isChromeContext) FBTrace.sysout("FBL.initialize - persistent application", "initialize chrome context");\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // initialize namespaces\n\n    if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("FBL.initialize", namespaces.length/2+" namespaces BEGIN");\n\n    for (var i = 0; i < namespaces.length; i += 2)\n    {\n        var fn = namespaces[i];\n        var ns = namespaces[i+1];\n        fn.apply(ns);\n    }\n\n    if (FBTrace.DBG_INITIALIZE) {\n        FBTrace.sysout("FBL.initialize", namespaces.length/2+" namespaces END");\n        FBTrace.sysout("FBL waitForDocument", "waiting document load");\n    }\n\n    FBL.Ajax.initialize();\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // finish environment initialization\n    FBL.Firebug.loadPrefs();\n\n    if (FBL.Env.Options.enablePersistent)\n    {\n        // TODO: xxxpedro persist - make a better synchronization\n        if (isChromeContext)\n        {\n            FBL.FirebugChrome.clone(FBL.Env.FirebugChrome);\n        }\n        else\n        {\n            FBL.Env.FirebugChrome = FBL.FirebugChrome;\n            FBL.Env.traceMessageQueue = FBTrace.messageQueue;\n        }\n    }\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // wait document load\n\n    waitForDocument();\n};\n\nvar waitForDocument = function waitForDocument()\n{\n    // document.body not available in XML+XSL documents in Firefox\n    var doc = FBL.Env.browser.document;\n    var body = doc.getElementsByTagName("body")[0];\n\n    if (body)\n    {\n        calculatePixelsPerInch(doc, body);\n        onDocumentLoad();\n    }\n    else\n        setTimeout(waitForDocument, 50);\n};\n\nvar onDocumentLoad = function onDocumentLoad()\n{\n    if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("FBL onDocumentLoad", "document loaded");\n\n    // fix IE6 problem with cache of background images, causing a lot of flickering\n    if (FBL.isIE6)\n        fixIE6BackgroundImageCache();\n\n    // chrome context of the persistent application\n    if (FBL.Env.Options.enablePersistent && FBL.Env.isChromeContext)\n    {\n        // finally, start the application in the chrome context\n        FBL.Firebug.initialize();\n\n        // if is not development mode, remove the shared environment cache object\n        // used to synchronize the both persistent contexts\n        if (!FBL.Env.isDevelopmentMode)\n        {\n            sharedEnv.destroy();\n            sharedEnv = null;\n        }\n    }\n    // non-persistent application\n    else\n    {\n        FBL.FirebugChrome.create();\n    }\n};\n\n// ************************************************************************************************\n// Env\n\nvar sharedEnv;\n\nthis.Env =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Env Options (will be transported to Firebug options)\n    Options:\n    {\n        saveCookies: true,\n\n        saveWindowPosition: false,\n        saveCommandLineHistory: false,\n\n        startOpened: false,\n        startInNewWindow: false,\n        showIconWhenHidden: true,\n\n        overrideConsole: true,\n        ignoreFirebugElements: true,\n        disableWhenFirebugActive: true,\n\n        disableXHRListener: false,\n        disableResourceFetching: false,\n\n        enableTrace: false,\n        enablePersistent: false\n\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Library location\n    Location:\n    {\n        sourceDir: null,\n        baseDir: null,\n        skinDir: null,\n        skin: null,\n        app: null\n    },\n\n    skin: "xp",\n    useLocalSkin: false,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Env states\n    isDevelopmentMode: false,\n    isDebugMode: false,\n    isChromeContext: false,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Env references\n    browser: null,\n    chrome: null\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar destroyEnvironment = function destroyEnvironment()\n{\n    setTimeout(function()\n    {\n        FBL = null;\n    }, 100);\n};\n\n// ************************************************************************************************\n// Library location\n\nvar findLocation =  function findLocation()\n{\n    var reFirebugFile = /(firebug-lite(?:-\\w+)?(?:\\.js|\\.jgz))(?:#(.+))?$/;\n    var reGetFirebugSite = /(?:http|https):\\/\\/getfirebug.com\\//;\n    var isGetFirebugSite;\n\n    var rePath = /^(.*\\/)/;\n    var reProtocol = /^\\w+:\\/\\//;\n    var path = null;\n    var doc = document;\n\n    // Firebug Lite 1.3.0 bookmarklet identification\n    var script = doc.getElementById("FirebugLite");\n\n    var scriptSrc;\n    var hasSrcAttribute = true;\n\n    // If the script was loaded via bookmarklet, we already have the script tag\n    if (script)\n    {\n        scriptSrc = script.src;\n        file = reFirebugFile.exec(scriptSrc);\n\n        var version = script.getAttribute("FirebugLite");\n        var number = version ? parseInt(version) : 0;\n\n        if (!version || !number || number < bookmarkletVersion)\n        {\n            FBL.Env.bookmarkletOutdated = true;\n        }\n    }\n    // otherwise we must search for the correct script tag\n    else\n    {\n        for(var i=0, s=doc.getElementsByTagName("script"), si; si=s[i]; i++)\n        {\n            var file = null;\n            if ( si.nodeName.toLowerCase() == "script" )\n            {\n                if (file = reFirebugFile.exec(si.getAttribute("firebugSrc")))\n                {\n                    scriptSrc = si.getAttribute("firebugSrc");\n                    hasSrcAttribute = false;\n                }\n                else if (file = reFirebugFile.exec(si.src))\n                {\n                    scriptSrc = si.src;\n                }\n                else\n                    continue;\n\n                script = si;\n                break;\n            }\n        }\n    }\n\n    // mark the script tag to be ignored by Firebug Lite\n    if (script)\n        script.firebugIgnore = true;\n\n    if (file)\n    {\n        var fileName = file[1];\n        var fileOptions = file[2];\n\n        // absolute path\n        if (reProtocol.test(scriptSrc)) {\n            path = rePath.exec(scriptSrc)[1];\n\n        }\n        // relative path\n        else\n        {\n            var r = rePath.exec(scriptSrc);\n            var src = r ? r[1] : scriptSrc;\n            var backDir = /^((?:\\.\\.\\/)+)(.*)/.exec(src);\n            var reLastDir = /^(.*\\/)[^\\/]+\\/$/;\n            path = rePath.exec(location.href)[1];\n\n            // "../some/path"\n            if (backDir)\n            {\n                var j = backDir[1].length/3;\n                var p;\n                while (j-- > 0)\n                    path = reLastDir.exec(path)[1];\n\n                path += backDir[2];\n            }\n\n            else if(src.indexOf("/") != -1)\n            {\n                // "./some/path"\n                if(/^\\.\\/./.test(src))\n                {\n                    path += src.substring(2);\n                }\n                // "/some/path"\n                else if(/^\\/./.test(src))\n                {\n                    var domain = /^(\\w+:\\/\\/[^\\/]+)/.exec(path);\n                    path = domain[1] + src;\n                }\n                // "some/path"\n                else\n                {\n                    path += src;\n                }\n            }\n        }\n    }\n\n    FBL.Env.isChromeExtension = script && script.getAttribute("extension") == "Chrome";\n    if (FBL.Env.isChromeExtension)\n    {\n        path = productionDir;\n        FBL.Env.bookmarkletOutdated = false;\n        script = {innerHTML: "{showIconWhenHidden:false}"};\n    }\n\n    isGetFirebugSite = reGetFirebugSite.test(path);\n\n    if (isGetFirebugSite && path.indexOf("/releases/lite/") == -1)\n    {\n        // See Issue 4587 - If we are loading the script from getfirebug.com shortcut, like\n        // https://getfirebug.com/firebug-lite.js, then we must manually add the full path,\n        // otherwise the Env.Location will hold the wrong path, which will in turn lead to\n        // undesirable effects like the problem in Issue 4587\n        path += "releases/lite/" + (fileName == "firebug-lite-beta.js" ? "beta/" : "latest/");\n    }\n\n    var m = path && path.match(/([^\\/]+)\\/$/) || null;\n\n    if (path && m)\n    {\n        var Env = FBL.Env;\n\n        // Always use the local skin when running in the same domain\n        // See Issue 3554: Firebug Lite should use local images when loaded locally\n        Env.useLocalSkin = path.indexOf(location.protocol + "//" + location.host + "/") == 0 &&\n                // but we cannot use the locan skin when loaded from getfirebug.com, otherwise\n                // the bookmarklet won\'t work when visiting getfirebug.com\n                !isGetFirebugSite;\n\n        // detecting development and debug modes via file name\n        if (fileName == "firebug-lite-dev.js")\n        {\n            Env.isDevelopmentMode = true;\n            Env.isDebugMode = true;\n        }\n        else if (fileName == "firebug-lite-debug.js")\n        {\n            Env.isDebugMode = true;\n        }\n\n        // process the <html debug="true">\n        if (Env.browser.document.documentElement.getAttribute("debug") == "true")\n        {\n            Env.Options.startOpened = true;\n        }\n\n        // process the Script URL Options\n        if (fileOptions)\n        {\n            var options = fileOptions.split(",");\n\n            for (var i = 0, length = options.length; i < length; i++)\n            {\n                var option = options[i];\n                var name, value;\n\n                if (option.indexOf("=") != -1)\n                {\n                    var parts = option.split("=");\n                    name = parts[0];\n                    value = eval(unescape(parts[1]));\n                }\n                else\n                {\n                    name = option;\n                    value = true;\n                }\n\n                if (name == "debug")\n                {\n                    Env.isDebugMode = !!value;\n                }\n                else if (name in Env.Options)\n                {\n                    Env.Options[name] = value;\n                }\n                else\n                {\n                    Env[name] = value;\n                }\n            }\n        }\n\n        // process the Script JSON Options\n        if (hasSrcAttribute)\n        {\n            var innerOptions = FBL.trim(script.innerHTML);\n            if (innerOptions)\n            {\n                var innerOptionsObject = eval("(" + innerOptions + ")");\n\n                for (var name in innerOptionsObject)\n                {\n                    var value = innerOptionsObject[name];\n\n                    if (name == "debug")\n                    {\n                        Env.isDebugMode = !!value;\n                    }\n                    else if (name in Env.Options)\n                    {\n                        Env.Options[name] = value;\n                    }\n                    else\n                    {\n                        Env[name] = value;\n                    }\n                }\n            }\n        }\n\n        if (!Env.Options.saveCookies)\n            FBL.Store.remove("FirebugLite");\n\n        // process the Debug Mode\n        if (Env.isDebugMode)\n        {\n            Env.Options.startOpened = true;\n            Env.Options.enableTrace = true;\n            Env.Options.disableWhenFirebugActive = false;\n        }\n\n        var loc = Env.Location;\n        var isProductionRelease = path.indexOf(productionDir) != -1;\n\n        loc.sourceDir = path;\n        loc.baseDir = path.substr(0, path.length - m[1].length - 1);\n        loc.skinDir = (isProductionRelease ? path : loc.baseDir) + "skin/" + Env.skin + "/";\n        loc.skin = loc.skinDir + "firebug.html";\n        loc.app = path + fileName;\n    }\n    else\n    {\n        throw new Error("Firebug Error: Library path not found");\n    }\n};\n\n// ************************************************************************************************\n// Basics\n\nthis.bind = function()  // fn, thisObject, args => thisObject.fn(args, arguments);\n{\n   var args = cloneArray(arguments), fn = args.shift(), object = args.shift();\n   return function() { return fn.apply(object, arrayInsert(cloneArray(args), 0, arguments)); };\n};\n\nthis.bindFixed = function() // fn, thisObject, args => thisObject.fn(args);\n{\n    var args = cloneArray(arguments), fn = args.shift(), object = args.shift();\n    return function() { return fn.apply(object, args); };\n};\n\nthis.extend = function(l, r)\n{\n    var newOb = {};\n    for (var n in l)\n        newOb[n] = l[n];\n    for (var n in r)\n        newOb[n] = r[n];\n    return newOb;\n};\n\nthis.descend = function(prototypeParent, childProperties)\n{\n    function protoSetter() {};\n    protoSetter.prototype = prototypeParent;\n    var newOb = new protoSetter();\n    for (var n in childProperties)\n        newOb[n] = childProperties[n];\n    return newOb;\n};\n\nthis.append = function(l, r)\n{\n    for (var n in r)\n        l[n] = r[n];\n\n    return l;\n};\n\nthis.keys = function(map)  // At least sometimes the keys will be on user-level window objects\n{\n    var keys = [];\n    try\n    {\n        for (var name in map)  // enumeration is safe\n            keys.push(name);   // name is string, safe\n    }\n    catch (exc)\n    {\n        // Sometimes we get exceptions trying to iterate properties\n    }\n\n    return keys;  // return is safe\n};\n\nthis.values = function(map)\n{\n    var values = [];\n    try\n    {\n        for (var name in map)\n        {\n            try\n            {\n                values.push(map[name]);\n            }\n            catch (exc)\n            {\n                // Sometimes we get exceptions trying to access properties\n                if (FBTrace.DBG_ERRORS)\n                    FBTrace.sysout("lib.values FAILED ", exc);\n            }\n\n        }\n    }\n    catch (exc)\n    {\n        // Sometimes we get exceptions trying to iterate properties\n        if (FBTrace.DBG_ERRORS)\n            FBTrace.sysout("lib.values FAILED ", exc);\n    }\n\n    return values;\n};\n\nthis.remove = function(list, item)\n{\n    for (var i = 0; i < list.length; ++i)\n    {\n        if (list[i] == item)\n        {\n            list.splice(i, 1);\n            break;\n        }\n    }\n};\n\nthis.sliceArray = function(array, index)\n{\n    var slice = [];\n    for (var i = index; i < array.length; ++i)\n        slice.push(array[i]);\n\n    return slice;\n};\n\nfunction cloneArray(array, fn)\n{\n   var newArray = [];\n\n   if (fn)\n       for (var i = 0; i < array.length; ++i)\n           newArray.push(fn(array[i]));\n   else\n       for (var i = 0; i < array.length; ++i)\n           newArray.push(array[i]);\n\n   return newArray;\n}\n\nfunction extendArray(array, array2)\n{\n   var newArray = [];\n   newArray.push.apply(newArray, array);\n   newArray.push.apply(newArray, array2);\n   return newArray;\n}\n\nthis.extendArray = extendArray;\nthis.cloneArray = cloneArray;\n\nfunction arrayInsert(array, index, other)\n{\n   for (var i = 0; i < other.length; ++i)\n       array.splice(i+index, 0, other[i]);\n\n   return array;\n}\n\n// ************************************************************************************************\n\nthis.createStyleSheet = function(doc, url)\n{\n    //TODO: xxxpedro\n    //var style = doc.createElementNS("http://www.w3.org/1999/xhtml", "style");\n    var style = this.createElement("link");\n    style.setAttribute("charset","utf-8");\n    style.firebugIgnore = true;\n    style.setAttribute("rel", "stylesheet");\n    style.setAttribute("type", "text/css");\n    style.setAttribute("href", url);\n\n    //TODO: xxxpedro\n    //style.innerHTML = this.getResource(url);\n    return style;\n};\n\nthis.addStyleSheet = function(doc, style)\n{\n    var heads = doc.getElementsByTagName("head");\n    if (heads.length)\n        heads[0].appendChild(style);\n    else\n        doc.documentElement.appendChild(style);\n};\n\nthis.appendStylesheet = function(doc, uri)\n{\n    // Make sure the stylesheet is not appended twice.\n    if (this.$(uri, doc))\n        return;\n\n    var styleSheet = this.createStyleSheet(doc, uri);\n    styleSheet.setAttribute("id", uri);\n    this.addStyleSheet(doc, styleSheet);\n};\n\nthis.addScript = function(doc, id, src)\n{\n    var element = doc.createElementNS("http://www.w3.org/1999/xhtml", "html:script");\n    element.setAttribute("type", "text/javascript");\n    element.setAttribute("id", id);\n    if (!FBTrace.DBG_CONSOLE)\n        FBL.unwrapObject(element).firebugIgnore = true;\n\n    element.innerHTML = src;\n    if (doc.documentElement)\n        doc.documentElement.appendChild(element);\n    else\n    {\n        // See issue 1079, the svg test case gives this error\n        if (FBTrace.DBG_ERRORS)\n            FBTrace.sysout("lib.addScript doc has no documentElement:", doc);\n    }\n    return element;\n};\n\n\n// ************************************************************************************************\n\nthis.getStyle = this.isIE ?\n    function(el, name)\n    {\n        return el.currentStyle[name] || el.style[name] || undefined;\n    }\n    :\n    function(el, name)\n    {\n        return el.ownerDocument.defaultView.getComputedStyle(el,null)[name]\n            || el.style[name] || undefined;\n    };\n\n\n// ************************************************************************************************\n// Whitespace and Entity conversions\n\nvar entityConversionLists = this.entityConversionLists = {\n    normal : {\n        whitespace : {\n            \'\\t\' : \'\\u200c\\u2192\',\n            \'\\n\' : \'\\u200c\\u00b6\',\n            \'\\r\' : \'\\u200c\\u00ac\',\n            \' \'  : \'\\u200c\\u00b7\'\n        }\n    },\n    reverse : {\n        whitespace : {\n            \'&Tab;\' : \'\\t\',\n            \'&NewLine;\' : \'\\n\',\n            \'\\u200c\\u2192\' : \'\\t\',\n            \'\\u200c\\u00b6\' : \'\\n\',\n            \'\\u200c\\u00ac\' : \'\\r\',\n            \'\\u200c\\u00b7\' : \' \'\n        }\n    }\n};\n\nvar normal = entityConversionLists.normal,\n    reverse = entityConversionLists.reverse;\n\nfunction addEntityMapToList(ccode, entity)\n{\n    var lists = Array.prototype.slice.call(arguments, 2),\n        len = lists.length,\n        ch = String.fromCharCode(ccode);\n    for (var i = 0; i < len; i++)\n    {\n        var list = lists[i];\n        normal[list]=normal[list] || {};\n        normal[list][ch] = \'&\' + entity + \';\';\n        reverse[list]=reverse[list] || {};\n        reverse[list][\'&\' + entity + \';\'] = ch;\n    }\n};\n\nvar e = addEntityMapToList,\n    white = \'whitespace\',\n    text = \'text\',\n    attr = \'attributes\',\n    css = \'css\',\n    editor = \'editor\';\n\ne(0x0022, \'quot\', attr, css);\ne(0x0026, \'amp\', attr, text, css);\ne(0x0027, \'apos\', css);\ne(0x003c, \'lt\', attr, text, css);\ne(0x003e, \'gt\', attr, text, css);\ne(0xa9, \'copy\', text, editor);\ne(0xae, \'reg\', text, editor);\ne(0x2122, \'trade\', text, editor);\n\n// See http://en.wikipedia.org/wiki/Dash\ne(0x2012, \'#8210\', attr, text, editor); // figure dash\ne(0x2013, \'ndash\', attr, text, editor); // en dash\ne(0x2014, \'mdash\', attr, text, editor); // em dash\ne(0x2015, \'#8213\', attr, text, editor); // horizontal bar\n\ne(0x00a0, \'nbsp\', attr, text, white, editor);\ne(0x2002, \'ensp\', attr, text, white, editor);\ne(0x2003, \'emsp\', attr, text, white, editor);\ne(0x2009, \'thinsp\', attr, text, white, editor);\ne(0x200c, \'zwnj\', attr, text, white, editor);\ne(0x200d, \'zwj\', attr, text, white, editor);\ne(0x200e, \'lrm\', attr, text, white, editor);\ne(0x200f, \'rlm\', attr, text, white, editor);\ne(0x200b, \'#8203\', attr, text, white, editor); // zero-width space (ZWSP)\n\n//************************************************************************************************\n// Entity escaping\n\nvar entityConversionRegexes = {\n        normal : {},\n        reverse : {}\n    };\n\nvar escapeEntitiesRegEx = {\n    normal : function(list)\n    {\n        var chars = [];\n        for ( var ch in list)\n        {\n            chars.push(ch);\n        }\n        return new RegExp(\'([\' + chars.join(\'\') + \'])\', \'gm\');\n    },\n    reverse : function(list)\n    {\n        var chars = [];\n        for ( var ch in list)\n        {\n            chars.push(ch);\n        }\n        return new RegExp(\'(\' + chars.join(\'|\') + \')\', \'gm\');\n    }\n};\n\nfunction getEscapeRegexp(direction, lists)\n{\n    var name = \'\', re;\n    var groups = [].concat(lists);\n    for (i = 0; i < groups.length; i++)\n    {\n        name += groups[i].group;\n    }\n    re = entityConversionRegexes[direction][name];\n    if (!re)\n    {\n        var list = {};\n        if (groups.length > 1)\n        {\n            for ( var i = 0; i < groups.length; i++)\n            {\n                var aList = entityConversionLists[direction][groups[i].group];\n                for ( var item in aList)\n                    list[item] = aList[item];\n            }\n        } else if (groups.length==1)\n        {\n            list = entityConversionLists[direction][groups[0].group]; // faster for special case\n        } else {\n            list = {}; // perhaps should print out an error here?\n        }\n        re = entityConversionRegexes[direction][name] = escapeEntitiesRegEx[direction](list);\n    }\n    return re;\n};\n\nfunction createSimpleEscape(name, direction)\n{\n    return function(value)\n    {\n        var list = entityConversionLists[direction][name];\n        return String(value).replace(\n                getEscapeRegexp(direction, {\n                    group : name,\n                    list : list\n                }),\n                function(ch)\n                {\n                    return list[ch];\n                }\n               );\n    };\n};\n\nfunction escapeGroupsForEntities(str, lists)\n{\n    lists = [].concat(lists);\n    var re = getEscapeRegexp(\'normal\', lists),\n        split = String(str).split(re),\n        len = split.length,\n        results = [],\n        cur, r, i, ri = 0, l, list, last = \'\';\n    if (!len)\n        return [ {\n            str : String(str),\n            group : \'\',\n            name : \'\'\n        } ];\n    for (i = 0; i < len; i++)\n    {\n        cur = split[i];\n        if (cur == \'\')\n            continue;\n        for (l = 0; l < lists.length; l++)\n        {\n            list = lists[l];\n            r = entityConversionLists.normal[list.group][cur];\n            // if (cur == \' \' && list.group == \'whitespace\' && last == \' \') // only show for runs of more than one space\n            //     r = \' \';\n            if (r)\n            {\n                results[ri] = {\n                    \'str\' : r,\n                    \'class\' : list[\'class\'],\n                    \'extra\' : list.extra[cur] ? list[\'class\']\n                            + list.extra[cur] : \'\'\n                };\n                break;\n            }\n        }\n        // last=cur;\n        if (!r)\n            results[ri] = {\n                \'str\' : cur,\n                \'class\' : \'\',\n                \'extra\' : \'\'\n            };\n        ri++;\n    }\n    return results;\n};\n\nthis.escapeGroupsForEntities = escapeGroupsForEntities;\n\n\nfunction unescapeEntities(str, lists)\n{\n    var re = getEscapeRegexp(\'reverse\', lists),\n        split = String(str).split(re),\n        len = split.length,\n        results = [],\n        cur, r, i, ri = 0, l, list;\n    if (!len)\n        return str;\n    lists = [].concat(lists);\n    for (i = 0; i < len; i++)\n    {\n        cur = split[i];\n        if (cur == \'\')\n            continue;\n        for (l = 0; l < lists.length; l++)\n        {\n            list = lists[l];\n            r = entityConversionLists.reverse[list.group][cur];\n            if (r)\n            {\n                results[ri] = r;\n                break;\n            }\n        }\n        if (!r)\n            results[ri] = cur;\n        ri++;\n    }\n    return results.join(\'\') || \'\';\n};\n\n\n// ************************************************************************************************\n// String escaping\n\nvar escapeForTextNode = this.escapeForTextNode = createSimpleEscape(\'text\', \'normal\');\nvar escapeForHtmlEditor = this.escapeForHtmlEditor = createSimpleEscape(\'editor\', \'normal\');\nvar escapeForElementAttribute = this.escapeForElementAttribute = createSimpleEscape(\'attributes\', \'normal\');\nvar escapeForCss = this.escapeForCss = createSimpleEscape(\'css\', \'normal\');\n\n// deprecated compatibility functions\n//this.deprecateEscapeHTML = createSimpleEscape(\'text\', \'normal\');\n//this.deprecatedUnescapeHTML = createSimpleEscape(\'text\', \'reverse\');\n//this.escapeHTML = deprecated("use appropriate escapeFor... function", this.deprecateEscapeHTML);\n//this.unescapeHTML = deprecated("use appropriate unescapeFor... function", this.deprecatedUnescapeHTML);\n\nvar escapeForSourceLine = this.escapeForSourceLine = createSimpleEscape(\'text\', \'normal\');\n\nvar unescapeWhitespace = createSimpleEscape(\'whitespace\', \'reverse\');\n\nthis.unescapeForTextNode = function(str)\n{\n    if (Firebug.showTextNodesWithWhitespace)\n        str = unescapeWhitespace(str);\n    if (!Firebug.showTextNodesWithEntities)\n        str = escapeForElementAttribute(str);\n    return str;\n};\n\nthis.escapeNewLines = function(value)\n{\n    return value.replace(/\\r/g, "\\\\r").replace(/\\n/g, "\\\\n");\n};\n\nthis.stripNewLines = function(value)\n{\n    return typeof(value) == "string" ? value.replace(/[\\r\\n]/g, " ") : value;\n};\n\nthis.escapeJS = function(value)\n{\n    return value.replace(/\\r/g, "\\\\r").replace(/\\n/g, "\\\\n").replace(\'"\', \'\\\\"\', "g");\n};\n\nfunction escapeHTMLAttribute(value)\n{\n    function replaceChars(ch)\n    {\n        switch (ch)\n        {\n            case "&":\n                return "&amp;";\n            case "\'":\n                return apos;\n            case \'"\':\n                return quot;\n        }\n        return "?";\n    };\n    var apos = "&#39;", quot = "&quot;", around = \'"\';\n    if( value.indexOf(\'"\') == -1 ) {\n        quot = \'"\';\n        apos = "\'";\n    } else if( value.indexOf("\'") == -1 ) {\n        quot = \'"\';\n        around = "\'";\n    }\n    return around + (String(value).replace(/[&\'"]/g, replaceChars)) + around;\n}\n\n\nfunction escapeHTML(value)\n{\n    function replaceChars(ch)\n    {\n        switch (ch)\n        {\n            case "<":\n                return "&lt;";\n            case ">":\n                return "&gt;";\n            case "&":\n                return "&amp;";\n            case "\'":\n                return "&#39;";\n            case \'"\':\n                return "&quot;";\n        }\n        return "?";\n    };\n    return String(value).replace(/[<>&"\']/g, replaceChars);\n}\n\nthis.escapeHTML = escapeHTML;\n\nthis.cropString = function(text, limit)\n{\n    text = text + "";\n\n    if (!limit)\n        var halfLimit = 50;\n    else\n        var halfLimit = limit / 2;\n\n    if (text.length > limit)\n        return this.escapeNewLines(text.substr(0, halfLimit) + "..." + text.substr(text.length-halfLimit));\n    else\n        return this.escapeNewLines(text);\n};\n\nthis.isWhitespace = function(text)\n{\n    return !reNotWhitespace.exec(text);\n};\n\nthis.splitLines = function(text)\n{\n    var reSplitLines2 = /.*(:?\\r\\n|\\n|\\r)?/mg;\n    var lines;\n    if (text.match)\n    {\n        lines = text.match(reSplitLines2);\n    }\n    else\n    {\n        var str = text+"";\n        lines = str.match(reSplitLines2);\n    }\n    lines.pop();\n    return lines;\n};\n\n\n// ************************************************************************************************\n\nthis.safeToString = function(ob)\n{\n    if (this.isIE)\n    {\n        try\n        {\n            // FIXME: xxxpedro this is failing in IE for the global "external" object\n            return ob + "";\n        }\n        catch(E)\n        {\n            FBTrace.sysout("Lib.safeToString() failed for ", ob);\n            return "";\n        }\n    }\n\n    try\n    {\n        if (ob && "toString" in ob && typeof ob.toString == "function")\n            return ob.toString();\n    }\n    catch (exc)\n    {\n        // xxxpedro it is not safe to use ob+""?\n        return ob + "";\n        ///return "[an object with no toString() function]";\n    }\n};\n\n// ************************************************************************************************\n\nthis.hasProperties = function(ob)\n{\n    try\n    {\n        for (var name in ob)\n            return true;\n    } catch (exc) {}\n    return false;\n};\n\n// ************************************************************************************************\n// String Util\n\nvar reTrim = /^\\s+|\\s+$/g;\nthis.trim = function(s)\n{\n    return s.replace(reTrim, "");\n};\n\n\n// ************************************************************************************************\n// Empty\n\nthis.emptyFn = function(){};\n\n\n\n// ************************************************************************************************\n// Visibility\n\nthis.isVisible = function(elt)\n{\n    /*\n    if (elt instanceof XULElement)\n    {\n        //FBTrace.sysout("isVisible elt.offsetWidth: "+elt.offsetWidth+" offsetHeight:"+ elt.offsetHeight+" localName:"+ elt.localName+" nameSpace:"+elt.nameSpaceURI+"\\n");\n        return (!elt.hidden && !elt.collapsed);\n    }\n    /**/\n\n    return this.getStyle(elt, "visibility") != "hidden" &&\n        ( elt.offsetWidth > 0 || elt.offsetHeight > 0\n        || elt.tagName in invisibleTags\n        || elt.namespaceURI == "http://www.w3.org/2000/svg"\n        || elt.namespaceURI == "http://www.w3.org/1998/Math/MathML" );\n};\n\nthis.collapse = function(elt, collapsed)\n{\n    // IE6 doesn\'t support the [collapsed] CSS selector. IE7 does support the selector,\n    // but it is causing a bug (the element disappears when you set the "collapsed"\n    // attribute, but it doesn\'t appear when you remove the attribute. So, for those\n    // cases, we need to use the class attribute.\n    if (this.isIElt8)\n    {\n        if (collapsed)\n            this.setClass(elt, "collapsed");\n        else\n            this.removeClass(elt, "collapsed");\n    }\n    else\n        elt.setAttribute("collapsed", collapsed ? "true" : "false");\n};\n\nthis.obscure = function(elt, obscured)\n{\n    if (obscured)\n        this.setClass(elt, "obscured");\n    else\n        this.removeClass(elt, "obscured");\n};\n\nthis.hide = function(elt, hidden)\n{\n    elt.style.visibility = hidden ? "hidden" : "visible";\n};\n\nthis.clearNode = function(node)\n{\n    var nodeName = " " + node.nodeName.toLowerCase() + " ";\n    var ignoreTags = " table tbody thead tfoot th tr td ";\n\n    // IE can\'t use innerHTML of table elements\n    if (this.isIE && ignoreTags.indexOf(nodeName) != -1)\n        this.eraseNode(node);\n    else\n        node.innerHTML = "";\n};\n\nthis.eraseNode = function(node)\n{\n    while (node.lastChild)\n        node.removeChild(node.lastChild);\n};\n\n// ************************************************************************************************\n// Window iteration\n\nthis.iterateWindows = function(win, handler)\n{\n    if (!win || !win.document)\n        return;\n\n    handler(win);\n\n    if (win == top || !win.frames) return; // XXXjjb hack for chromeBug\n\n    for (var i = 0; i < win.frames.length; ++i)\n    {\n        var subWin = win.frames[i];\n        if (subWin != win)\n            this.iterateWindows(subWin, handler);\n    }\n};\n\nthis.getRootWindow = function(win)\n{\n    for (; win; win = win.parent)\n    {\n        if (!win.parent || win == win.parent || !this.instanceOf(win.parent, "Window"))\n            return win;\n    }\n    return null;\n};\n\n// ************************************************************************************************\n// Graphics\n\nthis.getClientOffset = function(elt)\n{\n    var addOffset = function addOffset(elt, coords, view)\n    {\n        var p = elt.offsetParent;\n\n        ///var style = isIE ? elt.currentStyle : view.getComputedStyle(elt, "");\n        var chrome = Firebug.chrome;\n\n        if (elt.offsetLeft)\n            ///coords.x += elt.offsetLeft + parseInt(style.borderLeftWidth);\n            coords.x += elt.offsetLeft + chrome.getMeasurementInPixels(elt, "borderLeft");\n        if (elt.offsetTop)\n            ///coords.y += elt.offsetTop + parseInt(style.borderTopWidth);\n            coords.y += elt.offsetTop + chrome.getMeasurementInPixels(elt, "borderTop");\n\n        if (p)\n        {\n            if (p.nodeType == 1)\n                addOffset(p, coords, view);\n        }\n        else\n        {\n            var otherView = isIE ? elt.ownerDocument.parentWindow : elt.ownerDocument.defaultView;\n            // IE will fail when reading the frameElement property of a popup window.\n            // We don\'t need it anyway once it is outside the (popup) viewport, so we\'re\n            // ignoring the frameElement check when the window is a popup\n            if (!otherView.opener && otherView.frameElement)\n                addOffset(otherView.frameElement, coords, otherView);\n        }\n    };\n\n    var isIE = this.isIE;\n    var coords = {x: 0, y: 0};\n    if (elt)\n    {\n        var view = isIE ? elt.ownerDocument.parentWindow : elt.ownerDocument.defaultView;\n        addOffset(elt, coords, view);\n    }\n\n    return coords;\n};\n\nthis.getViewOffset = function(elt, singleFrame)\n{\n    function addOffset(elt, coords, view)\n    {\n        var p = elt.offsetParent;\n        coords.x += elt.offsetLeft - (p ? p.scrollLeft : 0);\n        coords.y += elt.offsetTop - (p ? p.scrollTop : 0);\n\n        if (p)\n        {\n            if (p.nodeType == 1)\n            {\n                var parentStyle = view.getComputedStyle(p, "");\n                if (parentStyle.position != "static")\n                {\n                    coords.x += parseInt(parentStyle.borderLeftWidth);\n                    coords.y += parseInt(parentStyle.borderTopWidth);\n\n                    if (p.localName == "TABLE")\n                    {\n                        coords.x += parseInt(parentStyle.paddingLeft);\n                        coords.y += parseInt(parentStyle.paddingTop);\n                    }\n                    else if (p.localName == "BODY")\n                    {\n                        var style = view.getComputedStyle(elt, "");\n                        coords.x += parseInt(style.marginLeft);\n                        coords.y += parseInt(style.marginTop);\n                    }\n                }\n                else if (p.localName == "BODY")\n                {\n                    coords.x += parseInt(parentStyle.borderLeftWidth);\n                    coords.y += parseInt(parentStyle.borderTopWidth);\n                }\n\n                var parent = elt.parentNode;\n                while (p != parent)\n                {\n                    coords.x -= parent.scrollLeft;\n                    coords.y -= parent.scrollTop;\n                    parent = parent.parentNode;\n                }\n                addOffset(p, coords, view);\n            }\n        }\n        else\n        {\n            if (elt.localName == "BODY")\n            {\n                var style = view.getComputedStyle(elt, "");\n                coords.x += parseInt(style.borderLeftWidth);\n                coords.y += parseInt(style.borderTopWidth);\n\n                var htmlStyle = view.getComputedStyle(elt.parentNode, "");\n                coords.x -= parseInt(htmlStyle.paddingLeft);\n                coords.y -= parseInt(htmlStyle.paddingTop);\n            }\n\n            if (elt.scrollLeft)\n                coords.x += elt.scrollLeft;\n            if (elt.scrollTop)\n                coords.y += elt.scrollTop;\n\n            var win = elt.ownerDocument.defaultView;\n            if (win && (!singleFrame && win.frameElement))\n                addOffset(win.frameElement, coords, win);\n        }\n\n    }\n\n    var coords = {x: 0, y: 0};\n    if (elt)\n        addOffset(elt, coords, elt.ownerDocument.defaultView);\n\n    return coords;\n};\n\nthis.getLTRBWH = function(elt)\n{\n    var bcrect,\n        dims = {"left": 0, "top": 0, "right": 0, "bottom": 0, "width": 0, "height": 0};\n\n    if (elt)\n    {\n        bcrect = elt.getBoundingClientRect();\n        dims.left = bcrect.left;\n        dims.top = bcrect.top;\n        dims.right = bcrect.right;\n        dims.bottom = bcrect.bottom;\n\n        if(bcrect.width)\n        {\n            dims.width = bcrect.width;\n            dims.height = bcrect.height;\n        }\n        else\n        {\n            dims.width = dims.right - dims.left;\n            dims.height = dims.bottom - dims.top;\n        }\n    }\n    return dims;\n};\n\nthis.applyBodyOffsets = function(elt, clientRect)\n{\n    var od = elt.ownerDocument;\n    if (!od.body)\n        return clientRect;\n\n    var style = od.defaultView.getComputedStyle(od.body, null);\n\n    var pos = style.getPropertyValue(\'position\');\n    if(pos === \'absolute\' || pos === \'relative\')\n    {\n        var borderLeft = parseInt(style.getPropertyValue(\'border-left-width\').replace(\'px\', \'\'),10) || 0;\n        var borderTop = parseInt(style.getPropertyValue(\'border-top-width\').replace(\'px\', \'\'),10) || 0;\n        var paddingLeft = parseInt(style.getPropertyValue(\'padding-left\').replace(\'px\', \'\'),10) || 0;\n        var paddingTop = parseInt(style.getPropertyValue(\'padding-top\').replace(\'px\', \'\'),10) || 0;\n        var marginLeft = parseInt(style.getPropertyValue(\'margin-left\').replace(\'px\', \'\'),10) || 0;\n        var marginTop = parseInt(style.getPropertyValue(\'margin-top\').replace(\'px\', \'\'),10) || 0;\n\n        var offsetX = borderLeft + paddingLeft + marginLeft;\n        var offsetY = borderTop + paddingTop + marginTop;\n\n        clientRect.left -= offsetX;\n        clientRect.top -= offsetY;\n        clientRect.right -= offsetX;\n        clientRect.bottom -= offsetY;\n    }\n\n    return clientRect;\n};\n\nthis.getOffsetSize = function(elt)\n{\n    return {width: elt.offsetWidth, height: elt.offsetHeight};\n};\n\nthis.getOverflowParent = function(element)\n{\n    for (var scrollParent = element.parentNode; scrollParent; scrollParent = scrollParent.offsetParent)\n    {\n        if (scrollParent.scrollHeight > scrollParent.offsetHeight)\n            return scrollParent;\n    }\n};\n\nthis.isScrolledToBottom = function(element)\n{\n    var onBottom = (element.scrollTop + element.offsetHeight) == element.scrollHeight;\n    if (FBTrace.DBG_CONSOLE)\n        FBTrace.sysout("isScrolledToBottom offsetHeight: "+element.offsetHeight +" onBottom:"+onBottom);\n    return onBottom;\n};\n\nthis.scrollToBottom = function(element)\n{\n        element.scrollTop = element.scrollHeight;\n\n        if (FBTrace.DBG_CONSOLE)\n        {\n            FBTrace.sysout("scrollToBottom reset scrollTop "+element.scrollTop+" = "+element.scrollHeight);\n            if (element.scrollHeight == element.offsetHeight)\n                FBTrace.sysout("scrollToBottom attempt to scroll non-scrollable element "+element, element);\n        }\n\n        return (element.scrollTop == element.scrollHeight);\n};\n\nthis.move = function(element, x, y)\n{\n    element.style.left = x + "px";\n    element.style.top = y + "px";\n};\n\nthis.resize = function(element, w, h)\n{\n    element.style.width = w + "px";\n    element.style.height = h + "px";\n};\n\nthis.linesIntoCenterView = function(element, scrollBox)  // {before: int, after: int}\n{\n    if (!scrollBox)\n        scrollBox = this.getOverflowParent(element);\n\n    if (!scrollBox)\n        return;\n\n    var offset = this.getClientOffset(element);\n\n    var topSpace = offset.y - scrollBox.scrollTop;\n    var bottomSpace = (scrollBox.scrollTop + scrollBox.clientHeight)\n            - (offset.y + element.offsetHeight);\n\n    if (topSpace < 0 || bottomSpace < 0)\n    {\n        var split = (scrollBox.clientHeight/2);\n        var centerY = offset.y - split;\n        scrollBox.scrollTop = centerY;\n        topSpace = split;\n        bottomSpace = split -  element.offsetHeight;\n    }\n\n    return {before: Math.round((topSpace/element.offsetHeight) + 0.5),\n            after: Math.round((bottomSpace/element.offsetHeight) + 0.5) };\n};\n\nthis.scrollIntoCenterView = function(element, scrollBox, notX, notY)\n{\n    if (!element)\n        return;\n\n    if (!scrollBox)\n        scrollBox = this.getOverflowParent(element);\n\n    if (!scrollBox)\n        return;\n\n    var offset = this.getClientOffset(element);\n\n    if (!notY)\n    {\n        var topSpace = offset.y - scrollBox.scrollTop;\n        var bottomSpace = (scrollBox.scrollTop + scrollBox.clientHeight)\n            - (offset.y + element.offsetHeight);\n\n        if (topSpace < 0 || bottomSpace < 0)\n        {\n            var centerY = offset.y - (scrollBox.clientHeight/2);\n            scrollBox.scrollTop = centerY;\n        }\n    }\n\n    if (!notX)\n    {\n        var leftSpace = offset.x - scrollBox.scrollLeft;\n        var rightSpace = (scrollBox.scrollLeft + scrollBox.clientWidth)\n            - (offset.x + element.clientWidth);\n\n        if (leftSpace < 0 || rightSpace < 0)\n        {\n            var centerX = offset.x - (scrollBox.clientWidth/2);\n            scrollBox.scrollLeft = centerX;\n        }\n    }\n    if (FBTrace.DBG_SOURCEFILES)\n        FBTrace.sysout("lib.scrollIntoCenterView ","Element:"+element.innerHTML);\n};\n\n\n// ************************************************************************************************\n// CSS\n\nvar cssKeywordMap = null;\nvar cssPropNames = null;\nvar cssColorNames = null;\nvar imageRules = null;\n\nthis.getCSSKeywordsByProperty = function(propName)\n{\n    if (!cssKeywordMap)\n    {\n        cssKeywordMap = {};\n\n        for (var name in this.cssInfo)\n        {\n            var list = [];\n\n            var types = this.cssInfo[name];\n            for (var i = 0; i < types.length; ++i)\n            {\n                var keywords = this.cssKeywords[types[i]];\n                if (keywords)\n                    list.push.apply(list, keywords);\n            }\n\n            cssKeywordMap[name] = list;\n        }\n    }\n\n    return propName in cssKeywordMap ? cssKeywordMap[propName] : [];\n};\n\nthis.getCSSPropertyNames = function()\n{\n    if (!cssPropNames)\n    {\n        cssPropNames = [];\n\n        for (var name in this.cssInfo)\n            cssPropNames.push(name);\n    }\n\n    return cssPropNames;\n};\n\nthis.isColorKeyword = function(keyword)\n{\n    if (keyword == "transparent")\n        return false;\n\n    if (!cssColorNames)\n    {\n        cssColorNames = [];\n\n        var colors = this.cssKeywords["color"];\n        for (var i = 0; i < colors.length; ++i)\n            cssColorNames.push(colors[i].toLowerCase());\n\n        var systemColors = this.cssKeywords["systemColor"];\n        for (var i = 0; i < systemColors.length; ++i)\n            cssColorNames.push(systemColors[i].toLowerCase());\n    }\n\n    return cssColorNames.indexOf ? // Array.indexOf is not available in IE\n            cssColorNames.indexOf(keyword.toLowerCase()) != -1 :\n            (" " + cssColorNames.join(" ") + " ").indexOf(" " + keyword.toLowerCase() + " ") != -1;\n};\n\nthis.isImageRule = function(rule)\n{\n    if (!imageRules)\n    {\n        imageRules = [];\n\n        for (var i in this.cssInfo)\n        {\n            var r = i.toLowerCase();\n            var suffix = "image";\n            if (r.match(suffix + "$") == suffix || r == "background")\n                imageRules.push(r);\n        }\n    }\n\n    return imageRules.indexOf ? // Array.indexOf is not available in IE\n            imageRules.indexOf(rule.toLowerCase()) != -1 :\n            (" " + imageRules.join(" ") + " ").indexOf(" " + rule.toLowerCase() + " ") != -1;\n};\n\nthis.copyTextStyles = function(fromNode, toNode, style)\n{\n    var view = this.isIE ?\n            fromNode.ownerDocument.parentWindow :\n            fromNode.ownerDocument.defaultView;\n\n    if (view)\n    {\n        if (!style)\n            style = this.isIE ? fromNode.currentStyle : view.getComputedStyle(fromNode, "");\n\n        toNode.style.fontFamily = style.fontFamily;\n\n        // TODO: xxxpedro need to create a FBL.getComputedStyle() because IE\n        // returns wrong computed styles for inherited properties (like font-*)\n        //\n        // Also would be good to create a FBL.getStyle()\n        toNode.style.fontSize = style.fontSize;\n        toNode.style.fontWeight = style.fontWeight;\n        toNode.style.fontStyle = style.fontStyle;\n\n        return style;\n    }\n};\n\nthis.copyBoxStyles = function(fromNode, toNode, style)\n{\n    var view = this.isIE ?\n            fromNode.ownerDocument.parentWindow :\n            fromNode.ownerDocument.defaultView;\n\n    if (view)\n    {\n        if (!style)\n            style = this.isIE ? fromNode.currentStyle : view.getComputedStyle(fromNode, "");\n\n        toNode.style.marginTop = style.marginTop;\n        toNode.style.marginRight = style.marginRight;\n        toNode.style.marginBottom = style.marginBottom;\n        toNode.style.marginLeft = style.marginLeft;\n        toNode.style.borderTopWidth = style.borderTopWidth;\n        toNode.style.borderRightWidth = style.borderRightWidth;\n        toNode.style.borderBottomWidth = style.borderBottomWidth;\n        toNode.style.borderLeftWidth = style.borderLeftWidth;\n\n        return style;\n    }\n};\n\nthis.readBoxStyles = function(style)\n{\n    var styleNames = {\n        "margin-top": "marginTop", "margin-right": "marginRight",\n        "margin-left": "marginLeft", "margin-bottom": "marginBottom",\n        "border-top-width": "borderTop", "border-right-width": "borderRight",\n        "border-left-width": "borderLeft", "border-bottom-width": "borderBottom",\n        "padding-top": "paddingTop", "padding-right": "paddingRight",\n        "padding-left": "paddingLeft", "padding-bottom": "paddingBottom",\n        "z-index": "zIndex"\n    };\n\n    var styles = {};\n    for (var styleName in styleNames)\n        styles[styleNames[styleName]] = parseInt(style.getPropertyCSSValue(styleName).cssText) || 0;\n    if (FBTrace.DBG_INSPECT)\n        FBTrace.sysout("readBoxStyles ", styles);\n    return styles;\n};\n\nthis.getBoxFromStyles = function(style, element)\n{\n    var args = this.readBoxStyles(style);\n    args.width = element.offsetWidth\n        - (args.paddingLeft+args.paddingRight+args.borderLeft+args.borderRight);\n    args.height = element.offsetHeight\n        - (args.paddingTop+args.paddingBottom+args.borderTop+args.borderBottom);\n    return args;\n};\n\nthis.getElementCSSSelector = function(element)\n{\n    var label = element.localName.toLowerCase();\n    if (element.id)\n        label += "#" + element.id;\n    if (element.hasAttribute("class"))\n        label += "." + element.getAttribute("class").split(" ")[0];\n\n    return label;\n};\n\nthis.getURLForStyleSheet= function(styleSheet)\n{\n    //http://www.w3.org/TR/DOM-Level-2-Style/stylesheets.html#StyleSheets-StyleSheet. For inline style sheets, the value of this attribute is null.\n    return (styleSheet.href ? styleSheet.href : styleSheet.ownerNode.ownerDocument.URL);\n};\n\nthis.getDocumentForStyleSheet = function(styleSheet)\n{\n    while (styleSheet.parentStyleSheet && !styleSheet.ownerNode)\n    {\n        styleSheet = styleSheet.parentStyleSheet;\n    }\n    if (styleSheet.ownerNode)\n      return styleSheet.ownerNode.ownerDocument;\n};\n\n/**\n * Retrieves the instance number for a given style sheet. The instance number\n * is sheet\'s index within the set of all other sheets whose URL is the same.\n */\nthis.getInstanceForStyleSheet = function(styleSheet, ownerDocument)\n{\n    // System URLs are always unique (or at least we are making this assumption)\n    if (FBL.isSystemStyleSheet(styleSheet))\n        return 0;\n\n    // ownerDocument is an optional hint for performance\n    if (FBTrace.DBG_CSS) FBTrace.sysout("getInstanceForStyleSheet: " + styleSheet.href + " " + styleSheet.media.mediaText + " " + (styleSheet.ownerNode && FBL.getElementXPath(styleSheet.ownerNode)), ownerDocument);\n    ownerDocument = ownerDocument || FBL.getDocumentForStyleSheet(styleSheet);\n\n    var ret = 0,\n        styleSheets = ownerDocument.styleSheets,\n        href = styleSheet.href;\n    for (var i = 0; i < styleSheets.length; i++)\n    {\n        var curSheet = styleSheets[i];\n        if (FBTrace.DBG_CSS) FBTrace.sysout("getInstanceForStyleSheet: compare href " + i + " " + curSheet.href + " " + curSheet.media.mediaText + " " + (curSheet.ownerNode && FBL.getElementXPath(curSheet.ownerNode)));\n        if (curSheet == styleSheet)\n            break;\n        if (curSheet.href == href)\n            ret++;\n    }\n    return ret;\n};\n\n// ************************************************************************************************\n// HTML and XML Serialization\n\n\nvar getElementType = this.getElementType = function(node)\n{\n    if (isElementXUL(node))\n        return \'xul\';\n    else if (isElementSVG(node))\n        return \'svg\';\n    else if (isElementMathML(node))\n        return \'mathml\';\n    else if (isElementXHTML(node))\n        return \'xhtml\';\n    else if (isElementHTML(node))\n        return \'html\';\n};\n\nvar getElementSimpleType = this.getElementSimpleType = function(node)\n{\n    if (isElementSVG(node))\n        return \'svg\';\n    else if (isElementMathML(node))\n        return \'mathml\';\n    else\n        return \'html\';\n};\n\nvar isElementHTML = this.isElementHTML = function(node)\n{\n    return node.nodeName == node.nodeName.toUpperCase();\n};\n\nvar isElementXHTML = this.isElementXHTML = function(node)\n{\n    return node.nodeName == node.nodeName.toLowerCase();\n};\n\nvar isElementMathML = this.isElementMathML = function(node)\n{\n    return node.namespaceURI == \'http://www.w3.org/1998/Math/MathML\';\n};\n\nvar isElementSVG = this.isElementSVG = function(node)\n{\n    return node.namespaceURI == \'http://www.w3.org/2000/svg\';\n};\n\nvar isElementXUL = this.isElementXUL = function(node)\n{\n    return node instanceof XULElement;\n};\n\nthis.isSelfClosing = function(element)\n{\n    if (isElementSVG(element) || isElementMathML(element))\n        return true;\n    var tag = element.localName.toLowerCase();\n    return (this.selfClosingTags.hasOwnProperty(tag));\n};\n\nthis.getElementHTML = function(element)\n{\n    var self=this;\n    function toHTML(elt)\n    {\n        if (elt.nodeType == Node.ELEMENT_NODE)\n        {\n            if (unwrapObject(elt).firebugIgnore)\n                return;\n\n            html.push(\'<\', elt.nodeName.toLowerCase());\n\n            for (var i = 0; i < elt.attributes.length; ++i)\n            {\n                var attr = elt.attributes[i];\n\n                // Hide attributes set by Firebug\n                if (attr.localName.indexOf("firebug-") == 0)\n                    continue;\n\n                // MathML\n                if (attr.localName.indexOf("-moz-math") == 0)\n                {\n                    // just hide for now\n                    continue;\n                }\n\n                html.push(\' \', attr.nodeName, \'="\', escapeForElementAttribute(attr.nodeValue),\'"\');\n            }\n\n            if (elt.firstChild)\n            {\n                html.push(\'>\');\n\n                var pureText=true;\n                for (var child = element.firstChild; child; child = child.nextSibling)\n                    pureText=pureText && (child.nodeType == Node.TEXT_NODE);\n\n                if (pureText)\n                    html.push(escapeForHtmlEditor(elt.textContent));\n                else {\n                    for (var child = elt.firstChild; child; child = child.nextSibling)\n                        toHTML(child);\n                }\n\n                html.push(\'</\', elt.nodeName.toLowerCase(), \'>\');\n            }\n            else if (isElementSVG(elt) || isElementMathML(elt))\n            {\n                html.push(\'/>\');\n            }\n            else if (self.isSelfClosing(elt))\n            {\n                html.push((isElementXHTML(elt))?\'/>\':\'>\');\n            }\n            else\n            {\n                html.push(\'></\', elt.nodeName.toLowerCase(), \'>\');\n            }\n        }\n        else if (elt.nodeType == Node.TEXT_NODE)\n            html.push(escapeForTextNode(elt.textContent));\n        else if (elt.nodeType == Node.CDATA_SECTION_NODE)\n            html.push(\'<![CDATA[\', elt.nodeValue, \']]>\');\n        else if (elt.nodeType == Node.COMMENT_NODE)\n            html.push(\'<!--\', elt.nodeValue, \'-->\');\n    }\n\n    var html = [];\n    toHTML(element);\n    return html.join("");\n};\n\nthis.getElementXML = function(element)\n{\n    function toXML(elt)\n    {\n        if (elt.nodeType == Node.ELEMENT_NODE)\n        {\n            if (unwrapObject(elt).firebugIgnore)\n                return;\n\n            xml.push(\'<\', elt.nodeName.toLowerCase());\n\n            for (var i = 0; i < elt.attributes.length; ++i)\n            {\n                var attr = elt.attributes[i];\n\n                // Hide attributes set by Firebug\n                if (attr.localName.indexOf("firebug-") == 0)\n                    continue;\n\n                // MathML\n                if (attr.localName.indexOf("-moz-math") == 0)\n                {\n                    // just hide for now\n                    continue;\n                }\n\n                xml.push(\' \', attr.nodeName, \'="\', escapeForElementAttribute(attr.nodeValue),\'"\');\n            }\n\n            if (elt.firstChild)\n            {\n                xml.push(\'>\');\n\n                for (var child = elt.firstChild; child; child = child.nextSibling)\n                    toXML(child);\n\n                xml.push(\'</\', elt.nodeName.toLowerCase(), \'>\');\n            }\n            else\n                xml.push(\'/>\');\n        }\n        else if (elt.nodeType == Node.TEXT_NODE)\n            xml.push(elt.nodeValue);\n        else if (elt.nodeType == Node.CDATA_SECTION_NODE)\n            xml.push(\'<![CDATA[\', elt.nodeValue, \']]>\');\n        else if (elt.nodeType == Node.COMMENT_NODE)\n            xml.push(\'<!--\', elt.nodeValue, \'-->\');\n    }\n\n    var xml = [];\n    toXML(element);\n    return xml.join("");\n};\n\n\n// ************************************************************************************************\n// CSS classes\n\nthis.hasClass = function(node, name) // className, className, ...\n{\n    // TODO: xxxpedro when lib.hasClass is called with more than 2 arguments?\n    // this function can be optimized a lot if assumed 2 arguments only,\n    // which seems to be what happens 99% of the time\n    if (arguments.length == 2)\n        return (\' \'+node.className+\' \').indexOf(\' \'+name+\' \') != -1;\n\n    if (!node || node.nodeType != 1)\n        return false;\n    else\n    {\n        for (var i=1; i<arguments.length; ++i)\n        {\n            var name = arguments[i];\n            var re = new RegExp("(^|\\\\s)"+name+"($|\\\\s)");\n            if (!re.exec(node.className))\n                return false;\n        }\n\n        return true;\n    }\n};\n\nthis.old_hasClass = function(node, name) // className, className, ...\n{\n    if (!node || node.nodeType != 1)\n        return false;\n    else\n    {\n        for (var i=1; i<arguments.length; ++i)\n        {\n            var name = arguments[i];\n            var re = new RegExp("(^|\\\\s)"+name+"($|\\\\s)");\n            if (!re.exec(node.className))\n                return false;\n        }\n\n        return true;\n    }\n};\n\nthis.setClass = function(node, name)\n{\n    if (node && (\' \'+node.className+\' \').indexOf(\' \'+name+\' \') == -1)\n    ///if (node && !this.hasClass(node, name))\n        node.className += " " + name;\n};\n\nthis.getClassValue = function(node, name)\n{\n    var re = new RegExp(name+"-([^ ]+)");\n    var m = re.exec(node.className);\n    return m ? m[1] : "";\n};\n\nthis.removeClass = function(node, name)\n{\n    if (node && node.className)\n    {\n        var index = node.className.indexOf(name);\n        if (index >= 0)\n        {\n            var size = name.length;\n            node.className = node.className.substr(0,index-1) + node.className.substr(index+size);\n        }\n    }\n};\n\nthis.toggleClass = function(elt, name)\n{\n    if ((\' \'+elt.className+\' \').indexOf(\' \'+name+\' \') != -1)\n    ///if (this.hasClass(elt, name))\n        this.removeClass(elt, name);\n    else\n        this.setClass(elt, name);\n};\n\nthis.setClassTimed = function(elt, name, context, timeout)\n{\n    if (!timeout)\n        timeout = 1300;\n\n    if (elt.__setClassTimeout)\n        context.clearTimeout(elt.__setClassTimeout);\n    else\n        this.setClass(elt, name);\n\n    elt.__setClassTimeout = context.setTimeout(function()\n    {\n        delete elt.__setClassTimeout;\n\n        FBL.removeClass(elt, name);\n    }, timeout);\n};\n\nthis.cancelClassTimed = function(elt, name, context)\n{\n    if (elt.__setClassTimeout)\n    {\n        FBL.removeClass(elt, name);\n        context.clearTimeout(elt.__setClassTimeout);\n        delete elt.__setClassTimeout;\n    }\n};\n\n\n// ************************************************************************************************\n// DOM queries\n\nthis.$ = function(id, doc)\n{\n    if (doc)\n        return doc.getElementById(id);\n    else\n    {\n        return FBL.Firebug.chrome.document.getElementById(id);\n    }\n};\n\nthis.$$ = function(selector, doc)\n{\n    if (doc || !FBL.Firebug.chrome)\n        return FBL.Firebug.Selector(selector, doc);\n    else\n    {\n        return FBL.Firebug.Selector(selector, FBL.Firebug.chrome.document);\n    }\n};\n\nthis.getChildByClass = function(node) // ,classname, classname, classname...\n{\n    for (var i = 1; i < arguments.length; ++i)\n    {\n        var className = arguments[i];\n        var child = node.firstChild;\n        node = null;\n        for (; child; child = child.nextSibling)\n        {\n            if (this.hasClass(child, className))\n            {\n                node = child;\n                break;\n            }\n        }\n    }\n\n    return node;\n};\n\nthis.getAncestorByClass = function(node, className)\n{\n    for (var parent = node; parent; parent = parent.parentNode)\n    {\n        if (this.hasClass(parent, className))\n            return parent;\n    }\n\n    return null;\n};\n\n\nthis.getElementsByClass = function(node, className)\n{\n    var result = [];\n\n    for (var child = node.firstChild; child; child = child.nextSibling)\n    {\n        if (this.hasClass(child, className))\n            result.push(child);\n    }\n\n    return result;\n};\n\nthis.getElementByClass = function(node, className)  // className, className, ...\n{\n    var args = cloneArray(arguments); args.splice(0, 1);\n    for (var child = node.firstChild; child; child = child.nextSibling)\n    {\n        var args1 = cloneArray(args); args1.unshift(child);\n        if (FBL.hasClass.apply(null, args1))\n            return child;\n        else\n        {\n            var found = FBL.getElementByClass.apply(null, args1);\n            if (found)\n                return found;\n        }\n    }\n\n    return null;\n};\n\nthis.isAncestor = function(node, potentialAncestor)\n{\n    for (var parent = node; parent; parent = parent.parentNode)\n    {\n        if (parent == potentialAncestor)\n            return true;\n    }\n\n    return false;\n};\n\nthis.getNextElement = function(node)\n{\n    while (node && node.nodeType != 1)\n        node = node.nextSibling;\n\n    return node;\n};\n\nthis.getPreviousElement = function(node)\n{\n    while (node && node.nodeType != 1)\n        node = node.previousSibling;\n\n    return node;\n};\n\nthis.getBody = function(doc)\n{\n    if (doc.body)\n        return doc.body;\n\n    var body = doc.getElementsByTagName("body")[0];\n    if (body)\n        return body;\n\n    return doc.firstChild;  // For non-HTML docs\n};\n\nthis.findNextDown = function(node, criteria)\n{\n    if (!node)\n        return null;\n\n    for (var child = node.firstChild; child; child = child.nextSibling)\n    {\n        if (criteria(child))\n            return child;\n\n        var next = this.findNextDown(child, criteria);\n        if (next)\n            return next;\n    }\n};\n\nthis.findPreviousUp = function(node, criteria)\n{\n    if (!node)\n        return null;\n\n    for (var child = node.lastChild; child; child = child.previousSibling)\n    {\n        var next = this.findPreviousUp(child, criteria);\n        if (next)\n            return next;\n\n        if (criteria(child))\n            return child;\n    }\n};\n\nthis.findNext = function(node, criteria, upOnly, maxRoot)\n{\n    if (!node)\n        return null;\n\n    if (!upOnly)\n    {\n        var next = this.findNextDown(node, criteria);\n        if (next)\n            return next;\n    }\n\n    for (var sib = node.nextSibling; sib; sib = sib.nextSibling)\n    {\n        if (criteria(sib))\n            return sib;\n\n        var next = this.findNextDown(sib, criteria);\n        if (next)\n            return next;\n    }\n\n    if (node.parentNode && node.parentNode != maxRoot)\n        return this.findNext(node.parentNode, criteria, true);\n};\n\nthis.findPrevious = function(node, criteria, downOnly, maxRoot)\n{\n    if (!node)\n        return null;\n\n    for (var sib = node.previousSibling; sib; sib = sib.previousSibling)\n    {\n        var prev = this.findPreviousUp(sib, criteria);\n        if (prev)\n            return prev;\n\n        if (criteria(sib))\n            return sib;\n    }\n\n    if (!downOnly)\n    {\n        var next = this.findPreviousUp(node, criteria);\n        if (next)\n            return next;\n    }\n\n    if (node.parentNode && node.parentNode != maxRoot)\n    {\n        if (criteria(node.parentNode))\n            return node.parentNode;\n\n        return this.findPrevious(node.parentNode, criteria, true);\n    }\n};\n\nthis.getNextByClass = function(root, state)\n{\n    var iter = function iter(node) { return node.nodeType == 1 && FBL.hasClass(node, state); };\n    return this.findNext(root, iter);\n};\n\nthis.getPreviousByClass = function(root, state)\n{\n    var iter = function iter(node) { return node.nodeType == 1 && FBL.hasClass(node, state); };\n    return this.findPrevious(root, iter);\n};\n\nthis.isElement = function(o)\n{\n    try {\n        return o && this.instanceOf(o, "Element");\n    }\n    catch (ex) {\n        return false;\n    }\n};\n\n\n// ************************************************************************************************\n// DOM Modification\n\n// TODO: xxxpedro use doc fragments in Context API\nvar appendFragment = null;\n\nthis.appendInnerHTML = function(element, html, referenceElement)\n{\n    // if undefined, we must convert it to null otherwise it will throw an error in IE\n    // when executing element.insertBefore(firstChild, referenceElement)\n    referenceElement = referenceElement || null;\n\n    var doc = element.ownerDocument;\n\n    // doc.createRange not available in IE\n    if (doc.createRange)\n    {\n        var range = doc.createRange();  // a helper object\n        range.selectNodeContents(element); // the environment to interpret the html\n\n        var fragment = range.createContextualFragment(html);  // parse\n        var firstChild = fragment.firstChild;\n        element.insertBefore(fragment, referenceElement);\n    }\n    else\n    {\n        if (!appendFragment || appendFragment.ownerDocument != doc)\n            appendFragment = doc.createDocumentFragment();\n\n        var div = doc.createElement("div");\n        div.innerHTML = html;\n\n        var firstChild = div.firstChild;\n        while (div.firstChild)\n            appendFragment.appendChild(div.firstChild);\n\n        element.insertBefore(appendFragment, referenceElement);\n\n        div = null;\n    }\n\n    return firstChild;\n};\n\n\n// ************************************************************************************************\n// DOM creation\n\nthis.createElement = function(tagName, properties)\n{\n    properties = properties || {};\n    var doc = properties.document || FBL.Firebug.chrome.document;\n\n    var element = doc.createElement(tagName);\n\n    for(var name in properties)\n    {\n        if (name != "document")\n        {\n            element[name] = properties[name];\n        }\n    }\n\n    return element;\n};\n\nthis.createGlobalElement = function(tagName, properties)\n{\n    properties = properties || {};\n    var doc = FBL.Env.browser.document;\n\n    var element = this.NS && doc.createElementNS ?\n            doc.createElementNS(FBL.NS, tagName) :\n            doc.createElement(tagName);\n\n    for(var name in properties)\n    {\n        var propname = name;\n        if (FBL.isIE && name == "class") propname = "className";\n\n        if (name != "document")\n        {\n            element.setAttribute(propname, properties[name]);\n        }\n    }\n\n    return element;\n};\n\n//************************************************************************************************\n\nthis.safeGetWindowLocation = function(window)\n{\n    try\n    {\n        if (window)\n        {\n            if (window.closed)\n                return "(window.closed)";\n            if ("location" in window)\n                return window.location+"";\n            else\n                return "(no window.location)";\n        }\n        else\n            return "(no context.window)";\n    }\n    catch(exc)\n    {\n        if (FBTrace.DBG_WINDOWS || FBTrace.DBG_ERRORS)\n            FBTrace.sysout("TabContext.getWindowLocation failed "+exc, exc);\n            FBTrace.sysout("TabContext.getWindowLocation failed window:", window);\n        return "(getWindowLocation: "+exc+")";\n    }\n};\n\n// ************************************************************************************************\n// Events\n\nthis.isLeftClick = function(event)\n{\n    return (this.isIE && event.type != "click" && event.type != "dblclick" ?\n            event.button == 1 : // IE "click" and "dblclick" button model\n            event.button == 0) && // others\n        this.noKeyModifiers(event);\n};\n\nthis.isMiddleClick = function(event)\n{\n    return (this.isIE && event.type != "click" && event.type != "dblclick" ?\n            event.button == 4 : // IE "click" and "dblclick" button model\n            event.button == 1) &&\n        this.noKeyModifiers(event);\n};\n\nthis.isRightClick = function(event)\n{\n    return (this.isIE && event.type != "click" && event.type != "dblclick" ?\n            event.button == 2 : // IE "click" and "dblclick" button model\n            event.button == 2) &&\n        this.noKeyModifiers(event);\n};\n\nthis.noKeyModifiers = function(event)\n{\n    return !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey;\n};\n\nthis.isControlClick = function(event)\n{\n    return (this.isIE && event.type != "click" && event.type != "dblclick" ?\n            event.button == 1 : // IE "click" and "dblclick" button model\n            event.button == 0) &&\n        this.isControl(event);\n};\n\nthis.isShiftClick = function(event)\n{\n    return (this.isIE && event.type != "click" && event.type != "dblclick" ?\n            event.button == 1 : // IE "click" and "dblclick" button model\n            event.button == 0) &&\n        this.isShift(event);\n};\n\nthis.isControl = function(event)\n{\n    return (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey;\n};\n\nthis.isAlt = function(event)\n{\n    return event.altKey && !event.ctrlKey && !event.shiftKey && !event.metaKey;\n};\n\nthis.isAltClick = function(event)\n{\n    return (this.isIE && event.type != "click" && event.type != "dblclick" ?\n            event.button == 1 : // IE "click" and "dblclick" button model\n            event.button == 0) &&\n        this.isAlt(event);\n};\n\nthis.isControlShift = function(event)\n{\n    return (event.metaKey || event.ctrlKey) && event.shiftKey && !event.altKey;\n};\n\nthis.isShift = function(event)\n{\n    return event.shiftKey && !event.metaKey && !event.ctrlKey && !event.altKey;\n};\n\nthis.addEvent = function(object, name, handler, useCapture)\n{\n    if (object.addEventListener)\n        object.addEventListener(name, handler, useCapture);\n    else\n        object.attachEvent("on"+name, handler);\n};\n\nthis.removeEvent = function(object, name, handler, useCapture)\n{\n    try\n    {\n        if (object.removeEventListener)\n            object.removeEventListener(name, handler, useCapture);\n        else\n            object.detachEvent("on"+name, handler);\n    }\n    catch(e)\n    {\n        if (FBTrace.DBG_ERRORS)\n            FBTrace.sysout("FBL.removeEvent error: ", object, name);\n    }\n};\n\nthis.cancelEvent = function(e, preventDefault)\n{\n    if (!e) return;\n\n    if (preventDefault)\n    {\n                if (e.preventDefault)\n                    e.preventDefault();\n                else\n                    e.returnValue = false;\n    }\n\n    if (e.stopPropagation)\n        e.stopPropagation();\n    else\n        e.cancelBubble = true;\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.addGlobalEvent = function(name, handler)\n{\n    var doc = this.Firebug.browser.document;\n    var frames = this.Firebug.browser.window.frames;\n\n    this.addEvent(doc, name, handler);\n\n    if (this.Firebug.chrome.type == "popup")\n        this.addEvent(this.Firebug.chrome.document, name, handler);\n\n    for (var i = 0, frame; frame = frames[i]; i++)\n    {\n        try\n        {\n            this.addEvent(frame.document, name, handler);\n        }\n        catch(E)\n        {\n            // Avoid acess denied\n        }\n    }\n};\n\nthis.removeGlobalEvent = function(name, handler)\n{\n    var doc = this.Firebug.browser.document;\n    var frames = this.Firebug.browser.window.frames;\n\n    this.removeEvent(doc, name, handler);\n\n    if (this.Firebug.chrome.type == "popup")\n        this.removeEvent(this.Firebug.chrome.document, name, handler);\n\n    for (var i = 0, frame; frame = frames[i]; i++)\n    {\n        try\n        {\n            this.removeEvent(frame.document, name, handler);\n        }\n        catch(E)\n        {\n            // Avoid acess denied\n        }\n    }\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.dispatch = function(listeners, name, args)\n{\n    if (!listeners) return;\n\n    try\n    {/**/\n        if (typeof listeners.length != "undefined")\n        {\n            if (FBTrace.DBG_DISPATCH) FBTrace.sysout("FBL.dispatch", name+" to "+listeners.length+" listeners");\n\n            for (var i = 0; i < listeners.length; ++i)\n            {\n                var listener = listeners[i];\n                if ( listener[name] )\n                    listener[name].apply(listener, args);\n            }\n        }\n        else\n        {\n            if (FBTrace.DBG_DISPATCH) FBTrace.sysout("FBL.dispatch", name+" to listeners of an object");\n\n            for (var prop in listeners)\n            {\n                var listener = listeners[prop];\n                if ( listener[name] )\n                    listener[name].apply(listener, args);\n            }\n        }\n    }\n    catch (exc)\n    {\n        if (FBTrace.DBG_ERRORS)\n        {\n            FBTrace.sysout(" Exception in lib.dispatch "+ name, exc);\n            //FBTrace.dumpProperties(" Exception in lib.dispatch listener", listener);\n        }\n    }\n    /**/\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar disableTextSelectionHandler = function(event)\n{\n    FBL.cancelEvent(event, true);\n\n    return false;\n};\n\nthis.disableTextSelection = function(e)\n{\n    if (typeof e.onselectstart != "undefined") // IE\n        this.addEvent(e, "selectstart", disableTextSelectionHandler);\n\n    else // others\n    {\n        e.style.cssText = "user-select: none; -khtml-user-select: none; -moz-user-select: none;";\n\n        // canceling the event in FF will prevent the menu popups to close when clicking over\n        // text-disabled elements\n        if (!this.isFirefox)\n            this.addEvent(e, "mousedown", disableTextSelectionHandler);\n    }\n\n    e.style.cursor = "default";\n};\n\nthis.restoreTextSelection = function(e)\n{\n    if (typeof e.onselectstart != "undefined") // IE\n        this.removeEvent(e, "selectstart", disableTextSelectionHandler);\n\n    else // others\n    {\n        e.style.cssText = "cursor: default;";\n\n        // canceling the event in FF will prevent the menu popups to close when clicking over\n        // text-disabled elements\n        if (!this.isFirefox)\n            this.removeEvent(e, "mousedown", disableTextSelectionHandler);\n    }\n};\n\n// ************************************************************************************************\n// DOM Events\n\nvar eventTypes =\n{\n    composition: [\n        "composition",\n        "compositionstart",\n        "compositionend" ],\n    contextmenu: [\n        "contextmenu" ],\n    drag: [\n        "dragenter",\n        "dragover",\n        "dragexit",\n        "dragdrop",\n        "draggesture" ],\n    focus: [\n        "focus",\n        "blur" ],\n    form: [\n        "submit",\n        "reset",\n        "change",\n        "select",\n        "input" ],\n    key: [\n        "keydown",\n        "keyup",\n        "keypress" ],\n    load: [\n        "load",\n        "beforeunload",\n        "unload",\n        "abort",\n        "error" ],\n    mouse: [\n        "mousedown",\n        "mouseup",\n        "click",\n        "dblclick",\n        "mouseover",\n        "mouseout",\n        "mousemove" ],\n    mutation: [\n        "DOMSubtreeModified",\n        "DOMNodeInserted",\n        "DOMNodeRemoved",\n        "DOMNodeRemovedFromDocument",\n        "DOMNodeInsertedIntoDocument",\n        "DOMAttrModified",\n        "DOMCharacterDataModified" ],\n    paint: [\n        "paint",\n        "resize",\n        "scroll" ],\n    scroll: [\n        "overflow",\n        "underflow",\n        "overflowchanged" ],\n    text: [\n        "text" ],\n    ui: [\n        "DOMActivate",\n        "DOMFocusIn",\n        "DOMFocusOut" ],\n    xul: [\n        "popupshowing",\n        "popupshown",\n        "popuphiding",\n        "popuphidden",\n        "close",\n        "command",\n        "broadcast",\n        "commandupdate" ]\n};\n\nthis.getEventFamily = function(eventType)\n{\n    if (!this.families)\n    {\n        this.families = {};\n\n        for (var family in eventTypes)\n        {\n            var types = eventTypes[family];\n            for (var i = 0; i < types.length; ++i)\n                this.families[types[i]] = family;\n        }\n    }\n\n    return this.families[eventType];\n};\n\n\n// ************************************************************************************************\n// URLs\n\nthis.getFileName = function(url)\n{\n    var split = this.splitURLBase(url);\n    return split.name;\n};\n\nthis.splitURLBase = function(url)\n{\n    if (this.isDataURL(url))\n        return this.splitDataURL(url);\n    return this.splitURLTrue(url);\n};\n\nthis.splitDataURL = function(url)\n{\n    var mark = url.indexOf(\':\', 3);\n    if (mark != 4)\n        return false;   //  the first 5 chars must be \'data:\'\n\n    var point = url.indexOf(\',\', mark+1);\n    if (point < mark)\n        return false; // syntax error\n\n    var props = { encodedContent: url.substr(point+1) };\n\n    var metadataBuffer = url.substr(mark+1, point);\n    var metadata = metadataBuffer.split(\';\');\n    for (var i = 0; i < metadata.length; i++)\n    {\n        var nv = metadata[i].split(\'=\');\n        if (nv.length == 2)\n            props[nv[0]] = nv[1];\n    }\n\n    // Additional Firebug-specific properties\n    if (props.hasOwnProperty(\'fileName\'))\n    {\n         var caller_URL = decodeURIComponent(props[\'fileName\']);\n         var caller_split = this.splitURLTrue(caller_URL);\n\n        if (props.hasOwnProperty(\'baseLineNumber\'))  // this means it\'s probably an eval()\n        {\n            props[\'path\'] = caller_split.path;\n            props[\'line\'] = props[\'baseLineNumber\'];\n            var hint = decodeURIComponent(props[\'encodedContent\'].substr(0,200)).replace(/\\s*$/, "");\n            props[\'name\'] =  \'eval->\'+hint;\n        }\n        else\n        {\n            props[\'name\'] = caller_split.name;\n            props[\'path\'] = caller_split.path;\n        }\n    }\n    else\n    {\n        if (!props.hasOwnProperty(\'path\'))\n            props[\'path\'] = "data:";\n        if (!props.hasOwnProperty(\'name\'))\n            props[\'name\'] =  decodeURIComponent(props[\'encodedContent\'].substr(0,200)).replace(/\\s*$/, "");\n    }\n\n    return props;\n};\n\nthis.splitURLTrue = function(url)\n{\n    var m = reSplitFile.exec(url);\n    if (!m)\n        return {name: url, path: url};\n    else if (!m[2])\n        return {path: m[1], name: m[1]};\n    else\n        return {path: m[1], name: m[2]+m[3]};\n};\n\nthis.getFileExtension = function(url)\n{\n    if (!url)\n        return null;\n\n    // Remove query string from the URL if any.\n    var queryString = url.indexOf("?");\n    if (queryString != -1)\n        url = url.substr(0, queryString);\n\n    // Now get the file extension.\n    var lastDot = url.lastIndexOf(".");\n    return url.substr(lastDot+1);\n};\n\nthis.isSystemURL = function(url)\n{\n    if (!url) return true;\n    if (url.length == 0) return true;\n    if (url[0] == \'h\') return false;\n    if (url.substr(0, 9) == "resource:")\n        return true;\n    else if (url.substr(0, 16) == "chrome://firebug")\n        return true;\n    else if (url  == "XPCSafeJSObjectWrapper.cpp")\n        return true;\n    else if (url.substr(0, 6) == "about:")\n        return true;\n    else if (url.indexOf("firebug-service.js") != -1)\n        return true;\n    else\n        return false;\n};\n\nthis.isSystemPage = function(win)\n{\n    try\n    {\n        var doc = win.document;\n        if (!doc)\n            return false;\n\n        // Detect pages for pretty printed XML\n        if ((doc.styleSheets.length && doc.styleSheets[0].href\n                == "chrome://global/content/xml/XMLPrettyPrint.css")\n            || (doc.styleSheets.length > 1 && doc.styleSheets[1].href\n                == "chrome://browser/skin/feeds/subscribe.css"))\n            return true;\n\n        return FBL.isSystemURL(win.location.href);\n    }\n    catch (exc)\n    {\n        // Sometimes documents just aren\'t ready to be manipulated here, but don\'t let that\n        // gum up the works\n        ERROR("tabWatcher.isSystemPage document not ready:"+ exc);\n        return false;\n    }\n};\n\nthis.isSystemStyleSheet = function(sheet)\n{\n    var href = sheet && sheet.href;\n    return href && FBL.isSystemURL(href);\n};\n\nthis.getURIHost = function(uri)\n{\n    try\n    {\n        if (uri)\n            return uri.host;\n        else\n            return "";\n    }\n    catch (exc)\n    {\n        return "";\n    }\n};\n\nthis.isLocalURL = function(url)\n{\n    if (url.substr(0, 5) == "file:")\n        return true;\n    else if (url.substr(0, 8) == "wyciwyg:")\n        return true;\n    else\n        return false;\n};\n\nthis.isDataURL = function(url)\n{\n    return (url && url.substr(0,5) == "data:");\n};\n\nthis.getLocalPath = function(url)\n{\n    if (this.isLocalURL(url))\n    {\n        var fileHandler = ioService.getProtocolHandler("file").QueryInterface(Ci.nsIFileProtocolHandler);\n        var file = fileHandler.getFileFromURLSpec(url);\n        return file.path;\n    }\n};\n\nthis.getURLFromLocalFile = function(file)\n{\n    var fileHandler = ioService.getProtocolHandler("file").QueryInterface(Ci.nsIFileProtocolHandler);\n    var URL = fileHandler.getURLSpecFromFile(file);\n    return URL;\n};\n\nthis.getDataURLForContent = function(content, url)\n{\n    // data:text/javascript;fileName=x%2Cy.js;baseLineNumber=10,<the-url-encoded-data>\n    var uri = "data:text/html;";\n    uri += "fileName="+encodeURIComponent(url)+ ",";\n    uri += encodeURIComponent(content);\n    return uri;\n},\n\nthis.getDomain = function(url)\n{\n    var m = /[^:]+:\\/{1,3}([^\\/]+)/.exec(url);\n    return m ? m[1] : "";\n};\n\nthis.getURLPath = function(url)\n{\n    var m = /[^:]+:\\/{1,3}[^\\/]+(\\/.*?)$/.exec(url);\n    return m ? m[1] : "";\n};\n\nthis.getPrettyDomain = function(url)\n{\n    var m = /[^:]+:\\/{1,3}(www\\.)?([^\\/]+)/.exec(url);\n    return m ? m[2] : "";\n};\n\nthis.absoluteURL = function(url, baseURL)\n{\n    return this.absoluteURLWithDots(url, baseURL).replace("/./", "/", "g");\n};\n\nthis.absoluteURLWithDots = function(url, baseURL)\n{\n    if (url[0] == "?")\n        return baseURL + url;\n\n    var reURL = /(([^:]+:)\\/{1,2}[^\\/]*)(.*?)$/;\n    var m = reURL.exec(url);\n    if (m)\n        return url;\n\n    var m = reURL.exec(baseURL);\n    if (!m)\n        return "";\n\n    var head = m[1];\n    var tail = m[3];\n    if (url.substr(0, 2) == "//")\n        return m[2] + url;\n    else if (url[0] == "/")\n    {\n        return head + url;\n    }\n    else if (tail[tail.length-1] == "/")\n        return baseURL + url;\n    else\n    {\n        var parts = tail.split("/");\n        return head + parts.slice(0, parts.length-1).join("/") + "/" + url;\n    }\n};\n\nthis.normalizeURL = function(url)  // this gets called a lot, any performance improvement welcome\n{\n    if (!url)\n        return "";\n    // Replace one or more characters that are not forward-slash followed by /.., by space.\n    if (url.length < 255) // guard against monsters.\n    {\n        // Replace one or more characters that are not forward-slash followed by /.., by space.\n        url = url.replace(/[^\\/]+\\/\\.\\.\\//, "", "g");\n        // Issue 1496, avoid #\n        url = url.replace(/#.*/,"");\n        // For some reason, JSDS reports file URLs like "file:/" instead of "file:///", so they\n        // don\'t match up with the URLs we get back from the DOM\n        url = url.replace(/file:\\/([^\\/])/g, "file:///$1");\n        if (url.indexOf(\'chrome:\')==0)\n        {\n            var m = reChromeCase.exec(url);  // 1 is package name, 2 is path\n            if (m)\n            {\n                url = "chrome://"+m[1].toLowerCase()+"/"+m[2];\n            }\n        }\n    }\n    return url;\n};\n\nthis.denormalizeURL = function(url)\n{\n    return url.replace(/file:\\/\\/\\//g, "file:/");\n};\n\nthis.parseURLParams = function(url)\n{\n    var q = url ? url.indexOf("?") : -1;\n    if (q == -1)\n        return [];\n\n    var search = url.substr(q+1);\n    var h = search.lastIndexOf("#");\n    if (h != -1)\n        search = search.substr(0, h);\n\n    if (!search)\n        return [];\n\n    return this.parseURLEncodedText(search);\n};\n\nthis.parseURLEncodedText = function(text)\n{\n    var maxValueLength = 25000;\n\n    var params = [];\n\n    // Unescape \'+\' characters that are used to encode a space.\n    // See section 2.2.in RFC 3986: http://www.ietf.org/rfc/rfc3986.txt\n    text = text.replace(/\\+/g, " ");\n\n    var args = text.split("&");\n    for (var i = 0; i < args.length; ++i)\n    {\n        try {\n            var parts = args[i].split("=");\n            if (parts.length == 2)\n            {\n                if (parts[1].length > maxValueLength)\n                    parts[1] = this.$STR("LargeData");\n\n                params.push({name: decodeURIComponent(parts[0]), value: decodeURIComponent(parts[1])});\n            }\n            else\n                params.push({name: decodeURIComponent(parts[0]), value: ""});\n        }\n        catch (e)\n        {\n            if (FBTrace.DBG_ERRORS)\n            {\n                FBTrace.sysout("parseURLEncodedText EXCEPTION ", e);\n                FBTrace.sysout("parseURLEncodedText EXCEPTION URI", args[i]);\n            }\n        }\n    }\n\n    params.sort(function(a, b) { return a.name <= b.name ? -1 : 1; });\n\n    return params;\n};\n\n// TODO: xxxpedro lib. why loops in domplate are requiring array in parameters\n// as in response/request headers and get/post parameters in Net module?\nthis.parseURLParamsArray = function(url)\n{\n    var q = url ? url.indexOf("?") : -1;\n    if (q == -1)\n        return [];\n\n    var search = url.substr(q+1);\n    var h = search.lastIndexOf("#");\n    if (h != -1)\n        search = search.substr(0, h);\n\n    if (!search)\n        return [];\n\n    return this.parseURLEncodedTextArray(search);\n};\n\nthis.parseURLEncodedTextArray = function(text)\n{\n    var maxValueLength = 25000;\n\n    var params = [];\n\n    // Unescape \'+\' characters that are used to encode a space.\n    // See section 2.2.in RFC 3986: http://www.ietf.org/rfc/rfc3986.txt\n    text = text.replace(/\\+/g, " ");\n\n    var args = text.split("&");\n    for (var i = 0; i < args.length; ++i)\n    {\n        try {\n            var parts = args[i].split("=");\n            if (parts.length == 2)\n            {\n                if (parts[1].length > maxValueLength)\n                    parts[1] = this.$STR("LargeData");\n\n                params.push({name: decodeURIComponent(parts[0]), value: [decodeURIComponent(parts[1])]});\n            }\n            else\n                params.push({name: decodeURIComponent(parts[0]), value: [""]});\n        }\n        catch (e)\n        {\n            if (FBTrace.DBG_ERRORS)\n            {\n                FBTrace.sysout("parseURLEncodedText EXCEPTION ", e);\n                FBTrace.sysout("parseURLEncodedText EXCEPTION URI", args[i]);\n            }\n        }\n    }\n\n    params.sort(function(a, b) { return a.name <= b.name ? -1 : 1; });\n\n    return params;\n};\n\nthis.reEncodeURL = function(file, text)\n{\n    var lines = text.split("\\n");\n    var params = this.parseURLEncodedText(lines[lines.length-1]);\n\n    var args = [];\n    for (var i = 0; i < params.length; ++i)\n        args.push(encodeURIComponent(params[i].name)+"="+encodeURIComponent(params[i].value));\n\n    var url = file.href;\n    url += (url.indexOf("?") == -1 ? "?" : "&") + args.join("&");\n\n    return url;\n};\n\nthis.getResource = function(aURL)\n{\n    try\n    {\n        var channel=ioService.newChannel(aURL,null,null);\n        var input=channel.open();\n        return FBL.readFromStream(input);\n    }\n    catch (e)\n    {\n        if (FBTrace.DBG_ERRORS)\n            FBTrace.sysout("lib.getResource FAILS for "+aURL, e);\n    }\n};\n\nthis.parseJSONString = function(jsonString, originURL)\n{\n    // See if this is a Prototype style *-secure request.\n    var regex = new RegExp(/^\\/\\*-secure-([\\s\\S]*)\\*\\/\\s*$/);\n    var matches = regex.exec(jsonString);\n\n    if (matches)\n    {\n        jsonString = matches[1];\n\n        if (jsonString[0] == "\\\\" && jsonString[1] == "n")\n            jsonString = jsonString.substr(2);\n\n        if (jsonString[jsonString.length-2] == "\\\\" && jsonString[jsonString.length-1] == "n")\n            jsonString = jsonString.substr(0, jsonString.length-2);\n    }\n\n    if (jsonString.indexOf("&&&START&&&"))\n    {\n        regex = new RegExp(/&&&START&&& (.+) &&&END&&&/);\n        matches = regex.exec(jsonString);\n        if (matches)\n            jsonString = matches[1];\n    }\n\n    // throw on the extra parentheses\n    jsonString = "(" + jsonString + ")";\n\n    ///var s = Components.utils.Sandbox(originURL);\n    var jsonObject = null;\n\n    try\n    {\n        ///jsonObject = Components.utils.evalInSandbox(jsonString, s);\n\n        //jsonObject = Firebug.context.eval(jsonString);\n        jsonObject = Firebug.context.evaluate(jsonString, null, null, function(){return null;});\n    }\n    catch(e)\n    {\n        /***\n        if (e.message.indexOf("is not defined"))\n        {\n            var parts = e.message.split(" ");\n            s[parts[0]] = function(str){ return str; };\n            try {\n                jsonObject = Components.utils.evalInSandbox(jsonString, s);\n            } catch(ex) {\n                if (FBTrace.DBG_ERRORS || FBTrace.DBG_JSONVIEWER)\n                    FBTrace.sysout("jsonviewer.parseJSON EXCEPTION", e);\n                return null;\n            }\n        }\n        else\n        {/**/\n            if (FBTrace.DBG_ERRORS || FBTrace.DBG_JSONVIEWER)\n                FBTrace.sysout("jsonviewer.parseJSON EXCEPTION", e);\n            return null;\n        ///}\n    }\n\n    return jsonObject;\n};\n\n// ************************************************************************************************\n\nthis.objectToString = function(object)\n{\n    try\n    {\n        return object+"";\n    }\n    catch (exc)\n    {\n        return null;\n    }\n};\n\n// ************************************************************************************************\n// Input Caret Position\n\nthis.setSelectionRange = function(input, start, length)\n{\n    if (input.createTextRange)\n    {\n        var range = input.createTextRange();\n        range.moveStart("character", start);\n        range.moveEnd("character", length - input.value.length);\n        range.select();\n    }\n    else if (input.setSelectionRange)\n    {\n        input.setSelectionRange(start, length);\n        input.focus();\n    }\n};\n\n// ************************************************************************************************\n// Input Selection Start / Caret Position\n\nthis.getInputSelectionStart = function(input)\n{\n    if (document.selection)\n    {\n        var range = input.ownerDocument.selection.createRange();\n        var text = range.text;\n\n        //console.log("range", range.text);\n\n        // if there is a selection, find the start position\n        if (text)\n        {\n            return input.value.indexOf(text);\n        }\n        // if there is no selection, find the caret position\n        else\n        {\n            range.moveStart("character", -input.value.length);\n\n            return range.text.length;\n        }\n    }\n    else if (typeof input.selectionStart != "undefined")\n        return input.selectionStart;\n\n    return 0;\n};\n\n// ************************************************************************************************\n// Opera Tab Fix\n\nfunction onOperaTabBlur(e)\n{\n    if (this.lastKey == 9)\n      this.focus();\n};\n\nfunction onOperaTabKeyDown(e)\n{\n    this.lastKey = e.keyCode;\n};\n\nfunction onOperaTabFocus(e)\n{\n    this.lastKey = null;\n};\n\nthis.fixOperaTabKey = function(el)\n{\n    el.onfocus = onOperaTabFocus;\n    el.onblur = onOperaTabBlur;\n    el.onkeydown = onOperaTabKeyDown;\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.Property = function(object, name)\n{\n    this.object = object;\n    this.name = name;\n\n    this.getObject = function()\n    {\n        return object[name];\n    };\n};\n\nthis.ErrorCopy = function(message)\n{\n    this.message = message;\n};\n\nfunction EventCopy(event)\n{\n    // Because event objects are destroyed arbitrarily by Gecko, we must make a copy of them to\n    // represent them long term in the inspector.\n    for (var name in event)\n    {\n        try {\n            this[name] = event[name];\n        } catch (exc) { }\n    }\n}\n\nthis.EventCopy = EventCopy;\n\n\n// ************************************************************************************************\n// Type Checking\n\nvar toString = Object.prototype.toString;\nvar reFunction = /^\\s*function(\\s+[\\w_$][\\w\\d_$]*)?\\s*\\(/;\n\nthis.isArray = function(object) {\n    return toString.call(object) === \'[object Array]\';\n};\n\nthis.isFunction = function(object) {\n    if (!object) return false;\n\n    try\n    {\n        // FIXME: xxxpedro this is failing in IE for the global "external" object\n        return toString.call(object) === "[object Function]" ||\n                this.isIE && typeof object != "string" && reFunction.test(""+object);\n    }\n    catch (E)\n    {\n        FBTrace.sysout("Lib.isFunction() failed for ", object);\n        return false;\n    }\n};\n\n\n// ************************************************************************************************\n// Instance Checking\n\nthis.instanceOf = function(object, className)\n{\n    if (!object || typeof object != "object")\n        return false;\n\n    // Try to use the native instanceof operator. We can only use it when we know\n    // exactly the window where the object is located at\n    if (object.ownerDocument)\n    {\n        // find the correct window of the object\n        var win = object.ownerDocument.defaultView || object.ownerDocument.parentWindow;\n\n        // if the class is accessible in the window, uses the native instanceof operator\n        // if the instanceof evaluates to "true" we can assume it is a instance, but if it\n        // evaluates to "false" we must continue with the duck type detection below because\n        // the native object may be extended, thus breaking the instanceof result\n        // See Issue 3524: Firebug Lite Style Panel doesn\'t work if the native Element is extended\n        if (className in win && object instanceof win[className])\n            return true;\n    }\n    // If the object doesn\'t have the ownerDocument property, we\'ll try to look at\n    // the current context\'s window\n    else\n    {\n        // TODO: xxxpedro context\n        // Since we\'re not using yet a Firebug.context, we\'ll just use the top window\n        // (browser) as a reference\n        var win = Firebug.browser.window;\n        if (className in win)\n            return object instanceof win[className];\n    }\n\n    // get the duck type model from the cache\n    var cache = instanceCheckMap[className];\n    if (!cache)\n        return false;\n\n    // starts the hacky duck type detection\n    for(var n in cache)\n    {\n        var obj = cache[n];\n        var type = typeof obj;\n        obj = type == "object" ? obj : [obj];\n\n        for(var name in obj)\n        {\n            // avoid problems with extended native objects\n            // See Issue 3524: Firebug Lite Style Panel doesn\'t work if the native Element is extended\n            if (!obj.hasOwnProperty(name))\n                continue;\n\n            var value = obj[name];\n\n            if( n == "property" && !(value in object) ||\n                n == "method" && !this.isFunction(object[value]) ||\n                n == "value" && (""+object[name]).toLowerCase() != (""+value).toLowerCase() )\n                    return false;\n        }\n    }\n\n    return true;\n};\n\nvar instanceCheckMap =\n{\n    // DuckTypeCheck:\n    // {\n    //     property: ["window", "document"],\n    //     method: "setTimeout",\n    //     value: {nodeType: 1}\n    // },\n\n    Window:\n    {\n        property: ["window", "document"],\n        method: "setTimeout"\n    },\n\n    Document:\n    {\n        property: ["body", "cookie"],\n        method: "getElementById"\n    },\n\n    Node:\n    {\n        property: "ownerDocument",\n        method: "appendChild"\n    },\n\n    Element:\n    {\n        property: "tagName",\n        value: {nodeType: 1}\n    },\n\n    Location:\n    {\n        property: ["hostname", "protocol"],\n        method: "assign"\n    },\n\n    HTMLImageElement:\n    {\n        property: "useMap",\n        value:\n        {\n            nodeType: 1,\n            tagName: "img"\n        }\n    },\n\n    HTMLAnchorElement:\n    {\n        property: "hreflang",\n        value:\n        {\n            nodeType: 1,\n            tagName: "a"\n        }\n    },\n\n    HTMLInputElement:\n    {\n        property: "form",\n        value:\n        {\n            nodeType: 1,\n            tagName: "input"\n        }\n    },\n\n    HTMLButtonElement:\n    {\n        // ?\n    },\n\n    HTMLFormElement:\n    {\n        method: "submit",\n        value:\n        {\n            nodeType: 1,\n            tagName: "form"\n        }\n    },\n\n    HTMLBodyElement:\n    {\n\n    },\n\n    HTMLHtmlElement:\n    {\n\n    },\n\n    CSSStyleRule:\n    {\n        property: ["selectorText", "style"]\n    }\n\n};\n\n\n// ************************************************************************************************\n// DOM Constants\n\n/*\n\nProblems:\n\n  - IE does not have window.Node, window.Element, etc\n  - for (var name in Node.prototype) return nothing on FF\n\n*/\n\n\nvar domMemberMap2 = {};\n\nvar domMemberMap2Sandbox = null;\n\nvar getDomMemberMap2 = function(name)\n{\n    if (!domMemberMap2Sandbox)\n    {\n        var doc = Firebug.chrome.document;\n        var frame = doc.createElement("iframe");\n\n        frame.id = "FirebugSandbox";\n        frame.style.display = "none";\n        frame.src = "about:blank";\n\n        doc.body.appendChild(frame);\n\n        domMemberMap2Sandbox = frame.window || frame.contentWindow;\n    }\n\n    var props = [];\n\n    //var object = domMemberMap2Sandbox[name];\n    //object = object.prototype || object;\n\n    var object = null;\n\n    if (name == "Window")\n        object = domMemberMap2Sandbox.window;\n\n    else if (name == "Document")\n        object = domMemberMap2Sandbox.document;\n\n    else if (name == "HTMLScriptElement")\n        object = domMemberMap2Sandbox.document.createElement("script");\n\n    else if (name == "HTMLAnchorElement")\n        object = domMemberMap2Sandbox.document.createElement("a");\n\n    else if (name.indexOf("Element") != -1)\n    {\n        object = domMemberMap2Sandbox.document.createElement("div");\n    }\n\n    if (object)\n    {\n        //object = object.prototype || object;\n\n        //props  = \'addEventListener,document,location,navigator,window\'.split(\',\');\n\n        for (var n in object)\n          props.push(n);\n    }\n    /**/\n\n    return props;\n    return extendArray(props, domMemberMap[name]);\n};\n\n// xxxpedro experimental get DOM members\nthis.getDOMMembers = function(object)\n{\n    if (!domMemberCache)\n    {\n        FBL.domMemberCache = domMemberCache = {};\n\n        for (var name in domMemberMap)\n        {\n            var builtins = getDomMemberMap2(name);\n            var cache = domMemberCache[name] = {};\n\n            /*\n            if (name.indexOf("Element") != -1)\n            {\n                this.append(cache, this.getDOMMembers("Node"));\n                this.append(cache, this.getDOMMembers("Element"));\n            }\n            /**/\n\n            for (var i = 0; i < builtins.length; ++i)\n                cache[builtins[i]] = i;\n        }\n    }\n\n    try\n    {\n        if (this.instanceOf(object, "Window"))\n            { return domMemberCache.Window; }\n        else if (this.instanceOf(object, "Document") || this.instanceOf(object, "XMLDocument"))\n            { return domMemberCache.Document; }\n        else if (this.instanceOf(object, "Location"))\n            { return domMemberCache.Location; }\n        else if (this.instanceOf(object, "HTMLImageElement"))\n            { return domMemberCache.HTMLImageElement; }\n        else if (this.instanceOf(object, "HTMLAnchorElement"))\n            { return domMemberCache.HTMLAnchorElement; }\n        else if (this.instanceOf(object, "HTMLInputElement"))\n            { return domMemberCache.HTMLInputElement; }\n        else if (this.instanceOf(object, "HTMLButtonElement"))\n            { return domMemberCache.HTMLButtonElement; }\n        else if (this.instanceOf(object, "HTMLFormElement"))\n            { return domMemberCache.HTMLFormElement; }\n        else if (this.instanceOf(object, "HTMLBodyElement"))\n            { return domMemberCache.HTMLBodyElement; }\n        else if (this.instanceOf(object, "HTMLHtmlElement"))\n            { return domMemberCache.HTMLHtmlElement; }\n        else if (this.instanceOf(object, "HTMLScriptElement"))\n            { return domMemberCache.HTMLScriptElement; }\n        else if (this.instanceOf(object, "HTMLTableElement"))\n            { return domMemberCache.HTMLTableElement; }\n        else if (this.instanceOf(object, "HTMLTableRowElement"))\n            { return domMemberCache.HTMLTableRowElement; }\n        else if (this.instanceOf(object, "HTMLTableCellElement"))\n            { return domMemberCache.HTMLTableCellElement; }\n        else if (this.instanceOf(object, "HTMLIFrameElement"))\n            { return domMemberCache.HTMLIFrameElement; }\n        else if (this.instanceOf(object, "SVGSVGElement"))\n            { return domMemberCache.SVGSVGElement; }\n        else if (this.instanceOf(object, "SVGElement"))\n            { return domMemberCache.SVGElement; }\n        else if (this.instanceOf(object, "Element"))\n            { return domMemberCache.Element; }\n        else if (this.instanceOf(object, "Text") || this.instanceOf(object, "CDATASection"))\n            { return domMemberCache.Text; }\n        else if (this.instanceOf(object, "Attr"))\n            { return domMemberCache.Attr; }\n        else if (this.instanceOf(object, "Node"))\n            { return domMemberCache.Node; }\n        else if (this.instanceOf(object, "Event") || this.instanceOf(object, "EventCopy"))\n            { return domMemberCache.Event; }\n        else\n            return {};\n    }\n    catch(E)\n    {\n        if (FBTrace.DBG_ERRORS)\n            FBTrace.sysout("lib.getDOMMembers FAILED ", E);\n\n        return {};\n    }\n};\n\n\n/*\nthis.getDOMMembers = function(object)\n{\n    if (!domMemberCache)\n    {\n        domMemberCache = {};\n\n        for (var name in domMemberMap)\n        {\n            var builtins = domMemberMap[name];\n            var cache = domMemberCache[name] = {};\n\n            for (var i = 0; i < builtins.length; ++i)\n                cache[builtins[i]] = i;\n        }\n    }\n\n    try\n    {\n        if (this.instanceOf(object, "Window"))\n            { return domMemberCache.Window; }\n        else if (object instanceof Document || object instanceof XMLDocument)\n            { return domMemberCache.Document; }\n        else if (object instanceof Location)\n            { return domMemberCache.Location; }\n        else if (object instanceof HTMLImageElement)\n            { return domMemberCache.HTMLImageElement; }\n        else if (object instanceof HTMLAnchorElement)\n            { return domMemberCache.HTMLAnchorElement; }\n        else if (object instanceof HTMLInputElement)\n            { return domMemberCache.HTMLInputElement; }\n        else if (object instanceof HTMLButtonElement)\n            { return domMemberCache.HTMLButtonElement; }\n        else if (object instanceof HTMLFormElement)\n            { return domMemberCache.HTMLFormElement; }\n        else if (object instanceof HTMLBodyElement)\n            { return domMemberCache.HTMLBodyElement; }\n        else if (object instanceof HTMLHtmlElement)\n            { return domMemberCache.HTMLHtmlElement; }\n        else if (object instanceof HTMLScriptElement)\n            { return domMemberCache.HTMLScriptElement; }\n        else if (object instanceof HTMLTableElement)\n            { return domMemberCache.HTMLTableElement; }\n        else if (object instanceof HTMLTableRowElement)\n            { return domMemberCache.HTMLTableRowElement; }\n        else if (object instanceof HTMLTableCellElement)\n            { return domMemberCache.HTMLTableCellElement; }\n        else if (object instanceof HTMLIFrameElement)\n            { return domMemberCache.HTMLIFrameElement; }\n        else if (object instanceof SVGSVGElement)\n            { return domMemberCache.SVGSVGElement; }\n        else if (object instanceof SVGElement)\n            { return domMemberCache.SVGElement; }\n        else if (object instanceof Element)\n            { return domMemberCache.Element; }\n        else if (object instanceof Text || object instanceof CDATASection)\n            { return domMemberCache.Text; }\n        else if (object instanceof Attr)\n            { return domMemberCache.Attr; }\n        else if (object instanceof Node)\n            { return domMemberCache.Node; }\n        else if (object instanceof Event || object instanceof EventCopy)\n            { return domMemberCache.Event; }\n        else\n            return {};\n    }\n    catch(E)\n    {\n        return {};\n    }\n};\n/**/\n\nthis.isDOMMember = function(object, propName)\n{\n    var members = this.getDOMMembers(object);\n    return members && propName in members;\n};\n\nvar domMemberCache = null;\nvar domMemberMap = {};\n\ndomMemberMap.Window =\n[\n    "document",\n    "frameElement",\n\n    "innerWidth",\n    "innerHeight",\n    "outerWidth",\n    "outerHeight",\n    "screenX",\n    "screenY",\n    "pageXOffset",\n    "pageYOffset",\n    "scrollX",\n    "scrollY",\n    "scrollMaxX",\n    "scrollMaxY",\n\n    "status",\n    "defaultStatus",\n\n    "parent",\n    "opener",\n    "top",\n    "window",\n    "content",\n    "self",\n\n    "location",\n    "history",\n    "frames",\n    "navigator",\n    "screen",\n    "menubar",\n    "toolbar",\n    "locationbar",\n    "personalbar",\n    "statusbar",\n    "directories",\n    "scrollbars",\n    "fullScreen",\n    "netscape",\n    "java",\n    "console",\n    "Components",\n    "controllers",\n    "closed",\n    "crypto",\n    "pkcs11",\n\n    "name",\n    "property",\n    "length",\n\n    "sessionStorage",\n    "globalStorage",\n\n    "setTimeout",\n    "setInterval",\n    "clearTimeout",\n    "clearInterval",\n    "addEventListener",\n    "removeEventListener",\n    "dispatchEvent",\n    "getComputedStyle",\n    "captureEvents",\n    "releaseEvents",\n    "routeEvent",\n    "enableExternalCapture",\n    "disableExternalCapture",\n    "moveTo",\n    "moveBy",\n    "resizeTo",\n    "resizeBy",\n    "scroll",\n    "scrollTo",\n    "scrollBy",\n    "scrollByLines",\n    "scrollByPages",\n    "sizeToContent",\n    "setResizable",\n    "getSelection",\n    "open",\n    "openDialog",\n    "close",\n    "alert",\n    "confirm",\n    "prompt",\n    "dump",\n    "focus",\n    "blur",\n    "find",\n    "back",\n    "forward",\n    "home",\n    "stop",\n    "print",\n    "atob",\n    "btoa",\n    "updateCommands",\n    "XPCNativeWrapper",\n    "GeckoActiveXObject",\n    "applicationCache"      // FF3\n];\n\ndomMemberMap.Location =\n[\n    "href",\n    "protocol",\n    "host",\n    "hostname",\n    "port",\n    "pathname",\n    "search",\n    "hash",\n\n    "assign",\n    "reload",\n    "replace"\n];\n\ndomMemberMap.Node =\n[\n    "id",\n    "className",\n\n    "nodeType",\n    "tagName",\n    "nodeName",\n    "localName",\n    "prefix",\n    "namespaceURI",\n    "nodeValue",\n\n    "ownerDocument",\n    "parentNode",\n    "offsetParent",\n    "nextSibling",\n    "previousSibling",\n    "firstChild",\n    "lastChild",\n    "childNodes",\n    "attributes",\n\n    "dir",\n    "baseURI",\n    "textContent",\n    "innerHTML",\n\n    "addEventListener",\n    "removeEventListener",\n    "dispatchEvent",\n    "cloneNode",\n    "appendChild",\n    "insertBefore",\n    "replaceChild",\n    "removeChild",\n    "compareDocumentPosition",\n    "hasAttributes",\n    "hasChildNodes",\n    "lookupNamespaceURI",\n    "lookupPrefix",\n    "normalize",\n    "isDefaultNamespace",\n    "isEqualNode",\n    "isSameNode",\n    "isSupported",\n    "getFeature",\n    "getUserData",\n    "setUserData"\n];\n\ndomMemberMap.Document = extendArray(domMemberMap.Node,\n[\n    "documentElement",\n    "body",\n    "title",\n    "location",\n    "referrer",\n    "cookie",\n    "contentType",\n    "lastModified",\n    "characterSet",\n    "inputEncoding",\n    "xmlEncoding",\n    "xmlStandalone",\n    "xmlVersion",\n    "strictErrorChecking",\n    "documentURI",\n    "URL",\n\n    "defaultView",\n    "doctype",\n    "implementation",\n    "styleSheets",\n    "images",\n    "links",\n    "forms",\n    "anchors",\n    "embeds",\n    "plugins",\n    "applets",\n\n    "width",\n    "height",\n\n    "designMode",\n    "compatMode",\n    "async",\n    "preferredStylesheetSet",\n\n    "alinkColor",\n    "linkColor",\n    "vlinkColor",\n    "bgColor",\n    "fgColor",\n    "domain",\n\n    "addEventListener",\n    "removeEventListener",\n    "dispatchEvent",\n    "captureEvents",\n    "releaseEvents",\n    "routeEvent",\n    "clear",\n    "open",\n    "close",\n    "execCommand",\n    "execCommandShowHelp",\n    "getElementsByName",\n    "getSelection",\n    "queryCommandEnabled",\n    "queryCommandIndeterm",\n    "queryCommandState",\n    "queryCommandSupported",\n    "queryCommandText",\n    "queryCommandValue",\n    "write",\n    "writeln",\n    "adoptNode",\n    "appendChild",\n    "removeChild",\n    "renameNode",\n    "cloneNode",\n    "compareDocumentPosition",\n    "createAttribute",\n    "createAttributeNS",\n    "createCDATASection",\n    "createComment",\n    "createDocumentFragment",\n    "createElement",\n    "createElementNS",\n    "createEntityReference",\n    "createEvent",\n    "createExpression",\n    "createNSResolver",\n    "createNodeIterator",\n    "createProcessingInstruction",\n    "createRange",\n    "createTextNode",\n    "createTreeWalker",\n    "domConfig",\n    "evaluate",\n    "evaluateFIXptr",\n    "evaluateXPointer",\n    "getAnonymousElementByAttribute",\n    "getAnonymousNodes",\n    "addBinding",\n    "removeBinding",\n    "getBindingParent",\n    "getBoxObjectFor",\n    "setBoxObjectFor",\n    "getElementById",\n    "getElementsByTagName",\n    "getElementsByTagNameNS",\n    "hasAttributes",\n    "hasChildNodes",\n    "importNode",\n    "insertBefore",\n    "isDefaultNamespace",\n    "isEqualNode",\n    "isSameNode",\n    "isSupported",\n    "load",\n    "loadBindingDocument",\n    "lookupNamespaceURI",\n    "lookupPrefix",\n    "normalize",\n    "normalizeDocument",\n    "getFeature",\n    "getUserData",\n    "setUserData"\n]);\n\ndomMemberMap.Element = extendArray(domMemberMap.Node,\n[\n    "clientWidth",\n    "clientHeight",\n    "offsetLeft",\n    "offsetTop",\n    "offsetWidth",\n    "offsetHeight",\n    "scrollLeft",\n    "scrollTop",\n    "scrollWidth",\n    "scrollHeight",\n\n    "style",\n\n    "tabIndex",\n    "title",\n    "lang",\n    "align",\n    "spellcheck",\n\n    "addEventListener",\n    "removeEventListener",\n    "dispatchEvent",\n    "focus",\n    "blur",\n    "cloneNode",\n    "appendChild",\n    "insertBefore",\n    "replaceChild",\n    "removeChild",\n    "compareDocumentPosition",\n    "getElementsByTagName",\n    "getElementsByTagNameNS",\n    "getAttribute",\n    "getAttributeNS",\n    "getAttributeNode",\n    "getAttributeNodeNS",\n    "setAttribute",\n    "setAttributeNS",\n    "setAttributeNode",\n    "setAttributeNodeNS",\n    "removeAttribute",\n    "removeAttributeNS",\n    "removeAttributeNode",\n    "hasAttribute",\n    "hasAttributeNS",\n    "hasAttributes",\n    "hasChildNodes",\n    "lookupNamespaceURI",\n    "lookupPrefix",\n    "normalize",\n    "isDefaultNamespace",\n    "isEqualNode",\n    "isSameNode",\n    "isSupported",\n    "getFeature",\n    "getUserData",\n    "setUserData"\n]);\n\ndomMemberMap.SVGElement = extendArray(domMemberMap.Element,\n[\n    "x",\n    "y",\n    "width",\n    "height",\n    "rx",\n    "ry",\n    "transform",\n    "href",\n\n    "ownerSVGElement",\n    "viewportElement",\n    "farthestViewportElement",\n    "nearestViewportElement",\n\n    "getBBox",\n    "getCTM",\n    "getScreenCTM",\n    "getTransformToElement",\n    "getPresentationAttribute",\n    "preserveAspectRatio"\n]);\n\ndomMemberMap.SVGSVGElement = extendArray(domMemberMap.Element,\n[\n    "x",\n    "y",\n    "width",\n    "height",\n    "rx",\n    "ry",\n    "transform",\n\n    "viewBox",\n    "viewport",\n    "currentView",\n    "useCurrentView",\n    "pixelUnitToMillimeterX",\n    "pixelUnitToMillimeterY",\n    "screenPixelToMillimeterX",\n    "screenPixelToMillimeterY",\n    "currentScale",\n    "currentTranslate",\n    "zoomAndPan",\n\n    "ownerSVGElement",\n    "viewportElement",\n    "farthestViewportElement",\n    "nearestViewportElement",\n    "contentScriptType",\n    "contentStyleType",\n\n    "getBBox",\n    "getCTM",\n    "getScreenCTM",\n    "getTransformToElement",\n    "getEnclosureList",\n    "getIntersectionList",\n    "getViewboxToViewportTransform",\n    "getPresentationAttribute",\n    "getElementById",\n    "checkEnclosure",\n    "checkIntersection",\n    "createSVGAngle",\n    "createSVGLength",\n    "createSVGMatrix",\n    "createSVGNumber",\n    "createSVGPoint",\n    "createSVGRect",\n    "createSVGString",\n    "createSVGTransform",\n    "createSVGTransformFromMatrix",\n    "deSelectAll",\n    "preserveAspectRatio",\n    "forceRedraw",\n    "suspendRedraw",\n    "unsuspendRedraw",\n    "unsuspendRedrawAll",\n    "getCurrentTime",\n    "setCurrentTime",\n    "animationsPaused",\n    "pauseAnimations",\n    "unpauseAnimations"\n]);\n\ndomMemberMap.HTMLImageElement = extendArray(domMemberMap.Element,\n[\n    "src",\n    "naturalWidth",\n    "naturalHeight",\n    "width",\n    "height",\n    "x",\n    "y",\n    "name",\n    "alt",\n    "longDesc",\n    "lowsrc",\n    "border",\n    "complete",\n    "hspace",\n    "vspace",\n    "isMap",\n    "useMap"\n]);\n\ndomMemberMap.HTMLAnchorElement = extendArray(domMemberMap.Element,\n[\n    "name",\n    "target",\n    "accessKey",\n    "href",\n    "protocol",\n    "host",\n    "hostname",\n    "port",\n    "pathname",\n    "search",\n    "hash",\n    "hreflang",\n    "coords",\n    "shape",\n    "text",\n    "type",\n    "rel",\n    "rev",\n    "charset"\n]);\n\ndomMemberMap.HTMLIFrameElement = extendArray(domMemberMap.Element,\n[\n    "contentDocument",\n    "contentWindow",\n    "frameBorder",\n    "height",\n    "longDesc",\n    "marginHeight",\n    "marginWidth",\n    "name",\n    "scrolling",\n    "src",\n    "width"\n]);\n\ndomMemberMap.HTMLTableElement = extendArray(domMemberMap.Element,\n[\n    "bgColor",\n    "border",\n    "caption",\n    "cellPadding",\n    "cellSpacing",\n    "frame",\n    "rows",\n    "rules",\n    "summary",\n    "tBodies",\n    "tFoot",\n    "tHead",\n    "width",\n\n    "createCaption",\n    "createTFoot",\n    "createTHead",\n    "deleteCaption",\n    "deleteRow",\n    "deleteTFoot",\n    "deleteTHead",\n    "insertRow"\n]);\n\ndomMemberMap.HTMLTableRowElement = extendArray(domMemberMap.Element,\n[\n    "bgColor",\n    "cells",\n    "ch",\n    "chOff",\n    "rowIndex",\n    "sectionRowIndex",\n    "vAlign",\n\n    "deleteCell",\n    "insertCell"\n]);\n\ndomMemberMap.HTMLTableCellElement = extendArray(domMemberMap.Element,\n[\n    "abbr",\n    "axis",\n    "bgColor",\n    "cellIndex",\n    "ch",\n    "chOff",\n    "colSpan",\n    "headers",\n    "height",\n    "noWrap",\n    "rowSpan",\n    "scope",\n    "vAlign",\n    "width"\n\n]);\n\ndomMemberMap.HTMLScriptElement = extendArray(domMemberMap.Element,\n[\n    "src"\n]);\n\ndomMemberMap.HTMLButtonElement = extendArray(domMemberMap.Element,\n[\n    "accessKey",\n    "disabled",\n    "form",\n    "name",\n    "type",\n    "value",\n\n    "click"\n]);\n\ndomMemberMap.HTMLInputElement = extendArray(domMemberMap.Element,\n[\n    "type",\n    "value",\n    "checked",\n    "accept",\n    "accessKey",\n    "alt",\n    "controllers",\n    "defaultChecked",\n    "defaultValue",\n    "disabled",\n    "form",\n    "maxLength",\n    "name",\n    "readOnly",\n    "selectionEnd",\n    "selectionStart",\n    "size",\n    "src",\n    "textLength",\n    "useMap",\n\n    "click",\n    "select",\n    "setSelectionRange"\n]);\n\ndomMemberMap.HTMLFormElement = extendArray(domMemberMap.Element,\n[\n    "acceptCharset",\n    "action",\n    "author",\n    "elements",\n    "encoding",\n    "enctype",\n    "entry_id",\n    "length",\n    "method",\n    "name",\n    "post",\n    "target",\n    "text",\n    "url",\n\n    "reset",\n    "submit"\n]);\n\ndomMemberMap.HTMLBodyElement = extendArray(domMemberMap.Element,\n[\n    "aLink",\n    "background",\n    "bgColor",\n    "link",\n    "text",\n    "vLink"\n]);\n\ndomMemberMap.HTMLHtmlElement = extendArray(domMemberMap.Element,\n[\n    "version"\n]);\n\ndomMemberMap.Text = extendArray(domMemberMap.Node,\n[\n    "data",\n    "length",\n\n    "appendData",\n    "deleteData",\n    "insertData",\n    "replaceData",\n    "splitText",\n    "substringData"\n]);\n\ndomMemberMap.Attr = extendArray(domMemberMap.Node,\n[\n    "name",\n    "value",\n    "specified",\n    "ownerElement"\n]);\n\ndomMemberMap.Event =\n[\n    "type",\n    "target",\n    "currentTarget",\n    "originalTarget",\n    "explicitOriginalTarget",\n    "relatedTarget",\n    "rangeParent",\n    "rangeOffset",\n    "view",\n\n    "keyCode",\n    "charCode",\n    "screenX",\n    "screenY",\n    "clientX",\n    "clientY",\n    "layerX",\n    "layerY",\n    "pageX",\n    "pageY",\n\n    "detail",\n    "button",\n    "which",\n    "ctrlKey",\n    "shiftKey",\n    "altKey",\n    "metaKey",\n\n    "eventPhase",\n    "timeStamp",\n    "bubbles",\n    "cancelable",\n    "cancelBubble",\n\n    "isTrusted",\n    "isChar",\n\n    "getPreventDefault",\n    "initEvent",\n    "initMouseEvent",\n    "initKeyEvent",\n    "initUIEvent",\n    "preventBubble",\n    "preventCapture",\n    "preventDefault",\n    "stopPropagation"\n];\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.domConstantMap =\n{\n    "ELEMENT_NODE": 1,\n    "ATTRIBUTE_NODE": 1,\n    "TEXT_NODE": 1,\n    "CDATA_SECTION_NODE": 1,\n    "ENTITY_REFERENCE_NODE": 1,\n    "ENTITY_NODE": 1,\n    "PROCESSING_INSTRUCTION_NODE": 1,\n    "COMMENT_NODE": 1,\n    "DOCUMENT_NODE": 1,\n    "DOCUMENT_TYPE_NODE": 1,\n    "DOCUMENT_FRAGMENT_NODE": 1,\n    "NOTATION_NODE": 1,\n\n    "DOCUMENT_POSITION_DISCONNECTED": 1,\n    "DOCUMENT_POSITION_PRECEDING": 1,\n    "DOCUMENT_POSITION_FOLLOWING": 1,\n    "DOCUMENT_POSITION_CONTAINS": 1,\n    "DOCUMENT_POSITION_CONTAINED_BY": 1,\n    "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC": 1,\n\n    "UNKNOWN_RULE": 1,\n    "STYLE_RULE": 1,\n    "CHARSET_RULE": 1,\n    "IMPORT_RULE": 1,\n    "MEDIA_RULE": 1,\n    "FONT_FACE_RULE": 1,\n    "PAGE_RULE": 1,\n\n    "CAPTURING_PHASE": 1,\n    "AT_TARGET": 1,\n    "BUBBLING_PHASE": 1,\n\n    "SCROLL_PAGE_UP": 1,\n    "SCROLL_PAGE_DOWN": 1,\n\n    "MOUSEUP": 1,\n    "MOUSEDOWN": 1,\n    "MOUSEOVER": 1,\n    "MOUSEOUT": 1,\n    "MOUSEMOVE": 1,\n    "MOUSEDRAG": 1,\n    "CLICK": 1,\n    "DBLCLICK": 1,\n    "KEYDOWN": 1,\n    "KEYUP": 1,\n    "KEYPRESS": 1,\n    "DRAGDROP": 1,\n    "FOCUS": 1,\n    "BLUR": 1,\n    "SELECT": 1,\n    "CHANGE": 1,\n    "RESET": 1,\n    "SUBMIT": 1,\n    "SCROLL": 1,\n    "LOAD": 1,\n    "UNLOAD": 1,\n    "XFER_DONE": 1,\n    "ABORT": 1,\n    "ERROR": 1,\n    "LOCATE": 1,\n    "MOVE": 1,\n    "RESIZE": 1,\n    "FORWARD": 1,\n    "HELP": 1,\n    "BACK": 1,\n    "TEXT": 1,\n\n    "ALT_MASK": 1,\n    "CONTROL_MASK": 1,\n    "SHIFT_MASK": 1,\n    "META_MASK": 1,\n\n    "DOM_VK_TAB": 1,\n    "DOM_VK_PAGE_UP": 1,\n    "DOM_VK_PAGE_DOWN": 1,\n    "DOM_VK_UP": 1,\n    "DOM_VK_DOWN": 1,\n    "DOM_VK_LEFT": 1,\n    "DOM_VK_RIGHT": 1,\n    "DOM_VK_CANCEL": 1,\n    "DOM_VK_HELP": 1,\n    "DOM_VK_BACK_SPACE": 1,\n    "DOM_VK_CLEAR": 1,\n    "DOM_VK_RETURN": 1,\n    "DOM_VK_ENTER": 1,\n    "DOM_VK_SHIFT": 1,\n    "DOM_VK_CONTROL": 1,\n    "DOM_VK_ALT": 1,\n    "DOM_VK_PAUSE": 1,\n    "DOM_VK_CAPS_LOCK": 1,\n    "DOM_VK_ESCAPE": 1,\n    "DOM_VK_SPACE": 1,\n    "DOM_VK_END": 1,\n    "DOM_VK_HOME": 1,\n    "DOM_VK_PRINTSCREEN": 1,\n    "DOM_VK_INSERT": 1,\n    "DOM_VK_DELETE": 1,\n    "DOM_VK_0": 1,\n    "DOM_VK_1": 1,\n    "DOM_VK_2": 1,\n    "DOM_VK_3": 1,\n    "DOM_VK_4": 1,\n    "DOM_VK_5": 1,\n    "DOM_VK_6": 1,\n    "DOM_VK_7": 1,\n    "DOM_VK_8": 1,\n    "DOM_VK_9": 1,\n    "DOM_VK_SEMICOLON": 1,\n    "DOM_VK_EQUALS": 1,\n    "DOM_VK_A": 1,\n    "DOM_VK_B": 1,\n    "DOM_VK_C": 1,\n    "DOM_VK_D": 1,\n    "DOM_VK_E": 1,\n    "DOM_VK_F": 1,\n    "DOM_VK_G": 1,\n    "DOM_VK_H": 1,\n    "DOM_VK_I": 1,\n    "DOM_VK_J": 1,\n    "DOM_VK_K": 1,\n    "DOM_VK_L": 1,\n    "DOM_VK_M": 1,\n    "DOM_VK_N": 1,\n    "DOM_VK_O": 1,\n    "DOM_VK_P": 1,\n    "DOM_VK_Q": 1,\n    "DOM_VK_R": 1,\n    "DOM_VK_S": 1,\n    "DOM_VK_T": 1,\n    "DOM_VK_U": 1,\n    "DOM_VK_V": 1,\n    "DOM_VK_W": 1,\n    "DOM_VK_X": 1,\n    "DOM_VK_Y": 1,\n    "DOM_VK_Z": 1,\n    "DOM_VK_CONTEXT_MENU": 1,\n    "DOM_VK_NUMPAD0": 1,\n    "DOM_VK_NUMPAD1": 1,\n    "DOM_VK_NUMPAD2": 1,\n    "DOM_VK_NUMPAD3": 1,\n    "DOM_VK_NUMPAD4": 1,\n    "DOM_VK_NUMPAD5": 1,\n    "DOM_VK_NUMPAD6": 1,\n    "DOM_VK_NUMPAD7": 1,\n    "DOM_VK_NUMPAD8": 1,\n    "DOM_VK_NUMPAD9": 1,\n    "DOM_VK_MULTIPLY": 1,\n    "DOM_VK_ADD": 1,\n    "DOM_VK_SEPARATOR": 1,\n    "DOM_VK_SUBTRACT": 1,\n    "DOM_VK_DECIMAL": 1,\n    "DOM_VK_DIVIDE": 1,\n    "DOM_VK_F1": 1,\n    "DOM_VK_F2": 1,\n    "DOM_VK_F3": 1,\n    "DOM_VK_F4": 1,\n    "DOM_VK_F5": 1,\n    "DOM_VK_F6": 1,\n    "DOM_VK_F7": 1,\n    "DOM_VK_F8": 1,\n    "DOM_VK_F9": 1,\n    "DOM_VK_F10": 1,\n    "DOM_VK_F11": 1,\n    "DOM_VK_F12": 1,\n    "DOM_VK_F13": 1,\n    "DOM_VK_F14": 1,\n    "DOM_VK_F15": 1,\n    "DOM_VK_F16": 1,\n    "DOM_VK_F17": 1,\n    "DOM_VK_F18": 1,\n    "DOM_VK_F19": 1,\n    "DOM_VK_F20": 1,\n    "DOM_VK_F21": 1,\n    "DOM_VK_F22": 1,\n    "DOM_VK_F23": 1,\n    "DOM_VK_F24": 1,\n    "DOM_VK_NUM_LOCK": 1,\n    "DOM_VK_SCROLL_LOCK": 1,\n    "DOM_VK_COMMA": 1,\n    "DOM_VK_PERIOD": 1,\n    "DOM_VK_SLASH": 1,\n    "DOM_VK_BACK_QUOTE": 1,\n    "DOM_VK_OPEN_BRACKET": 1,\n    "DOM_VK_BACK_SLASH": 1,\n    "DOM_VK_CLOSE_BRACKET": 1,\n    "DOM_VK_QUOTE": 1,\n    "DOM_VK_META": 1,\n\n    "SVG_ZOOMANDPAN_DISABLE": 1,\n    "SVG_ZOOMANDPAN_MAGNIFY": 1,\n    "SVG_ZOOMANDPAN_UNKNOWN": 1\n};\n\nthis.cssInfo =\n{\n    "background": ["bgRepeat", "bgAttachment", "bgPosition", "color", "systemColor", "none"],\n    "background-attachment": ["bgAttachment"],\n    "background-color": ["color", "systemColor"],\n    "background-image": ["none"],\n    "background-position": ["bgPosition"],\n    "background-repeat": ["bgRepeat"],\n\n    "border": ["borderStyle", "thickness", "color", "systemColor", "none"],\n    "border-top": ["borderStyle", "borderCollapse", "color", "systemColor", "none"],\n    "border-right": ["borderStyle", "borderCollapse", "color", "systemColor", "none"],\n    "border-bottom": ["borderStyle", "borderCollapse", "color", "systemColor", "none"],\n    "border-left": ["borderStyle", "borderCollapse", "color", "systemColor", "none"],\n    "border-collapse": ["borderCollapse"],\n    "border-color": ["color", "systemColor"],\n    "border-top-color": ["color", "systemColor"],\n    "border-right-color": ["color", "systemColor"],\n    "border-bottom-color": ["color", "systemColor"],\n    "border-left-color": ["color", "systemColor"],\n    "border-spacing": [],\n    "border-style": ["borderStyle"],\n    "border-top-style": ["borderStyle"],\n    "border-right-style": ["borderStyle"],\n    "border-bottom-style": ["borderStyle"],\n    "border-left-style": ["borderStyle"],\n    "border-width": ["thickness"],\n    "border-top-width": ["thickness"],\n    "border-right-width": ["thickness"],\n    "border-bottom-width": ["thickness"],\n    "border-left-width": ["thickness"],\n\n    "bottom": ["auto"],\n    "caption-side": ["captionSide"],\n    "clear": ["clear", "none"],\n    "clip": ["auto"],\n    "color": ["color", "systemColor"],\n    "content": ["content"],\n    "counter-increment": ["none"],\n    "counter-reset": ["none"],\n    "cursor": ["cursor", "none"],\n    "direction": ["direction"],\n    "display": ["display", "none"],\n    "empty-cells": [],\n    "float": ["float", "none"],\n    "font": ["fontStyle", "fontVariant", "fontWeight", "fontFamily"],\n\n    "font-family": ["fontFamily"],\n    "font-size": ["fontSize"],\n    "font-size-adjust": [],\n    "font-stretch": [],\n    "font-style": ["fontStyle"],\n    "font-variant": ["fontVariant"],\n    "font-weight": ["fontWeight"],\n\n    "height": ["auto"],\n    "left": ["auto"],\n    "letter-spacing": [],\n    "line-height": [],\n\n    "list-style": ["listStyleType", "listStylePosition", "none"],\n    "list-style-image": ["none"],\n    "list-style-position": ["listStylePosition"],\n    "list-style-type": ["listStyleType", "none"],\n\n    "margin": [],\n    "margin-top": [],\n    "margin-right": [],\n    "margin-bottom": [],\n    "margin-left": [],\n\n    "marker-offset": ["auto"],\n    "min-height": ["none"],\n    "max-height": ["none"],\n    "min-width": ["none"],\n    "max-width": ["none"],\n\n    "outline": ["borderStyle", "color", "systemColor", "none"],\n    "outline-color": ["color", "systemColor"],\n    "outline-style": ["borderStyle"],\n    "outline-width": [],\n\n    "overflow": ["overflow", "auto"],\n    "overflow-x": ["overflow", "auto"],\n    "overflow-y": ["overflow", "auto"],\n\n    "padding": [],\n    "padding-top": [],\n    "padding-right": [],\n    "padding-bottom": [],\n    "padding-left": [],\n\n    "position": ["position"],\n    "quotes": ["none"],\n    "right": ["auto"],\n    "table-layout": ["tableLayout", "auto"],\n    "text-align": ["textAlign"],\n    "text-decoration": ["textDecoration", "none"],\n    "text-indent": [],\n    "text-shadow": [],\n    "text-transform": ["textTransform", "none"],\n    "top": ["auto"],\n    "unicode-bidi": [],\n    "vertical-align": ["verticalAlign"],\n    "white-space": ["whiteSpace"],\n    "width": ["auto"],\n    "word-spacing": [],\n    "z-index": [],\n\n    "-moz-appearance": ["mozAppearance"],\n    "-moz-border-radius": [],\n    "-moz-border-radius-bottomleft": [],\n    "-moz-border-radius-bottomright": [],\n    "-moz-border-radius-topleft": [],\n    "-moz-border-radius-topright": [],\n    "-moz-border-top-colors": ["color", "systemColor"],\n    "-moz-border-right-colors": ["color", "systemColor"],\n    "-moz-border-bottom-colors": ["color", "systemColor"],\n    "-moz-border-left-colors": ["color", "systemColor"],\n    "-moz-box-align": ["mozBoxAlign"],\n    "-moz-box-direction": ["mozBoxDirection"],\n    "-moz-box-flex": [],\n    "-moz-box-ordinal-group": [],\n    "-moz-box-orient": ["mozBoxOrient"],\n    "-moz-box-pack": ["mozBoxPack"],\n    "-moz-box-sizing": ["mozBoxSizing"],\n    "-moz-opacity": [],\n    "-moz-user-focus": ["userFocus", "none"],\n    "-moz-user-input": ["userInput"],\n    "-moz-user-modify": [],\n    "-moz-user-select": ["userSelect", "none"],\n    "-moz-background-clip": [],\n    "-moz-background-inline-policy": [],\n    "-moz-background-origin": [],\n    "-moz-binding": [],\n    "-moz-column-count": [],\n    "-moz-column-gap": [],\n    "-moz-column-width": [],\n    "-moz-image-region": []\n};\n\nthis.inheritedStyleNames =\n{\n    "border-collapse": 1,\n    "border-spacing": 1,\n    "border-style": 1,\n    "caption-side": 1,\n    "color": 1,\n    "cursor": 1,\n    "direction": 1,\n    "empty-cells": 1,\n    "font": 1,\n    "font-family": 1,\n    "font-size-adjust": 1,\n    "font-size": 1,\n    "font-style": 1,\n    "font-variant": 1,\n    "font-weight": 1,\n    "letter-spacing": 1,\n    "line-height": 1,\n    "list-style": 1,\n    "list-style-image": 1,\n    "list-style-position": 1,\n    "list-style-type": 1,\n    "quotes": 1,\n    "text-align": 1,\n    "text-decoration": 1,\n    "text-indent": 1,\n    "text-shadow": 1,\n    "text-transform": 1,\n    "white-space": 1,\n    "word-spacing": 1\n};\n\nthis.cssKeywords =\n{\n    "appearance":\n    [\n        "button",\n        "button-small",\n        "checkbox",\n        "checkbox-container",\n        "checkbox-small",\n        "dialog",\n        "listbox",\n        "menuitem",\n        "menulist",\n        "menulist-button",\n        "menulist-textfield",\n        "menupopup",\n        "progressbar",\n        "radio",\n        "radio-container",\n        "radio-small",\n        "resizer",\n        "scrollbar",\n        "scrollbarbutton-down",\n        "scrollbarbutton-left",\n        "scrollbarbutton-right",\n        "scrollbarbutton-up",\n        "scrollbartrack-horizontal",\n        "scrollbartrack-vertical",\n        "separator",\n        "statusbar",\n        "tab",\n        "tab-left-edge",\n        "tabpanels",\n        "textfield",\n        "toolbar",\n        "toolbarbutton",\n        "toolbox",\n        "tooltip",\n        "treeheadercell",\n        "treeheadersortarrow",\n        "treeitem",\n        "treetwisty",\n        "treetwistyopen",\n        "treeview",\n        "window"\n    ],\n\n    "systemColor":\n    [\n        "ActiveBorder",\n        "ActiveCaption",\n        "AppWorkspace",\n        "Background",\n        "ButtonFace",\n        "ButtonHighlight",\n        "ButtonShadow",\n        "ButtonText",\n        "CaptionText",\n        "GrayText",\n        "Highlight",\n        "HighlightText",\n        "InactiveBorder",\n        "InactiveCaption",\n        "InactiveCaptionText",\n        "InfoBackground",\n        "InfoText",\n        "Menu",\n        "MenuText",\n        "Scrollbar",\n        "ThreeDDarkShadow",\n        "ThreeDFace",\n        "ThreeDHighlight",\n        "ThreeDLightShadow",\n        "ThreeDShadow",\n        "Window",\n        "WindowFrame",\n        "WindowText",\n        "-moz-field",\n        "-moz-fieldtext",\n        "-moz-workspace",\n        "-moz-visitedhyperlinktext",\n        "-moz-use-text-color"\n    ],\n\n    "color":\n    [\n        "AliceBlue",\n        "AntiqueWhite",\n        "Aqua",\n        "Aquamarine",\n        "Azure",\n        "Beige",\n        "Bisque",\n        "Black",\n        "BlanchedAlmond",\n        "Blue",\n        "BlueViolet",\n        "Brown",\n        "BurlyWood",\n        "CadetBlue",\n        "Chartreuse",\n        "Chocolate",\n        "Coral",\n        "CornflowerBlue",\n        "Cornsilk",\n        "Crimson",\n        "Cyan",\n        "DarkBlue",\n        "DarkCyan",\n        "DarkGoldenRod",\n        "DarkGray",\n        "DarkGreen",\n        "DarkKhaki",\n        "DarkMagenta",\n        "DarkOliveGreen",\n        "DarkOrange",\n        "DarkOrchid",\n        "DarkRed",\n        "DarkSalmon",\n        "DarkSeaGreen",\n        "DarkSlateBlue",\n        "DarkSlateGray",\n        "DarkTurquoise",\n        "DarkViolet",\n        "DeepPink",\n        "DarkSkyBlue",\n        "DimGray",\n        "DodgerBlue",\n        "Feldspar",\n        "FireBrick",\n        "FloralWhite",\n        "ForestGreen",\n        "Fuchsia",\n        "Gainsboro",\n        "GhostWhite",\n        "Gold",\n        "GoldenRod",\n        "Gray",\n        "Green",\n        "GreenYellow",\n        "HoneyDew",\n        "HotPink",\n        "IndianRed",\n        "Indigo",\n        "Ivory",\n        "Khaki",\n        "Lavender",\n        "LavenderBlush",\n        "LawnGreen",\n        "LemonChiffon",\n        "LightBlue",\n        "LightCoral",\n        "LightCyan",\n        "LightGoldenRodYellow",\n        "LightGrey",\n        "LightGreen",\n        "LightPink",\n        "LightSalmon",\n        "LightSeaGreen",\n        "LightSkyBlue",\n        "LightSlateBlue",\n        "LightSlateGray",\n        "LightSteelBlue",\n        "LightYellow",\n        "Lime",\n        "LimeGreen",\n        "Linen",\n        "Magenta",\n        "Maroon",\n        "MediumAquaMarine",\n        "MediumBlue",\n        "MediumOrchid",\n        "MediumPurple",\n        "MediumSeaGreen",\n        "MediumSlateBlue",\n        "MediumSpringGreen",\n        "MediumTurquoise",\n        "MediumVioletRed",\n        "MidnightBlue",\n        "MintCream",\n        "MistyRose",\n        "Moccasin",\n        "NavajoWhite",\n        "Navy",\n        "OldLace",\n        "Olive",\n        "OliveDrab",\n        "Orange",\n        "OrangeRed",\n        "Orchid",\n        "PaleGoldenRod",\n        "PaleGreen",\n        "PaleTurquoise",\n        "PaleVioletRed",\n        "PapayaWhip",\n        "PeachPuff",\n        "Peru",\n        "Pink",\n        "Plum",\n        "PowderBlue",\n        "Purple",\n        "Red",\n        "RosyBrown",\n        "RoyalBlue",\n        "SaddleBrown",\n        "Salmon",\n        "SandyBrown",\n        "SeaGreen",\n        "SeaShell",\n        "Sienna",\n        "Silver",\n        "SkyBlue",\n        "SlateBlue",\n        "SlateGray",\n        "Snow",\n        "SpringGreen",\n        "SteelBlue",\n        "Tan",\n        "Teal",\n        "Thistle",\n        "Tomato",\n        "Turquoise",\n        "Violet",\n        "VioletRed",\n        "Wheat",\n        "White",\n        "WhiteSmoke",\n        "Yellow",\n        "YellowGreen",\n        "transparent",\n        "invert"\n    ],\n\n    "auto":\n    [\n        "auto"\n    ],\n\n    "none":\n    [\n        "none"\n    ],\n\n    "captionSide":\n    [\n        "top",\n        "bottom",\n        "left",\n        "right"\n    ],\n\n    "clear":\n    [\n        "left",\n        "right",\n        "both"\n    ],\n\n    "cursor":\n    [\n        "auto",\n        "cell",\n        "context-menu",\n        "crosshair",\n        "default",\n        "help",\n        "pointer",\n        "progress",\n        "move",\n        "e-resize",\n        "all-scroll",\n        "ne-resize",\n        "nw-resize",\n        "n-resize",\n        "se-resize",\n        "sw-resize",\n        "s-resize",\n        "w-resize",\n        "ew-resize",\n        "ns-resize",\n        "nesw-resize",\n        "nwse-resize",\n        "col-resize",\n        "row-resize",\n        "text",\n        "vertical-text",\n        "wait",\n        "alias",\n        "copy",\n        "move",\n        "no-drop",\n        "not-allowed",\n        "-moz-alias",\n        "-moz-cell",\n        "-moz-copy",\n        "-moz-grab",\n        "-moz-grabbing",\n        "-moz-contextmenu",\n        "-moz-zoom-in",\n        "-moz-zoom-out",\n        "-moz-spinning"\n    ],\n\n    "direction":\n    [\n        "ltr",\n        "rtl"\n    ],\n\n    "bgAttachment":\n    [\n        "scroll",\n        "fixed"\n    ],\n\n    "bgPosition":\n    [\n        "top",\n        "center",\n        "bottom",\n        "left",\n        "right"\n    ],\n\n    "bgRepeat":\n    [\n        "repeat",\n        "repeat-x",\n        "repeat-y",\n        "no-repeat"\n    ],\n\n    "borderStyle":\n    [\n        "hidden",\n        "dotted",\n        "dashed",\n        "solid",\n        "double",\n        "groove",\n        "ridge",\n        "inset",\n        "outset",\n        "-moz-bg-inset",\n        "-moz-bg-outset",\n        "-moz-bg-solid"\n    ],\n\n    "borderCollapse":\n    [\n        "collapse",\n        "separate"\n    ],\n\n    "overflow":\n    [\n        "visible",\n        "hidden",\n        "scroll",\n        "-moz-scrollbars-horizontal",\n        "-moz-scrollbars-none",\n        "-moz-scrollbars-vertical"\n    ],\n\n    "listStyleType":\n    [\n        "disc",\n        "circle",\n        "square",\n        "decimal",\n        "decimal-leading-zero",\n        "lower-roman",\n        "upper-roman",\n        "lower-greek",\n        "lower-alpha",\n        "lower-latin",\n        "upper-alpha",\n        "upper-latin",\n        "hebrew",\n        "armenian",\n        "georgian",\n        "cjk-ideographic",\n        "hiragana",\n        "katakana",\n        "hiragana-iroha",\n        "katakana-iroha",\n        "inherit"\n    ],\n\n    "listStylePosition":\n    [\n        "inside",\n        "outside"\n    ],\n\n    "content":\n    [\n        "open-quote",\n        "close-quote",\n        "no-open-quote",\n        "no-close-quote",\n        "inherit"\n    ],\n\n    "fontStyle":\n    [\n        "normal",\n        "italic",\n        "oblique",\n        "inherit"\n    ],\n\n    "fontVariant":\n    [\n        "normal",\n        "small-caps",\n        "inherit"\n    ],\n\n    "fontWeight":\n    [\n        "normal",\n        "bold",\n        "bolder",\n        "lighter",\n        "inherit"\n    ],\n\n    "fontSize":\n    [\n        "xx-small",\n        "x-small",\n        "small",\n        "medium",\n        "large",\n        "x-large",\n        "xx-large",\n        "smaller",\n        "larger"\n    ],\n\n    "fontFamily":\n    [\n        "Arial",\n        "Comic Sans MS",\n        "Georgia",\n        "Tahoma",\n        "Verdana",\n        "Times New Roman",\n        "Trebuchet MS",\n        "Lucida Grande",\n        "Helvetica",\n        "serif",\n        "sans-serif",\n        "cursive",\n        "fantasy",\n        "monospace",\n        "caption",\n        "icon",\n        "menu",\n        "message-box",\n        "small-caption",\n        "status-bar",\n        "inherit"\n    ],\n\n    "display":\n    [\n        "block",\n        "inline",\n        "inline-block",\n        "list-item",\n        "marker",\n        "run-in",\n        "compact",\n        "table",\n        "inline-table",\n        "table-row-group",\n        "table-column",\n        "table-column-group",\n        "table-header-group",\n        "table-footer-group",\n        "table-row",\n        "table-cell",\n        "table-caption",\n        "-moz-box",\n        "-moz-compact",\n        "-moz-deck",\n        "-moz-grid",\n        "-moz-grid-group",\n        "-moz-grid-line",\n        "-moz-groupbox",\n        "-moz-inline-block",\n        "-moz-inline-box",\n        "-moz-inline-grid",\n        "-moz-inline-stack",\n        "-moz-inline-table",\n        "-moz-marker",\n        "-moz-popup",\n        "-moz-runin",\n        "-moz-stack"\n    ],\n\n    "position":\n    [\n        "static",\n        "relative",\n        "absolute",\n        "fixed",\n        "inherit"\n    ],\n\n    "float":\n    [\n        "left",\n        "right"\n    ],\n\n    "textAlign":\n    [\n        "left",\n        "right",\n        "center",\n        "justify"\n    ],\n\n    "tableLayout":\n    [\n        "fixed"\n    ],\n\n    "textDecoration":\n    [\n        "underline",\n        "overline",\n        "line-through",\n        "blink"\n    ],\n\n    "textTransform":\n    [\n        "capitalize",\n        "lowercase",\n        "uppercase",\n        "inherit"\n    ],\n\n    "unicodeBidi":\n    [\n        "normal",\n        "embed",\n        "bidi-override"\n    ],\n\n    "whiteSpace":\n    [\n        "normal",\n        "pre",\n        "nowrap"\n    ],\n\n    "verticalAlign":\n    [\n        "baseline",\n        "sub",\n        "super",\n        "top",\n        "text-top",\n        "middle",\n        "bottom",\n        "text-bottom",\n        "inherit"\n    ],\n\n    "thickness":\n    [\n        "thin",\n        "medium",\n        "thick"\n    ],\n\n    "userFocus":\n    [\n        "ignore",\n        "normal"\n    ],\n\n    "userInput":\n    [\n        "disabled",\n        "enabled"\n    ],\n\n    "userSelect":\n    [\n        "normal"\n    ],\n\n    "mozBoxSizing":\n    [\n        "content-box",\n        "padding-box",\n        "border-box"\n    ],\n\n    "mozBoxAlign":\n    [\n        "start",\n        "center",\n        "end",\n        "baseline",\n        "stretch"\n    ],\n\n    "mozBoxDirection":\n    [\n        "normal",\n        "reverse"\n    ],\n\n    "mozBoxOrient":\n    [\n        "horizontal",\n        "vertical"\n    ],\n\n    "mozBoxPack":\n    [\n        "start",\n        "center",\n        "end"\n    ]\n};\n\nthis.nonEditableTags =\n{\n    "HTML": 1,\n    "HEAD": 1,\n    "html": 1,\n    "head": 1\n};\n\nthis.innerEditableTags =\n{\n    "BODY": 1,\n    "body": 1\n};\n\nthis.selfClosingTags =\n{ // End tags for void elements are forbidden http://wiki.whatwg.org/wiki/HTML_vs._XHTML\n    "meta": 1,\n    "link": 1,\n    "area": 1,\n    "base": 1,\n    "col": 1,\n    "input": 1,\n    "img": 1,\n    "br": 1,\n    "hr": 1,\n    "param":1,\n    "embed":1\n};\n\nvar invisibleTags = this.invisibleTags =\n{\n    "HTML": 1,\n    "HEAD": 1,\n    "TITLE": 1,\n    "META": 1,\n    "LINK": 1,\n    "STYLE": 1,\n    "SCRIPT": 1,\n    "NOSCRIPT": 1,\n    "BR": 1,\n    "PARAM": 1,\n    "COL": 1,\n\n    "html": 1,\n    "head": 1,\n    "title": 1,\n    "meta": 1,\n    "link": 1,\n    "style": 1,\n    "script": 1,\n    "noscript": 1,\n    "br": 1,\n    "param": 1,\n    "col": 1\n    /*\n    "window": 1,\n    "browser": 1,\n    "frame": 1,\n    "tabbrowser": 1,\n    "WINDOW": 1,\n    "BROWSER": 1,\n    "FRAME": 1,\n    "TABBROWSER": 1,\n    */\n};\n\n\nif (typeof KeyEvent == "undefined") {\n    this.KeyEvent = {\n        DOM_VK_CANCEL: 3,\n        DOM_VK_HELP: 6,\n        DOM_VK_BACK_SPACE: 8,\n        DOM_VK_TAB: 9,\n        DOM_VK_CLEAR: 12,\n        DOM_VK_RETURN: 13,\n        DOM_VK_ENTER: 14,\n        DOM_VK_SHIFT: 16,\n        DOM_VK_CONTROL: 17,\n        DOM_VK_ALT: 18,\n        DOM_VK_PAUSE: 19,\n        DOM_VK_CAPS_LOCK: 20,\n        DOM_VK_ESCAPE: 27,\n        DOM_VK_SPACE: 32,\n        DOM_VK_PAGE_UP: 33,\n        DOM_VK_PAGE_DOWN: 34,\n        DOM_VK_END: 35,\n        DOM_VK_HOME: 36,\n        DOM_VK_LEFT: 37,\n        DOM_VK_UP: 38,\n        DOM_VK_RIGHT: 39,\n        DOM_VK_DOWN: 40,\n        DOM_VK_PRINTSCREEN: 44,\n        DOM_VK_INSERT: 45,\n        DOM_VK_DELETE: 46,\n        DOM_VK_0: 48,\n        DOM_VK_1: 49,\n        DOM_VK_2: 50,\n        DOM_VK_3: 51,\n        DOM_VK_4: 52,\n        DOM_VK_5: 53,\n        DOM_VK_6: 54,\n        DOM_VK_7: 55,\n        DOM_VK_8: 56,\n        DOM_VK_9: 57,\n        DOM_VK_SEMICOLON: 59,\n        DOM_VK_EQUALS: 61,\n        DOM_VK_A: 65,\n        DOM_VK_B: 66,\n        DOM_VK_C: 67,\n        DOM_VK_D: 68,\n        DOM_VK_E: 69,\n        DOM_VK_F: 70,\n        DOM_VK_G: 71,\n        DOM_VK_H: 72,\n        DOM_VK_I: 73,\n        DOM_VK_J: 74,\n        DOM_VK_K: 75,\n        DOM_VK_L: 76,\n        DOM_VK_M: 77,\n        DOM_VK_N: 78,\n        DOM_VK_O: 79,\n        DOM_VK_P: 80,\n        DOM_VK_Q: 81,\n        DOM_VK_R: 82,\n        DOM_VK_S: 83,\n        DOM_VK_T: 84,\n        DOM_VK_U: 85,\n        DOM_VK_V: 86,\n        DOM_VK_W: 87,\n        DOM_VK_X: 88,\n        DOM_VK_Y: 89,\n        DOM_VK_Z: 90,\n        DOM_VK_CONTEXT_MENU: 93,\n        DOM_VK_NUMPAD0: 96,\n        DOM_VK_NUMPAD1: 97,\n        DOM_VK_NUMPAD2: 98,\n        DOM_VK_NUMPAD3: 99,\n        DOM_VK_NUMPAD4: 100,\n        DOM_VK_NUMPAD5: 101,\n        DOM_VK_NUMPAD6: 102,\n        DOM_VK_NUMPAD7: 103,\n        DOM_VK_NUMPAD8: 104,\n        DOM_VK_NUMPAD9: 105,\n        DOM_VK_MULTIPLY: 106,\n        DOM_VK_ADD: 107,\n        DOM_VK_SEPARATOR: 108,\n        DOM_VK_SUBTRACT: 109,\n        DOM_VK_DECIMAL: 110,\n        DOM_VK_DIVIDE: 111,\n        DOM_VK_F1: 112,\n        DOM_VK_F2: 113,\n        DOM_VK_F3: 114,\n        DOM_VK_F4: 115,\n        DOM_VK_F5: 116,\n        DOM_VK_F6: 117,\n        DOM_VK_F7: 118,\n        DOM_VK_F8: 119,\n        DOM_VK_F9: 120,\n        DOM_VK_F10: 121,\n        DOM_VK_F11: 122,\n        DOM_VK_F12: 123,\n        DOM_VK_F13: 124,\n        DOM_VK_F14: 125,\n        DOM_VK_F15: 126,\n        DOM_VK_F16: 127,\n        DOM_VK_F17: 128,\n        DOM_VK_F18: 129,\n        DOM_VK_F19: 130,\n        DOM_VK_F20: 131,\n        DOM_VK_F21: 132,\n        DOM_VK_F22: 133,\n        DOM_VK_F23: 134,\n        DOM_VK_F24: 135,\n        DOM_VK_NUM_LOCK: 144,\n        DOM_VK_SCROLL_LOCK: 145,\n        DOM_VK_COMMA: 188,\n        DOM_VK_PERIOD: 190,\n        DOM_VK_SLASH: 191,\n        DOM_VK_BACK_QUOTE: 192,\n        DOM_VK_OPEN_BRACKET: 219,\n        DOM_VK_BACK_SLASH: 220,\n        DOM_VK_CLOSE_BRACKET: 221,\n        DOM_VK_QUOTE: 222,\n        DOM_VK_META: 224\n    };\n}\n\n\n// ************************************************************************************************\n// Ajax\n\n/**\n * @namespace\n */\nthis.Ajax =\n{\n\n    requests: [],\n    transport: null,\n    states: ["Uninitialized","Loading","Loaded","Interactive","Complete"],\n\n    initialize: function()\n    {\n        this.transport = FBL.getNativeXHRObject();\n    },\n\n    getXHRObject: function()\n    {\n        var xhrObj = false;\n        try\n        {\n            xhrObj = new XMLHttpRequest();\n        }\n        catch(e)\n        {\n            var progid = [\n                    "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0",\n                    "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"\n                ];\n\n            for ( var i=0; i < progid.length; ++i ) {\n                try\n                {\n                    xhrObj = new ActiveXObject(progid[i]);\n                }\n                catch(e)\n                {\n                    continue;\n                }\n                break;\n            }\n        }\n        finally\n        {\n            return xhrObj;\n        }\n    },\n\n\n    /**\n     * Create a AJAX request.\n     *\n     * @name request\n     * @param {Object}   options               request options\n     * @param {String}   options.url           URL to be requested\n     * @param {String}   options.type          Request type ("get" ou "post"). Default is "get".\n     * @param {Boolean}  options.async         Asynchronous flag. Default is "true".\n     * @param {String}   options.dataType      Data type ("text", "html", "xml" or "json"). Default is "text".\n     * @param {String}   options.contentType   Content-type of the data being sent. Default is "application/x-www-form-urlencoded".\n     * @param {Function} options.onLoading     onLoading callback\n     * @param {Function} options.onLoaded      onLoaded callback\n     * @param {Function} options.onInteractive onInteractive callback\n     * @param {Function} options.onComplete    onComplete callback\n     * @param {Function} options.onUpdate      onUpdate callback\n     * @param {Function} options.onSuccess     onSuccess callback\n     * @param {Function} options.onFailure     onFailure callback\n     */\n    request: function(options)\n    {\n        // process options\n        var o = FBL.extend(\n                {\n                    // default values\n                    type: "get",\n                    async: true,\n                    dataType: "text",\n                    contentType: "application/x-www-form-urlencoded"\n                },\n                options || {}\n            );\n\n        this.requests.push(o);\n\n        var s = this.getState();\n        if (s == "Uninitialized" || s == "Complete" || s == "Loaded")\n            this.sendRequest();\n    },\n\n    serialize: function(data)\n    {\n        var r = [""], rl = 0;\n        if (data) {\n            if (typeof data == "string")  r[rl++] = data;\n\n            else if (data.innerHTML && data.elements) {\n                for (var i=0,el,l=(el=data.elements).length; i < l; i++)\n                    if (el[i].name) {\n                        r[rl++] = encodeURIComponent(el[i].name);\n                        r[rl++] = "=";\n                        r[rl++] = encodeURIComponent(el[i].value);\n                        r[rl++] = "&";\n                    }\n\n            } else\n                for(var param in data) {\n                    r[rl++] = encodeURIComponent(param);\n                    r[rl++] = "=";\n                    r[rl++] = encodeURIComponent(data[param]);\n                    r[rl++] = "&";\n                }\n        }\n        return r.join("").replace(/&$/, "");\n    },\n\n    sendRequest: function()\n    {\n        var t = FBL.Ajax.transport, r = FBL.Ajax.requests.shift(), data;\n\n        // open XHR object\n        t.open(r.type, r.url, r.async);\n\n        //setRequestHeaders();\n\n        // indicates that it is a XHR request to the server\n        t.setRequestHeader("X-Requested-With", "XMLHttpRequest");\n\n        // if data is being sent, sets the appropriate content-type\n        if (data = FBL.Ajax.serialize(r.data))\n            t.setRequestHeader("Content-Type", r.contentType);\n\n        /** @ignore */\n        // onreadystatechange handler\n        t.onreadystatechange = function()\n        {\n            FBL.Ajax.onStateChange(r);\n        };\n\n        // send the request\n        t.send(data);\n    },\n\n    /**\n     * Handles the state change\n     */\n    onStateChange: function(options)\n    {\n        var fn, o = options, t = this.transport;\n        var state = this.getState(t);\n\n        if (fn = o["on" + state]) fn(this.getResponse(o), o);\n\n        if (state == "Complete")\n        {\n            var success = t.status == 200, response = this.getResponse(o);\n\n            if (fn = o["onUpdate"])\n              fn(response, o);\n\n            if (fn = o["on" + (success ? "Success" : "Failure")])\n              fn(response, o);\n\n            t.onreadystatechange = FBL.emptyFn;\n\n            if (this.requests.length > 0)\n                setTimeout(this.sendRequest, 10);\n        }\n    },\n\n    /**\n     * gets the appropriate response value according the type\n     */\n    getResponse: function(options)\n    {\n        var t = this.transport, type = options.dataType;\n\n        if      (t.status != 200) return t.statusText;\n        else if (type == "text")  return t.responseText;\n        else if (type == "html")  return t.responseText;\n        else if (type == "xml")   return t.responseXML;\n        else if (type == "json")  return eval("(" + t.responseText + ")");\n    },\n\n    /**\n     * returns the current state of the XHR object\n     */\n    getState: function()\n    {\n        return this.states[this.transport.readyState];\n    }\n\n};\n\n\n// ************************************************************************************************\n// Cookie, from http://www.quirksmode.org/js/cookies.html\n\nthis.createCookie = function(name,value,days)\n{\n    if (\'cookie\' in document)\n    {\n        if (days)\n        {\n            var date = new Date();\n            date.setTime(date.getTime()+(days*24*60*60*1000));\n            var expires = "; expires="+date.toGMTString();\n        }\n        else\n            var expires = "";\n\n        document.cookie = name+"="+value+expires+"; path=/";\n    }\n};\n\nthis.readCookie = function (name)\n{\n    if (\'cookie\' in document)\n    {\n        var nameEQ = name + "=";\n        var ca = document.cookie.split(\';\');\n\n        for(var i=0; i < ca.length; i++)\n        {\n            var c = ca[i];\n            while (c.charAt(0)==\' \') c = c.substring(1,c.length);\n            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);\n        }\n    }\n\n    return null;\n};\n\nthis.removeCookie = function(name)\n{\n    this.createCookie(name, "", -1);\n};\n\n\n// ************************************************************************************************\n// http://www.mister-pixel.com/#Content__state=is_that_simple\nvar fixIE6BackgroundImageCache = function(doc)\n{\n    doc = doc || document;\n    try\n    {\n        doc.execCommand("BackgroundImageCache", false, true);\n    }\n    catch(E)\n    {\n\n    }\n};\n\n// ************************************************************************************************\n// calculatePixelsPerInch\n\nvar resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";\n\nvar calculatePixelsPerInch = function calculatePixelsPerInch(doc, body)\n{\n    var inch = FBL.createGlobalElement("div");\n    inch.style.cssText = resetStyle + "width:1in; height:1in; position:absolute; top:-1234px; left:-1234px;";\n    body.appendChild(inch);\n\n    FBL.pixelsPerInch = {\n        x: inch.offsetWidth,\n        y: inch.offsetHeight\n    };\n\n    body.removeChild(inch);\n};\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.SourceLink = function(url, line, type, object, instance)\n{\n    this.href = url;\n    this.instance = instance;\n    this.line = line;\n    this.type = type;\n    this.object = object;\n};\n\nthis.SourceLink.prototype =\n{\n    toString: function()\n    {\n        return this.href;\n    },\n    toJSON: function() // until 3.1...\n    {\n        return "{\\"href\\":\\""+this.href+"\\", "+\n            (this.line?("\\"line\\":"+this.line+","):"")+\n            (this.type?(" \\"type\\":\\""+this.type+"\\","):"")+\n                    "}";\n    }\n\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nthis.SourceText = function(lines, owner)\n{\n    this.lines = lines;\n    this.owner = owner;\n};\n\nthis.SourceText.getLineAsHTML = function(lineNo)\n{\n    return escapeForSourceLine(this.lines[lineNo-1]);\n};\n\n\n// ************************************************************************************************\n}).apply(FBL);\n\n/* See license.txt for terms of usage */\n\nFBL.ns( /** @scope s_i18n */ function() { with (FBL) {\n// ************************************************************************************************\n\n// TODO: xxxpedro localization\nvar oSTR =\n{\n    "NoMembersWarning": "There are no properties to show for this object.",\n\n    "EmptyStyleSheet": "There are no rules in this stylesheet.",\n    "EmptyElementCSS": "This element has no style rules.",\n    "AccessRestricted": "Access to restricted URI denied.",\n\n    "net.label.Parameters": "Parameters",\n    "net.label.Source": "Source",\n    "URLParameters": "Params",\n\n    "EditStyle": "Edit Element Style...",\n    "NewRule": "New Rule...",\n\n    "NewProp": "New Property...",\n    "EditProp": \'Edit "%s"\',\n    "DeleteProp": \'Delete "%s"\',\n    "DisableProp": \'Disable "%s"\'\n};\n\n// ************************************************************************************************\n\nFBL.$STR = function(name)\n{\n    return oSTR.hasOwnProperty(name) ? oSTR[name] : name;\n};\n\nFBL.$STRF = function(name, args)\n{\n    if (!oSTR.hasOwnProperty(name)) return name;\n\n    var format = oSTR[name];\n    var objIndex = 0;\n\n    var parts = parseFormat(format);\n    var trialIndex = objIndex;\n    var objects = args;\n\n    for (var i= 0; i < parts.length; i++)\n    {\n        var part = parts[i];\n        if (part && typeof(part) == "object")\n        {\n            if (++trialIndex > objects.length)  // then too few parameters for format, assume unformatted.\n            {\n                format = "";\n                objIndex = -1;\n                parts.length = 0;\n                break;\n            }\n        }\n\n    }\n\n    var result = [];\n    for (var i = 0; i < parts.length; ++i)\n    {\n        var part = parts[i];\n        if (part && typeof(part) == "object")\n        {\n            result.push(""+args.shift());\n        }\n        else\n            result.push(part);\n    }\n\n    return result.join("");\n};\n\n// ************************************************************************************************\n\nvar parseFormat = function parseFormat(format)\n{\n    var parts = [];\n    if (format.length <= 0)\n        return parts;\n\n    var reg = /((^%|.%)(\\d+)?(\\.)([a-zA-Z]))|((^%|.%)([a-zA-Z]))/;\n    for (var m = reg.exec(format); m; m = reg.exec(format))\n    {\n        if (m[0].substr(0, 2) == "%%")\n        {\n            parts.push(format.substr(0, m.index));\n            parts.push(m[0].substr(1));\n        }\n        else\n        {\n            var type = m[8] ? m[8] : m[5];\n            var precision = m[3] ? parseInt(m[3]) : (m[4] == "." ? -1 : 0);\n\n            var rep = null;\n            switch (type)\n            {\n                case "s":\n                    rep = FirebugReps.Text;\n                    break;\n                case "f":\n                case "i":\n                case "d":\n                    rep = FirebugReps.Number;\n                    break;\n                case "o":\n                    rep = null;\n                    break;\n            }\n\n            parts.push(format.substr(0, m[0][0] == "%" ? m.index : m.index+1));\n            parts.push({rep: rep, precision: precision, type: ("%" + type)});\n        }\n\n        format = format.substr(m.index+m[0].length);\n    }\n\n    parts.push(format);\n    return parts;\n};\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns( /** @scope s_firebug */ function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Globals\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Internals\n\nvar modules = [];\nvar panelTypes = [];\nvar panelTypeMap = {};\nvar reps = [];\n\nvar parentPanelMap = {};\n\n\n// ************************************************************************************************\n// Firebug\n\n/**\n * @namespace describe Firebug\n * @exports FBL.Firebug as Firebug\n */\nFBL.Firebug =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    version:  "Firebug Lite 1.4.0",\n    revision: "$Revision$",\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    modules: modules,\n    panelTypes: panelTypes,\n    panelTypeMap: panelTypeMap,\n    reps: reps,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Initialization\n\n    initialize: function()\n    {\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.initialize", "initializing application");\n\n        Firebug.browser = new Context(Env.browser);\n        Firebug.context = Firebug.browser;\n\n        Firebug.loadPrefs();\n        Firebug.context.persistedState.isOpen = false;\n\n        // Document must be cached before chrome initialization\n        cacheDocument();\n\n        if (Firebug.Inspector && Firebug.Inspector.create)\n            Firebug.Inspector.create();\n\n        if (FBL.CssAnalyzer && FBL.CssAnalyzer.processAllStyleSheets)\n            FBL.CssAnalyzer.processAllStyleSheets(Firebug.browser.document);\n\n        FirebugChrome.initialize();\n\n        dispatch(modules, "initialize", []);\n\n        if (Firebug.disableResourceFetching)\n            Firebug.Console.logFormatted(["Some Firebug Lite features are not working because " +\n            \t\t"resource fetching is disabled. To enabled it set the Firebug Lite option " +\n            \t\t"\\"disableResourceFetching\\" to \\"false\\". More info at " +\n            \t\t"http://getfirebug.com/firebuglite#Options"],\n            \t\tFirebug.context, "warn");\n\n        if (Env.onLoad)\n        {\n            var onLoad = Env.onLoad;\n            delete Env.onLoad;\n\n            setTimeout(onLoad, 200);\n        }\n    },\n\n    shutdown: function()\n    {\n        if (Firebug.saveCookies)\n            Firebug.savePrefs();\n\n        if (Firebug.Inspector)\n            Firebug.Inspector.destroy();\n\n        dispatch(modules, "shutdown", []);\n\n        var chromeMap = FirebugChrome.chromeMap;\n\n        for (var name in chromeMap)\n        {\n            if (chromeMap.hasOwnProperty(name))\n            {\n                try\n                {\n                    chromeMap[name].destroy();\n                }\n                catch(E)\n                {\n                    if (FBTrace.DBG_ERRORS) FBTrace.sysout("chrome.destroy() failed to: " + name);\n                }\n            }\n        }\n\n        Firebug.Lite.Cache.Element.clear();\n        Firebug.Lite.Cache.StyleSheet.clear();\n\n        Firebug.browser = null;\n        Firebug.context = null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Registration\n\n    registerModule: function()\n    {\n        modules.push.apply(modules, arguments);\n\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.registerModule");\n    },\n\n    registerPanel: function()\n    {\n        panelTypes.push.apply(panelTypes, arguments);\n\n        for (var i = 0, panelType; panelType = arguments[i]; ++i)\n        {\n            panelTypeMap[panelType.prototype.name] = arguments[i];\n\n            if (panelType.prototype.parentPanel)\n                parentPanelMap[panelType.prototype.parentPanel] = 1;\n        }\n\n        if (FBTrace.DBG_INITIALIZE)\n            for (var i = 0; i < arguments.length; ++i)\n                FBTrace.sysout("Firebug.registerPanel", arguments[i].prototype.name);\n    },\n\n    registerRep: function()\n    {\n        reps.push.apply(reps, arguments);\n    },\n\n    unregisterRep: function()\n    {\n        for (var i = 0; i < arguments.length; ++i)\n            remove(reps, arguments[i]);\n    },\n\n    setDefaultReps: function(funcRep, rep)\n    {\n        FBL.defaultRep = rep;\n        FBL.defaultFuncRep = funcRep;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Reps\n\n    getRep: function(object)\n    {\n        var type = typeof object;\n        if (isIE && isFunction(object))\n            type = "function";\n\n        for (var i = 0; i < reps.length; ++i)\n        {\n            var rep = reps[i];\n            try\n            {\n                if (rep.supportsObject(object, type))\n                {\n                    if (FBTrace.DBG_DOM)\n                        FBTrace.sysout("getRep type: "+type+" object: "+object, rep);\n                    return rep;\n                }\n            }\n            catch (exc)\n            {\n                if (FBTrace.DBG_ERRORS)\n                {\n                    FBTrace.sysout("firebug.getRep FAILS: ", exc.message || exc);\n                    FBTrace.sysout("firebug.getRep reps["+i+"/"+reps.length+"]: Rep="+reps[i].className);\n                    // TODO: xxxpedro add trace to FBTrace logs like in Firebug\n                    //firebug.trace();\n                }\n            }\n        }\n\n        return (type == \'function\') ? defaultFuncRep : defaultRep;\n    },\n\n    getRepObject: function(node)\n    {\n        var target = null;\n        for (var child = node; child; child = child.parentNode)\n        {\n            if (hasClass(child, "repTarget"))\n                target = child;\n\n            if (child.repObject)\n            {\n                if (!target && hasClass(child, "repIgnore"))\n                    break;\n                else\n                    return child.repObject;\n            }\n        }\n    },\n\n    getRepNode: function(node)\n    {\n        for (var child = node; child; child = child.parentNode)\n        {\n            if (child.repObject)\n                return child;\n        }\n    },\n\n    getElementByRepObject: function(element, object)\n    {\n        for (var child = element.firstChild; child; child = child.nextSibling)\n        {\n            if (child.repObject == object)\n                return child;\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Preferences\n\n    getPref: function(name)\n    {\n        return Firebug[name];\n    },\n\n    setPref: function(name, value)\n    {\n        Firebug[name] = value;\n\n        Firebug.savePrefs();\n    },\n\n    setPrefs: function(prefs)\n    {\n        for (var name in prefs)\n        {\n            if (prefs.hasOwnProperty(name))\n                Firebug[name] = prefs[name];\n        }\n\n        Firebug.savePrefs();\n    },\n\n    restorePrefs: function()\n    {\n        var Options = Env.DefaultOptions;\n\n        for (var name in Options)\n        {\n            Firebug[name] = Options[name];\n        }\n    },\n\n    loadPrefs: function()\n    {\n        this.restorePrefs();\n\n        var prefs = Store.get("FirebugLite") || {};\n        var options = prefs.options;\n        var persistedState = prefs.persistedState || FBL.defaultPersistedState;\n\n        for (var name in options)\n        {\n            if (options.hasOwnProperty(name))\n                Firebug[name] = options[name];\n        }\n\n        if (Firebug.context && persistedState)\n            Firebug.context.persistedState = persistedState;\n    },\n\n    savePrefs: function()\n    {\n        var prefs = {\n            options: {}\n        };\n\n        var EnvOptions = Env.Options;\n        var options = prefs.options;\n        for (var name in EnvOptions)\n        {\n            if (EnvOptions.hasOwnProperty(name))\n            {\n                options[name] = Firebug[name];\n            }\n        }\n\n        var persistedState = Firebug.context.persistedState;\n        if (!persistedState)\n        {\n            persistedState = Firebug.context.persistedState = FBL.defaultPersistedState;\n        }\n\n        prefs.persistedState = persistedState;\n\n        Store.set("FirebugLite", prefs);\n    },\n\n    erasePrefs: function()\n    {\n        Store.remove("FirebugLite");\n        this.restorePrefs();\n    }\n};\n\nFirebug.restorePrefs();\n\n// xxxpedro should we remove this?\nwindow.Firebug = FBL.Firebug;\n\nif (!Env.Options.enablePersistent ||\n     Env.Options.enablePersistent && Env.isChromeContext ||\n     Env.isDebugMode)\n        Env.browser.window.Firebug = FBL.Firebug;\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Other methods\n\nFBL.cacheDocument = function cacheDocument()\n{\n    var ElementCache = Firebug.Lite.Cache.Element;\n    var els = Firebug.browser.document.getElementsByTagName("*");\n    for (var i=0, l=els.length, el; i<l; i++)\n    {\n        el = els[i];\n        ElementCache(el);\n    }\n};\n\n// ************************************************************************************************\n\n/**\n * @class\n *\n * Support for listeners registration. This object also extended by Firebug.Module so,\n * all modules supports listening automatically. Notice that array of listeners\n * is created for each intance of a module within initialize method. Thus all derived\n * module classes must ensure that Firebug.Module.initialize method is called for the\n * super class.\n */\nFirebug.Listener = function()\n{\n    // The array is created when the first listeners is added.\n    // It can\'t be created here since derived objects would share\n    // the same array.\n    this.fbListeners = null;\n};\n\nFirebug.Listener.prototype =\n{\n    addListener: function(listener)\n    {\n        if (!this.fbListeners)\n            this.fbListeners = []; // delay the creation until the objects are created so \'this\' causes new array for each module\n\n        this.fbListeners.push(listener);\n    },\n\n    removeListener: function(listener)\n    {\n        remove(this.fbListeners, listener);  // if this.fbListeners is null, remove is being called with no add\n    }\n};\n\n// ************************************************************************************************\n\n\n// ************************************************************************************************\n// Module\n\n/**\n * @module Base class for all modules. Every derived module object must be registered using\n * <code>Firebug.registerModule</code> method. There is always one instance of a module object\n * per browser window.\n * @extends Firebug.Listener\n */\nFirebug.Module = extend(new Firebug.Listener(),\n/** @extend Firebug.Module */\n{\n    /**\n     * Called when the window is opened.\n     */\n    initialize: function()\n    {\n    },\n\n    /**\n     * Called when the window is closed.\n     */\n    shutdown: function()\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    /**\n     * Called when a new context is created but before the page is loaded.\n     */\n    initContext: function(context)\n    {\n    },\n\n    /**\n     * Called after a context is detached to a separate window;\n     */\n    reattachContext: function(browser, context)\n    {\n    },\n\n    /**\n     * Called when a context is destroyed. Module may store info on persistedState for reloaded pages.\n     */\n    destroyContext: function(context, persistedState)\n    {\n    },\n\n    // Called when a FF tab is create or activated (user changes FF tab)\n    // Called after context is created or with context == null (to abort?)\n    showContext: function(browser, context)\n    {\n    },\n\n    /**\n     * Called after a context\'s page gets DOMContentLoaded\n     */\n    loadedContext: function(context)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    showPanel: function(browser, panel)\n    {\n    },\n\n    showSidePanel: function(browser, panel)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    updateOption: function(name, value)\n    {\n    },\n\n    getObjectByURL: function(context, url)\n    {\n    }\n});\n\n// ************************************************************************************************\n// Panel\n\n/**\n * @panel Base class for all panels. Every derived panel must define a constructor and\n * register with "Firebug.registerPanel" method. An instance of the panel\n * object is created by the framework for each browser tab where Firebug is activated.\n */\nFirebug.Panel =\n{\n    name: "HelloWorld",\n    title: "Hello World!",\n\n    parentPanel: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    options: {\n        hasCommandLine: false,\n        hasStatusBar: false,\n        hasToolButtons: false,\n\n        // Pre-rendered panels are those included in the skin file (firebug.html)\n        isPreRendered: false,\n        innerHTMLSync: false\n\n        /*\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // To be used by external extensions\n        panelHTML: "",\n        panelCSS: "",\n\n        toolButtonsHTML: ""\n        /**/\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    tabNode: null,\n    panelNode: null,\n    sidePanelNode: null,\n    statusBarNode: null,\n    toolButtonsNode: null,\n\n    panelBarNode: null,\n\n    sidePanelBarBoxNode: null,\n    sidePanelBarNode: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    sidePanelBar: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    searchable: false,\n    editable: true,\n    order: 2147483647,\n    statusSeparator: "<",\n\n    create: function(context, doc)\n    {\n        this.hasSidePanel = parentPanelMap.hasOwnProperty(this.name);\n\n        this.panelBarNode = $("fbPanelBar1");\n        this.sidePanelBarBoxNode = $("fbPanelBar2");\n\n        if (this.hasSidePanel)\n        {\n            this.sidePanelBar = extend({}, PanelBar);\n            this.sidePanelBar.create(this);\n        }\n\n        var options = this.options = extend(Firebug.Panel.options, this.options);\n        var panelId = "fb" + this.name;\n\n        if (options.isPreRendered)\n        {\n            this.panelNode = $(panelId);\n\n            this.tabNode = $(panelId + "Tab");\n            this.tabNode.style.display = "block";\n\n            if (options.hasToolButtons)\n            {\n                this.toolButtonsNode = $(panelId + "Buttons");\n            }\n\n            if (options.hasStatusBar)\n            {\n                this.statusBarBox = $("fbStatusBarBox");\n                this.statusBarNode = $(panelId + "StatusBar");\n            }\n        }\n        else\n        {\n            var containerSufix = this.parentPanel ? "2" : "1";\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            // Create Panel\n            var panelNode = this.panelNode = createElement("div", {\n                id: panelId,\n                className: "fbPanel"\n            });\n\n            $("fbPanel" + containerSufix).appendChild(panelNode);\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            // Create Panel Tab\n            var tabHTML = \'<span class="fbTabL"></span><span class="fbTabText">\' +\n                    this.title + \'</span><span class="fbTabR"></span>\';\n\n            var tabNode = this.tabNode = createElement("a", {\n                id: panelId + "Tab",\n                className: "fbTab fbHover",\n                innerHTML: tabHTML\n            });\n\n            if (isIE6)\n            {\n                tabNode.href = "javascript:void(0)";\n            }\n\n            var panelBarNode = this.parentPanel ?\n                    Firebug.chrome.getPanel(this.parentPanel).sidePanelBarNode :\n                    this.panelBarNode;\n\n            panelBarNode.appendChild(tabNode);\n            tabNode.style.display = "block";\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            // create ToolButtons\n            if (options.hasToolButtons)\n            {\n                this.toolButtonsNode = createElement("span", {\n                    id: panelId + "Buttons",\n                    className: "fbToolbarButtons"\n                });\n\n                $("fbToolbarButtons").appendChild(this.toolButtonsNode);\n            }\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            // create StatusBar\n            if (options.hasStatusBar)\n            {\n                this.statusBarBox = $("fbStatusBarBox");\n\n                this.statusBarNode = createElement("span", {\n                    id: panelId + "StatusBar",\n                    className: "fbToolbarButtons fbStatusBar"\n                });\n\n                this.statusBarBox.appendChild(this.statusBarNode);\n            }\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            // create SidePanel\n        }\n\n        this.containerNode = this.panelNode.parentNode;\n\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.Panel.create", this.name);\n\n        // xxxpedro contextMenu\n        this.onContextMenu = bind(this.onContextMenu, this);\n\n        /*\n        this.context = context;\n        this.document = doc;\n\n        this.panelNode = doc.createElement("div");\n        this.panelNode.ownerPanel = this;\n\n        setClass(this.panelNode, "panelNode panelNode-"+this.name+" contextUID="+context.uid);\n        doc.body.appendChild(this.panelNode);\n\n        if (FBTrace.DBG_INITIALIZE)\n            FBTrace.sysout("firebug.initialize panelNode for "+this.name+"\\n");\n\n        this.initializeNode(this.panelNode);\n        /**/\n    },\n\n    destroy: function(state) // Panel may store info on state\n    {\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.Panel.destroy", this.name);\n\n        if (this.hasSidePanel)\n        {\n            this.sidePanelBar.destroy();\n            this.sidePanelBar = null;\n        }\n\n        this.options = null;\n        this.name = null;\n        this.parentPanel = null;\n\n        this.tabNode = null;\n        this.panelNode = null;\n        this.containerNode = null;\n\n        this.toolButtonsNode = null;\n        this.statusBarBox = null;\n        this.statusBarNode = null;\n\n        //if (this.panelNode)\n        //    delete this.panelNode.ownerPanel;\n\n        //this.destroyNode();\n    },\n\n    initialize: function()\n    {\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.Panel.initialize", this.name);\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        if (this.hasSidePanel)\n        {\n            this.sidePanelBar.initialize();\n        }\n\n        var options = this.options = extend(Firebug.Panel.options, this.options);\n        var panelId = "fb" + this.name;\n\n        this.panelNode = $(panelId);\n\n        this.tabNode = $(panelId + "Tab");\n        this.tabNode.style.display = "block";\n\n        if (options.hasStatusBar)\n        {\n            this.statusBarBox = $("fbStatusBarBox");\n            this.statusBarNode = $(panelId + "StatusBar");\n        }\n\n        if (options.hasToolButtons)\n        {\n            this.toolButtonsNode = $(panelId + "Buttons");\n        }\n\n        this.containerNode = this.panelNode.parentNode;\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // restore persistent state\n        this.containerNode.scrollTop = this.lastScrollTop;\n\n        // xxxpedro contextMenu\n        addEvent(this.containerNode, "contextmenu", this.onContextMenu);\n\n\n        /// TODO: xxxpedro infoTip Hack\n        Firebug.chrome.currentPanel =\n                Firebug.chrome.selectedPanel && Firebug.chrome.selectedPanel.sidePanelBar ?\n                Firebug.chrome.selectedPanel.sidePanelBar.selectedPanel :\n                Firebug.chrome.selectedPanel;\n\n        Firebug.showInfoTips = true;\n        if (Firebug.InfoTip)\n            Firebug.InfoTip.initializeBrowser(Firebug.chrome);\n    },\n\n    shutdown: function()\n    {\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.Panel.shutdown", this.name);\n\n        /// TODO: xxxpedro infoTip Hack\n        if (Firebug.InfoTip)\n            Firebug.InfoTip.uninitializeBrowser(Firebug.chrome);\n\n        if (Firebug.chrome.largeCommandLineVisible)\n            Firebug.chrome.hideLargeCommandLine();\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        if (this.hasSidePanel)\n        {\n            // TODO: xxxpedro firebug1.3a6\n            // new PanelBar mechanism will need to call shutdown to hide the panels (so it\n            // doesn\'t appears in other panel\'s sidePanelBar. Therefore, we need to implement\n            // a "remember selected panel" feature in the sidePanelBar\n            //this.sidePanelBar.shutdown();\n        }\n\n        // store persistent state\n        this.lastScrollTop = this.containerNode.scrollTop;\n\n        // xxxpedro contextMenu\n        removeEvent(this.containerNode, "contextmenu", this.onContextMenu);\n    },\n\n    detach: function(oldChrome, newChrome)\n    {\n        if (oldChrome && oldChrome.selectedPanel && oldChrome.selectedPanel.name == this.name)\n            this.lastScrollTop = oldChrome.selectedPanel.containerNode.scrollTop;\n    },\n\n    reattach: function(doc)\n    {\n        if (this.options.innerHTMLSync)\n            this.synchronizeUI();\n    },\n\n    synchronizeUI: function()\n    {\n        this.containerNode.scrollTop = this.lastScrollTop || 0;\n    },\n\n    show: function(state)\n    {\n        var options = this.options;\n\n        if (options.hasStatusBar)\n        {\n            this.statusBarBox.style.display = "inline";\n            this.statusBarNode.style.display = "inline";\n        }\n\n        if (options.hasToolButtons)\n        {\n            this.toolButtonsNode.style.display = "inline";\n        }\n\n        this.panelNode.style.display = "block";\n\n        this.visible = true;\n\n        if (!this.parentPanel)\n            Firebug.chrome.layout(this);\n    },\n\n    hide: function(state)\n    {\n        var options = this.options;\n\n        if (options.hasStatusBar)\n        {\n            this.statusBarBox.style.display = "none";\n            this.statusBarNode.style.display = "none";\n        }\n\n        if (options.hasToolButtons)\n        {\n            this.toolButtonsNode.style.display = "none";\n        }\n\n        this.panelNode.style.display = "none";\n\n        this.visible = false;\n    },\n\n    watchWindow: function(win)\n    {\n    },\n\n    unwatchWindow: function(win)\n    {\n    },\n\n    updateOption: function(name, value)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    /**\n     * Toolbar helpers\n     */\n    showToolbarButtons: function(buttonsId, show)\n    {\n        try\n        {\n            if (!this.context.browser) // XXXjjb this is bug. Somehow the panel context is not FirebugContext.\n            {\n                if (FBTrace.DBG_ERRORS)\n                    FBTrace.sysout("firebug.Panel showToolbarButtons this.context has no browser, this:", this);\n\n                return;\n            }\n            var buttons = this.context.browser.chrome.$(buttonsId);\n            if (buttons)\n                collapse(buttons, show ? "false" : "true");\n        }\n        catch (exc)\n        {\n            if (FBTrace.DBG_ERRORS)\n            {\n                FBTrace.dumpProperties("firebug.Panel showToolbarButtons FAILS", exc);\n                if (!this.context.browser)FBTrace.dumpStack("firebug.Panel showToolbarButtons no browser");\n            }\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    /**\n     * Returns a number indicating the view\'s ability to inspect the object.\n     *\n     * Zero means not supported, and higher numbers indicate specificity.\n     */\n    supportsObject: function(object)\n    {\n        return 0;\n    },\n\n    hasObject: function(object)  // beyond type testing, is this object selectable?\n    {\n        return false;\n    },\n\n    select: function(object, forceUpdate)\n    {\n        if (!object)\n            object = this.getDefaultSelection(this.context);\n\n        if(FBTrace.DBG_PANELS)\n            FBTrace.sysout("firebug.select "+this.name+" forceUpdate: "+forceUpdate+" "+object+((object==this.selection)?"==":"!=")+this.selection);\n\n        if (forceUpdate || object != this.selection)\n        {\n            this.selection = object;\n            this.updateSelection(object);\n\n            // TODO: xxxpedro\n            // XXXjoe This is kind of cheating, but, feh.\n            //Firebug.chrome.onPanelSelect(object, this);\n            //if (uiListeners.length > 0)\n            //    dispatch(uiListeners, "onPanelSelect", [object, this]);  // TODO: make Firebug.chrome a uiListener\n        }\n    },\n\n    updateSelection: function(object)\n    {\n    },\n\n    markChange: function(skipSelf)\n    {\n        if (this.dependents)\n        {\n            if (skipSelf)\n            {\n                for (var i = 0; i < this.dependents.length; ++i)\n                {\n                    var panelName = this.dependents[i];\n                    if (panelName != this.name)\n                        this.context.invalidatePanels(panelName);\n                }\n            }\n            else\n                this.context.invalidatePanels.apply(this.context, this.dependents);\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    startInspecting: function()\n    {\n    },\n\n    stopInspecting: function(object, cancelled)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    search: function(text, reverse)\n    {\n    },\n\n    /**\n     * Retrieves the search options that this modules supports.\n     * This is used by the search UI to present the proper options.\n     */\n    getSearchOptionsMenuItems: function()\n    {\n        return [\n            Firebug.Search.searchOptionMenu("search.Case Sensitive", "searchCaseSensitive")\n        ];\n    },\n\n    /**\n     * Navigates to the next document whose match parameter returns true.\n     */\n    navigateToNextDocument: function(match, reverse)\n    {\n        // This is an approximation of the UI that is displayed by the location\n        // selector. This should be close enough, although it may be better\n        // to simply generate the sorted list within the module, rather than\n        // sorting within the UI.\n        var self = this;\n        function compare(a, b) {\n            var locA = self.getObjectDescription(a);\n            var locB = self.getObjectDescription(b);\n            if(locA.path > locB.path)\n                return 1;\n            if(locA.path < locB.path)\n                return -1;\n            if(locA.name > locB.name)\n                return 1;\n            if(locA.name < locB.name)\n                return -1;\n            return 0;\n        }\n        var allLocs = this.getLocationList().sort(compare);\n        for (var curPos = 0; curPos < allLocs.length && allLocs[curPos] != this.location; curPos++);\n\n        function transformIndex(index) {\n            if (reverse) {\n                // For the reverse case we need to implement wrap around.\n                var intermediate = curPos - index - 1;\n                return (intermediate < 0 ? allLocs.length : 0) + intermediate;\n            } else {\n                return (curPos + index + 1) % allLocs.length;\n            }\n        };\n\n        for (var next = 0; next < allLocs.length - 1; next++)\n        {\n            var object = allLocs[transformIndex(next)];\n\n            if (match(object))\n            {\n                this.navigate(object);\n                return object;\n            }\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    // Called when "Options" clicked. Return array of\n    // {label: \'name\', nol10n: true,  type: "checkbox", checked: <value>, command:function to set <value>}\n    getOptionsMenuItems: function()\n    {\n        return null;\n    },\n\n    /*\n     * Called by chrome.onContextMenu to build the context menu when this panel has focus.\n     * See also FirebugRep for a similar function also called by onContextMenu\n     * Extensions may monkey patch and chain off this call\n     * @param object: the \'realObject\', a model value, eg a DOM property\n     * @param target: the HTML element clicked on.\n     * @return an array of menu items.\n     */\n    getContextMenuItems: function(object, target)\n    {\n        return [];\n    },\n\n    getBreakOnMenuItems: function()\n    {\n        return [];\n    },\n\n    getEditor: function(target, value)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getDefaultSelection: function()\n    {\n        return null;\n    },\n\n    browseObject: function(object)\n    {\n    },\n\n    getPopupObject: function(target)\n    {\n        return Firebug.getRepObject(target);\n    },\n\n    getTooltipObject: function(target)\n    {\n        return Firebug.getRepObject(target);\n    },\n\n    showInfoTip: function(infoTip, x, y)\n    {\n\n    },\n\n    getObjectPath: function(object)\n    {\n        return null;\n    },\n\n    // An array of objects that can be passed to getObjectLocation.\n    // The list of things a panel can show, eg sourceFiles.\n    // Only shown if panel.location defined and supportsObject true\n    getLocationList: function()\n    {\n        return null;\n    },\n\n    getDefaultLocation: function()\n    {\n        return null;\n    },\n\n    getObjectLocation: function(object)\n    {\n        return "";\n    },\n\n    // Text for the location list menu eg script panel source file list\n    // return.path: group/category label, return.name: item label\n    getObjectDescription: function(object)\n    {\n        var url = this.getObjectLocation(object);\n        return FBL.splitURLBase(url);\n    },\n\n    /*\n     *  UI signal that a tab needs attention, eg Script panel is currently stopped on a breakpoint\n     *  @param: show boolean, true turns on.\n     */\n    highlight: function(show)\n    {\n        var tab = this.getTab();\n        if (!tab)\n            return;\n\n        if (show)\n            tab.setAttribute("highlight", "true");\n        else\n            tab.removeAttribute("highlight");\n    },\n\n    getTab: function()\n    {\n        var chrome = Firebug.chrome;\n\n        var tab = chrome.$("fbPanelBar2").getTab(this.name);\n        if (!tab)\n            tab = chrome.$("fbPanelBar1").getTab(this.name);\n        return tab;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Support for Break On Next\n\n    /**\n     * Called by the framework when the user clicks on the Break On Next button.\n     * @param {Boolean} armed Set to true if the Break On Next feature is\n     * to be armed for action and set to false if the Break On Next should be disarmed.\n     * If \'armed\' is true, then the next call to shouldBreakOnNext should be |true|.\n     */\n    breakOnNext: function(armed)\n    {\n    },\n\n    /**\n     * Called when a panel is selected/displayed. The method should return true\n     * if the Break On Next feature is currently armed for this panel.\n     */\n    shouldBreakOnNext: function()\n    {\n        return false;\n    },\n\n    /**\n     * Returns labels for Break On Next tooltip (one for enabled and one for disabled state).\n     * @param {Boolean} enabled Set to true if the Break On Next feature is\n     * currently activated for this panel.\n     */\n    getBreakOnNextTooltip: function(enabled)\n    {\n        return null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    // xxxpedro contextMenu\n    onContextMenu: function(event)\n    {\n        if (!this.getContextMenuItems)\n            return;\n\n        cancelEvent(event, true);\n\n        var target = event.target || event.srcElement;\n\n        var menu = this.getContextMenuItems(this.selection, target);\n        if (!menu)\n            return;\n\n        var contextMenu = new Menu(\n        {\n            id: "fbPanelContextMenu",\n\n            items: menu\n        });\n\n        contextMenu.show(event.clientX, event.clientY);\n\n        return true;\n\n        /*\n        // TODO: xxxpedro move code to somewhere. code to get cross-browser\n        // window to screen coordinates\n        var box = Firebug.browser.getElementPosition(Firebug.chrome.node);\n\n        var screenY = 0;\n\n        // Firefox\n        if (typeof window.mozInnerScreenY != "undefined")\n        {\n            screenY = window.mozInnerScreenY;\n        }\n        // Chrome\n        else if (typeof window.innerHeight != "undefined")\n        {\n            screenY = window.outerHeight - window.innerHeight;\n        }\n        // IE\n        else if (typeof window.screenTop != "undefined")\n        {\n            screenY = window.screenTop;\n        }\n\n        contextMenu.show(event.screenX-box.left, event.screenY-screenY-box.top);\n        /**/\n    }\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n};\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n/**\n * MeasureBox\n * To get pixels size.width and size.height:\n * <ul><li>     this.startMeasuring(view); </li>\n *     <li>     var size = this.measureText(lineNoCharsSpacer); </li>\n *     <li>     this.stopMeasuring(); </li>\n * </ul>\n *\n * @namespace\n */\nFirebug.MeasureBox =\n{\n    startMeasuring: function(target)\n    {\n        if (!this.measureBox)\n        {\n            this.measureBox = target.ownerDocument.createElement("span");\n            this.measureBox.className = "measureBox";\n        }\n\n        copyTextStyles(target, this.measureBox);\n        target.ownerDocument.body.appendChild(this.measureBox);\n    },\n\n    getMeasuringElement: function()\n    {\n        return this.measureBox;\n    },\n\n    measureText: function(value)\n    {\n        this.measureBox.innerHTML = value ? escapeForSourceLine(value) : "m";\n        return {width: this.measureBox.offsetWidth, height: this.measureBox.offsetHeight-1};\n    },\n\n    measureInputText: function(value)\n    {\n        value = value ? escapeForTextNode(value) : "m";\n        if (!Firebug.showTextNodesWithWhitespace)\n            value = value.replace(/\\t/g,\'mmmmmm\').replace(/\\ /g,\'m\');\n        this.measureBox.innerHTML = value;\n        return {width: this.measureBox.offsetWidth, height: this.measureBox.offsetHeight-1};\n    },\n\n    getBox: function(target)\n    {\n        var style = this.measureBox.ownerDocument.defaultView.getComputedStyle(this.measureBox, "");\n        var box = getBoxFromStyles(style, this.measureBox);\n        return box;\n    },\n\n    stopMeasuring: function()\n    {\n        this.measureBox.parentNode.removeChild(this.measureBox);\n    }\n};\n\n\n// ************************************************************************************************\nif (FBL.domplate) Firebug.Rep = domplate(\n{\n    className: "",\n    inspectable: true,\n\n    supportsObject: function(object, type)\n    {\n        return false;\n    },\n\n    inspectObject: function(object, context)\n    {\n        Firebug.chrome.select(object);\n    },\n\n    browseObject: function(object, context)\n    {\n    },\n\n    persistObject: function(object, context)\n    {\n    },\n\n    getRealObject: function(object, context)\n    {\n        return object;\n    },\n\n    getTitle: function(object)\n    {\n        var label = safeToString(object);\n\n        var re = /\\[object (.*?)\\]/;\n        var m = re.exec(label);\n\n        ///return m ? m[1] : label;\n\n        // if the label is in the "[object TYPE]" format return its type\n        if (m)\n        {\n            return m[1];\n        }\n        // if it is IE we need to handle some special cases\n        else if (\n                // safeToString() fails to recognize some objects in IE\n                isIE &&\n                // safeToString() returns "[object]" for some objects like window.Image\n                (label == "[object]" ||\n                // safeToString() returns undefined for some objects like window.clientInformation\n                typeof object == "object" && typeof label == "undefined")\n            )\n        {\n            return "Object";\n        }\n        else\n        {\n            return label;\n        }\n    },\n\n    getTooltip: function(object)\n    {\n        return null;\n    },\n\n    getContextMenuItems: function(object, target, context)\n    {\n        return [];\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Convenience for domplates\n\n    STR: function(name)\n    {\n        return $STR(name);\n    },\n\n    cropString: function(text)\n    {\n        return cropString(text);\n    },\n\n    cropMultipleLines: function(text, limit)\n    {\n        return cropMultipleLines(text, limit);\n    },\n\n    toLowerCase: function(text)\n    {\n        return text ? text.toLowerCase() : text;\n    },\n\n    plural: function(n)\n    {\n        return n == 1 ? "" : "s";\n    }\n});\n\n// ************************************************************************************************\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns( /** @scope s_gui */ function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Controller\n\n/**@namespace*/\nFBL.Controller = {\n\n    controllers: null,\n    controllerContext: null,\n\n    initialize: function(context)\n    {\n        this.controllers = [];\n        this.controllerContext = context || Firebug.chrome;\n    },\n\n    shutdown: function()\n    {\n        this.removeControllers();\n\n        //this.controllers = null;\n        //this.controllerContext = null;\n    },\n\n    addController: function()\n    {\n        for (var i=0, arg; arg=arguments[i]; i++)\n        {\n            // If the first argument is a string, make a selector query\n            // within the controller node context\n            if (typeof arg[0] == "string")\n            {\n                arg[0] = $$(arg[0], this.controllerContext);\n            }\n\n            // bind the handler to the proper context\n            var handler = arg[2];\n            arg[2] = bind(handler, this);\n            // save the original handler as an extra-argument, so we can\n            // look for it later, when removing a particular controller\n            arg[3] = handler;\n\n            this.controllers.push(arg);\n            addEvent.apply(this, arg);\n        }\n    },\n\n    removeController: function()\n    {\n        for (var i=0, arg; arg=arguments[i]; i++)\n        {\n            for (var j=0, c; c=this.controllers[j]; j++)\n            {\n                if (arg[0] == c[0] && arg[1] == c[1] && arg[2] == c[3])\n                    removeEvent.apply(this, c);\n            }\n        }\n    },\n\n    removeControllers: function()\n    {\n        for (var i=0, c; c=this.controllers[i]; i++)\n        {\n            removeEvent.apply(this, c);\n        }\n    }\n};\n\n\n// ************************************************************************************************\n// PanelBar\n\n/**@namespace*/\nFBL.PanelBar =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    panelMap: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    selectedPanel: null,\n    parentPanelName: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    create: function(ownerPanel)\n    {\n        this.panelMap = {};\n        this.ownerPanel = ownerPanel;\n\n        if (ownerPanel)\n        {\n            ownerPanel.sidePanelBarNode = createElement("span");\n            ownerPanel.sidePanelBarNode.style.display = "none";\n            ownerPanel.sidePanelBarBoxNode.appendChild(ownerPanel.sidePanelBarNode);\n        }\n\n        var panels = Firebug.panelTypes;\n        for (var i=0, p; p=panels[i]; i++)\n        {\n            if ( // normal Panel  of the Chrome\'s PanelBar\n                !ownerPanel && !p.prototype.parentPanel ||\n                // Child Panel of the current Panel\'s SidePanelBar\n                ownerPanel && p.prototype.parentPanel &&\n                ownerPanel.name == p.prototype.parentPanel)\n            {\n                this.addPanel(p.prototype.name);\n            }\n        }\n    },\n\n    destroy: function()\n    {\n        PanelBar.shutdown.call(this);\n\n        for (var name in this.panelMap)\n        {\n            this.removePanel(name);\n\n            var panel = this.panelMap[name];\n            panel.destroy();\n\n            this.panelMap[name] = null;\n            delete this.panelMap[name];\n        }\n\n        this.panelMap = null;\n        this.ownerPanel = null;\n    },\n\n    initialize: function()\n    {\n        if (this.ownerPanel)\n            this.ownerPanel.sidePanelBarNode.style.display = "inline";\n\n        for(var name in this.panelMap)\n        {\n            (function(self, name){\n\n                // tab click handler\n                var onTabClick = function onTabClick()\n                {\n                    self.selectPanel(name);\n                    return false;\n                };\n\n                Firebug.chrome.addController([self.panelMap[name].tabNode, "mousedown", onTabClick]);\n\n            })(this, name);\n        }\n    },\n\n    shutdown: function()\n    {\n        var selectedPanel = this.selectedPanel;\n\n        if (selectedPanel)\n        {\n            removeClass(selectedPanel.tabNode, "fbSelectedTab");\n            selectedPanel.hide();\n            selectedPanel.shutdown();\n        }\n\n        if (this.ownerPanel)\n            this.ownerPanel.sidePanelBarNode.style.display = "none";\n\n        this.selectedPanel = null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    addPanel: function(panelName, parentPanel)\n    {\n        var PanelType = Firebug.panelTypeMap[panelName];\n        var panel = this.panelMap[panelName] = new PanelType();\n\n        panel.create();\n    },\n\n    removePanel: function(panelName)\n    {\n        var panel = this.panelMap[panelName];\n        if (panel.hasOwnProperty(panelName))\n            panel.destroy();\n    },\n\n    selectPanel: function(panelName)\n    {\n        var selectedPanel = this.selectedPanel;\n        var panel = this.panelMap[panelName];\n\n        if (panel && selectedPanel != panel)\n        {\n            if (selectedPanel)\n            {\n                removeClass(selectedPanel.tabNode, "fbSelectedTab");\n                selectedPanel.shutdown();\n                selectedPanel.hide();\n            }\n\n            if (!panel.parentPanel)\n                Firebug.context.persistedState.selectedPanelName = panelName;\n\n            this.selectedPanel = panel;\n\n            setClass(panel.tabNode, "fbSelectedTab");\n            panel.show();\n            panel.initialize();\n        }\n    },\n\n    getPanel: function(panelName)\n    {\n        var panel = this.panelMap[panelName];\n\n        return panel;\n    }\n\n};\n\n//************************************************************************************************\n// Button\n\n/**\n * options.element\n * options.caption\n * options.title\n *\n * options.owner\n * options.className\n * options.pressedClassName\n *\n * options.onPress\n * options.onUnpress\n * options.onClick\n *\n * @class\n * @extends FBL.Controller\n *\n */\n\nFBL.Button = function(options)\n{\n    options = options || {};\n\n    append(this, options);\n\n    this.state = "unpressed";\n    this.display = "unpressed";\n\n    if (this.element)\n    {\n        this.container = this.element.parentNode;\n    }\n    else\n    {\n        this.shouldDestroy = true;\n\n        this.container = this.owner.getPanel().toolButtonsNode;\n\n        this.element = createElement("a", {\n            className: this.baseClassName + " " + this.className + " fbHover",\n            innerHTML: this.caption\n        });\n\n        if (this.title)\n            this.element.title = this.title;\n\n        this.container.appendChild(this.element);\n    }\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nButton.prototype = extend(Controller,\n/**@extend FBL.Button.prototype*/\n{\n    type: "normal",\n    caption: "caption",\n    title: null,\n\n    className: "", // custom class\n    baseClassName: "fbButton", // control class\n    pressedClassName: "fbBtnPressed", // control pressed class\n\n    element: null,\n    container: null,\n    owner: null,\n\n    state: null,\n    display: null,\n\n    destroy: function()\n    {\n        this.shutdown();\n\n        // only remove if it is a dynamically generated button (not pre-rendered)\n        if (this.shouldDestroy)\n            this.container.removeChild(this.element);\n\n        this.element = null;\n        this.container = null;\n        this.owner = null;\n    },\n\n    initialize: function()\n    {\n        Controller.initialize.apply(this);\n\n        var element = this.element;\n\n        this.addController([element, "mousedown", this.handlePress]);\n\n        if (this.type == "normal")\n            this.addController(\n                [element, "mouseup", this.handleUnpress],\n                [element, "mouseout", this.handleUnpress],\n                [element, "click", this.handleClick]\n            );\n    },\n\n    shutdown: function()\n    {\n        Controller.shutdown.apply(this);\n    },\n\n    restore: function()\n    {\n        this.changeState("unpressed");\n    },\n\n    changeState: function(state)\n    {\n        this.state = state;\n        this.changeDisplay(state);\n    },\n\n    changeDisplay: function(display)\n    {\n        if (display != this.display)\n        {\n            if (display == "pressed")\n            {\n                setClass(this.element, this.pressedClassName);\n            }\n            else if (display == "unpressed")\n            {\n                removeClass(this.element, this.pressedClassName);\n            }\n            this.display = display;\n        }\n    },\n\n    handlePress: function(event)\n    {\n        cancelEvent(event, true);\n\n        if (this.type == "normal")\n        {\n            this.changeDisplay("pressed");\n            this.beforeClick = true;\n        }\n        else if (this.type == "toggle")\n        {\n            if (this.state == "pressed")\n            {\n                this.changeState("unpressed");\n\n                if (this.onUnpress)\n                    this.onUnpress.apply(this.owner, arguments);\n            }\n            else\n            {\n                this.changeState("pressed");\n\n                if (this.onPress)\n                    this.onPress.apply(this.owner, arguments);\n            }\n\n            if (this.onClick)\n                this.onClick.apply(this.owner, arguments);\n        }\n\n        return false;\n    },\n\n    handleUnpress: function(event)\n    {\n        cancelEvent(event, true);\n\n        if (this.beforeClick)\n            this.changeDisplay("unpressed");\n\n        return false;\n    },\n\n    handleClick: function(event)\n    {\n        cancelEvent(event, true);\n\n        if (this.type == "normal")\n        {\n            if (this.onClick)\n                this.onClick.apply(this.owner);\n\n            this.changeState("unpressed");\n        }\n\n        this.beforeClick = false;\n\n        return false;\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n/**\n * @class\n * @extends FBL.Button\n */\nFBL.IconButton = function()\n{\n    Button.apply(this, arguments);\n};\n\nIconButton.prototype = extend(Button.prototype,\n/**@extend FBL.IconButton.prototype*/\n{\n    baseClassName: "fbIconButton",\n    pressedClassName: "fbIconPressed"\n});\n\n\n//************************************************************************************************\n// Menu\n\nvar menuItemProps = {"class": "$item.className", type: "$item.type", value: "$item.value",\n        _command: "$item.command"};\n\nif (isIE6)\n    menuItemProps.href = "javascript:void(0)";\n\n// Allow GUI to be loaded even when Domplate module is not installed.\nif (FBL.domplate)\nvar MenuPlate = domplate(Firebug.Rep,\n{\n    tag:\n        DIV({"class": "fbMenu fbShadow"},\n            DIV({"class": "fbMenuContent fbShadowContent"},\n                FOR("item", "$object.items|memberIterator",\n                    TAG("$item.tag", {item: "$item"})\n                )\n            )\n        ),\n\n    itemTag:\n        A(menuItemProps,\n            "$item.label"\n        ),\n\n    checkBoxTag:\n        A(extend(menuItemProps, {checked : "$item.checked"}),\n\n            "$item.label"\n        ),\n\n    radioButtonTag:\n        A(extend(menuItemProps, {selected : "$item.selected"}),\n\n            "$item.label"\n        ),\n\n    groupTag:\n        A(extend(menuItemProps, {child: "$item.child"}),\n            "$item.label"\n        ),\n\n    shortcutTag:\n        A(menuItemProps,\n            "$item.label",\n            SPAN({"class": "fbMenuShortcutKey"},\n                "$item.key"\n            )\n        ),\n\n    separatorTag:\n        SPAN({"class": "fbMenuSeparator"}),\n\n    memberIterator: function(items)\n    {\n        var result = [];\n\n        for (var i=0, length=items.length; i<length; i++)\n        {\n            var item = items[i];\n\n            // separator representation\n            if (typeof item == "string" && item.indexOf("-") == 0)\n            {\n                result.push({tag: this.separatorTag});\n                continue;\n            }\n\n            item = extend(item, {});\n\n            item.type = item.type || "";\n            item.value = item.value || "";\n\n            var type = item.type;\n\n            // default item representation\n            item.tag = this.itemTag;\n\n            var className = item.className || "";\n\n            className += "fbMenuOption fbHover ";\n\n            // specific representations\n            if (type == "checkbox")\n            {\n                className += "fbMenuCheckBox ";\n                item.tag = this.checkBoxTag;\n            }\n            else if (type == "radiobutton")\n            {\n                className += "fbMenuRadioButton ";\n                item.tag = this.radioButtonTag;\n            }\n            else if (type == "group")\n            {\n                className += "fbMenuGroup ";\n                item.tag = this.groupTag;\n            }\n            else if (type == "shortcut")\n            {\n                className += "fbMenuShortcut ";\n                item.tag = this.shortcutTag;\n            }\n\n            if (item.checked)\n                className += "fbMenuChecked ";\n            else if (item.selected)\n                className += "fbMenuRadioSelected ";\n\n            if (item.disabled)\n                className += "fbMenuDisabled ";\n\n            item.className = className;\n\n            item.label = $STR(item.label);\n\n            result.push(item);\n        }\n\n        return result;\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n/**\n * options\n * options.element\n * options.id\n * options.items\n *\n * item.label\n * item.className\n * item.type\n * item.value\n * item.disabled\n * item.checked\n * item.selected\n * item.command\n * item.child\n *\n *\n * @class\n * @extends FBL.Controller\n *\n */\nFBL.Menu = function(options)\n{\n    // if element is not pre-rendered, we must render it now\n    if (!options.element)\n    {\n        if (options.getItems)\n            options.items = options.getItems();\n\n        options.element = MenuPlate.tag.append(\n                {object: options},\n                getElementByClass(Firebug.chrome.document, "fbBody"),\n                MenuPlate\n            );\n    }\n\n    // extend itself with the provided options\n    append(this, options);\n\n    if (typeof this.element == "string")\n    {\n        this.id = this.element;\n        this.element = $(this.id);\n    }\n    else if (this.id)\n    {\n        this.element.id = this.id;\n    }\n\n    this.element.firebugIgnore = true;\n    this.elementStyle = this.element.style;\n\n    this.isVisible = false;\n\n    this.handleMouseDown = bind(this.handleMouseDown, this);\n    this.handleMouseOver = bind(this.handleMouseOver, this);\n    this.handleMouseOut = bind(this.handleMouseOut, this);\n\n    this.handleWindowMouseDown = bind(this.handleWindowMouseDown, this);\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar menuMap = {};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nMenu.prototype =  extend(Controller,\n/**@extend FBL.Menu.prototype*/\n{\n    destroy: function()\n    {\n        //if (this.element) console.log("destroy", this.element.id);\n\n        this.hide();\n\n        // if it is a childMenu, remove its reference from the parentMenu\n        if (this.parentMenu)\n            this.parentMenu.childMenu = null;\n\n        // remove the element from the document\n        this.element.parentNode.removeChild(this.element);\n\n        // clear references\n        this.element = null;\n        this.elementStyle = null;\n        this.parentMenu = null;\n        this.parentTarget = null;\n    },\n\n    initialize: function()\n    {\n        Controller.initialize.call(this);\n\n        this.addController(\n                [this.element, "mousedown", this.handleMouseDown],\n                [this.element, "mouseover", this.handleMouseOver]\n             );\n    },\n\n    shutdown: function()\n    {\n        Controller.shutdown.call(this);\n    },\n\n    show: function(x, y)\n    {\n        this.initialize();\n\n        if (this.isVisible) return;\n\n        //console.log("show", this.element.id);\n\n        x = x || 0;\n        y = y || 0;\n\n        if (this.parentMenu)\n        {\n            var oldChildMenu = this.parentMenu.childMenu;\n            if (oldChildMenu && oldChildMenu != this)\n            {\n                oldChildMenu.destroy();\n            }\n\n            this.parentMenu.childMenu = this;\n        }\n        else\n            addEvent(Firebug.chrome.document, "mousedown", this.handleWindowMouseDown);\n\n        this.elementStyle.display = "block";\n        this.elementStyle.visibility = "hidden";\n\n        var size = Firebug.chrome.getSize();\n\n        x = Math.min(x, size.width - this.element.clientWidth - 10);\n        x = Math.max(x, 0);\n\n        y = Math.min(y, size.height - this.element.clientHeight - 10);\n        y = Math.max(y, 0);\n\n        this.elementStyle.left = x + "px";\n        this.elementStyle.top = y + "px";\n\n        this.elementStyle.visibility = "visible";\n\n        this.isVisible = true;\n\n        if (isFunction(this.onShow))\n            this.onShow.apply(this, arguments);\n    },\n\n    hide: function()\n    {\n        this.clearHideTimeout();\n        this.clearShowChildTimeout();\n\n        if (!this.isVisible) return;\n\n        //console.log("hide", this.element.id);\n\n        this.elementStyle.display = "none";\n\n        if(this.childMenu)\n        {\n            this.childMenu.destroy();\n            this.childMenu = null;\n        }\n\n        if(this.parentTarget)\n            removeClass(this.parentTarget, "fbMenuGroupSelected");\n\n        this.isVisible = false;\n\n        this.shutdown();\n\n        if (isFunction(this.onHide))\n            this.onHide.apply(this, arguments);\n    },\n\n    showChildMenu: function(target)\n    {\n        var id = target.getAttribute("child");\n\n        var parent = this;\n        var target = target;\n\n        this.showChildTimeout = Firebug.chrome.window.setTimeout(function(){\n\n            //if (!parent.isVisible) return;\n\n            var box = Firebug.chrome.getElementBox(target);\n\n            var childMenuObject = menuMap.hasOwnProperty(id) ?\n                    menuMap[id] : {element: $(id)};\n\n            var childMenu = new Menu(extend(childMenuObject,\n                {\n                    parentMenu: parent,\n                    parentTarget: target\n                }));\n\n            var offsetLeft = isIE6 ? -1 : -6; // IE6 problem with fixed position\n            childMenu.show(box.left + box.width + offsetLeft, box.top -6);\n            setClass(target, "fbMenuGroupSelected");\n\n        },350);\n    },\n\n    clearHideTimeout: function()\n    {\n        if (this.hideTimeout)\n        {\n            Firebug.chrome.window.clearTimeout(this.hideTimeout);\n            delete this.hideTimeout;\n        }\n    },\n\n    clearShowChildTimeout: function()\n    {\n        if(this.showChildTimeout)\n        {\n            Firebug.chrome.window.clearTimeout(this.showChildTimeout);\n            this.showChildTimeout = null;\n        }\n    },\n\n    handleMouseDown: function(event)\n    {\n        cancelEvent(event, true);\n\n        var topParent = this;\n        while (topParent.parentMenu)\n            topParent = topParent.parentMenu;\n\n        var target = event.target || event.srcElement;\n\n        target = getAncestorByClass(target, "fbMenuOption");\n\n        if(!target || hasClass(target, "fbMenuGroup"))\n            return false;\n\n        if (target && !hasClass(target, "fbMenuDisabled"))\n        {\n            var type = target.getAttribute("type");\n\n            if (type == "checkbox")\n            {\n                var checked = target.getAttribute("checked");\n                var value = target.getAttribute("value");\n                var wasChecked = hasClass(target, "fbMenuChecked");\n\n                if (wasChecked)\n                {\n                    removeClass(target, "fbMenuChecked");\n                    target.setAttribute("checked", "");\n                }\n                else\n                {\n                    setClass(target, "fbMenuChecked");\n                    target.setAttribute("checked", "true");\n                }\n\n                if (isFunction(this.onCheck))\n                    this.onCheck.call(this, target, value, !wasChecked);\n            }\n\n            if (type == "radiobutton")\n            {\n                var selectedRadios = getElementsByClass(target.parentNode, "fbMenuRadioSelected");\n\n                var group = target.getAttribute("group");\n\n                for (var i = 0, length = selectedRadios.length; i < length; i++)\n                {\n                    radio = selectedRadios[i];\n\n                    if (radio.getAttribute("group") == group)\n                    {\n                        removeClass(radio, "fbMenuRadioSelected");\n                        radio.setAttribute("selected", "");\n                    }\n                }\n\n                setClass(target, "fbMenuRadioSelected");\n                target.setAttribute("selected", "true");\n            }\n\n            var handler = null;\n\n            // target.command can be a function or a string.\n            var cmd = target.command;\n\n            // If it is a function it will be used as the handler\n            if (isFunction(cmd))\n                handler = cmd;\n            // If it is a string it the property of the current menu object\n            // will be used as the handler\n            else if (typeof cmd == "string")\n                handler = this[cmd];\n\n            var closeMenu = true;\n\n            if (handler)\n                closeMenu = handler.call(this, target) !== false;\n\n            if (closeMenu)\n                topParent.hide();\n        }\n\n        return false;\n    },\n\n    handleWindowMouseDown: function(event)\n    {\n        //console.log("handleWindowMouseDown");\n\n        var target = event.target || event.srcElement;\n\n        target = getAncestorByClass(target, "fbMenu");\n\n        if (!target)\n        {\n            removeEvent(Firebug.chrome.document, "mousedown", this.handleWindowMouseDown);\n            this.hide();\n        }\n    },\n\n    handleMouseOver: function(event)\n    {\n        //console.log("handleMouseOver", this.element.id);\n\n        this.clearHideTimeout();\n        this.clearShowChildTimeout();\n\n        var target = event.target || event.srcElement;\n\n        target = getAncestorByClass(target, "fbMenuOption");\n\n        if(!target)\n            return;\n\n        var childMenu = this.childMenu;\n        if(childMenu)\n        {\n            removeClass(childMenu.parentTarget, "fbMenuGroupSelected");\n\n            if (childMenu.parentTarget != target && childMenu.isVisible)\n            {\n                childMenu.clearHideTimeout();\n                childMenu.hideTimeout = Firebug.chrome.window.setTimeout(function(){\n                    childMenu.destroy();\n                },300);\n            }\n        }\n\n        if(hasClass(target, "fbMenuGroup"))\n        {\n            this.showChildMenu(target);\n        }\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nappend(Menu,\n/**@extend FBL.Menu*/\n{\n    register: function(object)\n    {\n        menuMap[object.id] = object;\n    },\n\n    check: function(element)\n    {\n        setClass(element, "fbMenuChecked");\n        element.setAttribute("checked", "true");\n    },\n\n    uncheck: function(element)\n    {\n        removeClass(element, "fbMenuChecked");\n        element.setAttribute("checked", "");\n    },\n\n    disable: function(element)\n    {\n        setClass(element, "fbMenuDisabled");\n    },\n\n    enable: function(element)\n    {\n        removeClass(element, "fbMenuDisabled");\n    }\n});\n\n\n//************************************************************************************************\n// Status Bar\n\n/**@class*/\nfunction StatusBar(){};\n\nStatusBar.prototype = extend(Controller, {\n\n});\n\n// ************************************************************************************************\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns( /**@scope s_context*/ function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Globals\n\nvar refreshDelay = 300;\n\n// Opera and some versions of webkit returns the wrong value of document.elementFromPoint()\n// function, without taking into account the scroll position. Safari 4 (webkit/531.21.8)\n// still have this issue. Google Chrome 4 (webkit/532.5) does not. So, we\'re assuming this\n// issue was fixed in the 532 version\nvar shouldFixElementFromPoint = isOpera || isSafari && browserVersion < "532";\n\nvar evalError = "___firebug_evaluation_error___";\nvar pixelsPerInch;\n\nvar resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";\nvar offscreenStyle = resetStyle + "top:-1234px; left:-1234px;";\n\n\n// ************************************************************************************************\n// Context\n\n/** @class */\nFBL.Context = function(win)\n{\n    this.window = win.window;\n    this.document = win.document;\n\n    this.browser = Env.browser;\n\n    // Some windows in IE, like iframe, doesn\'t have the eval() method\n    if (isIE && !this.window.eval)\n    {\n        // But after executing the following line the method magically appears!\n        this.window.execScript("null");\n        // Just to make sure the "magic" really happened\n        if (!this.window.eval)\n            throw new Error("Firebug Error: eval() method not found in this window");\n    }\n\n    // Create a new "black-box" eval() method that runs in the global namespace\n    // of the context window, without exposing the local variables declared\n    // by the function that calls it\n    this.eval = this.window.eval("new Function(\'" +\n            "try{ return window.eval.apply(window,arguments) }catch(E){ E."+evalError+"=true; return E }" +\n        "\')");\n};\n\nFBL.Context.prototype =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // partial-port of Firebug tabContext.js\n\n    browser: null,\n    loaded: true,\n\n    setTimeout: function(fn, delay)\n    {\n        var win = this.window;\n\n        if (win.setTimeout == this.setTimeout)\n            throw new Error("setTimeout recursion");\n\n        var timeout = win.setTimeout.apply ? // IE doesn\'t have apply method on setTimeout\n                win.setTimeout.apply(win, arguments) :\n                win.setTimeout(fn, delay);\n\n        if (!this.timeouts)\n            this.timeouts = {};\n\n        this.timeouts[timeout] = 1;\n\n        return timeout;\n    },\n\n    clearTimeout: function(timeout)\n    {\n        clearTimeout(timeout);\n\n        if (this.timeouts)\n            delete this.timeouts[timeout];\n    },\n\n    setInterval: function(fn, delay)\n    {\n        var win = this.window;\n\n        var timeout = win.setInterval.apply ? // IE doesn\'t have apply method on setTimeout\n                win.setInterval.apply(win, arguments) :\n                win.setInterval(fn, delay);\n\n        if (!this.intervals)\n            this.intervals = {};\n\n        this.intervals[timeout] = 1;\n\n        return timeout;\n    },\n\n    clearInterval: function(timeout)\n    {\n        clearInterval(timeout);\n\n        if (this.intervals)\n            delete this.intervals[timeout];\n    },\n\n    invalidatePanels: function()\n    {\n        if (!this.invalidPanels)\n            this.invalidPanels = {};\n\n        for (var i = 0; i < arguments.length; ++i)\n        {\n            var panelName = arguments[i];\n\n            // avoid error. need to create a better getPanel() function as explained below\n            if (!Firebug.chrome || !Firebug.chrome.selectedPanel)\n                return;\n\n            //var panel = this.getPanel(panelName, true);\n            //TODO: xxxpedro context how to get all panels using a single function?\n            // the current workaround to make the invalidation works is invalidating\n            // only sidePanels. There\'s also a problem with panel name (LowerCase in Firebug Lite)\n            var panel = Firebug.chrome.selectedPanel.sidePanelBar ?\n                    Firebug.chrome.selectedPanel.sidePanelBar.getPanel(panelName, true) :\n                    null;\n\n            if (panel && !panel.noRefresh)\n                this.invalidPanels[panelName] = 1;\n        }\n\n        if (this.refreshTimeout)\n        {\n            this.clearTimeout(this.refreshTimeout);\n            delete this.refreshTimeout;\n        }\n\n        this.refreshTimeout = this.setTimeout(bindFixed(function()\n        {\n            var invalids = [];\n\n            for (var panelName in this.invalidPanels)\n            {\n                //var panel = this.getPanel(panelName, true);\n                //TODO: xxxpedro context how to get all panels using a single function?\n                // the current workaround to make the invalidation works is invalidating\n                // only sidePanels. There\'s also a problem with panel name (LowerCase in Firebug Lite)\n                var panel = Firebug.chrome.selectedPanel.sidePanelBar ?\n                        Firebug.chrome.selectedPanel.sidePanelBar.getPanel(panelName, true) :\n                        null;\n\n                if (panel)\n                {\n                    if (panel.visible && !panel.editing)\n                        panel.refresh();\n                    else\n                        panel.needsRefresh = true;\n\n                    // If the panel is being edited, we\'ll keep trying to\n                    // refresh it until editing is done\n                    if (panel.editing)\n                        invalids.push(panelName);\n                }\n            }\n\n            delete this.invalidPanels;\n            delete this.refreshTimeout;\n\n            // Keep looping until every tab is valid\n            if (invalids.length)\n                this.invalidatePanels.apply(this, invalids);\n        }, this), refreshDelay);\n    },\n\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Evalutation Method\n\n    /**\n     * Evaluates an expression in the current context window.\n     *\n     * @param {String}   expr           expression to be evaluated\n     *\n     * @param {String}   context        string indicating the global location\n     *                                  of the object that will be used as the\n     *                                  context. The context is referred in\n     *                                  the expression as the "this" keyword.\n     *                                  If no context is informed, the "window"\n     *                                  context is used.\n     *\n     * @param {String}   api            string indicating the global location\n     *                                  of the object that will be used as the\n     *                                  api of the evaluation.\n     *\n     * @param {Function} errorHandler(message) error handler to be called\n     *                                         if the evaluation fails.\n     */\n    evaluate: function(expr, context, api, errorHandler)\n    {\n        // the default context is the "window" object. It can be any string that represents\n        // a global accessible element as: "my.namespaced.object"\n        context = context || "window";\n\n        var isObjectLiteral = trim(expr).indexOf("{") == 0,\n            cmd,\n            result;\n\n        // if the context is the "window" object, we don\'t need a closure\n        if (context == "window")\n        {\n            // If it is an object literal, then wrap the expression with parenthesis so we can\n            // capture the return value\n            if (isObjectLiteral)\n            {\n                cmd = api ?\n                    "with("+api+"){ ("+expr+") }" :\n                    "(" + expr + ")";\n            }\n            else\n            {\n                cmd = api ?\n                    "with("+api+"){ "+expr+" }" :\n                    expr;\n            }\n        }\n        else\n        {\n            cmd = api ?\n                // with API and context, no return value\n                "(function(arguments){ with(" + api + "){ " +\n                    expr +\n                " } }).call(" + context + ",undefined)"\n                :\n                // with context only, no return value\n                "(function(arguments){ " +\n                    expr +\n                " }).call(" + context + ",undefined)";\n        }\n\n        result = this.eval(cmd);\n\n        if (result && result[evalError])\n        {\n            var msg = result.name ? (result.name + ": ") : "";\n            msg += result.message || result;\n\n            if (errorHandler)\n                result = errorHandler(msg);\n            else\n                result = msg;\n        }\n\n        return result;\n    },\n\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Window Methods\n\n    getWindowSize: function()\n    {\n        var width=0, height=0, el;\n\n        if (typeof this.window.innerWidth == "number")\n        {\n            width = this.window.innerWidth;\n            height = this.window.innerHeight;\n        }\n        else if ((el=this.document.documentElement) && (el.clientHeight || el.clientWidth))\n        {\n            width = el.clientWidth;\n            height = el.clientHeight;\n        }\n        else if ((el=this.document.body) && (el.clientHeight || el.clientWidth))\n        {\n            width = el.clientWidth;\n            height = el.clientHeight;\n        }\n\n        return {width: width, height: height};\n    },\n\n    getWindowScrollSize: function()\n    {\n        var width=0, height=0, el;\n\n        // first try the document.documentElement scroll size\n        if (!isIEQuiksMode && (el=this.document.documentElement) &&\n           (el.scrollHeight || el.scrollWidth))\n        {\n            width = el.scrollWidth;\n            height = el.scrollHeight;\n        }\n\n        // then we need to check if document.body has a bigger scroll size value\n        // because sometimes depending on the browser and the page, the document.body\n        // scroll size returns a smaller (and wrong) measure\n        if ((el=this.document.body) && (el.scrollHeight || el.scrollWidth) &&\n            (el.scrollWidth > width || el.scrollHeight > height))\n        {\n            width = el.scrollWidth;\n            height = el.scrollHeight;\n        }\n\n        return {width: width, height: height};\n    },\n\n    getWindowScrollPosition: function()\n    {\n        var top=0, left=0, el;\n\n        if(typeof this.window.pageYOffset == "number")\n        {\n            top = this.window.pageYOffset;\n            left = this.window.pageXOffset;\n        }\n        else if((el=this.document.body) && (el.scrollTop || el.scrollLeft))\n        {\n            top = el.scrollTop;\n            left = el.scrollLeft;\n        }\n        else if((el=this.document.documentElement) && (el.scrollTop || el.scrollLeft))\n        {\n            top = el.scrollTop;\n            left = el.scrollLeft;\n        }\n\n        return {top:top, left:left};\n    },\n\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Element Methods\n\n    getElementFromPoint: function(x, y)\n    {\n        if (shouldFixElementFromPoint)\n        {\n            var scroll = this.getWindowScrollPosition();\n            return this.document.elementFromPoint(x + scroll.left, y + scroll.top);\n        }\n        else\n            return this.document.elementFromPoint(x, y);\n    },\n\n    getElementPosition: function(el)\n    {\n        var left = 0;\n        var top = 0;\n\n        do\n        {\n            left += el.offsetLeft;\n            top += el.offsetTop;\n        }\n        while (el = el.offsetParent);\n\n        return {left:left, top:top};\n    },\n\n    getElementBox: function(el)\n    {\n        var result = {};\n\n        if (el.getBoundingClientRect)\n        {\n            var rect = el.getBoundingClientRect();\n\n            // fix IE problem with offset when not in fullscreen mode\n            var offset = isIE ? this.document.body.clientTop || this.document.documentElement.clientTop: 0;\n\n            var scroll = this.getWindowScrollPosition();\n\n            result.top = Math.round(rect.top - offset + scroll.top);\n            result.left = Math.round(rect.left - offset + scroll.left);\n            result.height = Math.round(rect.bottom - rect.top);\n            result.width = Math.round(rect.right - rect.left);\n        }\n        else\n        {\n            var position = this.getElementPosition(el);\n\n            result.top = position.top;\n            result.left = position.left;\n            result.height = el.offsetHeight;\n            result.width = el.offsetWidth;\n        }\n\n        return result;\n    },\n\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Measurement Methods\n\n    getMeasurement: function(el, name)\n    {\n        var result = {value: 0, unit: "px"};\n\n        var cssValue = this.getStyle(el, name);\n\n        if (!cssValue) return result;\n        if (cssValue.toLowerCase() == "auto") return result;\n\n        var reMeasure = /(\\d+\\.?\\d*)(.*)/;\n        var m = cssValue.match(reMeasure);\n\n        if (m)\n        {\n            result.value = m[1]-0;\n            result.unit = m[2].toLowerCase();\n        }\n\n        return result;\n    },\n\n    getMeasurementInPixels: function(el, name)\n    {\n        if (!el) return null;\n\n        var m = this.getMeasurement(el, name);\n        var value = m.value;\n        var unit = m.unit;\n\n        if (unit == "px")\n            return value;\n\n        else if (unit == "pt")\n            return this.pointsToPixels(name, value);\n\n        else if (unit == "em")\n            return this.emToPixels(el, value);\n\n        else if (unit == "%")\n            return this.percentToPixels(el, value);\n\n        else if (unit == "ex")\n            return this.exToPixels(el, value);\n\n        // TODO: add other units. Maybe create a better general way\n        // to calculate measurements in different units.\n    },\n\n    getMeasurementBox1: function(el, name)\n    {\n        var sufixes = ["Top", "Left", "Bottom", "Right"];\n        var result = [];\n\n        for(var i=0, sufix; sufix=sufixes[i]; i++)\n            result[i] = Math.round(this.getMeasurementInPixels(el, name + sufix));\n\n        return {top:result[0], left:result[1], bottom:result[2], right:result[3]};\n    },\n\n    getMeasurementBox: function(el, name)\n    {\n        var result = [];\n        var sufixes = name == "border" ?\n                ["TopWidth", "LeftWidth", "BottomWidth", "RightWidth"] :\n                ["Top", "Left", "Bottom", "Right"];\n\n        if (isIE)\n        {\n            var propName, cssValue;\n            var autoMargin = null;\n\n            for(var i=0, sufix; sufix=sufixes[i]; i++)\n            {\n                propName = name + sufix;\n\n                cssValue = el.currentStyle[propName] || el.style[propName];\n\n                if (cssValue == "auto")\n                {\n                    if (!autoMargin)\n                        autoMargin = this.getCSSAutoMarginBox(el);\n\n                    result[i] = autoMargin[sufix.toLowerCase()];\n                }\n                else\n                    result[i] = this.getMeasurementInPixels(el, propName);\n\n            }\n\n        }\n        else\n        {\n            for(var i=0, sufix; sufix=sufixes[i]; i++)\n                result[i] = this.getMeasurementInPixels(el, name + sufix);\n        }\n\n        return {top:result[0], left:result[1], bottom:result[2], right:result[3]};\n    },\n\n    getCSSAutoMarginBox: function(el)\n    {\n        if (isIE && " meta title input script link a ".indexOf(" "+el.nodeName.toLowerCase()+" ") != -1)\n            return {top:0, left:0, bottom:0, right:0};\n            /**/\n\n        if (isIE && " h1 h2 h3 h4 h5 h6 h7 ul p ".indexOf(" "+el.nodeName.toLowerCase()+" ") == -1)\n            return {top:0, left:0, bottom:0, right:0};\n            /**/\n\n        var offsetTop = 0;\n        if (false && isIEStantandMode)\n        {\n            var scrollSize = Firebug.browser.getWindowScrollSize();\n            offsetTop = scrollSize.height;\n        }\n\n        var box = this.document.createElement("div");\n        //box.style.cssText = "margin:0; padding:1px; border: 0; position:static; overflow:hidden; visibility: hidden;";\n        box.style.cssText = "margin:0; padding:1px; border: 0; visibility: hidden;";\n\n        var clone = el.cloneNode(false);\n        var text = this.document.createTextNode("&nbsp;");\n        clone.appendChild(text);\n\n        box.appendChild(clone);\n\n        this.document.body.appendChild(box);\n\n        var marginTop = clone.offsetTop - box.offsetTop - 1;\n        var marginBottom = box.offsetHeight - clone.offsetHeight - 2 - marginTop;\n\n        var marginLeft = clone.offsetLeft - box.offsetLeft - 1;\n        var marginRight = box.offsetWidth - clone.offsetWidth - 2 - marginLeft;\n\n        this.document.body.removeChild(box);\n\n        return {top:marginTop+offsetTop, left:marginLeft, bottom:marginBottom-offsetTop, right:marginRight};\n    },\n\n    getFontSizeInPixels: function(el)\n    {\n        var size = this.getMeasurement(el, "fontSize");\n\n        if (size.unit == "px") return size.value;\n\n        // get font size, the dirty way\n        var computeDirtyFontSize = function(el, calibration)\n        {\n            var div = this.document.createElement("div");\n            var divStyle = offscreenStyle;\n\n            if (calibration)\n                divStyle +=  " font-size:"+calibration+"px;";\n\n            div.style.cssText = divStyle;\n            div.innerHTML = "A";\n            el.appendChild(div);\n\n            var value = div.offsetHeight;\n            el.removeChild(div);\n            return value;\n        };\n\n        /*\n        var calibrationBase = 200;\n        var calibrationValue = computeDirtyFontSize(el, calibrationBase);\n        var rate = calibrationBase / calibrationValue;\n        /**/\n\n        // the "dirty technique" fails in some environments, so we\'re using a static value\n        // based in some tests.\n        var rate = 200 / 225;\n\n        var value = computeDirtyFontSize(el);\n\n        return value * rate;\n    },\n\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Unit Funtions\n\n    pointsToPixels: function(name, value, returnFloat)\n    {\n        var axis = /Top$|Bottom$/.test(name) ? "y" : "x";\n\n        var result = value * pixelsPerInch[axis] / 72;\n\n        return returnFloat ? result : Math.round(result);\n    },\n\n    emToPixels: function(el, value)\n    {\n        if (!el) return null;\n\n        var fontSize = this.getFontSizeInPixels(el);\n\n        return Math.round(value * fontSize);\n    },\n\n    exToPixels: function(el, value)\n    {\n        if (!el) return null;\n\n        // get ex value, the dirty way\n        var div = this.document.createElement("div");\n        div.style.cssText = offscreenStyle + "width:"+value + "ex;";\n\n        el.appendChild(div);\n        var value = div.offsetWidth;\n        el.removeChild(div);\n\n        return value;\n    },\n\n    percentToPixels: function(el, value)\n    {\n        if (!el) return null;\n\n        // get % value, the dirty way\n        var div = this.document.createElement("div");\n        div.style.cssText = offscreenStyle + "width:"+value + "%;";\n\n        el.appendChild(div);\n        var value = div.offsetWidth;\n        el.removeChild(div);\n\n        return value;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getStyle: isIE ? function(el, name)\n    {\n        return el.currentStyle[name] || el.style[name] || undefined;\n    }\n    : function(el, name)\n    {\n        return this.document.defaultView.getComputedStyle(el,null)[name]\n            || el.style[name] || undefined;\n    }\n\n};\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns( /**@scope ns-chrome*/ function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Globals\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Window Options\n\nvar WindowDefaultOptions =\n    {\n        type: "frame",\n        id: "FirebugUI"\n        //height: 350 // obsolete\n    },\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Instantiated objects\n\n    commandLine,\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Interface Elements Cache\n\n    fbTop,\n    fbContent,\n    fbContentStyle,\n    fbBottom,\n    fbBtnInspect,\n\n    fbToolbar,\n\n    fbPanelBox1,\n    fbPanelBox1Style,\n    fbPanelBox2,\n    fbPanelBox2Style,\n    fbPanelBar2Box,\n    fbPanelBar2BoxStyle,\n\n    fbHSplitter,\n    fbVSplitter,\n    fbVSplitterStyle,\n\n    fbPanel1,\n    fbPanel1Style,\n    fbPanel2,\n    fbPanel2Style,\n\n    fbConsole,\n    fbConsoleStyle,\n    fbHTML,\n\n    fbCommandLine,\n    fbLargeCommandLine,\n    fbLargeCommandButtons,\n\n//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Cached size values\n\n    topHeight,\n    topPartialHeight,\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    chromeRedrawSkipRate = isIE ? 75 : isOpera ? 80 : 75,\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    lastSelectedPanelName,\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    focusCommandLineState = 0,\n    lastFocusedPanelName,\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    lastHSplitterMouseMove = 0,\n    onHSplitterMouseMoveBuffer = null,\n    onHSplitterMouseMoveTimer = null,\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    lastVSplitterMouseMove = 0;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n// ************************************************************************************************\n// FirebugChrome\n\nFBL.defaultPersistedState =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    isOpen: false,\n    height: 300,\n    sidePanelWidth: 350,\n\n    selectedPanelName: "Console",\n    selectedHTMLElementId: null,\n\n    htmlSelectionStack: []\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n};\n\n/**@namespace*/\nFBL.FirebugChrome =\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    //isOpen: false,\n    //height: 300,\n    //sidePanelWidth: 350,\n\n    //selectedPanelName: "Console",\n    //selectedHTMLElementId: null,\n\n    chromeMap: {},\n\n    htmlSelectionStack: [],\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    create: function()\n    {\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("FirebugChrome.create", "creating chrome window");\n\n        createChromeWindow();\n    },\n\n    initialize: function()\n    {\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("FirebugChrome.initialize", "initializing chrome window");\n\n        if (Env.chrome.type == "frame" || Env.chrome.type == "div")\n            ChromeMini.create(Env.chrome);\n\n        var chrome = Firebug.chrome = new Chrome(Env.chrome);\n        FirebugChrome.chromeMap[chrome.type] = chrome;\n\n        addGlobalEvent("keydown", onGlobalKeyDown);\n\n        if (Env.Options.enablePersistent && chrome.type == "popup")\n        {\n            // TODO: xxxpedro persist - revise chrome synchronization when in persistent mode\n            var frame = FirebugChrome.chromeMap.frame;\n            if (frame)\n                frame.close();\n\n            //chrome.reattach(frame, chrome);\n            //TODO: xxxpedro persist synchronize?\n            chrome.initialize();\n        }\n    },\n\n    clone: function(FBChrome)\n    {\n        for (var name in FBChrome)\n        {\n            var prop = FBChrome[name];\n            if (FBChrome.hasOwnProperty(name) && !isFunction(prop))\n            {\n                this[name] = prop;\n            }\n        }\n    }\n};\n\n\n\n// ************************************************************************************************\n// Chrome Window Creation\n\nvar createChromeWindow = function(options)\n{\n    options = extend(WindowDefaultOptions, options || {});\n\n    //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Locals\n\n    var browserWin = Env.browser.window;\n    var browserContext = new Context(browserWin);\n    var prefs = Store.get("FirebugLite");\n    var persistedState = prefs && prefs.persistedState || defaultPersistedState;\n\n    var chrome = {},\n\n        context = options.context || Env.browser,\n\n        type = chrome.type = Env.Options.enablePersistent ?\n                "popup" :\n                options.type,\n\n        isChromeFrame = type == "frame",\n\n        useLocalSkin = Env.useLocalSkin,\n\n        url = useLocalSkin ?\n                Env.Location.skin :\n                "about:blank",\n\n        // document.body not available in XML+XSL documents in Firefox\n        body = context.document.getElementsByTagName("body")[0],\n\n        formatNode = function(node)\n        {\n            if (!Env.isDebugMode)\n            {\n                node.firebugIgnore = true;\n            }\n\n            var browserWinSize = browserContext.getWindowSize();\n            var height = persistedState.height || 300;\n\n            height = Math.min(browserWinSize.height, height);\n            height = Math.max(200, height);\n\n            node.style.border = "0";\n            node.style.visibility = "hidden";\n            node.style.zIndex = "2147483647"; // MAX z-index = 2147483647\n            node.style.position = noFixedPosition ? "absolute" : "fixed";\n            node.style.width = "100%"; // "102%"; IE auto margin bug\n            node.style.left = "0";\n            node.style.bottom = noFixedPosition ? "-1px" : "0";\n            node.style.height = height + "px";\n\n            // avoid flickering during chrome rendering\n            //if (isFirefox)\n            //    node.style.display = "none";\n        },\n\n        createChromeDiv = function()\n        {\n            //Firebug.Console.warn("Firebug Lite GUI is working in \'windowless mode\'. It may behave slower and receive interferences from the page in which it is installed.");\n\n            var node = chrome.node = createGlobalElement("div"),\n                style = createGlobalElement("style"),\n\n                css = FirebugChrome.Skin.CSS\n                        /*\n                        .replace(/;/g, " !important;")\n                        .replace(/!important\\s!important/g, "!important")\n                        .replace(/display\\s*:\\s*(\\w+)\\s*!important;/g, "display:$1;")*/,\n\n                        // reset some styles to minimize interference from the main page\'s style\n                rules = ".fbBody *{margin:0;padding:0;font-size:11px;line-height:13px;color:inherit;}" +\n                        // load the chrome styles\n                        css +\n                        // adjust some remaining styles\n                        ".fbBody #fbHSplitter{position:absolute !important;} .fbBody #fbHTML span{line-height:14px;} .fbBody .lineNo div{line-height:inherit !important;}";\n            /*\n            if (isIE)\n            {\n                // IE7 CSS bug (FbChrome table bigger than its parent div)\n                rules += ".fbBody table.fbChrome{position: static !important;}";\n            }/**/\n\n            style.type = "text/css";\n\n            if (style.styleSheet)\n                style.styleSheet.cssText = rules;\n            else\n                style.appendChild(context.document.createTextNode(rules));\n\n            document.getElementsByTagName("head")[0].appendChild(style);\n\n            node.className = "fbBody";\n            node.style.overflow = "hidden";\n            node.innerHTML = getChromeDivTemplate();\n\n            if (isIE)\n            {\n                // IE7 CSS bug (FbChrome table bigger than its parent div)\n                setTimeout(function(){\n                node.firstChild.style.height = "1px";\n                node.firstChild.style.position = "static";\n                },0);\n                /**/\n            }\n\n            formatNode(node);\n\n            body.appendChild(node);\n\n            chrome.window = window;\n            chrome.document = document;\n            onChromeLoad(chrome);\n        };\n\n    //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    try\n    {\n        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // create the Chrome as a "div" (windowless mode)\n        if (type == "div")\n        {\n            createChromeDiv();\n            return;\n        }\n\n        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // cretate the Chrome as an "iframe"\n        else if (isChromeFrame)\n        {\n            // Create the Chrome Frame\n            var node = chrome.node = createGlobalElement("iframe");\n            node.setAttribute("src", url);\n            node.setAttribute("frameBorder", "0");\n\n            formatNode(node);\n\n            body.appendChild(node);\n\n            // must set the id after appending to the document, otherwise will cause an\n            // strange error in IE, making the iframe load the page in which the bookmarklet\n            // was created (like getfirebug.com), before loading the injected UI HTML,\n            // generating an "Access Denied" error.\n            node.id = options.id;\n        }\n\n        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // create the Chrome as a "popup"\n        else\n        {\n            var height = persistedState.popupHeight || 300;\n            var browserWinSize = browserContext.getWindowSize();\n\n            var browserWinLeft = typeof browserWin.screenX == "number" ?\n                    browserWin.screenX : browserWin.screenLeft;\n\n            var popupLeft = typeof persistedState.popupLeft == "number" ?\n                    persistedState.popupLeft : browserWinLeft;\n\n            var browserWinTop = typeof browserWin.screenY == "number" ?\n                    browserWin.screenY : browserWin.screenTop;\n\n            var popupTop = typeof persistedState.popupTop == "number" ?\n                    persistedState.popupTop :\n                    Math.max(\n                            0,\n                            Math.min(\n                                    browserWinTop + browserWinSize.height - height,\n                                    // Google Chrome bug\n                                    screen.availHeight - height - 61\n                                )\n                            );\n\n            var popupWidth = typeof persistedState.popupWidth == "number" ?\n                    persistedState.popupWidth :\n                    Math.max(\n                            0,\n                            Math.min(\n                                    browserWinSize.width,\n                                    // Opera opens popup in a new tab if it\'s too big!\n                                    screen.availWidth-10\n                                )\n                            );\n\n            var popupHeight = typeof persistedState.popupHeight == "number" ?\n                    persistedState.popupHeight : 300;\n\n            var options = [\n                    "true,top=", popupTop,\n                    ",left=", popupLeft,\n                    ",height=", popupHeight,\n                    ",width=", popupWidth,\n                    ",resizable"\n                ].join(""),\n\n                node = chrome.node = context.window.open(\n                    url,\n                    "popup",\n                    options\n                );\n\n            if (node)\n            {\n                try\n                {\n                    node.focus();\n                }\n                catch(E)\n                {\n                    alert("Firebug Error: Firebug popup was blocked.");\n                    return;\n                }\n            }\n            else\n            {\n                alert("Firebug Error: Firebug popup was blocked.");\n                return;\n            }\n        }\n\n        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // Inject the interface HTML if it is not using the local skin\n\n        if (!useLocalSkin)\n        {\n            var tpl = getChromeTemplate(!isChromeFrame),\n                doc = isChromeFrame ? node.contentWindow.document : node.document;\n\n            doc.write(tpl);\n            doc.close();\n        }\n\n        //* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // Wait the Window to be loaded\n\n        var win,\n\n            waitDelay = useLocalSkin ? isChromeFrame ? 200 : 300 : 100,\n\n            waitForWindow = function()\n            {\n                if ( // Frame loaded... OR\n                     isChromeFrame && (win=node.contentWindow) &&\n                     node.contentWindow.document.getElementById("fbCommandLine") ||\n\n                     // Popup loaded\n                     !isChromeFrame && (win=node.window) && node.document &&\n                     node.document.getElementById("fbCommandLine") )\n                {\n                    chrome.window = win.window;\n                    chrome.document = win.document;\n\n                    // Prevent getting the wrong chrome height in FF when opening a popup\n                    setTimeout(function(){\n                        onChromeLoad(chrome);\n                    }, useLocalSkin ? 200 : 0);\n                }\n                else\n                    setTimeout(waitForWindow, waitDelay);\n            };\n\n        waitForWindow();\n    }\n    catch(e)\n    {\n        var msg = e.message || e;\n\n        if (/access/i.test(msg))\n        {\n            // Firebug Lite could not create a window for its Graphical User Interface due to\n            // a access restriction. This happens in some pages, when loading via bookmarklet.\n            // In such cases, the only way is to load the GUI in a "windowless mode".\n\n            if (isChromeFrame)\n                body.removeChild(node);\n            else if(type == "popup")\n                node.close();\n\n            // Load the GUI in a "windowless mode"\n            createChromeDiv();\n        }\n        else\n        {\n            alert("Firebug Error: Firebug GUI could not be created.");\n        }\n    }\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar onChromeLoad = function onChromeLoad(chrome)\n{\n    Env.chrome = chrome;\n\n    if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Chrome onChromeLoad", "chrome window loaded");\n\n    if (Env.Options.enablePersistent)\n    {\n        // TODO: xxxpedro persist - make better chrome synchronization when in persistent mode\n        Env.FirebugChrome = FirebugChrome;\n\n        chrome.window.Firebug = chrome.window.Firebug || {};\n        chrome.window.Firebug.SharedEnv = Env;\n\n        if (Env.isDevelopmentMode)\n        {\n            Env.browser.window.FBDev.loadChromeApplication(chrome);\n        }\n        else\n        {\n            var doc = chrome.document;\n            var script = doc.createElement("script");\n            script.src = Env.Location.app + "#remote,persist";\n            doc.getElementsByTagName("head")[0].appendChild(script);\n        }\n    }\n    else\n    {\n        if (chrome.type == "frame" || chrome.type == "div")\n        {\n            // initialize the chrome application\n            setTimeout(function(){\n                FBL.Firebug.initialize();\n            },0);\n        }\n        else if (chrome.type == "popup")\n        {\n            var oldChrome = FirebugChrome.chromeMap.frame;\n\n            var newChrome = new Chrome(chrome);\n\n            // TODO: xxxpedro sync detach reattach attach\n            dispatch(newChrome.panelMap, "detach", [oldChrome, newChrome]);\n\n            newChrome.reattach(oldChrome, newChrome);\n        }\n    }\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar getChromeDivTemplate = function()\n{\n    return FirebugChrome.Skin.HTML;\n};\n\nvar getChromeTemplate = function(isPopup)\n{\n    var tpl = FirebugChrome.Skin;\n    var r = [], i = -1;\n\n    r[++i] = \'<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/DTD/strict.dtd">\';\n    r[++i] = \'<html><head><title>\';\n    r[++i] = Firebug.version;\n\n    /*\n    r[++i] = \'</title><link href="\';\n    r[++i] = Env.Location.skinDir + \'firebug.css\';\n    r[++i] = \'" rel="stylesheet" type="text/css" />\';\n    /**/\n\n    r[++i] = \'</title><style>html,body{margin:0;padding:0;overflow:hidden;}\';\n    r[++i] = tpl.CSS;\n    r[++i] = \'</style>\';\n    /**/\n\n    r[++i] = \'</head><body class="fbBody\' + (isPopup ? \' FirebugPopup\' : \'\') + \'">\';\n    r[++i] = tpl.HTML;\n    r[++i] = \'</body></html>\';\n\n    return r.join("");\n};\n\n\n// ************************************************************************************************\n// Chrome Class\n\n/**@class*/\nvar Chrome = function Chrome(chrome)\n{\n    var type = chrome.type;\n    var Base = type == "frame" || type == "div" ? ChromeFrameBase : ChromePopupBase;\n\n    append(this, Base);   // inherit from base class (ChromeFrameBase or ChromePopupBase)\n    append(this, chrome); // inherit chrome window properties\n    append(this, new Context(chrome.window)); // inherit from Context class\n\n    FirebugChrome.chromeMap[type] = this;\n    Firebug.chrome = this;\n    Env.chrome = chrome.window;\n\n    this.commandLineVisible = false;\n    this.sidePanelVisible = false;\n\n    this.create();\n\n    return this;\n};\n\n// ************************************************************************************************\n// ChromeBase\n\n/**\n * @namespace\n * @extends FBL.Controller\n * @extends FBL.PanelBar\n **/\nvar ChromeBase = {};\nappend(ChromeBase, Controller);\nappend(ChromeBase, PanelBar);\nappend(ChromeBase,\n/**@extend ns-chrome-ChromeBase*/\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // inherited properties\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // inherited from createChrome function\n\n    node: null,\n    type: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // inherited from Context.prototype\n\n    document: null,\n    window: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // value properties\n\n    sidePanelVisible: false,\n    commandLineVisible: false,\n    largeCommandLineVisible: false,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // object properties\n\n    inspectButton: null,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    create: function()\n    {\n        PanelBar.create.call(this);\n\n        if (Firebug.Inspector)\n            this.inspectButton = new Button({\n                type: "toggle",\n                element: $("fbChrome_btInspect"),\n                owner: Firebug.Inspector,\n\n                onPress: Firebug.Inspector.startInspecting,\n                onUnpress: Firebug.Inspector.stopInspecting\n            });\n    },\n\n    destroy: function()\n    {\n        if(Firebug.Inspector)\n            this.inspectButton.destroy();\n\n        PanelBar.destroy.call(this);\n\n        this.shutdown();\n    },\n\n    testMenu: function()\n    {\n        var firebugMenu = new Menu(\n        {\n            id: "fbFirebugMenu",\n\n            items:\n            [\n                {\n                    label: "Open Firebug",\n                    type: "shortcut",\n                    key: isFirefox ? "Shift+F12" : "F12",\n                    checked: true,\n                    command: "toggleChrome"\n                },\n                {\n                    label: "Open Firebug in New Window",\n                    type: "shortcut",\n                    key: isFirefox ? "Ctrl+Shift+F12" : "Ctrl+F12",\n                    command: "openPopup"\n                },\n                {\n                    label: "Inspect Element",\n                    type: "shortcut",\n                    key: "Ctrl+Shift+C",\n                    command: "toggleInspect"\n                },\n                {\n                    label: "Command Line",\n                    type: "shortcut",\n                    key: "Ctrl+Shift+L",\n                    command: "focusCommandLine"\n                },\n                "-",\n                {\n                    label: "Options",\n                    type: "group",\n                    child: "fbFirebugOptionsMenu"\n                },\n                "-",\n                {\n                    label: "Firebug Lite Website...",\n                    command: "visitWebsite"\n                },\n                {\n                    label: "Discussion Group...",\n                    command: "visitDiscussionGroup"\n                },\n                {\n                    label: "Issue Tracker...",\n                    command: "visitIssueTracker"\n                }\n            ],\n\n            onHide: function()\n            {\n                iconButton.restore();\n            },\n\n            toggleChrome: function()\n            {\n                Firebug.chrome.toggle();\n            },\n\n            openPopup: function()\n            {\n                Firebug.chrome.toggle(true, true);\n            },\n\n            toggleInspect: function()\n            {\n                Firebug.Inspector.toggleInspect();\n            },\n\n            focusCommandLine: function()\n            {\n                Firebug.chrome.focusCommandLine();\n            },\n\n            visitWebsite: function()\n            {\n                this.visit("http://getfirebug.com/lite.html");\n            },\n\n            visitDiscussionGroup: function()\n            {\n                this.visit("http://groups.google.com/group/firebug");\n            },\n\n            visitIssueTracker: function()\n            {\n                this.visit("http://code.google.com/p/fbug/issues/list");\n            },\n\n            visit: function(url)\n            {\n                window.open(url);\n            }\n\n        });\n\n        /**@private*/\n        var firebugOptionsMenu =\n        {\n            id: "fbFirebugOptionsMenu",\n\n            getItems: function()\n            {\n                var cookiesDisabled = !Firebug.saveCookies;\n\n                return [\n                    {\n                        label: "Start Opened",\n                        type: "checkbox",\n                        value: "startOpened",\n                        checked: Firebug.startOpened,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Start in New Window",\n                        type: "checkbox",\n                        value: "startInNewWindow",\n                        checked: Firebug.startInNewWindow,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Show Icon When Hidden",\n                        type: "checkbox",\n                        value: "showIconWhenHidden",\n                        checked: Firebug.showIconWhenHidden,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Override Console Object",\n                        type: "checkbox",\n                        value: "overrideConsole",\n                        checked: Firebug.overrideConsole,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Ignore Firebug Elements",\n                        type: "checkbox",\n                        value: "ignoreFirebugElements",\n                        checked: Firebug.ignoreFirebugElements,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Disable When Firebug Active",\n                        type: "checkbox",\n                        value: "disableWhenFirebugActive",\n                        checked: Firebug.disableWhenFirebugActive,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Disable XHR Listener",\n                        type: "checkbox",\n                        value: "disableXHRListener",\n                        checked: Firebug.disableXHRListener,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Disable Resource Fetching",\n                        type: "checkbox",\n                        value: "disableResourceFetching",\n                        checked: Firebug.disableResourceFetching,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Enable Trace Mode",\n                        type: "checkbox",\n                        value: "enableTrace",\n                        checked: Firebug.enableTrace,\n                        disabled: cookiesDisabled\n                    },\n                    {\n                        label: "Enable Persistent Mode (experimental)",\n                        type: "checkbox",\n                        value: "enablePersistent",\n                        checked: Firebug.enablePersistent,\n                        disabled: cookiesDisabled\n                    },\n                    "-",\n                    {\n                        label: "Reset All Firebug Options",\n                        command: "restorePrefs",\n                        disabled: cookiesDisabled\n                    }\n                ];\n            },\n\n            onCheck: function(target, value, checked)\n            {\n                Firebug.setPref(value, checked);\n            },\n\n            restorePrefs: function(target)\n            {\n                Firebug.erasePrefs();\n\n                if (target)\n                    this.updateMenu(target);\n            },\n\n            updateMenu: function(target)\n            {\n                var options = getElementsByClass(target.parentNode, "fbMenuOption");\n\n                var firstOption = options[0];\n                var enabled = Firebug.saveCookies;\n                if (enabled)\n                    Menu.check(firstOption);\n                else\n                    Menu.uncheck(firstOption);\n\n                if (enabled)\n                    Menu.check(options[0]);\n                else\n                    Menu.uncheck(options[0]);\n\n                for (var i = 1, length = options.length; i < length; i++)\n                {\n                    var option = options[i];\n\n                    var value = option.getAttribute("value");\n                    var pref = Firebug[value];\n\n                    if (pref)\n                        Menu.check(option);\n                    else\n                        Menu.uncheck(option);\n\n                    if (enabled)\n                        Menu.enable(option);\n                    else\n                        Menu.disable(option);\n                }\n            }\n        };\n\n        Menu.register(firebugOptionsMenu);\n\n        var menu = firebugMenu;\n\n        var testMenuClick = function(event)\n        {\n            //console.log("testMenuClick");\n            cancelEvent(event, true);\n\n            var target = event.target || event.srcElement;\n\n            if (menu.isVisible)\n                menu.hide();\n            else\n            {\n                var offsetLeft = isIE6 ? 1 : -4,  // IE6 problem with fixed position\n\n                    chrome = Firebug.chrome,\n\n                    box = chrome.getElementBox(target),\n\n                    offset = chrome.type == "div" ?\n                            chrome.getElementPosition(chrome.node) :\n                            {top: 0, left: 0};\n\n                menu.show(\n                            box.left + offsetLeft - offset.left,\n                            box.top + box.height -5 - offset.top\n                        );\n            }\n\n            return false;\n        };\n\n        var iconButton = new IconButton({\n            type: "toggle",\n            element: $("fbFirebugButton"),\n\n            onClick: testMenuClick\n        });\n\n        iconButton.initialize();\n\n        //addEvent($("fbToolbarIcon"), "click", testMenuClick);\n    },\n\n    initialize: function()\n    {\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        if (Env.bookmarkletOutdated)\n            Firebug.Console.logFormatted([\n                  "A new bookmarklet version is available. " +\n                  "Please visit http://getfirebug.com/firebuglite#Install and update it."\n                ], Firebug.context, "warn");\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        if (Firebug.Console)\n            Firebug.Console.flush();\n\n        if (Firebug.Trace)\n            FBTrace.flush(Firebug.Trace);\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.chrome.initialize", "initializing chrome application");\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // initialize inherited classes\n        Controller.initialize.call(this);\n        PanelBar.initialize.call(this);\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // create the interface elements cache\n\n        fbTop = $("fbTop");\n        fbContent = $("fbContent");\n        fbContentStyle = fbContent.style;\n        fbBottom = $("fbBottom");\n        fbBtnInspect = $("fbBtnInspect");\n\n        fbToolbar = $("fbToolbar");\n\n        fbPanelBox1 = $("fbPanelBox1");\n        fbPanelBox1Style = fbPanelBox1.style;\n        fbPanelBox2 = $("fbPanelBox2");\n        fbPanelBox2Style = fbPanelBox2.style;\n        fbPanelBar2Box = $("fbPanelBar2Box");\n        fbPanelBar2BoxStyle = fbPanelBar2Box.style;\n\n        fbHSplitter = $("fbHSplitter");\n        fbVSplitter = $("fbVSplitter");\n        fbVSplitterStyle = fbVSplitter.style;\n\n        fbPanel1 = $("fbPanel1");\n        fbPanel1Style = fbPanel1.style;\n        fbPanel2 = $("fbPanel2");\n        fbPanel2Style = fbPanel2.style;\n\n        fbConsole = $("fbConsole");\n        fbConsoleStyle = fbConsole.style;\n        fbHTML = $("fbHTML");\n\n        fbCommandLine = $("fbCommandLine");\n        fbLargeCommandLine = $("fbLargeCommandLine");\n        fbLargeCommandButtons = $("fbLargeCommandButtons");\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // static values cache\n        topHeight = fbTop.offsetHeight;\n        topPartialHeight = fbToolbar.offsetHeight;\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n        disableTextSelection($("fbToolbar"));\n        disableTextSelection($("fbPanelBarBox"));\n        disableTextSelection($("fbPanelBar1"));\n        disableTextSelection($("fbPanelBar2"));\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // Add the "javascript:void(0)" href attributes used to make the hover effect in IE6\n        if (isIE6 && Firebug.Selector)\n        {\n            // TODO: xxxpedro change to getElementsByClass\n            var as = $$(".fbHover");\n            for (var i=0, a; a=as[i]; i++)\n            {\n                a.setAttribute("href", "javascript:void(0)");\n            }\n        }\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // initialize all panels\n        /*\n        var panelMap = Firebug.panelTypes;\n        for (var i=0, p; p=panelMap[i]; i++)\n        {\n            if (!p.parentPanel)\n            {\n                this.addPanel(p.prototype.name);\n            }\n        }\n        /**/\n\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n\n        if(Firebug.Inspector)\n            this.inspectButton.initialize();\n\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n\n        this.addController(\n            [$("fbLargeCommandLineIcon"), "click", this.showLargeCommandLine]\n        );\n\n        // ************************************************************************************************\n\n        // Select the first registered panel\n        // TODO: BUG IE7\n        var self = this;\n        setTimeout(function(){\n            self.selectPanel(Firebug.context.persistedState.selectedPanelName);\n\n            if (Firebug.context.persistedState.selectedPanelName == "Console" && Firebug.CommandLine)\n                Firebug.chrome.focusCommandLine();\n        },0);\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        //this.draw();\n\n\n\n\n\n\n\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n        var onPanelMouseDown = function onPanelMouseDown(event)\n        {\n            //console.log("onPanelMouseDown", event.target || event.srcElement, event);\n\n            var target = event.target || event.srcElement;\n\n            if (FBL.isLeftClick(event))\n            {\n                var editable = FBL.getAncestorByClass(target, "editable");\n\n                // if an editable element has been clicked then start editing\n                if (editable)\n                {\n                    Firebug.Editor.startEditing(editable);\n                    FBL.cancelEvent(event);\n                }\n                // if any other element has been clicked then stop editing\n                else\n                {\n                    if (!hasClass(target, "textEditorInner"))\n                        Firebug.Editor.stopEditing();\n                }\n            }\n            else if (FBL.isMiddleClick(event) && Firebug.getRepNode(target))\n            {\n                // Prevent auto-scroll when middle-clicking a rep object\n                FBL.cancelEvent(event);\n            }\n        };\n\n        Firebug.getElementPanel = function(element)\n        {\n            var panelNode = getAncestorByClass(element, "fbPanel");\n            var id = panelNode.id.substr(2);\n\n            var panel = Firebug.chrome.panelMap[id];\n\n            if (!panel)\n            {\n                if (Firebug.chrome.selectedPanel.sidePanelBar)\n                    panel = Firebug.chrome.selectedPanel.sidePanelBar.panelMap[id];\n            }\n\n            return panel;\n        };\n\n\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n        // TODO: xxxpedro port to Firebug\n\n        // Improved window key code event listener. Only one "keydown" event will be attached\n        // to the window, and the onKeyCodeListen() function will delegate which listeners\n        // should be called according to the event.keyCode fired.\n        var onKeyCodeListenersMap = [];\n        var onKeyCodeListen = function(event)\n        {\n            for (var keyCode in onKeyCodeListenersMap)\n            {\n                var listeners = onKeyCodeListenersMap[keyCode];\n\n                for (var i = 0, listener; listener = listeners[i]; i++)\n                {\n                    var filter = listener.filter || FBL.noKeyModifiers;\n\n                    if (event.keyCode == keyCode && (!filter || filter(event)))\n                    {\n                        listener.listener();\n                        FBL.cancelEvent(event, true);\n                        return false;\n                    }\n                }\n            }\n        };\n\n        addEvent(Firebug.chrome.document, "keydown", onKeyCodeListen);\n\n        /**\n         * @name keyCodeListen\n         * @memberOf FBL.FirebugChrome\n         */\n        Firebug.chrome.keyCodeListen = function(key, filter, listener, capture)\n        {\n            var keyCode = KeyEvent["DOM_VK_"+key];\n\n            if (!onKeyCodeListenersMap[keyCode])\n                onKeyCodeListenersMap[keyCode] = [];\n\n            onKeyCodeListenersMap[keyCode].push({\n                filter: filter,\n                listener: listener\n            });\n\n            return keyCode;\n        };\n\n        /**\n         * @name keyIgnore\n         * @memberOf FBL.FirebugChrome\n         */\n        Firebug.chrome.keyIgnore = function(keyCode)\n        {\n            onKeyCodeListenersMap[keyCode] = null;\n            delete onKeyCodeListenersMap[keyCode];\n        };\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n        /**/\n        // move to shutdown\n        //removeEvent(Firebug.chrome.document, "keydown", listener[0]);\n\n\n        /*\n        Firebug.chrome.keyCodeListen = function(key, filter, listener, capture)\n        {\n            if (!filter)\n                filter = FBL.noKeyModifiers;\n\n            var keyCode = KeyEvent["DOM_VK_"+key];\n\n            var fn = function fn(event)\n            {\n                if (event.keyCode == keyCode && (!filter || filter(event)))\n                {\n                    listener();\n                    FBL.cancelEvent(event, true);\n                    return false;\n                }\n            }\n\n            addEvent(Firebug.chrome.document, "keydown", fn);\n\n            return [fn, capture];\n        };\n\n        Firebug.chrome.keyIgnore = function(listener)\n        {\n            removeEvent(Firebug.chrome.document, "keydown", listener[0]);\n        };\n        /**/\n\n\n        this.addController(\n                [fbPanel1, "mousedown", onPanelMouseDown],\n                [fbPanel2, "mousedown", onPanelMouseDown]\n             );\n/**/\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n        // menus can be used without domplate\n        if (FBL.domplate)\n            this.testMenu();\n        /**/\n\n        //test XHR\n        /*\n        setTimeout(function(){\n\n        FBL.Ajax.request({url: "../content/firebug/boot.js"});\n        FBL.Ajax.request({url: "../content/firebug/boot.js.invalid"});\n\n        },1000);\n        /**/\n    },\n\n    shutdown: function()\n    {\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n\n        if(Firebug.Inspector)\n            this.inspectButton.shutdown();\n\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n        // ************************************************************************************************\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n        // remove disableTextSelection event handlers\n        restoreTextSelection($("fbToolbar"));\n        restoreTextSelection($("fbPanelBarBox"));\n        restoreTextSelection($("fbPanelBar1"));\n        restoreTextSelection($("fbPanelBar2"));\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // shutdown inherited classes\n        Controller.shutdown.call(this);\n        PanelBar.shutdown.call(this);\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // Remove the interface elements cache (this must happen after calling\n        // the shutdown method of all dependent components to avoid errors)\n\n        fbTop = null;\n        fbContent = null;\n        fbContentStyle = null;\n        fbBottom = null;\n        fbBtnInspect = null;\n\n        fbToolbar = null;\n\n        fbPanelBox1 = null;\n        fbPanelBox1Style = null;\n        fbPanelBox2 = null;\n        fbPanelBox2Style = null;\n        fbPanelBar2Box = null;\n        fbPanelBar2BoxStyle = null;\n\n        fbHSplitter = null;\n        fbVSplitter = null;\n        fbVSplitterStyle = null;\n\n        fbPanel1 = null;\n        fbPanel1Style = null;\n        fbPanel2 = null;\n\n        fbConsole = null;\n        fbConsoleStyle = null;\n        fbHTML = null;\n\n        fbCommandLine = null;\n        fbLargeCommandLine = null;\n        fbLargeCommandButtons = null;\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // static values cache\n\n        topHeight = null;\n        topPartialHeight = null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    toggle: function(forceOpen, popup)\n    {\n        if(popup)\n        {\n            this.detach();\n        }\n        else\n        {\n            if (isOpera && Firebug.chrome.type == "popup" && Firebug.chrome.node.closed)\n            {\n                var frame = FirebugChrome.chromeMap.frame;\n                frame.reattach();\n\n                FirebugChrome.chromeMap.popup = null;\n\n                frame.open();\n\n                return;\n            }\n\n            // If the context is a popup, ignores the toggle process\n            if (Firebug.chrome.type == "popup") return;\n\n            var shouldOpen = forceOpen || !Firebug.context.persistedState.isOpen;\n\n            if(shouldOpen)\n               this.open();\n            else\n               this.close();\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    detach: function()\n    {\n        if(!FirebugChrome.chromeMap.popup)\n        {\n            this.close();\n            createChromeWindow({type: "popup"});\n        }\n    },\n\n    reattach: function(oldChrome, newChrome)\n    {\n        Firebug.browser.window.Firebug = Firebug;\n\n        // chrome synchronization\n        var newPanelMap = newChrome.panelMap;\n        var oldPanelMap = oldChrome.panelMap;\n\n        var panel;\n        for(var name in newPanelMap)\n        {\n            // TODO: xxxpedro innerHTML\n            panel = newPanelMap[name];\n            if (panel.options.innerHTMLSync)\n                panel.panelNode.innerHTML = oldPanelMap[name].panelNode.innerHTML;\n        }\n\n        Firebug.chrome = newChrome;\n\n        // TODO: xxxpedro sync detach reattach attach\n        //dispatch(Firebug.chrome.panelMap, "detach", [oldChrome, newChrome]);\n\n        if (newChrome.type == "popup")\n        {\n            newChrome.initialize();\n            //dispatch(Firebug.modules, "initialize", []);\n        }\n        else\n        {\n            // TODO: xxxpedro only needed in persistent\n            // should use FirebugChrome.clone, but popup FBChrome\n            // isn\'t acessible\n            Firebug.context.persistedState.selectedPanelName = oldChrome.selectedPanel.name;\n        }\n\n        dispatch(newPanelMap, "reattach", [oldChrome, newChrome]);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    draw: function()\n    {\n        var size = this.getSize();\n\n        // Height related values\n        var commandLineHeight = Firebug.chrome.commandLineVisible ? fbCommandLine.offsetHeight : 0,\n\n            y = Math.max(size.height /* chrome height */, topHeight),\n\n            heightValue = Math.max(y - topHeight - commandLineHeight /* fixed height */, 0),\n\n            height = heightValue + "px",\n\n            // Width related values\n            sideWidthValue = Firebug.chrome.sidePanelVisible ? Firebug.context.persistedState.sidePanelWidth : 0,\n\n            width = Math.max(size.width /* chrome width */ - sideWidthValue, 0) + "px";\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // Height related rendering\n        fbPanelBox1Style.height = height;\n        fbPanel1Style.height = height;\n\n        if (isIE || isOpera)\n        {\n            // Fix IE and Opera problems with auto resizing the verticall splitter\n            fbVSplitterStyle.height = Math.max(y - topPartialHeight - commandLineHeight, 0) + "px";\n        }\n        //xxxpedro FF2 only?\n        /*\n        else if (isFirefox)\n        {\n            // Fix Firefox problem with table rows with 100% height (fit height)\n            fbContentStyle.maxHeight = Math.max(y - fixedHeight, 0)+ "px";\n        }/**/\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // Width related rendering\n        fbPanelBox1Style.width = width;\n        fbPanel1Style.width = width;\n\n        // SidePanel rendering\n        if (Firebug.chrome.sidePanelVisible)\n        {\n            sideWidthValue = Math.max(sideWidthValue - 6, 0);\n\n            var sideWidth = sideWidthValue + "px";\n\n            fbPanelBox2Style.width = sideWidth;\n\n            fbVSplitterStyle.right = sideWidth;\n\n            if (Firebug.chrome.largeCommandLineVisible)\n            {\n                fbLargeCommandLine = $("fbLargeCommandLine");\n\n                fbLargeCommandLine.style.height = heightValue - 4 + "px";\n                fbLargeCommandLine.style.width = sideWidthValue - 2 + "px";\n\n                fbLargeCommandButtons = $("fbLargeCommandButtons");\n                fbLargeCommandButtons.style.width = sideWidth;\n            }\n            else\n            {\n                fbPanel2Style.height = height;\n                fbPanel2Style.width = sideWidth;\n\n                fbPanelBar2BoxStyle.width = sideWidth;\n            }\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getSize: function()\n    {\n        return this.type == "div" ?\n            {\n                height: this.node.offsetHeight,\n                width: this.node.offsetWidth\n            }\n            :\n            this.getWindowSize();\n    },\n\n    resize: function()\n    {\n        var self = this;\n\n        // avoid partial resize when maximizing window\n        setTimeout(function(){\n            self.draw();\n\n            if (noFixedPosition && (self.type == "frame" || self.type == "div"))\n                self.fixIEPosition();\n        }, 0);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    layout: function(panel)\n    {\n        if (FBTrace.DBG_CHROME) FBTrace.sysout("Chrome.layout", "");\n\n        var options = panel.options;\n\n        changeCommandLineVisibility(options.hasCommandLine);\n        changeSidePanelVisibility(panel.hasSidePanel);\n\n        Firebug.chrome.draw();\n    },\n\n    showLargeCommandLine: function(hideToggleIcon)\n    {\n        var chrome = Firebug.chrome;\n\n        if (!chrome.largeCommandLineVisible)\n        {\n            chrome.largeCommandLineVisible = true;\n\n            if (chrome.selectedPanel.options.hasCommandLine)\n            {\n                if (Firebug.CommandLine)\n                    Firebug.CommandLine.blur();\n\n                changeCommandLineVisibility(false);\n            }\n\n            changeSidePanelVisibility(true);\n\n            fbLargeCommandLine.style.display = "block";\n            fbLargeCommandButtons.style.display = "block";\n\n            fbPanel2Style.display = "none";\n            fbPanelBar2BoxStyle.display = "none";\n\n            chrome.draw();\n\n            fbLargeCommandLine.focus();\n\n            if (Firebug.CommandLine)\n                Firebug.CommandLine.setMultiLine(true);\n        }\n    },\n\n    hideLargeCommandLine: function()\n    {\n        if (Firebug.chrome.largeCommandLineVisible)\n        {\n            Firebug.chrome.largeCommandLineVisible = false;\n\n            if (Firebug.CommandLine)\n                Firebug.CommandLine.setMultiLine(false);\n\n            fbLargeCommandLine.blur();\n\n            fbPanel2Style.display = "block";\n            fbPanelBar2BoxStyle.display = "block";\n\n            fbLargeCommandLine.style.display = "none";\n            fbLargeCommandButtons.style.display = "none";\n\n            changeSidePanelVisibility(false);\n\n            if (Firebug.chrome.selectedPanel.options.hasCommandLine)\n                changeCommandLineVisibility(true);\n\n            Firebug.chrome.draw();\n\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    focusCommandLine: function()\n    {\n        var selectedPanelName = this.selectedPanel.name, panelToSelect;\n\n        if (focusCommandLineState == 0 || selectedPanelName != "Console")\n        {\n            focusCommandLineState = 0;\n            lastFocusedPanelName = selectedPanelName;\n\n            panelToSelect = "Console";\n        }\n        if (focusCommandLineState == 1)\n        {\n            panelToSelect = lastFocusedPanelName;\n        }\n\n        this.selectPanel(panelToSelect);\n\n        try\n        {\n            if (Firebug.CommandLine)\n            {\n                if (panelToSelect == "Console")\n                    Firebug.CommandLine.focus();\n                else\n                    Firebug.CommandLine.blur();\n            }\n        }\n        catch(e)\n        {\n            //TODO: xxxpedro trace error\n        }\n\n        focusCommandLineState = ++focusCommandLineState % 2;\n    }\n\n});\n\n// ************************************************************************************************\n// ChromeFrameBase\n\n/**\n * @namespace\n * @extends ns-chrome-ChromeBase\n */\nvar ChromeFrameBase = extend(ChromeBase,\n/**@extend ns-chrome-ChromeFrameBase*/\n{\n    create: function()\n    {\n        ChromeBase.create.call(this);\n\n        // restore display for the anti-flicker trick\n        if (isFirefox)\n            this.node.style.display = "block";\n\n        if (Env.Options.startInNewWindow)\n        {\n            this.close();\n            this.toggle(true, true);\n            return;\n        }\n\n        if (Env.Options.startOpened)\n            this.open();\n        else\n            this.close();\n    },\n\n    destroy: function()\n    {\n        var size = Firebug.chrome.getWindowSize();\n\n        Firebug.context.persistedState.height = size.height;\n\n        if (Firebug.saveCookies)\n            Firebug.savePrefs();\n\n        removeGlobalEvent("keydown", onGlobalKeyDown);\n\n        ChromeBase.destroy.call(this);\n\n        this.document = null;\n        delete this.document;\n\n        this.window = null;\n        delete this.window;\n\n        this.node.parentNode.removeChild(this.node);\n        this.node = null;\n        delete this.node;\n    },\n\n    initialize: function()\n    {\n        //FBTrace.sysout("Frame", "initialize();")\n        ChromeBase.initialize.call(this);\n\n        this.addController(\n            [Firebug.browser.window, "resize", this.resize],\n            [$("fbWindow_btClose"), "click", this.close],\n            [$("fbWindow_btDetach"), "click", this.detach],\n            [$("fbWindow_btDeactivate"), "click", this.deactivate]\n        );\n\n        if (!Env.Options.enablePersistent)\n            this.addController([Firebug.browser.window, "unload", Firebug.shutdown]);\n\n        if (noFixedPosition)\n        {\n            this.addController(\n                [Firebug.browser.window, "scroll", this.fixIEPosition]\n            );\n        }\n\n        fbVSplitter.onmousedown = onVSplitterMouseDown;\n        fbHSplitter.onmousedown = onHSplitterMouseDown;\n\n        this.isInitialized = true;\n    },\n\n    shutdown: function()\n    {\n        fbVSplitter.onmousedown = null;\n        fbHSplitter.onmousedown = null;\n\n        ChromeBase.shutdown.apply(this);\n\n        this.isInitialized = false;\n    },\n\n    reattach: function()\n    {\n        var frame = FirebugChrome.chromeMap.frame;\n\n        ChromeBase.reattach(FirebugChrome.chromeMap.popup, this);\n    },\n\n    open: function()\n    {\n        if (!Firebug.context.persistedState.isOpen)\n        {\n            Firebug.context.persistedState.isOpen = true;\n\n            if (Env.isChromeExtension)\n                localStorage.setItem("Firebug", "1,1");\n\n            var node = this.node;\n\n            node.style.visibility = "hidden"; // Avoid flickering\n\n            if (Firebug.showIconWhenHidden)\n            {\n                if (ChromeMini.isInitialized)\n                {\n                    ChromeMini.shutdown();\n                }\n\n            }\n            else\n                node.style.display = "block";\n\n            var main = $("fbChrome");\n\n            // IE6 throws an error when setting this property! why?\n            //main.style.display = "table";\n            main.style.display = "";\n\n            var self = this;\n                /// TODO: xxxpedro FOUC\n                node.style.visibility = "visible";\n            setTimeout(function(){\n                ///node.style.visibility = "visible";\n\n                //dispatch(Firebug.modules, "initialize", []);\n                self.initialize();\n\n                if (noFixedPosition)\n                    self.fixIEPosition();\n\n                self.draw();\n\n            }, 10);\n        }\n    },\n\n    close: function()\n    {\n        if (Firebug.context.persistedState.isOpen)\n        {\n            if (this.isInitialized)\n            {\n                //dispatch(Firebug.modules, "shutdown", []);\n                this.shutdown();\n            }\n\n            Firebug.context.persistedState.isOpen = false;\n\n            if (Env.isChromeExtension)\n                localStorage.setItem("Firebug", "1,0");\n\n            var node = this.node;\n\n            if (Firebug.showIconWhenHidden)\n            {\n                node.style.visibility = "hidden"; // Avoid flickering\n\n                // TODO: xxxpedro - persist IE fixed?\n                var main = $("fbChrome", FirebugChrome.chromeMap.frame.document);\n                main.style.display = "none";\n\n                ChromeMini.initialize();\n\n                node.style.visibility = "visible";\n            }\n            else\n                node.style.display = "none";\n        }\n    },\n\n    deactivate: function()\n    {\n        // if it is running as a Chrome extension, dispatch a message to the extension signaling\n        // that Firebug should be deactivated for the current tab\n        if (Env.isChromeExtension)\n        {\n            localStorage.removeItem("Firebug");\n            Firebug.GoogleChrome.dispatch("FB_deactivate");\n\n            // xxxpedro problem here regarding Chrome extension. We can\'t deactivate the whole\n            // app, otherwise it won\'t be able to be reactivated without reloading the page.\n            // but we need to stop listening global keys, otherwise the key activation won\'t work.\n            Firebug.chrome.close();\n        }\n        else\n        {\n            Firebug.shutdown();\n        }\n    },\n\n    fixIEPosition: function()\n    {\n        // fix IE problem with offset when not in fullscreen mode\n        var doc = this.document;\n        var offset = isIE ? doc.body.clientTop || doc.documentElement.clientTop: 0;\n\n        var size = Firebug.browser.getWindowSize();\n        var scroll = Firebug.browser.getWindowScrollPosition();\n        var maxHeight = size.height;\n        var height = this.node.offsetHeight;\n\n        var bodyStyle = doc.body.currentStyle;\n\n        this.node.style.top = maxHeight - height + scroll.top + "px";\n\n        if ((this.type == "frame" || this.type == "div") &&\n            (bodyStyle.marginLeft || bodyStyle.marginRight))\n        {\n            this.node.style.width = size.width + "px";\n        }\n\n        if (fbVSplitterStyle)\n            fbVSplitterStyle.right = Firebug.context.persistedState.sidePanelWidth + "px";\n\n        this.draw();\n    }\n\n});\n\n\n// ************************************************************************************************\n// ChromeMini\n\n/**\n * @namespace\n * @extends FBL.Controller\n */\nvar ChromeMini = extend(Controller,\n/**@extend ns-chrome-ChromeMini*/\n{\n    create: function(chrome)\n    {\n        append(this, chrome);\n        this.type = "mini";\n    },\n\n    initialize: function()\n    {\n        Controller.initialize.apply(this);\n\n        var doc = FirebugChrome.chromeMap.frame.document;\n\n        var mini = $("fbMiniChrome", doc);\n        mini.style.display = "block";\n\n        var miniIcon = $("fbMiniIcon", doc);\n        var width = miniIcon.offsetWidth + 10;\n        miniIcon.title = "Open " + Firebug.version;\n\n        var errors = $("fbMiniErrors", doc);\n        if (errors.offsetWidth)\n            width += errors.offsetWidth + 10;\n\n        var node = this.node;\n        node.style.height = "27px";\n        node.style.width = width + "px";\n        node.style.left = "";\n        node.style.right = 0;\n\n        if (this.node.nodeName.toLowerCase() == "iframe")\n        {\n            node.setAttribute("allowTransparency", "true");\n            this.document.body.style.backgroundColor = "transparent";\n        }\n        else\n            node.style.background = "transparent";\n\n        if (noFixedPosition)\n            this.fixIEPosition();\n\n        this.addController(\n            [$("fbMiniIcon", doc), "click", onMiniIconClick]\n        );\n\n        if (noFixedPosition)\n        {\n            this.addController(\n                [Firebug.browser.window, "scroll", this.fixIEPosition]\n            );\n        }\n\n        this.isInitialized = true;\n    },\n\n    shutdown: function()\n    {\n        var node = this.node;\n        node.style.height = Firebug.context.persistedState.height + "px";\n        node.style.width = "100%";\n        node.style.left = 0;\n        node.style.right = "";\n\n        if (this.node.nodeName.toLowerCase() == "iframe")\n        {\n            node.setAttribute("allowTransparency", "false");\n            this.document.body.style.backgroundColor = "#fff";\n        }\n        else\n            node.style.background = "#fff";\n\n        if (noFixedPosition)\n            this.fixIEPosition();\n\n        var doc = FirebugChrome.chromeMap.frame.document;\n\n        var mini = $("fbMiniChrome", doc);\n        mini.style.display = "none";\n\n        Controller.shutdown.apply(this);\n\n        this.isInitialized = false;\n    },\n\n    draw: function()\n    {\n\n    },\n\n    fixIEPosition: ChromeFrameBase.fixIEPosition\n\n});\n\n\n// ************************************************************************************************\n// ChromePopupBase\n\n/**\n * @namespace\n * @extends ns-chrome-ChromeBase\n */\nvar ChromePopupBase = extend(ChromeBase,\n/**@extend ns-chrome-ChromePopupBase*/\n{\n\n    initialize: function()\n    {\n        setClass(this.document.body, "FirebugPopup");\n\n        ChromeBase.initialize.call(this);\n\n        this.addController(\n            [Firebug.chrome.window, "resize", this.resize],\n            [Firebug.chrome.window, "unload", this.destroy]\n            //[Firebug.chrome.window, "beforeunload", this.destroy]\n        );\n\n        if (Env.Options.enablePersistent)\n        {\n            this.persist = bind(this.persist, this);\n            addEvent(Firebug.browser.window, "unload", this.persist);\n        }\n        else\n            this.addController(\n                [Firebug.browser.window, "unload", this.close]\n            );\n\n        fbVSplitter.onmousedown = onVSplitterMouseDown;\n    },\n\n    destroy: function()\n    {\n        var chromeWin = Firebug.chrome.window;\n        var left = chromeWin.screenX || chromeWin.screenLeft;\n        var top = chromeWin.screenY || chromeWin.screenTop;\n        var size = Firebug.chrome.getWindowSize();\n\n        Firebug.context.persistedState.popupTop = top;\n        Firebug.context.persistedState.popupLeft = left;\n        Firebug.context.persistedState.popupWidth = size.width;\n        Firebug.context.persistedState.popupHeight = size.height;\n\n        if (Firebug.saveCookies)\n            Firebug.savePrefs();\n\n        // TODO: xxxpedro sync detach reattach attach\n        var frame = FirebugChrome.chromeMap.frame;\n\n        if(frame)\n        {\n            dispatch(frame.panelMap, "detach", [this, frame]);\n\n            frame.reattach(this, frame);\n        }\n\n        if (Env.Options.enablePersistent)\n        {\n            removeEvent(Firebug.browser.window, "unload", this.persist);\n        }\n\n        ChromeBase.destroy.apply(this);\n\n        FirebugChrome.chromeMap.popup = null;\n\n        this.node.close();\n    },\n\n    persist: function()\n    {\n        persistTimeStart = new Date().getTime();\n\n        removeEvent(Firebug.browser.window, "unload", this.persist);\n\n        Firebug.Inspector.destroy();\n        Firebug.browser.window.FirebugOldBrowser = true;\n\n        var persistTimeStart = new Date().getTime();\n\n        var waitMainWindow = function()\n        {\n            var doc, head;\n\n            try\n            {\n                if (window.opener && !window.opener.FirebugOldBrowser && (doc = window.opener.document)/* &&\n                    doc.documentElement && (head = doc.documentElement.firstChild)*/)\n                {\n\n                    try\n                    {\n                        // exposes the FBL to the global namespace when in debug mode\n                        if (Env.isDebugMode)\n                        {\n                            window.FBL = FBL;\n                        }\n\n                        window.Firebug = Firebug;\n                        window.opener.Firebug = Firebug;\n\n                        Env.browser = window.opener;\n                        Firebug.browser = Firebug.context = new Context(Env.browser);\n                        Firebug.loadPrefs();\n\n                        registerConsole();\n\n                        // the delay time should be calculated right after registering the\n                        // console, once right after the console registration, call log messages\n                        // will be properly handled\n                        var persistDelay = new Date().getTime() - persistTimeStart;\n\n                        var chrome = Firebug.chrome;\n                        addEvent(Firebug.browser.window, "unload", chrome.persist);\n\n                        FBL.cacheDocument();\n                        Firebug.Inspector.create();\n\n                        Firebug.Console.logFormatted(\n                            ["Firebug could not capture console calls during " +\n                            persistDelay + "ms"],\n                            Firebug.context,\n                            "info"\n                        );\n\n                        setTimeout(function(){\n                            var htmlPanel = chrome.getPanel("HTML");\n                            htmlPanel.createUI();\n                        },50);\n\n                    }\n                    catch(pE)\n                    {\n                        alert("persist error: " + (pE.message || pE));\n                    }\n\n                }\n                else\n                {\n                    window.setTimeout(waitMainWindow, 0);\n                }\n\n            } catch (E) {\n                window.close();\n            }\n        };\n\n        waitMainWindow();\n    },\n\n    close: function()\n    {\n        this.destroy();\n    }\n\n});\n\n\n//************************************************************************************************\n// UI helpers\n\nvar changeCommandLineVisibility = function changeCommandLineVisibility(visibility)\n{\n    var last = Firebug.chrome.commandLineVisible;\n    var visible = Firebug.chrome.commandLineVisible =\n        typeof visibility == "boolean" ? visibility : !Firebug.chrome.commandLineVisible;\n\n    if (visible != last)\n    {\n        if (visible)\n        {\n            fbBottom.className = "";\n\n            if (Firebug.CommandLine)\n                Firebug.CommandLine.activate();\n        }\n        else\n        {\n            if (Firebug.CommandLine)\n                Firebug.CommandLine.deactivate();\n\n            fbBottom.className = "hide";\n        }\n    }\n};\n\nvar changeSidePanelVisibility = function changeSidePanelVisibility(visibility)\n{\n    var last = Firebug.chrome.sidePanelVisible;\n    Firebug.chrome.sidePanelVisible =\n        typeof visibility == "boolean" ? visibility : !Firebug.chrome.sidePanelVisible;\n\n    if (Firebug.chrome.sidePanelVisible != last)\n    {\n        fbPanelBox2.className = Firebug.chrome.sidePanelVisible ? "" : "hide";\n        fbPanelBar2Box.className = Firebug.chrome.sidePanelVisible ? "" : "hide";\n    }\n};\n\n\n// ************************************************************************************************\n// F12 Handler\n\nvar onGlobalKeyDown = function onGlobalKeyDown(event)\n{\n    var keyCode = event.keyCode;\n    var shiftKey = event.shiftKey;\n    var ctrlKey = event.ctrlKey;\n\n    if (keyCode == 123 /* F12 */ && (!isFirefox && !shiftKey || shiftKey && isFirefox))\n    {\n        Firebug.chrome.toggle(false, ctrlKey);\n        cancelEvent(event, true);\n\n        // TODO: xxxpedro replace with a better solution. we\'re doing this\n        // to allow reactivating with the F12 key after being deactivated\n        if (Env.isChromeExtension)\n        {\n            Firebug.GoogleChrome.dispatch("FB_enableIcon");\n        }\n    }\n    else if (keyCode == 67 /* C */ && ctrlKey && shiftKey)\n    {\n        Firebug.Inspector.toggleInspect();\n        cancelEvent(event, true);\n    }\n    else if (keyCode == 76 /* L */ && ctrlKey && shiftKey)\n    {\n        Firebug.chrome.focusCommandLine();\n        cancelEvent(event, true);\n    }\n};\n\nvar onMiniIconClick = function onMiniIconClick(event)\n{\n    Firebug.chrome.toggle(false, event.ctrlKey);\n    cancelEvent(event, true);\n};\n\n\n// ************************************************************************************************\n// Horizontal Splitter Handling\n\nvar onHSplitterMouseDown = function onHSplitterMouseDown(event)\n{\n    addGlobalEvent("mousemove", onHSplitterMouseMove);\n    addGlobalEvent("mouseup", onHSplitterMouseUp);\n\n    if (isIE)\n        addEvent(Firebug.browser.document.documentElement, "mouseleave", onHSplitterMouseUp);\n\n    fbHSplitter.className = "fbOnMovingHSplitter";\n\n    return false;\n};\n\nvar onHSplitterMouseMove = function onHSplitterMouseMove(event)\n{\n    cancelEvent(event, true);\n\n    var clientY = event.clientY;\n    var win = isIE\n        ? event.srcElement.ownerDocument.parentWindow\n        : event.target.defaultView || event.target.ownerDocument && event.target.ownerDocument.defaultView;\n\n    if (!win)\n        return;\n\n    if (win != win.parent)\n    {\n        var frameElement = win.frameElement;\n        if (frameElement)\n        {\n            var framePos = Firebug.browser.getElementPosition(frameElement).top;\n            clientY += framePos;\n\n            if (frameElement.style.position != "fixed")\n                clientY -= Firebug.browser.getWindowScrollPosition().top;\n        }\n    }\n\n    if (isOpera && isQuiksMode && win.frameElement.id == "FirebugUI")\n    {\n        clientY = Firebug.browser.getWindowSize().height - win.frameElement.offsetHeight + clientY;\n    }\n\n    /*\n    console.log(\n            typeof win.FBL != "undefined" ? "no-Chrome" : "Chrome",\n            //win.frameElement.id,\n            event.target,\n            clientY\n        );/**/\n\n    onHSplitterMouseMoveBuffer = clientY; // buffer\n\n    if (new Date().getTime() - lastHSplitterMouseMove > chromeRedrawSkipRate) // frame skipping\n    {\n        lastHSplitterMouseMove = new Date().getTime();\n        handleHSplitterMouseMove();\n    }\n    else\n        if (!onHSplitterMouseMoveTimer)\n            onHSplitterMouseMoveTimer = setTimeout(handleHSplitterMouseMove, chromeRedrawSkipRate);\n\n    // improving the resizing performance by canceling the mouse event.\n    // canceling events will prevent the page to receive such events, which would imply\n    // in more processing being expended.\n    cancelEvent(event, true);\n    return false;\n};\n\nvar handleHSplitterMouseMove = function()\n{\n    if (onHSplitterMouseMoveTimer)\n    {\n        clearTimeout(onHSplitterMouseMoveTimer);\n        onHSplitterMouseMoveTimer = null;\n    }\n\n    var clientY = onHSplitterMouseMoveBuffer;\n\n    var windowSize = Firebug.browser.getWindowSize();\n    var scrollSize = Firebug.browser.getWindowScrollSize();\n\n    // compute chrome fixed size (top bar and command line)\n    var commandLineHeight = Firebug.chrome.commandLineVisible ? fbCommandLine.offsetHeight : 0;\n    var fixedHeight = topHeight + commandLineHeight;\n    var chromeNode = Firebug.chrome.node;\n\n    var scrollbarSize = !isIE && (scrollSize.width > windowSize.width) ? 17 : 0;\n\n    //var height = !isOpera ? chromeNode.offsetTop + chromeNode.clientHeight : windowSize.height;\n    var height =  windowSize.height;\n\n    // compute the min and max size of the chrome\n    var chromeHeight = Math.max(height - clientY + 5 - scrollbarSize, fixedHeight);\n        chromeHeight = Math.min(chromeHeight, windowSize.height - scrollbarSize);\n\n    Firebug.context.persistedState.height = chromeHeight;\n    chromeNode.style.height = chromeHeight + "px";\n\n    if (noFixedPosition)\n        Firebug.chrome.fixIEPosition();\n\n    Firebug.chrome.draw();\n};\n\nvar onHSplitterMouseUp = function onHSplitterMouseUp(event)\n{\n    removeGlobalEvent("mousemove", onHSplitterMouseMove);\n    removeGlobalEvent("mouseup", onHSplitterMouseUp);\n\n    if (isIE)\n        removeEvent(Firebug.browser.document.documentElement, "mouseleave", onHSplitterMouseUp);\n\n    fbHSplitter.className = "";\n\n    Firebug.chrome.draw();\n\n    // avoid text selection in IE when returning to the document\n    // after the mouse leaves the document during the resizing\n    return false;\n};\n\n\n// ************************************************************************************************\n// Vertical Splitter Handling\n\nvar onVSplitterMouseDown = function onVSplitterMouseDown(event)\n{\n    addGlobalEvent("mousemove", onVSplitterMouseMove);\n    addGlobalEvent("mouseup", onVSplitterMouseUp);\n\n    return false;\n};\n\nvar onVSplitterMouseMove = function onVSplitterMouseMove(event)\n{\n    if (new Date().getTime() - lastVSplitterMouseMove > chromeRedrawSkipRate) // frame skipping\n    {\n        var target = event.target || event.srcElement;\n        if (target && target.ownerDocument) // avoid error when cursor reaches out of the chrome\n        {\n            var clientX = event.clientX;\n            var win = document.all\n                ? event.srcElement.ownerDocument.parentWindow\n                : event.target.ownerDocument.defaultView;\n\n            if (win != win.parent)\n                clientX += win.frameElement ? win.frameElement.offsetLeft : 0;\n\n            var size = Firebug.chrome.getSize();\n            var x = Math.max(size.width - clientX + 3, 6);\n\n            Firebug.context.persistedState.sidePanelWidth = x;\n            Firebug.chrome.draw();\n        }\n\n        lastVSplitterMouseMove = new Date().getTime();\n    }\n\n    cancelEvent(event, true);\n    return false;\n};\n\nvar onVSplitterMouseUp = function onVSplitterMouseUp(event)\n{\n    removeGlobalEvent("mousemove", onVSplitterMouseMove);\n    removeGlobalEvent("mouseup", onVSplitterMouseUp);\n\n    Firebug.chrome.draw();\n};\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nFirebug.Lite =\n{\n};\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nFirebug.Lite.Cache =\n{\n    ID: "firebug-" + new Date().getTime()\n};\n\n// ************************************************************************************************\n\n/**\n * TODO: if a cached element is cloned, the expando property will be cloned too in IE\n * which will result in a bug. Firebug Lite will think the new cloned node is the old\n * one.\n *\n * TODO: Investigate a possibility of cache validation, to be customized by each\n * kind of cache. For ElementCache it should validate if the element still is\n * inserted at the DOM.\n */\nvar cacheUID = 0;\nvar createCache = function()\n{\n    var map = {};\n    var data = {};\n\n    var CID = Firebug.Lite.Cache.ID;\n\n    // better detection\n    var supportsDeleteExpando = !document.all;\n\n    var cacheFunction = function(element)\n    {\n        return cacheAPI.set(element);\n    };\n\n    var cacheAPI =\n    {\n        get: function(key)\n        {\n            return map.hasOwnProperty(key) ?\n                    map[key] :\n                    null;\n        },\n\n        set: function(element)\n        {\n            var id = getValidatedKey(element);\n\n            if (!id)\n            {\n                id = ++cacheUID;\n                element[CID] = id;\n            }\n\n            if (!map.hasOwnProperty(id))\n            {\n                map[id] = element;\n                data[id] = {};\n            }\n\n            return id;\n        },\n\n        unset: function(element)\n        {\n            var id = getValidatedKey(element);\n\n            if (!id) return;\n\n            if (supportsDeleteExpando)\n            {\n                delete element[CID];\n            }\n            else if (element.removeAttribute)\n            {\n                element.removeAttribute(CID);\n            }\n\n            delete map[id];\n            delete data[id];\n\n        },\n\n        key: function(element)\n        {\n            return getValidatedKey(element);\n        },\n\n        has: function(element)\n        {\n            var id = getValidatedKey(element);\n            return id && map.hasOwnProperty(id);\n        },\n\n        each: function(callback)\n        {\n            for (var key in map)\n            {\n                if (map.hasOwnProperty(key))\n                {\n                    callback(key, map[key]);\n                }\n            }\n        },\n\n        data: function(element, name, value)\n        {\n            // set data\n            if (value)\n            {\n                if (!name) return null;\n\n                var id = cacheAPI.set(element);\n\n                return data[id][name] = value;\n            }\n            // get data\n            else\n            {\n                var id = cacheAPI.key(element);\n\n                return data.hasOwnProperty(id) && data[id].hasOwnProperty(name) ?\n                        data[id][name] :\n                        null;\n            }\n        },\n\n        clear: function()\n        {\n            for (var id in map)\n            {\n                var element = map[id];\n                cacheAPI.unset(element);\n            }\n        }\n    };\n\n    var getValidatedKey = function(element)\n    {\n        var id = element[CID];\n\n        // If a cached element is cloned in IE, the expando property CID will be also\n        // cloned (differently than other browsers) resulting in a bug: Firebug Lite\n        // will think the new cloned node is the old one. To prevent this problem we\'re\n        // checking if the cached element matches the given element.\n        if (\n            !supportsDeleteExpando &&   // the problem happens when supportsDeleteExpando is false\n            id &&                       // the element has the expando property\n            map.hasOwnProperty(id) &&   // there is a cached element with the same id\n            map[id] != element          // but it is a different element than the current one\n            )\n        {\n            // remove the problematic property\n            element.removeAttribute(CID);\n\n            id = null;\n        }\n\n        return id;\n    };\n\n    FBL.append(cacheFunction, cacheAPI);\n\n    return cacheFunction;\n};\n\n// ************************************************************************************************\n\n// TODO: xxxpedro : check if we need really this on FBL scope\nFirebug.Lite.Cache.StyleSheet = createCache();\nFirebug.Lite.Cache.Element = createCache();\n\n// TODO: xxxpedro\nFirebug.Lite.Cache.Event = createCache();\n\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\nvar sourceMap = {};\n\n// ************************************************************************************************\nFirebug.Lite.Proxy =\n{\n    // jsonp callbacks\n    _callbacks: {},\n\n    /**\n     * Load a resource, either locally (directly) or externally (via proxy) using\n     * synchronous XHR calls. Loading external resources requires the proxy plugin to\n     * be installed and configured (see /plugin/proxy/proxy.php).\n     */\n    load: function(url)\n    {\n        var resourceDomain = getDomain(url);\n        var isLocalResource =\n            // empty domain means local URL\n            !resourceDomain ||\n            // same domain means local too\n            resourceDomain ==  Firebug.context.window.location.host; // TODO: xxxpedro context\n\n        return isLocalResource ? fetchResource(url) : fetchProxyResource(url);\n    },\n\n    /**\n     * Load a resource using JSONP technique.\n     */\n    loadJSONP: function(url, callback)\n    {\n        var script = createGlobalElement("script"),\n            doc = Firebug.context.document,\n\n            uid = "" + new Date().getTime(),\n            callbackName = "callback=Firebug.Lite.Proxy._callbacks." + uid,\n\n            jsonpURL = url.indexOf("?") != -1 ?\n                    url + "&" + callbackName :\n                    url + "?" + callbackName;\n\n        Firebug.Lite.Proxy._callbacks[uid] = function(data)\n        {\n            if (callback)\n                callback(data);\n\n            script.parentNode.removeChild(script);\n            delete Firebug.Lite.Proxy._callbacks[uid];\n        };\n\n        script.src = jsonpURL;\n\n        if (doc.documentElement)\n            doc.documentElement.appendChild(script);\n    },\n\n    /**\n     * Load a resource using YQL (not reliable).\n     */\n    YQL: function(url, callback)\n    {\n        var yql = "http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20html%20where%20url%3D%22" +\n                encodeURIComponent(url) + "%22&format=xml";\n\n        this.loadJSONP(yql, function(data)\n        {\n            var source = data.results[0];\n\n            // clean up YQL bogus elements\n            var match = /<body>\\s+<p>([\\s\\S]+)<\\/p>\\s+<\\/body>$/.exec(source);\n            if (match)\n                source = match[1];\n\n            console.log(source);\n        });\n    }\n};\n\n// ************************************************************************************************\n\nFirebug.Lite.Proxy.fetchResourceDisabledMessage =\n    "/* Firebug Lite resource fetching is disabled.\\n" +\n    "To enabled it set the Firebug Lite option \\"disableResourceFetching\\" to \\"false\\".\\n" +\n    "More info at http://getfirebug.com/firebuglite#Options */";\n\nvar fetchResource = function(url)\n{\n    if (Firebug.disableResourceFetching)\n    {\n        var source = sourceMap[url] = Firebug.Lite.Proxy.fetchResourceDisabledMessage;\n        return source;\n    }\n\n    if (sourceMap.hasOwnProperty(url))\n        return sourceMap[url];\n\n    // Getting the native XHR object so our calls won\'t be logged in the Console Panel\n    var xhr = FBL.getNativeXHRObject();\n    xhr.open("get", url, false);\n    xhr.send();\n\n    var source = sourceMap[url] = xhr.responseText;\n    return source;\n};\n\nvar fetchProxyResource = function(url)\n{\n    if (sourceMap.hasOwnProperty(url))\n        return sourceMap[url];\n\n    var proxyURL = Env.Location.baseDir + "plugin/proxy/proxy.php?url=" + encodeURIComponent(url);\n    var response = fetchResource(proxyURL);\n\n    try\n    {\n        var data = eval("(" + response + ")");\n    }\n    catch(E)\n    {\n        return "ERROR: Firebug Lite Proxy plugin returned an invalid response.";\n    }\n\n    var source = data ? data.contents : "";\n    return source;\n};\n\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nFirebug.Lite.Style =\n{\n};\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nFirebug.Lite.Script = function(window)\n{\n    this.fileName = null;\n    this.isValid = null;\n    this.baseLineNumber = null;\n    this.lineExtent = null;\n    this.tag = null;\n\n    this.functionName = null;\n    this.functionSource = null;\n};\n\nFirebug.Lite.Script.prototype =\n{\n    isLineExecutable: function(){},\n    pcToLine: function(){},\n    lineToPc: function(){},\n\n    toString: function()\n    {\n        return "Firebug.Lite.Script";\n    }\n};\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n\nFirebug.Lite.Browser = function(window)\n{\n    this.contentWindow = window;\n    this.contentDocument = window.document;\n    this.currentURI =\n    {\n        spec: window.location.href\n    };\n};\n\nFirebug.Lite.Browser.prototype =\n{\n    toString: function()\n    {\n        return "Firebug.Lite.Browser";\n    }\n};\n\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\n/*\n    http://www.JSON.org/json2.js\n    2010-03-20\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as \'\\t\' or \'&nbsp;\'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 ? \'0\' + n : n;\n                    }\n\n                    return this.getUTCFullYear()   + \'-\' +\n                         f(this.getUTCMonth() + 1) + \'-\' +\n                         f(this.getUTCDate())      + \'T\' +\n                         f(this.getUTCHours())     + \':\' +\n                         f(this.getUTCMinutes())   + \':\' +\n                         f(this.getUTCSeconds())   + \'Z\';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify([\'e\', {pluribus: \'unum\'}]);\n            // text is \'["e",{"pluribus":"unum"}]\'\n\n\n            text = JSON.stringify([\'e\', {pluribus: \'unum\'}], null, \'\\t\');\n            // text is \'[\\n\\t"e",\\n\\t{\\n\\t\\t"pluribus": "unum"\\n\\t}\\n]\'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date ?\n                    \'Date(\' + this[key] + \')\' : value;\n            });\n            // text is \'["Date(---current time---)"]\'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === \'string\') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse(\'["Date(09/09/2001)"]\', function (key, value) {\n                var d;\n                if (typeof value === \'string\' &&\n                        value.slice(0, 5) === \'Date(\' &&\n                        value.slice(-1) === \')\') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint evil: true, strict: false */\n\n/*members "", "\\b", "\\t", "\\n", "\\f", "\\r", "\\"", JSON, "\\\\", apply,\n    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\n// ************************************************************************************************\n\nvar JSON = window.JSON || {};\n\n// ************************************************************************************************\n\n(function () {\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 ? \'0\' + n : n;\n    }\n\n    if (typeof Date.prototype.toJSON !== \'function\') {\n\n        Date.prototype.toJSON = function (key) {\n\n            return isFinite(this.valueOf()) ?\n                   this.getUTCFullYear()   + \'-\' +\n                 f(this.getUTCMonth() + 1) + \'-\' +\n                 f(this.getUTCDate())      + \'T\' +\n                 f(this.getUTCHours())     + \':\' +\n                 f(this.getUTCMinutes())   + \':\' +\n                 f(this.getUTCSeconds())   + \'Z\' : null;\n        };\n\n        String.prototype.toJSON =\n        Number.prototype.toJSON =\n        Boolean.prototype.toJSON = function (key) {\n            return this.valueOf();\n        };\n    }\n\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        gap,\n        indent,\n        meta = {    // table of character substitutions\n            \'\\b\': \'\\\\b\',\n            \'\\t\': \'\\\\t\',\n            \'\\n\': \'\\\\n\',\n            \'\\f\': \'\\\\f\',\n            \'\\r\': \'\\\\r\',\n            \'"\' : \'\\\\"\',\n            \'\\\\\': \'\\\\\\\\\'\n        },\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        escapable.lastIndex = 0;\n        return escapable.test(string) ?\n            \'"\' + string.replace(escapable, function (a) {\n                var c = meta[a];\n                return typeof c === \'string\' ? c :\n                    \'\\\\u\' + (\'0000\' + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + \'"\' :\n            \'"\' + string + \'"\';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === \'object\' &&\n                typeof value.toJSON === \'function\') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === \'function\') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value\'s type.\n\n        switch (typeof value) {\n        case \'string\':\n            return quote(value);\n\n        case \'number\':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) ? String(value) : \'null\';\n\n        case \'boolean\':\n        case \'null\':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce \'null\'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is \'object\', we might be dealing with an object or an array or\n// null.\n\n        case \'object\':\n\n// Due to a specification blunder in ECMAScript, typeof null is \'object\',\n// so watch out for that case.\n\n            if (!value) {\n                return \'null\';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === \'[object Array]\') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || \'null\';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0 ? \'[]\' :\n                    gap ? \'[\\n\' + gap +\n                            partial.join(\',\\n\' + gap) + \'\\n\' +\n                                mind + \']\' :\n                          \'[\' + partial.join(\',\') + \']\';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === \'object\') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === \'string\') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? \': \' : \':\') + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? \': \' : \':\') + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0 ? \'{}\' :\n                gap ? \'{\\n\' + gap + partial.join(\',\\n\' + gap) + \'\\n\' +\n                        mind + \'}\' : \'{\' + partial.join(\',\') + \'}\';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== \'function\') {\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = \'\';\n            indent = \'\';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === \'number\') {\n                for (i = 0; i < space; i += 1) {\n                    indent += \' \';\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === \'string\') {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== \'function\' &&\n                    (typeof replacer !== \'object\' ||\n                     typeof replacer.length !== \'number\')) {\n                throw new Error(\'JSON.stringify\');\n            }\n\n// Make a fake root object containing our value under the key of \'\'.\n// Return the result of stringifying the value.\n\n            return str(\'\', {\'\': value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== \'function\') {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === \'object\') {\n                    for (k in value) {\n                        if (Object.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            cx.lastIndex = 0;\n            if (cx.test(text)) {\n                text = text.replace(cx, function (a) {\n                    return \'\\\\u\' +\n                        (\'0000\' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with \'()\' and \'new\'\n// because they can cause invocation, and \'=\' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE\'s and Safari\'s regexp engines. First we\n// replace the JSON backslash pairs with \'@\' (a non-JSON character). Second, we\n// replace all simple value tokens with \']\' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or \']\' or\n// \',\' or \':\' or \'{\' or \'}\'. If that is so, then the text is safe for eval.\n\n            if (/^[\\],:{}\\s]*$/.\ntest(text.replace(/\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \'@\').\nreplace(/"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \']\').\nreplace(/(?:^|:|,)(?:\\s*\\[)+/g, \'\'))) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The \'{\' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval(\'(\' + text + \')\');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === \'function\' ?\n                    walk({\'\': j}, \'\') : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError(\'JSON.parse\');\n        };\n    }\n\n// ************************************************************************************************\n// registration\n\nFBL.JSON = JSON;\n\n// ************************************************************************************************\n}());\n\n/* See license.txt for terms of usage */\n\n(function(){\n// ************************************************************************************************\n\n/* Copyright (c) 2010-2011 Marcus Westin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nvar store = (function(){\n\tvar api = {},\n\t\twin = window,\n\t\tdoc = win.document,\n\t\tlocalStorageName = \'localStorage\',\n\t\tglobalStorageName = \'globalStorage\',\n\t\tnamespace = \'__firebug__storejs__\',\n\t\tstorage\n\n\tapi.disabled = false\n\tapi.set = function(key, value) {}\n\tapi.get = function(key) {}\n\tapi.remove = function(key) {}\n\tapi.clear = function() {}\n\tapi.transact = function(key, transactionFn) {\n\t\tvar val = api.get(key)\n\t\tif (typeof val == \'undefined\') { val = {} }\n\t\ttransactionFn(val)\n\t\tapi.set(key, val)\n\t}\n\n\tapi.serialize = function(value) {\n\t\treturn JSON.stringify(value)\n\t}\n\tapi.deserialize = function(value) {\n\t\tif (typeof value != \'string\') { return undefined }\n\t\treturn JSON.parse(value)\n\t}\n\n\t// Functions to encapsulate questionable FireFox 3.6.13 behavior\n\t// when about.config::dom.storage.enabled === false\n\t// See https://github.com/marcuswestin/store.js/issues#issue/13\n\tfunction isLocalStorageNameSupported() {\n\t\ttry { return (localStorageName in win && win[localStorageName]) }\n\t\tcatch(err) { return false }\n\t}\n\n\tfunction isGlobalStorageNameSupported() {\n\t\ttry { return (globalStorageName in win && win[globalStorageName] && win[globalStorageName][win.location.hostname]) }\n\t\tcatch(err) { return false }\n\t}\n\n\tif (isLocalStorageNameSupported()) {\n\t\tstorage = win[localStorageName]\n\t\tapi.set = function(key, val) { storage.setItem(key, api.serialize(val)) }\n\t\tapi.get = function(key) { return api.deserialize(storage.getItem(key)) }\n\t\tapi.remove = function(key) { storage.removeItem(key) }\n\t\tapi.clear = function() { storage.clear() }\n\n\t} else if (isGlobalStorageNameSupported()) {\n\t\tstorage = win[globalStorageName][win.location.hostname]\n\t\tapi.set = function(key, val) { storage[key] = api.serialize(val) }\n\t\tapi.get = function(key) { return api.deserialize(storage[key] && storage[key].value) }\n\t\tapi.remove = function(key) { delete storage[key] }\n\t\tapi.clear = function() { for (var key in storage ) { delete storage[key] } }\n\n\t} else if (doc.documentElement.addBehavior) {\n\t\tvar storage = doc.createElement(\'div\')\n\t\tfunction withIEStorage(storeFunction) {\n\t\t\treturn function() {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments, 0)\n\t\t\t\targs.unshift(storage)\n\t\t\t\t// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx\n\t\t\t\t// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx\n\t\t\t\t// TODO: xxxpedro doc.body is not always available so we must use doc.documentElement.\n\t\t\t\t// We need to make sure this change won\'t affect the behavior of this library.\n\t\t\t\tdoc.documentElement.appendChild(storage)\n\t\t\t\tstorage.addBehavior(\'#default#userData\')\n\t\t\t\tstorage.load(localStorageName)\n\t\t\t\tvar result = storeFunction.apply(api, args)\n\t\t\t\tdoc.documentElement.removeChild(storage)\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t\tapi.set = withIEStorage(function(storage, key, val) {\n\t\t\tstorage.setAttribute(key, api.serialize(val))\n\t\t\tstorage.save(localStorageName)\n\t\t})\n\t\tapi.get = withIEStorage(function(storage, key) {\n\t\t\treturn api.deserialize(storage.getAttribute(key))\n\t\t})\n\t\tapi.remove = withIEStorage(function(storage, key) {\n\t\t\tstorage.removeAttribute(key)\n\t\t\tstorage.save(localStorageName)\n\t\t})\n\t\tapi.clear = withIEStorage(function(storage) {\n\t\t\tvar attributes = storage.XMLDocument.documentElement.attributes\n\t\t\tstorage.load(localStorageName)\n\t\t\tfor (var i=0, attr; attr = attributes[i]; i++) {\n\t\t\t\tstorage.removeAttribute(attr.name)\n\t\t\t}\n\t\t\tstorage.save(localStorageName)\n\t\t})\n\t}\n\n\ttry {\n\t\tapi.set(namespace, namespace)\n\t\tif (api.get(namespace) != namespace) { api.disabled = true }\n\t\tapi.remove(namespace)\n\t} catch(e) {\n\t\tapi.disabled = true\n\t}\n\n\treturn api\n})();\n\nif (typeof module != \'undefined\') { module.exports = store }\n\n\n// ************************************************************************************************\n// registration\n\nFBL.Store = store;\n\n// ************************************************************************************************\n})();\n\n/* See license.txt for terms of usage */\n\nFBL.ns( /**@scope s_selector*/ function() { with (FBL) {\n// ************************************************************************************************\n\n/*\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|[\'"][^\'"]*[\'"]|[^[\\]\'"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\n    done = 0,\n    toString = Object.prototype.toString,\n    hasDuplicate = false,\n    baseHasDuplicate = true;\n\n// Here we check if the JavaScript engine is using some sort of\n// optimization where it does not always call our comparision\n// function. If that is the case, discard the hasDuplicate value.\n//   Thus far that includes Google Chrome.\n[0, 0].sort(function(){\n    baseHasDuplicate = false;\n    return 0;\n});\n\n/**\n * @name Firebug.Selector\n * @namespace\n */\n\n/**\n * @exports Sizzle as Firebug.Selector\n */\nvar Sizzle = function(selector, context, results, seed) {\n    results = results || [];\n    var origContext = context = context || document;\n\n    if ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n        return [];\n    }\n\n    if ( !selector || typeof selector !== "string" ) {\n        return results;\n    }\n\n    var parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context),\n        soFar = selector;\n\n    // Reset the position of the chunker regexp (start from head)\n    while ( (chunker.exec(""), m = chunker.exec(soFar)) !== null ) {\n        soFar = m[3];\n\n        parts.push( m[1] );\n\n        if ( m[2] ) {\n            extra = m[3];\n            break;\n        }\n    }\n\n    if ( parts.length > 1 && origPOS.exec( selector ) ) {\n        if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n            set = posProcess( parts[0] + parts[1], context );\n        } else {\n            set = Expr.relative[ parts[0] ] ?\n                [ context ] :\n                Sizzle( parts.shift(), context );\n\n            while ( parts.length ) {\n                selector = parts.shift();\n\n                if ( Expr.relative[ selector ] )\n                    selector += parts.shift();\n\n                set = posProcess( selector, set );\n            }\n        }\n    } else {\n        // Take a shortcut and set the context if the root selector is an ID\n        // (but not if it\'ll be faster if the inner selector is an ID)\n        if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n                Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n            var ret = Sizzle.find( parts.shift(), context, contextXML );\n            context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\n        }\n\n        if ( context ) {\n            var ret = seed ?\n                { expr: parts.pop(), set: makeArray(seed) } :\n                Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );\n            set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\n\n            if ( parts.length > 0 ) {\n                checkSet = makeArray(set);\n            } else {\n                prune = false;\n            }\n\n            while ( parts.length ) {\n                var cur = parts.pop(), pop = cur;\n\n                if ( !Expr.relative[ cur ] ) {\n                    cur = "";\n                } else {\n                    pop = parts.pop();\n                }\n\n                if ( pop == null ) {\n                    pop = context;\n                }\n\n                Expr.relative[ cur ]( checkSet, pop, contextXML );\n            }\n        } else {\n            checkSet = parts = [];\n        }\n    }\n\n    if ( !checkSet ) {\n        checkSet = set;\n    }\n\n    if ( !checkSet ) {\n        throw "Syntax error, unrecognized expression: " + (cur || selector);\n    }\n\n    if ( toString.call(checkSet) === "[object Array]" ) {\n        if ( !prune ) {\n            results.push.apply( results, checkSet );\n        } else if ( context && context.nodeType === 1 ) {\n            for ( var i = 0; checkSet[i] != null; i++ ) {\n                if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n                    results.push( set[i] );\n                }\n            }\n        } else {\n            for ( var i = 0; checkSet[i] != null; i++ ) {\n                if ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n                    results.push( set[i] );\n                }\n            }\n        }\n    } else {\n        makeArray( checkSet, results );\n    }\n\n    if ( extra ) {\n        Sizzle( extra, origContext, results, seed );\n        Sizzle.uniqueSort( results );\n    }\n\n    return results;\n};\n\nSizzle.uniqueSort = function(results){\n    if ( sortOrder ) {\n        hasDuplicate = baseHasDuplicate;\n        results.sort(sortOrder);\n\n        if ( hasDuplicate ) {\n            for ( var i = 1; i < results.length; i++ ) {\n                if ( results[i] === results[i-1] ) {\n                    results.splice(i--, 1);\n                }\n            }\n        }\n    }\n\n    return results;\n};\n\nSizzle.matches = function(expr, set){\n    return Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n    var set, match;\n\n    if ( !expr ) {\n        return [];\n    }\n\n    for ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n        var type = Expr.order[i], match;\n\n        if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {\n            var left = match[1];\n            match.splice(1,1);\n\n            if ( left.substr( left.length - 1 ) !== "\\\\" ) {\n                match[1] = (match[1] || "").replace(/\\\\/g, "");\n                set = Expr.find[ type ]( match, context, isXML );\n                if ( set != null ) {\n                    expr = expr.replace( Expr.match[ type ], "" );\n                    break;\n                }\n            }\n        }\n    }\n\n    if ( !set ) {\n        set = context.getElementsByTagName("*");\n    }\n\n    return {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n    var old = expr, result = [], curLoop = set, match, anyFound,\n        isXMLFilter = set && set[0] && isXML(set[0]);\n\n    while ( expr && set.length ) {\n        for ( var type in Expr.filter ) {\n            if ( (match = Expr.match[ type ].exec( expr )) != null ) {\n                var filter = Expr.filter[ type ], found, item;\n                anyFound = false;\n\n                if ( curLoop == result ) {\n                    result = [];\n                }\n\n                if ( Expr.preFilter[ type ] ) {\n                    match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n                    if ( !match ) {\n                        anyFound = found = true;\n                    } else if ( match === true ) {\n                        continue;\n                    }\n                }\n\n                if ( match ) {\n                    for ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n                        if ( item ) {\n                            found = filter( item, match, i, curLoop );\n                            var pass = not ^ !!found;\n\n                            if ( inplace && found != null ) {\n                                if ( pass ) {\n                                    anyFound = true;\n                                } else {\n                                    curLoop[i] = false;\n                                }\n                            } else if ( pass ) {\n                                result.push( item );\n                                anyFound = true;\n                            }\n                        }\n                    }\n                }\n\n                if ( found !== undefined ) {\n                    if ( !inplace ) {\n                        curLoop = result;\n                    }\n\n                    expr = expr.replace( Expr.match[ type ], "" );\n\n                    if ( !anyFound ) {\n                        return [];\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // Improper expression\n        if ( expr == old ) {\n            if ( anyFound == null ) {\n                throw "Syntax error, unrecognized expression: " + expr;\n            } else {\n                break;\n            }\n        }\n\n        old = expr;\n    }\n\n    return curLoop;\n};\n\n/**#@+ @ignore */\nvar Expr = Sizzle.selectors = {\n    order: [ "ID", "NAME", "TAG" ],\n    match: {\n        ID: /#((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/,\n        CLASS: /\\.((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/,\n        NAME: /\\[name=[\'"]*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)[\'"]*\\]/,\n        ATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)\\s*(?:(\\S?=)\\s*([\'"]*)(.*?)\\3|)\\s*\\]/,\n        TAG: /^((?:[\\w\\u00c0-\\uFFFF\\*-]|\\\\.)+)/,\n        CHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n        POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n        PSEUDO: /:((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)(?:\\(([\'"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n    },\n    leftMatch: {},\n    attrMap: {\n        "class": "className",\n        "for": "htmlFor"\n    },\n    attrHandle: {\n        href: function(elem){\n            return elem.getAttribute("href");\n        }\n    },\n    relative: {\n        "+": function(checkSet, part, isXML){\n            var isPartStr = typeof part === "string",\n                isTag = isPartStr && !/\\W/.test(part),\n                isPartStrNotTag = isPartStr && !isTag;\n\n            if ( isTag && !isXML ) {\n                part = part.toUpperCase();\n            }\n\n            for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n                if ( (elem = checkSet[i]) ) {\n                    while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n                    checkSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?\n                        elem || false :\n                        elem === part;\n                }\n            }\n\n            if ( isPartStrNotTag ) {\n                Sizzle.filter( part, checkSet, true );\n            }\n        },\n        ">": function(checkSet, part, isXML){\n            var isPartStr = typeof part === "string";\n\n            if ( isPartStr && !/\\W/.test(part) ) {\n                part = isXML ? part : part.toUpperCase();\n\n                for ( var i = 0, l = checkSet.length; i < l; i++ ) {\n                    var elem = checkSet[i];\n                    if ( elem ) {\n                        var parent = elem.parentNode;\n                        checkSet[i] = parent.nodeName === part ? parent : false;\n                    }\n                }\n            } else {\n                for ( var i = 0, l = checkSet.length; i < l; i++ ) {\n                    var elem = checkSet[i];\n                    if ( elem ) {\n                        checkSet[i] = isPartStr ?\n                            elem.parentNode :\n                            elem.parentNode === part;\n                    }\n                }\n\n                if ( isPartStr ) {\n                    Sizzle.filter( part, checkSet, true );\n                }\n            }\n        },\n        "": function(checkSet, part, isXML){\n            var doneName = done++, checkFn = dirCheck;\n\n            if ( !/\\W/.test(part) ) {\n                var nodeCheck = part = isXML ? part : part.toUpperCase();\n                checkFn = dirNodeCheck;\n            }\n\n            checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);\n        },\n        "~": function(checkSet, part, isXML){\n            var doneName = done++, checkFn = dirCheck;\n\n            if ( typeof part === "string" && !/\\W/.test(part) ) {\n                var nodeCheck = part = isXML ? part : part.toUpperCase();\n                checkFn = dirNodeCheck;\n            }\n\n            checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);\n        }\n    },\n    find: {\n        ID: function(match, context, isXML){\n            if ( typeof context.getElementById !== "undefined" && !isXML ) {\n                var m = context.getElementById(match[1]);\n                return m ? [m] : [];\n            }\n        },\n        NAME: function(match, context, isXML){\n            if ( typeof context.getElementsByName !== "undefined" ) {\n                var ret = [], results = context.getElementsByName(match[1]);\n\n                for ( var i = 0, l = results.length; i < l; i++ ) {\n                    if ( results[i].getAttribute("name") === match[1] ) {\n                        ret.push( results[i] );\n                    }\n                }\n\n                return ret.length === 0 ? null : ret;\n            }\n        },\n        TAG: function(match, context){\n            return context.getElementsByTagName(match[1]);\n        }\n    },\n    preFilter: {\n        CLASS: function(match, curLoop, inplace, result, not, isXML){\n            match = " " + match[1].replace(/\\\\/g, "") + " ";\n\n            if ( isXML ) {\n                return match;\n            }\n\n            for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n                if ( elem ) {\n                    if ( not ^ (elem.className && (" " + elem.className + " ").indexOf(match) >= 0) ) {\n                        if ( !inplace )\n                            result.push( elem );\n                    } else if ( inplace ) {\n                        curLoop[i] = false;\n                    }\n                }\n            }\n\n            return false;\n        },\n        ID: function(match){\n            return match[1].replace(/\\\\/g, "");\n        },\n        TAG: function(match, curLoop){\n            for ( var i = 0; curLoop[i] === false; i++ ){}\n            return curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n        },\n        CHILD: function(match){\n            if ( match[1] == "nth" ) {\n                // parse equations like \'even\', \'odd\', \'5\', \'2n\', \'3n+2\', \'4n-1\', \'-n+6\'\n                var test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n                    match[2] == "even" && "2n" || match[2] == "odd" && "2n+1" ||\n                    !/\\D/.test( match[2] ) && "0n+" + match[2] || match[2]);\n\n                // calculate the numbers (first)n+(last) including if they are negative\n                match[2] = (test[1] + (test[2] || 1)) - 0;\n                match[3] = test[3] - 0;\n            }\n\n            // TODO: Move to normal caching system\n            match[0] = done++;\n\n            return match;\n        },\n        ATTR: function(match, curLoop, inplace, result, not, isXML){\n            var name = match[1].replace(/\\\\/g, "");\n\n            if ( !isXML && Expr.attrMap[name] ) {\n                match[1] = Expr.attrMap[name];\n            }\n\n            if ( match[2] === "~=" ) {\n                match[4] = " " + match[4] + " ";\n            }\n\n            return match;\n        },\n        PSEUDO: function(match, curLoop, inplace, result, not){\n            if ( match[1] === "not" ) {\n                // If we\'re dealing with a complex expression, or a simple one\n                if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\\w/.test(match[3]) ) {\n                    match[3] = Sizzle(match[3], null, null, curLoop);\n                } else {\n                    var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n                    if ( !inplace ) {\n                        result.push.apply( result, ret );\n                    }\n                    return false;\n                }\n            } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n                return true;\n            }\n\n            return match;\n        },\n        POS: function(match){\n            match.unshift( true );\n            return match;\n        }\n    },\n    filters: {\n        enabled: function(elem){\n            return elem.disabled === false && elem.type !== "hidden";\n        },\n        disabled: function(elem){\n            return elem.disabled === true;\n        },\n        checked: function(elem){\n            return elem.checked === true;\n        },\n        selected: function(elem){\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            elem.parentNode.selectedIndex;\n            return elem.selected === true;\n        },\n        parent: function(elem){\n            return !!elem.firstChild;\n        },\n        empty: function(elem){\n            return !elem.firstChild;\n        },\n        has: function(elem, i, match){\n            return !!Sizzle( match[3], elem ).length;\n        },\n        header: function(elem){\n            return /h\\d/i.test( elem.nodeName );\n        },\n        text: function(elem){\n            return "text" === elem.type;\n        },\n        radio: function(elem){\n            return "radio" === elem.type;\n        },\n        checkbox: function(elem){\n            return "checkbox" === elem.type;\n        },\n        file: function(elem){\n            return "file" === elem.type;\n        },\n        password: function(elem){\n            return "password" === elem.type;\n        },\n        submit: function(elem){\n            return "submit" === elem.type;\n        },\n        image: function(elem){\n            return "image" === elem.type;\n        },\n        reset: function(elem){\n            return "reset" === elem.type;\n        },\n        button: function(elem){\n            return "button" === elem.type || elem.nodeName.toUpperCase() === "BUTTON";\n        },\n        input: function(elem){\n            return /input|select|textarea|button/i.test(elem.nodeName);\n        }\n    },\n    setFilters: {\n        first: function(elem, i){\n            return i === 0;\n        },\n        last: function(elem, i, match, array){\n            return i === array.length - 1;\n        },\n        even: function(elem, i){\n            return i % 2 === 0;\n        },\n        odd: function(elem, i){\n            return i % 2 === 1;\n        },\n        lt: function(elem, i, match){\n            return i < match[3] - 0;\n        },\n        gt: function(elem, i, match){\n            return i > match[3] - 0;\n        },\n        nth: function(elem, i, match){\n            return match[3] - 0 == i;\n        },\n        eq: function(elem, i, match){\n            return match[3] - 0 == i;\n        }\n    },\n    filter: {\n        PSEUDO: function(elem, match, i, array){\n            var name = match[1], filter = Expr.filters[ name ];\n\n            if ( filter ) {\n                return filter( elem, i, match, array );\n            } else if ( name === "contains" ) {\n                return (elem.textContent || elem.innerText || "").indexOf(match[3]) >= 0;\n            } else if ( name === "not" ) {\n                var not = match[3];\n\n                for ( var i = 0, l = not.length; i < l; i++ ) {\n                    if ( not[i] === elem ) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n        },\n        CHILD: function(elem, match){\n            var type = match[1], node = elem;\n            switch (type) {\n                case \'only\':\n                case \'first\':\n                    while ( (node = node.previousSibling) )  {\n                        if ( node.nodeType === 1 ) return false;\n                    }\n                    if ( type == \'first\') return true;\n                    node = elem;\n                case \'last\':\n                    while ( (node = node.nextSibling) )  {\n                        if ( node.nodeType === 1 ) return false;\n                    }\n                    return true;\n                case \'nth\':\n                    var first = match[2], last = match[3];\n\n                    if ( first == 1 && last == 0 ) {\n                        return true;\n                    }\n\n                    var doneName = match[0],\n                        parent = elem.parentNode;\n\n                    if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n                        var count = 0;\n                        for ( node = parent.firstChild; node; node = node.nextSibling ) {\n                            if ( node.nodeType === 1 ) {\n                                node.nodeIndex = ++count;\n                            }\n                        }\n                        parent.sizcache = doneName;\n                    }\n\n                    var diff = elem.nodeIndex - last;\n                    if ( first == 0 ) {\n                        return diff == 0;\n                    } else {\n                        return ( diff % first == 0 && diff / first >= 0 );\n                    }\n            }\n        },\n        ID: function(elem, match){\n            return elem.nodeType === 1 && elem.getAttribute("id") === match;\n        },\n        TAG: function(elem, match){\n            return (match === "*" && elem.nodeType === 1) || elem.nodeName === match;\n        },\n        CLASS: function(elem, match){\n            return (" " + (elem.className || elem.getAttribute("class")) + " ")\n                .indexOf( match ) > -1;\n        },\n        ATTR: function(elem, match){\n            var name = match[1],\n                result = Expr.attrHandle[ name ] ?\n                    Expr.attrHandle[ name ]( elem ) :\n                    elem[ name ] != null ?\n                        elem[ name ] :\n                        elem.getAttribute( name ),\n                value = result + "",\n                type = match[2],\n                check = match[4];\n\n            return result == null ?\n                type === "!=" :\n                type === "=" ?\n                value === check :\n                type === "*=" ?\n                value.indexOf(check) >= 0 :\n                type === "~=" ?\n                (" " + value + " ").indexOf(check) >= 0 :\n                !check ?\n                value && result !== false :\n                type === "!=" ?\n                value != check :\n                type === "^=" ?\n                value.indexOf(check) === 0 :\n                type === "$=" ?\n                value.substr(value.length - check.length) === check :\n                type === "|=" ?\n                value === check || value.substr(0, check.length + 1) === check + "-" :\n                false;\n        },\n        POS: function(elem, match, i, array){\n            var name = match[2], filter = Expr.setFilters[ name ];\n\n            if ( filter ) {\n                return filter( elem, i, match, array );\n            }\n        }\n    }\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n    Expr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n    Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source );\n}\n\nvar makeArray = function(array, results) {\n    array = Array.prototype.slice.call( array, 0 );\n\n    if ( results ) {\n        results.push.apply( results, array );\n        return results;\n    }\n\n    return array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n    Array.prototype.slice.call( document.documentElement.childNodes, 0 );\n\n// Provide a fallback method if it does not work\n} catch(e){\n    makeArray = function(array, results) {\n        var ret = results || [];\n\n        if ( toString.call(array) === "[object Array]" ) {\n            Array.prototype.push.apply( ret, array );\n        } else {\n            if ( typeof array.length === "number" ) {\n                for ( var i = 0, l = array.length; i < l; i++ ) {\n                    ret.push( array[i] );\n                }\n            } else {\n                for ( var i = 0; array[i]; i++ ) {\n                    ret.push( array[i] );\n                }\n            }\n        }\n\n        return ret;\n    };\n}\n\nvar sortOrder;\n\nif ( document.documentElement.compareDocumentPosition ) {\n    sortOrder = function( a, b ) {\n        if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {\n            if ( a == b ) {\n                hasDuplicate = true;\n            }\n            return 0;\n        }\n\n        var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n        if ( ret === 0 ) {\n            hasDuplicate = true;\n        }\n        return ret;\n    };\n} else if ( "sourceIndex" in document.documentElement ) {\n    sortOrder = function( a, b ) {\n        if ( !a.sourceIndex || !b.sourceIndex ) {\n            if ( a == b ) {\n                hasDuplicate = true;\n            }\n            return 0;\n        }\n\n        var ret = a.sourceIndex - b.sourceIndex;\n        if ( ret === 0 ) {\n            hasDuplicate = true;\n        }\n        return ret;\n    };\n} else if ( document.createRange ) {\n    sortOrder = function( a, b ) {\n        if ( !a.ownerDocument || !b.ownerDocument ) {\n            if ( a == b ) {\n                hasDuplicate = true;\n            }\n            return 0;\n        }\n\n        var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n        aRange.setStart(a, 0);\n        aRange.setEnd(a, 0);\n        bRange.setStart(b, 0);\n        bRange.setEnd(b, 0);\n        var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n        if ( ret === 0 ) {\n            hasDuplicate = true;\n        }\n        return ret;\n    };\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n    // We\'re going to inject a fake input element with a specified name\n    var form = document.createElement("div"),\n        id = "script" + (new Date).getTime();\n    form.innerHTML = "<a name=\'" + id + "\'/>";\n\n    // Inject it into the root element, check its status, and remove it quickly\n    var root = document.documentElement;\n    root.insertBefore( form, root.firstChild );\n\n    // The workaround has to do additional checks after a getElementById\n    // Which slows things down for other browsers (hence the branching)\n    if ( !!document.getElementById( id ) ) {\n        Expr.find.ID = function(match, context, isXML){\n            if ( typeof context.getElementById !== "undefined" && !isXML ) {\n                var m = context.getElementById(match[1]);\n                return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];\n            }\n        };\n\n        Expr.filter.ID = function(elem, match){\n            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");\n            return elem.nodeType === 1 && node && node.nodeValue === match;\n        };\n    }\n\n    root.removeChild( form );\n    root = form = null; // release memory in IE\n})();\n\n(function(){\n    // Check to see if the browser returns only elements\n    // when doing getElementsByTagName("*")\n\n    // Create a fake element\n    var div = document.createElement("div");\n    div.appendChild( document.createComment("") );\n\n    // Make sure no comments are found\n    if ( div.getElementsByTagName("*").length > 0 ) {\n        Expr.find.TAG = function(match, context){\n            var results = context.getElementsByTagName(match[1]);\n\n            // Filter out possible comments\n            if ( match[1] === "*" ) {\n                var tmp = [];\n\n                for ( var i = 0; results[i]; i++ ) {\n                    if ( results[i].nodeType === 1 ) {\n                        tmp.push( results[i] );\n                    }\n                }\n\n                results = tmp;\n            }\n\n            return results;\n        };\n    }\n\n    // Check to see if an attribute returns normalized href attributes\n    div.innerHTML = "<a href=\'#\'></a>";\n    if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&\n            div.firstChild.getAttribute("href") !== "#" ) {\n        Expr.attrHandle.href = function(elem){\n            return elem.getAttribute("href", 2);\n        };\n    }\n\n    div = null; // release memory in IE\n})();\n\nif ( document.querySelectorAll ) (function(){\n    var oldSizzle = Sizzle, div = document.createElement("div");\n    div.innerHTML = "<p class=\'TEST\'></p>";\n\n    // Safari can\'t handle uppercase or unicode characters when\n    // in quirks mode.\n    if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {\n        return;\n    }\n\n    Sizzle = function(query, context, extra, seed){\n        context = context || document;\n\n        // Only use querySelectorAll on non-XML documents\n        // (ID selectors don\'t work in non-HTML documents)\n        if ( !seed && context.nodeType === 9 && !isXML(context) ) {\n            try {\n                return makeArray( context.querySelectorAll(query), extra );\n            } catch(e){}\n        }\n\n        return oldSizzle(query, context, extra, seed);\n    };\n\n    for ( var prop in oldSizzle ) {\n        Sizzle[ prop ] = oldSizzle[ prop ];\n    }\n\n    div = null; // release memory in IE\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){\n    var div = document.createElement("div");\n    div.innerHTML = "<div class=\'test e\'></div><div class=\'test\'></div>";\n\n    // Opera can\'t find a second classname (in 9.6)\n    if ( div.getElementsByClassName("e").length === 0 )\n        return;\n\n    // Safari caches class attributes, doesn\'t catch changes (in 3.2)\n    div.lastChild.className = "e";\n\n    if ( div.getElementsByClassName("e").length === 1 )\n        return;\n\n    Expr.order.splice(1, 0, "CLASS");\n    Expr.find.CLASS = function(match, context, isXML) {\n        if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {\n            return context.getElementsByClassName(match[1]);\n        }\n    };\n\n    div = null; // release memory in IE\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n    var sibDir = dir == "previousSibling" && !isXML;\n    for ( var i = 0, l = checkSet.length; i < l; i++ ) {\n        var elem = checkSet[i];\n        if ( elem ) {\n            if ( sibDir && elem.nodeType === 1 ){\n                elem.sizcache = doneName;\n                elem.sizset = i;\n            }\n            elem = elem[dir];\n            var match = false;\n\n            while ( elem ) {\n                if ( elem.sizcache === doneName ) {\n                    match = checkSet[elem.sizset];\n                    break;\n                }\n\n                if ( elem.nodeType === 1 && !isXML ){\n                    elem.sizcache = doneName;\n                    elem.sizset = i;\n                }\n\n                if ( elem.nodeName === cur ) {\n                    match = elem;\n                    break;\n                }\n\n                elem = elem[dir];\n            }\n\n            checkSet[i] = match;\n        }\n    }\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n    var sibDir = dir == "previousSibling" && !isXML;\n    for ( var i = 0, l = checkSet.length; i < l; i++ ) {\n        var elem = checkSet[i];\n        if ( elem ) {\n            if ( sibDir && elem.nodeType === 1 ) {\n                elem.sizcache = doneName;\n                elem.sizset = i;\n            }\n            elem = elem[dir];\n            var match = false;\n\n            while ( elem ) {\n                if ( elem.sizcache === doneName ) {\n                    match = checkSet[elem.sizset];\n                    break;\n                }\n\n                if ( elem.nodeType === 1 ) {\n                    if ( !isXML ) {\n                        elem.sizcache = doneName;\n                        elem.sizset = i;\n                    }\n                    if ( typeof cur !== "string" ) {\n                        if ( elem === cur ) {\n                            match = true;\n                            break;\n                        }\n\n                    } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n                        match = elem;\n                        break;\n                    }\n                }\n\n                elem = elem[dir];\n            }\n\n            checkSet[i] = match;\n        }\n    }\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n    return a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n    return a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n    return elem.nodeType === 9 && elem.documentElement.nodeName !== "HTML" ||\n        !!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== "HTML";\n};\n\nvar posProcess = function(selector, context){\n    var tmpSet = [], later = "", match,\n        root = context.nodeType ? [context] : context;\n\n    // Position selectors must be done after the filter\n    // And so must :not(positional) so we move all PSEUDOs to the end\n    while ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n        later += match[0];\n        selector = selector.replace( Expr.match.PSEUDO, "" );\n    }\n\n    selector = Expr.relative[selector] ? selector + "*" : selector;\n\n    for ( var i = 0, l = root.length; i < l; i++ ) {\n        Sizzle( selector, root[i], tmpSet );\n    }\n\n    return Sizzle.filter( later, tmpSet );\n};\n\n// EXPOSE\n\nFirebug.Selector = Sizzle;\n\n/**#@-*/\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Inspector Module\n\nvar ElementCache = Firebug.Lite.Cache.Element;\n\nvar inspectorTS, inspectorTimer, isInspecting;\n\nFirebug.Inspector =\n{\n    create: function()\n    {\n        offlineFragment = Env.browser.document.createDocumentFragment();\n\n        createBoxModelInspector();\n        createOutlineInspector();\n    },\n\n    destroy: function()\n    {\n        destroyBoxModelInspector();\n        destroyOutlineInspector();\n\n        offlineFragment = null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Inspect functions\n\n    toggleInspect: function()\n    {\n        if (isInspecting)\n        {\n            this.stopInspecting();\n        }\n        else\n        {\n            Firebug.chrome.inspectButton.changeState("pressed");\n            this.startInspecting();\n        }\n    },\n\n    startInspecting: function()\n    {\n        isInspecting = true;\n\n        Firebug.chrome.selectPanel("HTML");\n\n        createInspectorFrame();\n\n        var size = Firebug.browser.getWindowScrollSize();\n\n        fbInspectFrame.style.width = size.width + "px";\n        fbInspectFrame.style.height = size.height + "px";\n\n        //addEvent(Firebug.browser.document.documentElement, "mousemove", Firebug.Inspector.onInspectingBody);\n\n        addEvent(fbInspectFrame, "mousemove", Firebug.Inspector.onInspecting);\n        addEvent(fbInspectFrame, "mousedown", Firebug.Inspector.onInspectingClick);\n    },\n\n    stopInspecting: function()\n    {\n        isInspecting = false;\n\n        if (outlineVisible) this.hideOutline();\n        removeEvent(fbInspectFrame, "mousemove", Firebug.Inspector.onInspecting);\n        removeEvent(fbInspectFrame, "mousedown", Firebug.Inspector.onInspectingClick);\n\n        destroyInspectorFrame();\n\n        Firebug.chrome.inspectButton.restore();\n\n        if (Firebug.chrome.type == "popup")\n            Firebug.chrome.node.focus();\n    },\n\n    onInspectingClick: function(e)\n    {\n        fbInspectFrame.style.display = "none";\n        var targ = Firebug.browser.getElementFromPoint(e.clientX, e.clientY);\n        fbInspectFrame.style.display = "block";\n\n        // Avoid inspecting the outline, and the FirebugUI\n        var id = targ.id;\n        if (id && /^fbOutline\\w$/.test(id)) return;\n        if (id == "FirebugUI") return;\n\n        // Avoid looking at text nodes in Opera\n        while (targ.nodeType != 1) targ = targ.parentNode;\n\n        //Firebug.Console.log(targ);\n        Firebug.Inspector.stopInspecting();\n    },\n\n    onInspecting: function(e)\n    {\n        if (new Date().getTime() - lastInspecting > 30)\n        {\n            fbInspectFrame.style.display = "none";\n            var targ = Firebug.browser.getElementFromPoint(e.clientX, e.clientY);\n            fbInspectFrame.style.display = "block";\n\n            // Avoid inspecting the outline, and the FirebugUI\n            var id = targ.id;\n            if (id && /^fbOutline\\w$/.test(id)) return;\n            if (id == "FirebugUI") return;\n\n            // Avoid looking at text nodes in Opera\n            while (targ.nodeType != 1) targ = targ.parentNode;\n\n            if (targ.nodeName.toLowerCase() == "body") return;\n\n            //Firebug.Console.log(e.clientX, e.clientY, targ);\n            Firebug.Inspector.drawOutline(targ);\n\n            if (ElementCache(targ))\n            {\n                var target = ""+ElementCache.key(targ);\n                var lazySelect = function()\n                {\n                    inspectorTS = new Date().getTime();\n\n                    if (Firebug.HTML)\n                        Firebug.HTML.selectTreeNode(""+ElementCache.key(targ));\n                };\n\n                if (inspectorTimer)\n                {\n                    clearTimeout(inspectorTimer);\n                    inspectorTimer = null;\n                }\n\n                if (new Date().getTime() - inspectorTS > 200)\n                    setTimeout(lazySelect, 0);\n                else\n                    inspectorTimer = setTimeout(lazySelect, 300);\n            }\n\n            lastInspecting = new Date().getTime();\n        }\n    },\n\n    // TODO: xxxpedro remove this?\n    onInspectingBody: function(e)\n    {\n        if (new Date().getTime() - lastInspecting > 30)\n        {\n            var targ = e.target;\n\n            // Avoid inspecting the outline, and the FirebugUI\n            var id = targ.id;\n            if (id && /^fbOutline\\w$/.test(id)) return;\n            if (id == "FirebugUI") return;\n\n            // Avoid looking at text nodes in Opera\n            while (targ.nodeType != 1) targ = targ.parentNode;\n\n            if (targ.nodeName.toLowerCase() == "body") return;\n\n            //Firebug.Console.log(e.clientX, e.clientY, targ);\n            Firebug.Inspector.drawOutline(targ);\n\n            if (ElementCache.has(targ))\n                FBL.Firebug.HTML.selectTreeNode(""+ElementCache.key(targ));\n\n            lastInspecting = new Date().getTime();\n        }\n    },\n\n    /**\n     *\n     *   llttttttrr\n     *   llttttttrr\n     *   ll      rr\n     *   ll      rr\n     *   llbbbbbbrr\n     *   llbbbbbbrr\n     */\n    drawOutline: function(el)\n    {\n        var border = 2;\n        var scrollbarSize = 17;\n\n        var windowSize = Firebug.browser.getWindowSize();\n        var scrollSize = Firebug.browser.getWindowScrollSize();\n        var scrollPosition = Firebug.browser.getWindowScrollPosition();\n\n        var box = Firebug.browser.getElementBox(el);\n\n        var top = box.top;\n        var left = box.left;\n        var height = box.height;\n        var width = box.width;\n\n        var freeHorizontalSpace = scrollPosition.left + windowSize.width - left - width -\n                (!isIE && scrollSize.height > windowSize.height ? // is *vertical* scrollbar visible\n                 scrollbarSize : 0);\n\n        var freeVerticalSpace = scrollPosition.top + windowSize.height - top - height -\n                (!isIE && scrollSize.width > windowSize.width ? // is *horizontal* scrollbar visible\n                scrollbarSize : 0);\n\n        var numVerticalBorders = freeVerticalSpace > 0 ? 2 : 1;\n\n        var o = outlineElements;\n        var style;\n\n        style = o.fbOutlineT.style;\n        style.top = top-border + "px";\n        style.left = left + "px";\n        style.height = border + "px";  // TODO: on initialize()\n        style.width = width + "px";\n\n        style = o.fbOutlineL.style;\n        style.top = top-border + "px";\n        style.left = left-border + "px";\n        style.height = height+ numVerticalBorders*border + "px";\n        style.width = border + "px";  // TODO: on initialize()\n\n        style = o.fbOutlineB.style;\n        if (freeVerticalSpace > 0)\n        {\n            style.top = top+height + "px";\n            style.left = left + "px";\n            style.width = width + "px";\n            //style.height = border + "px"; // TODO: on initialize() or worst case?\n        }\n        else\n        {\n            style.top = -2*border + "px";\n            style.left = -2*border + "px";\n            style.width = border + "px";\n            //style.height = border + "px";\n        }\n\n        style = o.fbOutlineR.style;\n        if (freeHorizontalSpace > 0)\n        {\n            style.top = top-border + "px";\n            style.left = left+width + "px";\n            style.height = height + numVerticalBorders*border + "px";\n            style.width = (freeHorizontalSpace < border ? freeHorizontalSpace : border) + "px";\n        }\n        else\n        {\n            style.top = -2*border + "px";\n            style.left = -2*border + "px";\n            style.height = border + "px";\n            style.width = border + "px";\n        }\n\n        if (!outlineVisible) this.showOutline();\n    },\n\n    hideOutline: function()\n    {\n        if (!outlineVisible) return;\n\n        for (var name in outline)\n            offlineFragment.appendChild(outlineElements[name]);\n\n        outlineVisible = false;\n    },\n\n    showOutline: function()\n    {\n        if (outlineVisible) return;\n\n        if (boxModelVisible) this.hideBoxModel();\n\n        for (var name in outline)\n            Firebug.browser.document.getElementsByTagName("body")[0].appendChild(outlineElements[name]);\n\n        outlineVisible = true;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Box Model\n\n    drawBoxModel: function(el)\n    {\n        // avoid error when the element is not attached a document\n        if (!el || !el.parentNode)\n            return;\n\n        var box = Firebug.browser.getElementBox(el);\n\n        var windowSize = Firebug.browser.getWindowSize();\n        var scrollPosition = Firebug.browser.getWindowScrollPosition();\n\n        // element may be occluded by the chrome, when in frame mode\n        var offsetHeight = Firebug.chrome.type == "frame" ? Firebug.context.persistedState.height : 0;\n\n        // if element box is not inside the viewport, don\'t draw the box model\n        if (box.top > scrollPosition.top + windowSize.height - offsetHeight ||\n            box.left > scrollPosition.left + windowSize.width ||\n            scrollPosition.top > box.top + box.height ||\n            scrollPosition.left > box.left + box.width )\n            return;\n\n        var top = box.top;\n        var left = box.left;\n        var height = box.height;\n        var width = box.width;\n\n        var margin = Firebug.browser.getMeasurementBox(el, "margin");\n        var padding = Firebug.browser.getMeasurementBox(el, "padding");\n        var border = Firebug.browser.getMeasurementBox(el, "border");\n\n        boxModelStyle.top = top - margin.top + "px";\n        boxModelStyle.left = left - margin.left + "px";\n        boxModelStyle.height = height + margin.top + margin.bottom + "px";\n        boxModelStyle.width = width + margin.left + margin.right + "px";\n\n        boxBorderStyle.top = margin.top + "px";\n        boxBorderStyle.left = margin.left + "px";\n        boxBorderStyle.height = height + "px";\n        boxBorderStyle.width = width + "px";\n\n        boxPaddingStyle.top = margin.top + border.top + "px";\n        boxPaddingStyle.left = margin.left + border.left + "px";\n        boxPaddingStyle.height = height - border.top - border.bottom + "px";\n        boxPaddingStyle.width = width - border.left - border.right + "px";\n\n        boxContentStyle.top = margin.top + border.top + padding.top + "px";\n        boxContentStyle.left = margin.left + border.left + padding.left + "px";\n        boxContentStyle.height = height - border.top - padding.top - padding.bottom - border.bottom + "px";\n        boxContentStyle.width = width - border.left - padding.left - padding.right - border.right + "px";\n\n        if (!boxModelVisible) this.showBoxModel();\n    },\n\n    hideBoxModel: function()\n    {\n        if (!boxModelVisible) return;\n\n        offlineFragment.appendChild(boxModel);\n        boxModelVisible = false;\n    },\n\n    showBoxModel: function()\n    {\n        if (boxModelVisible) return;\n\n        if (outlineVisible) this.hideOutline();\n\n        Firebug.browser.document.getElementsByTagName("body")[0].appendChild(boxModel);\n        boxModelVisible = true;\n    }\n\n};\n\n// ************************************************************************************************\n// Inspector Internals\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Shared variables\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// Internal variables\n\nvar offlineFragment = null;\n\nvar boxModelVisible = false;\n\nvar boxModel, boxModelStyle,\n    boxMargin, boxMarginStyle,\n    boxBorder, boxBorderStyle,\n    boxPadding, boxPaddingStyle,\n    boxContent, boxContentStyle;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";\nvar offscreenStyle = resetStyle + "top:-1234px; left:-1234px;";\n\nvar inspectStyle = resetStyle + "z-index: 2147483500;";\nvar inspectFrameStyle = resetStyle + "z-index: 2147483550; top:0; left:0; background:url(" +\n                        Env.Location.skinDir + "pixel_transparent.gif);";\n\n//if (Env.Options.enableTrace) inspectFrameStyle = resetStyle + "z-index: 2147483550; top: 0; left: 0; background: #ff0; opacity: 0.05; _filter: alpha(opacity=5);";\n\nvar inspectModelOpacity = isIE ? "filter:alpha(opacity=80);" : "opacity:0.8;";\nvar inspectModelStyle = inspectStyle + inspectModelOpacity;\nvar inspectMarginStyle = inspectStyle + "background: #EDFF64; height:100%; width:100%;";\nvar inspectBorderStyle = inspectStyle + "background: #666;";\nvar inspectPaddingStyle = inspectStyle + "background: SlateBlue;";\nvar inspectContentStyle = inspectStyle + "background: SkyBlue;";\n\n\nvar outlineStyle = {\n    fbHorizontalLine: "background: #3875D7;height: 2px;",\n    fbVerticalLine: "background: #3875D7;width: 2px;"\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar lastInspecting = 0;\nvar fbInspectFrame = null;\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar outlineVisible = false;\nvar outlineElements = {};\nvar outline = {\n  "fbOutlineT": "fbHorizontalLine",\n  "fbOutlineL": "fbVerticalLine",\n  "fbOutlineB": "fbHorizontalLine",\n  "fbOutlineR": "fbVerticalLine"\n};\n\n\nvar getInspectingTarget = function()\n{\n\n};\n\n// ************************************************************************************************\n// Section\n\nvar createInspectorFrame = function createInspectorFrame()\n{\n    fbInspectFrame = createGlobalElement("div");\n    fbInspectFrame.id = "fbInspectFrame";\n    fbInspectFrame.firebugIgnore = true;\n    fbInspectFrame.style.cssText = inspectFrameStyle;\n    Firebug.browser.document.getElementsByTagName("body")[0].appendChild(fbInspectFrame);\n};\n\nvar destroyInspectorFrame = function destroyInspectorFrame()\n{\n    if (fbInspectFrame)\n    {\n        Firebug.browser.document.getElementsByTagName("body")[0].removeChild(fbInspectFrame);\n        fbInspectFrame = null;\n    }\n};\n\nvar createOutlineInspector = function createOutlineInspector()\n{\n    for (var name in outline)\n    {\n        var el = outlineElements[name] = createGlobalElement("div");\n        el.id = name;\n        el.firebugIgnore = true;\n        el.style.cssText = inspectStyle + outlineStyle[outline[name]];\n        offlineFragment.appendChild(el);\n    }\n};\n\nvar destroyOutlineInspector = function destroyOutlineInspector()\n{\n    for (var name in outline)\n    {\n        var el = outlineElements[name];\n        el.parentNode.removeChild(el);\n    }\n};\n\nvar createBoxModelInspector = function createBoxModelInspector()\n{\n    boxModel = createGlobalElement("div");\n    boxModel.id = "fbBoxModel";\n    boxModel.firebugIgnore = true;\n    boxModelStyle = boxModel.style;\n    boxModelStyle.cssText = inspectModelStyle;\n\n    boxMargin = createGlobalElement("div");\n    boxMargin.id = "fbBoxMargin";\n    boxMarginStyle = boxMargin.style;\n    boxMarginStyle.cssText = inspectMarginStyle;\n    boxModel.appendChild(boxMargin);\n\n    boxBorder = createGlobalElement("div");\n    boxBorder.id = "fbBoxBorder";\n    boxBorderStyle = boxBorder.style;\n    boxBorderStyle.cssText = inspectBorderStyle;\n    boxModel.appendChild(boxBorder);\n\n    boxPadding = createGlobalElement("div");\n    boxPadding.id = "fbBoxPadding";\n    boxPaddingStyle = boxPadding.style;\n    boxPaddingStyle.cssText = inspectPaddingStyle;\n    boxModel.appendChild(boxPadding);\n\n    boxContent = createGlobalElement("div");\n    boxContent.id = "fbBoxContent";\n    boxContentStyle = boxContent.style;\n    boxContentStyle.cssText = inspectContentStyle;\n    boxModel.appendChild(boxContent);\n\n    offlineFragment.appendChild(boxModel);\n};\n\nvar destroyBoxModelInspector = function destroyBoxModelInspector()\n{\n    boxModel.parentNode.removeChild(boxModel);\n};\n\n// ************************************************************************************************\n// Section\n\n\n\n\n// ************************************************************************************************\n}});\n\n// Problems in IE\n// FIXED - eval return\n// FIXED - addEventListener problem in IE\n// FIXED doc.createRange?\n//\n// class reserved word\n// test all honza examples in IE6 and IE7\n\n\n/* See license.txt for terms of usage */\n\n( /** @scope s_domplate */ function() {\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n/** @class */\nFBL.DomplateTag = function DomplateTag(tagName)\n{\n    this.tagName = tagName;\n};\n\n/**\n * @class\n * @extends FBL.DomplateTag\n */\nFBL.DomplateEmbed = function DomplateEmbed()\n{\n};\n\n/**\n * @class\n * @extends FBL.DomplateTag\n */\nFBL.DomplateLoop = function DomplateLoop()\n{\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar DomplateTag = FBL.DomplateTag;\nvar DomplateEmbed = FBL.DomplateEmbed;\nvar DomplateLoop = FBL.DomplateLoop;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar womb = null;\n\nFBL.domplate = function()\n{\n    var lastSubject;\n    for (var i = 0; i < arguments.length; ++i)\n        lastSubject = lastSubject ? copyObject(lastSubject, arguments[i]) : arguments[i];\n\n    for (var name in lastSubject)\n    {\n        var val = lastSubject[name];\n        if (isTag(val))\n            val.tag.subject = lastSubject;\n    }\n\n    return lastSubject;\n};\n\nvar domplate = FBL.domplate;\n\nFBL.domplate.context = function(context, fn)\n{\n    var lastContext = domplate.lastContext;\n    domplate.topContext = context;\n    fn.apply(context);\n    domplate.topContext = lastContext;\n};\n\nFBL.TAG = function()\n{\n    var embed = new DomplateEmbed();\n    return embed.merge(arguments);\n};\n\nFBL.FOR = function()\n{\n    var loop = new DomplateLoop();\n    return loop.merge(arguments);\n};\n\nFBL.DomplateTag.prototype =\n{\n    merge: function(args, oldTag)\n    {\n        if (oldTag)\n            this.tagName = oldTag.tagName;\n\n        this.context = oldTag ? oldTag.context : null;\n        this.subject = oldTag ? oldTag.subject : null;\n        this.attrs = oldTag ? copyObject(oldTag.attrs) : {};\n        this.classes = oldTag ? copyObject(oldTag.classes) : {};\n        this.props = oldTag ? copyObject(oldTag.props) : null;\n        this.listeners = oldTag ? copyArray(oldTag.listeners) : null;\n        this.children = oldTag ? copyArray(oldTag.children) : [];\n        this.vars = oldTag ? copyArray(oldTag.vars) : [];\n\n        var attrs = args.length ? args[0] : null;\n        var hasAttrs = typeof(attrs) == "object" && !isTag(attrs);\n\n        this.children = [];\n\n        if (domplate.topContext)\n            this.context = domplate.topContext;\n\n        if (args.length)\n            parseChildren(args, hasAttrs ? 1 : 0, this.vars, this.children);\n\n        if (hasAttrs)\n            this.parseAttrs(attrs);\n\n        return creator(this, DomplateTag);\n    },\n\n    parseAttrs: function(args)\n    {\n        for (var name in args)\n        {\n            var val = parseValue(args[name]);\n            readPartNames(val, this.vars);\n\n            if (name.indexOf("on") == 0)\n            {\n                var eventName = name.substr(2);\n                if (!this.listeners)\n                    this.listeners = [];\n                this.listeners.push(eventName, val);\n            }\n            else if (name.indexOf("_") == 0)\n            {\n                var propName = name.substr(1);\n                if (!this.props)\n                    this.props = {};\n                this.props[propName] = val;\n            }\n            else if (name.indexOf("$") == 0)\n            {\n                var className = name.substr(1);\n                if (!this.classes)\n                    this.classes = {};\n                this.classes[className] = val;\n            }\n            else\n            {\n                if (name == "class" && this.attrs.hasOwnProperty(name) )\n                    this.attrs[name] += " " + val;\n                else\n                    this.attrs[name] = val;\n            }\n        }\n    },\n\n    compile: function()\n    {\n        if (this.renderMarkup)\n            return;\n\n        this.compileMarkup();\n        this.compileDOM();\n\n        //if (FBTrace.DBG_DOM) FBTrace.sysout("domplate renderMarkup: ", this.renderMarkup);\n        //if (FBTrace.DBG_DOM) FBTrace.sysout("domplate renderDOM:", this.renderDOM);\n        //if (FBTrace.DBG_DOM) FBTrace.sysout("domplate domArgs:", this.domArgs);\n    },\n\n    compileMarkup: function()\n    {\n        this.markupArgs = [];\n        var topBlock = [], topOuts = [], blocks = [], info = {args: this.markupArgs, argIndex: 0};\n\n        this.generateMarkup(topBlock, topOuts, blocks, info);\n        this.addCode(topBlock, topOuts, blocks);\n\n        var fnBlock = [\'r=(function (__code__, __context__, __in__, __out__\'];\n        for (var i = 0; i < info.argIndex; ++i)\n            fnBlock.push(\', s\', i);\n        fnBlock.push(\') {\');\n\n        if (this.subject)\n            fnBlock.push(\'with (this) {\');\n        if (this.context)\n            fnBlock.push(\'with (__context__) {\');\n        fnBlock.push(\'with (__in__) {\');\n\n        fnBlock.push.apply(fnBlock, blocks);\n\n        if (this.subject)\n            fnBlock.push(\'}\');\n        if (this.context)\n            fnBlock.push(\'}\');\n\n        fnBlock.push(\'}})\');\n\n        function __link__(tag, code, outputs, args)\n        {\n            if (!tag || !tag.tag)\n                return;\n\n            tag.tag.compile();\n\n            var tagOutputs = [];\n            var markupArgs = [code, tag.tag.context, args, tagOutputs];\n            markupArgs.push.apply(markupArgs, tag.tag.markupArgs);\n            tag.tag.renderMarkup.apply(tag.tag.subject, markupArgs);\n\n            outputs.push(tag);\n            outputs.push(tagOutputs);\n        }\n\n        function __escape__(value)\n        {\n            function replaceChars(ch)\n            {\n                switch (ch)\n                {\n                    case "<":\n                        return "&lt;";\n                    case ">":\n                        return "&gt;";\n                    case "&":\n                        return "&amp;";\n                    case "\'":\n                        return "&#39;";\n                    case \'"\':\n                        return "&quot;";\n                }\n                return "?";\n            };\n            return String(value).replace(/[<>&"\']/g, replaceChars);\n        }\n\n        function __loop__(iter, outputs, fn)\n        {\n            var iterOuts = [];\n            outputs.push(iterOuts);\n\n            if (iter instanceof Array)\n                iter = new ArrayIterator(iter);\n\n            try\n            {\n                while (1)\n                {\n                    var value = iter.next();\n                    var itemOuts = [0,0];\n                    iterOuts.push(itemOuts);\n                    fn.apply(this, [value, itemOuts]);\n                }\n            }\n            catch (exc)\n            {\n                if (exc != StopIteration)\n                    throw exc;\n            }\n        }\n\n        var js = fnBlock.join("");\n        var r = null;\n        eval(js);\n        this.renderMarkup = r;\n    },\n\n    getVarNames: function(args)\n    {\n        if (this.vars)\n            args.push.apply(args, this.vars);\n\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            var child = this.children[i];\n            if (isTag(child))\n                child.tag.getVarNames(args);\n            else if (child instanceof Parts)\n            {\n                for (var i = 0; i < child.parts.length; ++i)\n                {\n                    if (child.parts[i] instanceof Variable)\n                    {\n                        var name = child.parts[i].name;\n                        var names = name.split(".");\n                        args.push(names[0]);\n                    }\n                }\n            }\n        }\n    },\n\n    generateMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        topBlock.push(\',"<\', this.tagName, \'"\');\n\n        for (var name in this.attrs)\n        {\n            if (name != "class")\n            {\n                var val = this.attrs[name];\n                topBlock.push(\', " \', name, \'=\\\\""\');\n                addParts(val, \',\', topBlock, info, true);\n                topBlock.push(\', "\\\\""\');\n            }\n        }\n\n        if (this.listeners)\n        {\n            for (var i = 0; i < this.listeners.length; i += 2)\n                readPartNames(this.listeners[i+1], topOuts);\n        }\n\n        if (this.props)\n        {\n            for (var name in this.props)\n                readPartNames(this.props[name], topOuts);\n        }\n\n        if ( this.attrs.hasOwnProperty("class") || this.classes)\n        {\n            topBlock.push(\', " class=\\\\""\');\n            if (this.attrs.hasOwnProperty("class"))\n                addParts(this.attrs["class"], \',\', topBlock, info, true);\n              topBlock.push(\', " "\');\n            for (var name in this.classes)\n            {\n                topBlock.push(\', (\');\n                addParts(this.classes[name], \'\', topBlock, info);\n                topBlock.push(\' ? "\', name, \'" + " " : "")\');\n            }\n            topBlock.push(\', "\\\\""\');\n        }\n        topBlock.push(\',">"\');\n\n        this.generateChildMarkup(topBlock, topOuts, blocks, info);\n        topBlock.push(\',"</\', this.tagName, \'>"\');\n    },\n\n    generateChildMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            var child = this.children[i];\n            if (isTag(child))\n                child.tag.generateMarkup(topBlock, topOuts, blocks, info);\n            else\n                addParts(child, \',\', topBlock, info, true);\n        }\n    },\n\n    addCode: function(topBlock, topOuts, blocks)\n    {\n        if (topBlock.length)\n            blocks.push(\'__code__.push(""\', topBlock.join(""), \');\');\n        if (topOuts.length)\n            blocks.push(\'__out__.push(\', topOuts.join(","), \');\');\n        topBlock.splice(0, topBlock.length);\n        topOuts.splice(0, topOuts.length);\n    },\n\n    addLocals: function(blocks)\n    {\n        var varNames = [];\n        this.getVarNames(varNames);\n\n        var map = {};\n        for (var i = 0; i < varNames.length; ++i)\n        {\n            var name = varNames[i];\n            if ( map.hasOwnProperty(name) )\n                continue;\n\n            map[name] = 1;\n            var names = name.split(".");\n            blocks.push(\'var \', names[0] + \' = \' + \'__in__.\' + names[0] + \';\');\n        }\n    },\n\n    compileDOM: function()\n    {\n        var path = [];\n        var blocks = [];\n        this.domArgs = [];\n        path.embedIndex = 0;\n        path.loopIndex = 0;\n        path.staticIndex = 0;\n        path.renderIndex = 0;\n        var nodeCount = this.generateDOM(path, blocks, this.domArgs);\n\n        var fnBlock = [\'r=(function (root, context, o\'];\n\n        for (var i = 0; i < path.staticIndex; ++i)\n            fnBlock.push(\', \', \'s\'+i);\n\n        for (var i = 0; i < path.renderIndex; ++i)\n            fnBlock.push(\', \', \'d\'+i);\n\n        fnBlock.push(\') {\');\n        for (var i = 0; i < path.loopIndex; ++i)\n            fnBlock.push(\'var l\', i, \' = 0;\');\n        for (var i = 0; i < path.embedIndex; ++i)\n            fnBlock.push(\'var e\', i, \' = 0;\');\n\n        if (this.subject)\n            fnBlock.push(\'with (this) {\');\n        if (this.context)\n            fnBlock.push(\'with (context) {\');\n\n        fnBlock.push(blocks.join(""));\n\n        if (this.subject)\n            fnBlock.push(\'}\');\n        if (this.context)\n            fnBlock.push(\'}\');\n\n        fnBlock.push(\'return \', nodeCount, \';\');\n        fnBlock.push(\'})\');\n\n        function __bind__(object, fn)\n        {\n            return function(event) { return fn.apply(object, [event]); };\n        }\n\n        function __link__(node, tag, args)\n        {\n            if (!tag || !tag.tag)\n                return;\n\n            tag.tag.compile();\n\n            var domArgs = [node, tag.tag.context, 0];\n            domArgs.push.apply(domArgs, tag.tag.domArgs);\n            domArgs.push.apply(domArgs, args);\n            //if (FBTrace.DBG_DOM) FBTrace.dumpProperties("domplate__link__ domArgs:", domArgs);\n            return tag.tag.renderDOM.apply(tag.tag.subject, domArgs);\n        }\n\n        var self = this;\n        function __loop__(iter, fn)\n        {\n            var nodeCount = 0;\n            for (var i = 0; i < iter.length; ++i)\n            {\n                iter[i][0] = i;\n                iter[i][1] = nodeCount;\n                nodeCount += fn.apply(this, iter[i]);\n                //if (FBTrace.DBG_DOM) FBTrace.sysout("nodeCount", nodeCount);\n            }\n            return nodeCount;\n        }\n\n        function __path__(parent, offset)\n        {\n            //if (FBTrace.DBG_DOM) FBTrace.sysout("domplate __path__ offset: "+ offset+"\\n");\n            var root = parent;\n\n            for (var i = 2; i < arguments.length; ++i)\n            {\n                var index = arguments[i];\n                if (i == 3)\n                    index += offset;\n\n                if (index == -1)\n                    parent = parent.parentNode;\n                else\n                    parent = parent.childNodes[index];\n            }\n\n            //if (FBTrace.DBG_DOM) FBTrace.sysout("domplate: "+arguments[2]+", root: "+ root+", parent: "+ parent+"\\n");\n            return parent;\n        }\n\n        var js = fnBlock.join("");\n        //if (FBTrace.DBG_DOM) FBTrace.sysout(js.replace(/(\\;|\\{)/g, "$1\\n"));\n        var r = null;\n        eval(js);\n        this.renderDOM = r;\n    },\n\n    generateDOM: function(path, blocks, args)\n    {\n        if (this.listeners || this.props)\n            this.generateNodePath(path, blocks);\n\n        if (this.listeners)\n        {\n            for (var i = 0; i < this.listeners.length; i += 2)\n            {\n                var val = this.listeners[i+1];\n                var arg = generateArg(val, path, args);\n                //blocks.push(\'node.addEventListener("\', this.listeners[i], \'", __bind__(this, \', arg, \'), false);\');\n                blocks.push(\'addEvent(node, "\', this.listeners[i], \'", __bind__(this, \', arg, \'), false);\');\n            }\n        }\n\n        if (this.props)\n        {\n            for (var name in this.props)\n            {\n                var val = this.props[name];\n                var arg = generateArg(val, path, args);\n                blocks.push(\'node.\', name, \' = \', arg, \';\');\n            }\n        }\n\n        this.generateChildDOM(path, blocks, args);\n        return 1;\n    },\n\n    generateNodePath: function(path, blocks)\n    {\n        blocks.push("var node = __path__(root, o");\n        for (var i = 0; i < path.length; ++i)\n            blocks.push(",", path[i]);\n        blocks.push(");");\n    },\n\n    generateChildDOM: function(path, blocks, args)\n    {\n        path.push(0);\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            var child = this.children[i];\n            if (isTag(child))\n                path[path.length-1] += \'+\' + child.tag.generateDOM(path, blocks, args);\n            else\n                path[path.length-1] += \'+1\';\n        }\n        path.pop();\n    }\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nFBL.DomplateEmbed.prototype = copyObject(FBL.DomplateTag.prototype,\n/** @lends FBL.DomplateEmbed.prototype */\n{\n    merge: function(args, oldTag)\n    {\n        this.value = oldTag ? oldTag.value : parseValue(args[0]);\n        this.attrs = oldTag ? oldTag.attrs : {};\n        this.vars = oldTag ? copyArray(oldTag.vars) : [];\n\n        var attrs = args[1];\n        for (var name in attrs)\n        {\n            var val = parseValue(attrs[name]);\n            this.attrs[name] = val;\n            readPartNames(val, this.vars);\n        }\n\n        return creator(this, DomplateEmbed);\n    },\n\n    getVarNames: function(names)\n    {\n        if (this.value instanceof Parts)\n            names.push(this.value.parts[0].name);\n\n        if (this.vars)\n            names.push.apply(names, this.vars);\n    },\n\n    generateMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        this.addCode(topBlock, topOuts, blocks);\n\n        blocks.push(\'__link__(\');\n        addParts(this.value, \'\', blocks, info);\n        blocks.push(\', __code__, __out__, {\');\n\n        var lastName = null;\n        for (var name in this.attrs)\n        {\n            if (lastName)\n                blocks.push(\',\');\n            lastName = name;\n\n            var val = this.attrs[name];\n            blocks.push(\'"\', name, \'":\');\n            addParts(val, \'\', blocks, info);\n        }\n\n        blocks.push(\'});\');\n        //this.generateChildMarkup(topBlock, topOuts, blocks, info);\n    },\n\n    generateDOM: function(path, blocks, args)\n    {\n        var embedName = \'e\'+path.embedIndex++;\n\n        this.generateNodePath(path, blocks);\n\n        var valueName = \'d\' + path.renderIndex++;\n        var argsName = \'d\' + path.renderIndex++;\n        blocks.push(embedName + \' = __link__(node, \', valueName, \', \', argsName, \');\');\n\n        return embedName;\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nFBL.DomplateLoop.prototype = copyObject(FBL.DomplateTag.prototype,\n/** @lends FBL.DomplateLoop.prototype */\n{\n    merge: function(args, oldTag)\n    {\n        this.varName = oldTag ? oldTag.varName : args[0];\n        this.iter = oldTag ? oldTag.iter : parseValue(args[1]);\n        this.vars = [];\n\n        this.children = oldTag ? copyArray(oldTag.children) : [];\n\n        var offset = Math.min(args.length, 2);\n        parseChildren(args, offset, this.vars, this.children);\n\n        return creator(this, DomplateLoop);\n    },\n\n    getVarNames: function(names)\n    {\n        if (this.iter instanceof Parts)\n            names.push(this.iter.parts[0].name);\n\n        DomplateTag.prototype.getVarNames.apply(this, [names]);\n    },\n\n    generateMarkup: function(topBlock, topOuts, blocks, info)\n    {\n        this.addCode(topBlock, topOuts, blocks);\n\n        var iterName;\n        if (this.iter instanceof Parts)\n        {\n            var part = this.iter.parts[0];\n            iterName = part.name;\n\n            if (part.format)\n            {\n                for (var i = 0; i < part.format.length; ++i)\n                    iterName = part.format[i] + "(" + iterName + ")";\n            }\n        }\n        else\n            iterName = this.iter;\n\n        blocks.push(\'__loop__.apply(this, [\', iterName, \', __out__, function(\', this.varName, \', __out__) {\');\n        this.generateChildMarkup(topBlock, topOuts, blocks, info);\n        this.addCode(topBlock, topOuts, blocks);\n        blocks.push(\'}]);\');\n    },\n\n    generateDOM: function(path, blocks, args)\n    {\n        var iterName = \'d\'+path.renderIndex++;\n        var counterName = \'i\'+path.loopIndex;\n        var loopName = \'l\'+path.loopIndex++;\n\n        if (!path.length)\n            path.push(-1, 0);\n\n        var preIndex = path.renderIndex;\n        path.renderIndex = 0;\n\n        var nodeCount = 0;\n\n        var subBlocks = [];\n        var basePath = path[path.length-1];\n        for (var i = 0; i < this.children.length; ++i)\n        {\n            path[path.length-1] = basePath+\'+\'+loopName+\'+\'+nodeCount;\n\n            var child = this.children[i];\n            if (isTag(child))\n                nodeCount += \'+\' + child.tag.generateDOM(path, subBlocks, args);\n            else\n                nodeCount += \'+1\';\n        }\n\n        path[path.length-1] = basePath+\'+\'+loopName;\n\n        blocks.push(loopName,\' = __loop__.apply(this, [\', iterName, \', function(\', counterName,\',\',loopName);\n        for (var i = 0; i < path.renderIndex; ++i)\n            blocks.push(\',d\'+i);\n        blocks.push(\') {\');\n        blocks.push(subBlocks.join(""));\n        blocks.push(\'return \', nodeCount, \';\');\n        blocks.push(\'}]);\');\n\n        path.renderIndex = preIndex;\n\n        return loopName;\n    }\n});\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n/** @class */\nfunction Variable(name, format)\n{\n    this.name = name;\n    this.format = format;\n}\n\n/** @class */\nfunction Parts(parts)\n{\n    this.parts = parts;\n}\n\n// ************************************************************************************************\n\nfunction parseParts(str)\n{\n    var re = /\\$([_A-Za-z][_A-Za-z0-9.|]*)/g;\n    var index = 0;\n    var parts = [];\n\n    var m;\n    while (m = re.exec(str))\n    {\n        var pre = str.substr(index, (re.lastIndex-m[0].length)-index);\n        if (pre)\n            parts.push(pre);\n\n        var expr = m[1].split("|");\n        parts.push(new Variable(expr[0], expr.slice(1)));\n        index = re.lastIndex;\n    }\n\n    if (!index)\n        return str;\n\n    var post = str.substr(index);\n    if (post)\n        parts.push(post);\n\n    return new Parts(parts);\n}\n\nfunction parseValue(val)\n{\n    return typeof(val) == \'string\' ? parseParts(val) : val;\n}\n\nfunction parseChildren(args, offset, vars, children)\n{\n    for (var i = offset; i < args.length; ++i)\n    {\n        var val = parseValue(args[i]);\n        children.push(val);\n        readPartNames(val, vars);\n    }\n}\n\nfunction readPartNames(val, vars)\n{\n    if (val instanceof Parts)\n    {\n        for (var i = 0; i < val.parts.length; ++i)\n        {\n            var part = val.parts[i];\n            if (part instanceof Variable)\n                vars.push(part.name);\n        }\n    }\n}\n\nfunction generateArg(val, path, args)\n{\n    if (val instanceof Parts)\n    {\n        var vals = [];\n        for (var i = 0; i < val.parts.length; ++i)\n        {\n            var part = val.parts[i];\n            if (part instanceof Variable)\n            {\n                var varName = \'d\'+path.renderIndex++;\n                if (part.format)\n                {\n                    for (var j = 0; j < part.format.length; ++j)\n                        varName = part.format[j] + \'(\' + varName + \')\';\n                }\n\n                vals.push(varName);\n            }\n            else\n                vals.push(\'"\'+part.replace(/"/g, \'\\\\"\')+\'"\');\n        }\n\n        return vals.join(\'+\');\n    }\n    else\n    {\n        args.push(val);\n        return \'s\' + path.staticIndex++;\n    }\n}\n\nfunction addParts(val, delim, block, info, escapeIt)\n{\n    var vals = [];\n    if (val instanceof Parts)\n    {\n        for (var i = 0; i < val.parts.length; ++i)\n        {\n            var part = val.parts[i];\n            if (part instanceof Variable)\n            {\n                var partName = part.name;\n                if (part.format)\n                {\n                    for (var j = 0; j < part.format.length; ++j)\n                        partName = part.format[j] + "(" + partName + ")";\n                }\n\n                if (escapeIt)\n                    vals.push("__escape__(" + partName + ")");\n                else\n                    vals.push(partName);\n            }\n            else\n                vals.push(\'"\'+ part + \'"\');\n        }\n    }\n    else if (isTag(val))\n    {\n        info.args.push(val);\n        vals.push(\'s\'+info.argIndex++);\n    }\n    else\n        vals.push(\'"\'+ val + \'"\');\n\n    var parts = vals.join(delim);\n    if (parts)\n        block.push(delim, parts);\n}\n\nfunction isTag(obj)\n{\n    return (typeof(obj) == "function" || obj instanceof Function) && !!obj.tag;\n}\n\nfunction creator(tag, cons)\n{\n    var fn = new Function(\n        "var tag = arguments.callee.tag;" +\n        "var cons = arguments.callee.cons;" +\n        "var newTag = new cons();" +\n        "return newTag.merge(arguments, tag);");\n\n    fn.tag = tag;\n    fn.cons = cons;\n    extend(fn, Renderer);\n\n    return fn;\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nfunction copyArray(oldArray)\n{\n    var ary = [];\n    if (oldArray)\n        for (var i = 0; i < oldArray.length; ++i)\n            ary.push(oldArray[i]);\n   return ary;\n}\n\nfunction copyObject(l, r)\n{\n    var m = {};\n    extend(m, l);\n    extend(m, r);\n    return m;\n}\n\nfunction extend(l, r)\n{\n    for (var n in r)\n        l[n] = r[n];\n}\n\nfunction addEvent(object, name, handler)\n{\n    if (document.all)\n        object.attachEvent("on"+name, handler);\n    else\n        object.addEventListener(name, handler, false);\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n/** @class */\nfunction ArrayIterator(array)\n{\n    var index = -1;\n\n    this.next = function()\n    {\n        if (++index >= array.length)\n            throw StopIteration;\n\n        return array[index];\n    };\n}\n\n/** @class */\nfunction StopIteration() {}\n\nFBL.$break = function()\n{\n    throw StopIteration;\n};\n\n// ************************************************************************************************\n\n/** @namespace */\nvar Renderer =\n{\n    renderHTML: function(args, outputs, self)\n    {\n        var code = [];\n        var markupArgs = [code, this.tag.context, args, outputs];\n        markupArgs.push.apply(markupArgs, this.tag.markupArgs);\n        this.tag.renderMarkup.apply(self ? self : this.tag.subject, markupArgs);\n        return code.join("");\n    },\n\n    insertRows: function(args, before, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        var doc = before.ownerDocument;\n        var div = doc.createElement("div");\n        div.innerHTML = "<table><tbody>"+html+"</tbody></table>";\n\n        var tbody = div.firstChild.firstChild;\n        var parent = before.tagName == "TR" ? before.parentNode : before;\n        var after = before.tagName == "TR" ? before.nextSibling : null;\n\n        var firstRow = tbody.firstChild, lastRow;\n        while (tbody.firstChild)\n        {\n            lastRow = tbody.firstChild;\n            if (after)\n                parent.insertBefore(lastRow, after);\n            else\n                parent.appendChild(lastRow);\n        }\n\n        var offset = 0;\n        if (before.tagName == "TR")\n        {\n            var node = firstRow.parentNode.firstChild;\n            for (; node && node != firstRow; node = node.nextSibling)\n                ++offset;\n        }\n\n        var domArgs = [firstRow, this.tag.context, offset];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n        return [firstRow, lastRow];\n    },\n\n    insertBefore: function(args, before, self)\n    {\n        return this.insertNode(args, before.ownerDocument, before, false, self);\n    },\n\n    insertAfter: function(args, after, self)\n    {\n        return this.insertNode(args, after.ownerDocument, after, true, self);\n    },\n\n    insertNode: function(args, doc, element, isAfter, self)\n    {\n        if (!args)\n            args = {};\n\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        //if (FBTrace.DBG_DOM)\n        //    FBTrace.sysout("domplate.insertNode html: "+html+"\\n");\n\n        var doc = element.ownerDocument;\n        if (!womb || womb.ownerDocument != doc)\n            womb = doc.createElement("div");\n\n        womb.innerHTML = html;\n\n        var root = womb.firstChild;\n        if (isAfter)\n        {\n            while (womb.firstChild)\n                if (element.nextSibling)\n                    element.parentNode.insertBefore(womb.firstChild, element.nextSibling);\n                else\n                    element.parentNode.appendChild(womb.firstChild);\n        }\n        else\n        {\n            while (womb.lastChild)\n                element.parentNode.insertBefore(womb.lastChild, element);\n        }\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n\n        //if (FBTrace.DBG_DOM)\n        //    FBTrace.sysout("domplate.insertNode domArgs:", domArgs);\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n\n        return root;\n    },\n    /**/\n\n    /*\n    insertAfter: function(args, before, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        var doc = before.ownerDocument;\n        if (!womb || womb.ownerDocument != doc)\n            womb = doc.createElement("div");\n\n        womb.innerHTML = html;\n\n        var root = womb.firstChild;\n        while (womb.firstChild)\n            if (before.nextSibling)\n                before.parentNode.insertBefore(womb.firstChild, before.nextSibling);\n            else\n                before.parentNode.appendChild(womb.firstChild);\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n\n        this.tag.renderDOM.apply(self ? self : (this.tag.subject ? this.tag.subject : null),\n            domArgs);\n\n        return root;\n    },\n    /**/\n\n    replace: function(args, parent, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n\n        var root;\n        if (parent.nodeType == 1)\n        {\n            parent.innerHTML = html;\n            root = parent.firstChild;\n        }\n        else\n        {\n            if (!parent || parent.nodeType != 9)\n                parent = document;\n\n            if (!womb || womb.ownerDocument != parent)\n                womb = parent.createElement("div");\n            womb.innerHTML = html;\n\n            root = womb.firstChild;\n            //womb.removeChild(root);\n        }\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n\n        return root;\n    },\n\n    append: function(args, parent, self)\n    {\n        this.tag.compile();\n\n        var outputs = [];\n        var html = this.renderHTML(args, outputs, self);\n        //if (FBTrace.DBG_DOM) FBTrace.sysout("domplate.append html: "+html+"\\n");\n\n        if (!womb || womb.ownerDocument != parent.ownerDocument)\n            womb = parent.ownerDocument.createElement("div");\n        womb.innerHTML = html;\n\n        // TODO: xxxpedro domplate port to Firebug\n        var root = womb.firstChild;\n        while (womb.firstChild)\n            parent.appendChild(womb.firstChild);\n\n        // clearing element reference to avoid reference error in IE8 when switching contexts\n        womb = null;\n\n        var domArgs = [root, this.tag.context, 0];\n        domArgs.push.apply(domArgs, this.tag.domArgs);\n        domArgs.push.apply(domArgs, outputs);\n\n        //if (FBTrace.DBG_DOM) FBTrace.dumpProperties("domplate append domArgs:", domArgs);\n        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);\n\n        return root;\n    }\n};\n\n// ************************************************************************************************\n\nfunction defineTags()\n{\n    for (var i = 0; i < arguments.length; ++i)\n    {\n        var tagName = arguments[i];\n        var fn = new Function("var newTag = new arguments.callee.DomplateTag(\'"+tagName+"\'); return newTag.merge(arguments);");\n        fn.DomplateTag = DomplateTag;\n\n        var fnName = tagName.toUpperCase();\n        FBL[fnName] = fn;\n    }\n}\n\ndefineTags(\n    "a", "button", "br", "canvas", "code", "col", "colgroup", "div", "fieldset", "form", "h1", "h2", "h3", "hr",\n     "img", "input", "label", "legend", "li", "ol", "optgroup", "option", "p", "pre", "select",\n    "span", "strong", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "tr", "tt", "ul", "iframe"\n);\n\n})();\n\n\n/* See license.txt for terms of usage */\n\nvar FirebugReps = FBL.ns(function() { with (FBL) {\n\n\n// ************************************************************************************************\n// Common Tags\n\nvar OBJECTBOX = this.OBJECTBOX =\n    SPAN({"class": "objectBox objectBox-$className"});\n\nvar OBJECTBLOCK = this.OBJECTBLOCK =\n    DIV({"class": "objectBox objectBox-$className"});\n\nvar OBJECTLINK = this.OBJECTLINK = isIE6 ? // IE6 object link representation\n    A({\n        "class": "objectLink objectLink-$className a11yFocus",\n        href: "javascript:void(0)",\n        // workaround to show XPath (a better approach would use the tooltip on mouseover,\n        // so the XPath information would be calculated dynamically, but we need to create\n        // a tooltip class/wrapper around Menu or InfoTip)\n        title: "$object|FBL.getElementXPath",\n        _repObject: "$object"\n    })\n    : // Other browsers\n    A({\n        "class": "objectLink objectLink-$className a11yFocus",\n        // workaround to show XPath (a better approach would use the tooltip on mouseover,\n        // so the XPath information would be calculated dynamically, but we need to create\n        // a tooltip class/wrapper around Menu or InfoTip)\n        title: "$object|FBL.getElementXPath",\n        _repObject: "$object"\n    });\n\n\n// ************************************************************************************************\n\nthis.Undefined = domplate(Firebug.Rep,\n{\n    tag: OBJECTBOX("undefined"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "undefined",\n\n    supportsObject: function(object, type)\n    {\n        return type == "undefined";\n    }\n});\n\n// ************************************************************************************************\n\nthis.Null = domplate(Firebug.Rep,\n{\n    tag: OBJECTBOX("null"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "null",\n\n    supportsObject: function(object, type)\n    {\n        return object == null;\n    }\n});\n\n// ************************************************************************************************\n\nthis.Nada = domplate(Firebug.Rep,\n{\n    tag: SPAN(""),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "nada"\n});\n\n// ************************************************************************************************\n\nthis.Number = domplate(Firebug.Rep,\n{\n    tag: OBJECTBOX("$object"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "number",\n\n    supportsObject: function(object, type)\n    {\n        return type == "boolean" || type == "number";\n    }\n});\n\n// ************************************************************************************************\n\nthis.String = domplate(Firebug.Rep,\n{\n    tag: OBJECTBOX("&quot;$object&quot;"),\n\n    shortTag: OBJECTBOX("&quot;$object|cropString&quot;"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "string",\n\n    supportsObject: function(object, type)\n    {\n        return type == "string";\n    }\n});\n\n// ************************************************************************************************\n\nthis.Text = domplate(Firebug.Rep,\n{\n    tag: OBJECTBOX("$object"),\n\n    shortTag: OBJECTBOX("$object|cropString"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "text"\n});\n\n// ************************************************************************************************\n\nthis.Caption = domplate(Firebug.Rep,\n{\n    tag: SPAN({"class": "caption"}, "$object")\n});\n\n// ************************************************************************************************\n\nthis.Warning = domplate(Firebug.Rep,\n{\n    tag: DIV({"class": "warning focusRow", role : \'listitem\'}, "$object|STR")\n});\n\n// ************************************************************************************************\n\nthis.Func = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK("$object|summarizeFunction"),\n\n    summarizeFunction: function(fn)\n    {\n        var fnRegex = /function ([^(]+\\([^)]*\\)) \\{/;\n        var fnText = safeToString(fn);\n\n        var m = fnRegex.exec(fnText);\n        return m ? m[1] : "function()";\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    copySource: function(fn)\n    {\n        copyToClipboard(safeToString(fn));\n    },\n\n    monitor: function(fn, script, monitored)\n    {\n        if (monitored)\n            Firebug.Debugger.unmonitorScript(fn, script, "monitor");\n        else\n            Firebug.Debugger.monitorScript(fn, script, "monitor");\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "function",\n\n    supportsObject: function(object, type)\n    {\n        return isFunction(object);\n    },\n\n    inspectObject: function(fn, context)\n    {\n        var sourceLink = findSourceForFunction(fn, context);\n        if (sourceLink)\n            Firebug.chrome.select(sourceLink);\n        if (FBTrace.DBG_FUNCTION_NAME)\n            FBTrace.sysout("reps.function.inspectObject selected sourceLink is ", sourceLink);\n    },\n\n    getTooltip: function(fn, context)\n    {\n        var script = findScriptForFunctionInContext(context, fn);\n        if (script)\n            return $STRF("Line", [normalizeURL(script.fileName), script.baseLineNumber]);\n        else\n            if (fn.toString)\n                return fn.toString();\n    },\n\n    getTitle: function(fn, context)\n    {\n        var name = fn.name ? fn.name : "function";\n        return name + "()";\n    },\n\n    getContextMenuItems: function(fn, target, context, script)\n    {\n        if (!script)\n            script = findScriptForFunctionInContext(context, fn);\n        if (!script)\n            return;\n\n        var scriptInfo = getSourceFileAndLineByScript(context, script);\n        var monitored = scriptInfo ? fbs.isMonitored(scriptInfo.sourceFile.href, scriptInfo.lineNo) : false;\n\n        var name = script ? getFunctionName(script, context) : fn.name;\n        return [\n            {label: "CopySource", command: bindFixed(this.copySource, this, fn) },\n            "-",\n            {label: $STRF("ShowCallsInConsole", [name]), nol10n: true,\n             type: "checkbox", checked: monitored,\n             command: bindFixed(this.monitor, this, fn, script, monitored) }\n        ];\n    }\n});\n\n// ************************************************************************************************\n/*\nthis.jsdScript = domplate(Firebug.Rep,\n{\n    copySource: function(script)\n    {\n        var fn = script.functionObject.getWrappedValue();\n        return FirebugReps.Func.copySource(fn);\n    },\n\n    monitor: function(fn, script, monitored)\n    {\n        fn = script.functionObject.getWrappedValue();\n        return FirebugReps.Func.monitor(fn, script, monitored);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "jsdScript",\n    inspectable: false,\n\n    supportsObject: function(object, type)\n    {\n        return object instanceof jsdIScript;\n    },\n\n    inspectObject: function(script, context)\n    {\n        var sourceLink = getSourceLinkForScript(script, context);\n        if (sourceLink)\n            Firebug.chrome.select(sourceLink);\n    },\n\n    getRealObject: function(script, context)\n    {\n        return script;\n    },\n\n    getTooltip: function(script)\n    {\n        return $STRF("jsdIScript", [script.tag]);\n    },\n\n    getTitle: function(script, context)\n    {\n        var fn = script.functionObject.getWrappedValue();\n        return FirebugReps.Func.getTitle(fn, context);\n    },\n\n    getContextMenuItems: function(script, target, context)\n    {\n        var fn = script.functionObject.getWrappedValue();\n\n        var scriptInfo = getSourceFileAndLineByScript(context, script);\n           var monitored = scriptInfo ? fbs.isMonitored(scriptInfo.sourceFile.href, scriptInfo.lineNo) : false;\n\n        var name = getFunctionName(script, context);\n\n        return [\n            {label: "CopySource", command: bindFixed(this.copySource, this, script) },\n            "-",\n            {label: $STRF("ShowCallsInConsole", [name]), nol10n: true,\n             type: "checkbox", checked: monitored,\n             command: bindFixed(this.monitor, this, fn, script, monitored) }\n        ];\n    }\n});\n/**/\n//************************************************************************************************\n\nthis.Obj = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK(\n            SPAN({"class": "objectTitle"}, "$object|getTitle "),\n\n            SPAN({"class": "objectProps"},\n                SPAN({"class": "objectLeftBrace", role: "presentation"}, "{"),\n                FOR("prop", "$object|propIterator",\n                    SPAN({"class": "objectPropName", role: "presentation"}, "$prop.name"),\n                    SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),\n                    TAG("$prop.tag", {object: "$prop.object"}),\n                    SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")\n                ),\n                SPAN({"class": "objectRightBrace"}, "}")\n            )\n        ),\n\n    propNumberTag:\n        SPAN({"class": "objectProp-number"}, "$object"),\n\n    propStringTag:\n        SPAN({"class": "objectProp-string"}, "&quot;$object&quot;"),\n\n    propObjectTag:\n        SPAN({"class": "objectProp-object"}, "$object"),\n\n    propIterator: function (object)\n    {\n        ///Firebug.ObjectShortIteratorMax;\n        var maxLength = 55; // default max length for long representation\n\n        if (!object)\n            return [];\n\n        var props = [];\n        var length = 0;\n\n        var numProperties = 0;\n        var numPropertiesShown = 0;\n        var maxLengthReached = false;\n\n        var lib = this;\n\n        var propRepsMap =\n        {\n            "boolean": this.propNumberTag,\n            "number": this.propNumberTag,\n            "string": this.propStringTag,\n            "object": this.propObjectTag\n        };\n\n        try\n        {\n            var title = Firebug.Rep.getTitle(object);\n            length += title.length;\n\n            for (var name in object)\n            {\n                var value;\n                try\n                {\n                    value = object[name];\n                }\n                catch (exc)\n                {\n                    continue;\n                }\n\n                var type = typeof(value);\n                if (type == "boolean" ||\n                    type == "number" ||\n                    (type == "string" && value) ||\n                    (type == "object" && value && value.toString))\n                {\n                    var tag = propRepsMap[type];\n\n                    var value = (type == "object") ?\n                        Firebug.getRep(value).getTitle(value) :\n                        value + "";\n\n                    length += name.length + value.length + 4;\n\n                    if (length <= maxLength)\n                    {\n                        props.push({\n                            tag: tag,\n                            name: name,\n                            object: value,\n                            equal: "=",\n                            delim: ", "\n                        });\n\n                        numPropertiesShown++;\n                    }\n                    else\n                        maxLengthReached = true;\n\n                }\n\n                numProperties++;\n\n                if (maxLengthReached && numProperties > numPropertiesShown)\n                    break;\n            }\n\n            if (numProperties > numPropertiesShown)\n            {\n                props.push({\n                    object: "...", //xxxHonza localization\n                    tag: FirebugReps.Caption.tag,\n                    name: "",\n                    equal:"",\n                    delim:""\n                });\n            }\n            else if (props.length > 0)\n            {\n                props[props.length-1].delim = \'\';\n            }\n        }\n        catch (exc)\n        {\n            // Sometimes we get exceptions when trying to read from certain objects, like\n            // StorageList, but don\'t let that gum up the works\n            // XXXjjb also History.previous fails because object is a web-page object which does not have\n            // permission to read the history\n        }\n        return props;\n    },\n\n    fb_1_6_propIterator: function (object, max)\n    {\n        max = max || 3;\n        if (!object)\n            return [];\n\n        var props = [];\n        var len = 0, count = 0;\n\n        try\n        {\n            for (var name in object)\n            {\n                var value;\n                try\n                {\n                    value = object[name];\n                }\n                catch (exc)\n                {\n                    continue;\n                }\n\n                var t = typeof(value);\n                if (t == "boolean" || t == "number" || (t == "string" && value)\n                    || (t == "object" && value && value.toString))\n                {\n                    var rep = Firebug.getRep(value);\n                    var tag = rep.shortTag || rep.tag;\n                    if (t == "object")\n                    {\n                        value = rep.getTitle(value);\n                        tag = rep.titleTag;\n                    }\n                    count++;\n                    if (count <= max)\n                        props.push({tag: tag, name: name, object: value, equal: "=", delim: ", "});\n                    else\n                        break;\n                }\n            }\n            if (count > max)\n            {\n                props[Math.max(1,max-1)] = {\n                    object: "more...", //xxxHonza localization\n                    tag: FirebugReps.Caption.tag,\n                    name: "",\n                    equal:"",\n                    delim:""\n                };\n            }\n            else if (props.length > 0)\n            {\n                props[props.length-1].delim = \'\';\n            }\n        }\n        catch (exc)\n        {\n            // Sometimes we get exceptions when trying to read from certain objects, like\n            // StorageList, but don\'t let that gum up the works\n            // XXXjjb also History.previous fails because object is a web-page object which does not have\n            // permission to read the history\n        }\n        return props;\n    },\n\n    /*\n    propIterator: function (object)\n    {\n        if (!object)\n            return [];\n\n        var props = [];\n        var len = 0;\n\n        try\n        {\n            for (var name in object)\n            {\n                var val;\n                try\n                {\n                    val = object[name];\n                }\n                catch (exc)\n                {\n                    continue;\n                }\n\n                var t = typeof val;\n                if (t == "boolean" || t == "number" || (t == "string" && val)\n                    || (t == "object" && !isFunction(val) && val && val.toString))\n                {\n                    var title = (t == "object")\n                        ? Firebug.getRep(val).getTitle(val)\n                        : val+"";\n\n                    len += name.length + title.length + 1;\n                    if (len < 50)\n                        props.push({name: name, value: title});\n                    else\n                        break;\n                }\n            }\n        }\n        catch (exc)\n        {\n            // Sometimes we get exceptions when trying to read from certain objects, like\n            // StorageList, but don\'t let that gum up the works\n            // XXXjjb also History.previous fails because object is a web-page object which does not have\n            // permission to read the history\n        }\n\n        return props;\n    },\n    /**/\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "object",\n\n    supportsObject: function(object, type)\n    {\n        return true;\n    }\n});\n\n\n// ************************************************************************************************\n\nthis.Arr = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTBOX({_repObject: "$object"},\n            SPAN({"class": "arrayLeftBracket", role : "presentation"}, "["),\n            FOR("item", "$object|arrayIterator",\n                TAG("$item.tag", {object: "$item.object"}),\n                SPAN({"class": "arrayComma", role : "presentation"}, "$item.delim")\n            ),\n            SPAN({"class": "arrayRightBracket", role : "presentation"}, "]")\n        ),\n\n    shortTag:\n        OBJECTBOX({_repObject: "$object"},\n            SPAN({"class": "arrayLeftBracket", role : "presentation"}, "["),\n            FOR("item", "$object|shortArrayIterator",\n                TAG("$item.tag", {object: "$item.object"}),\n                SPAN({"class": "arrayComma", role : "presentation"}, "$item.delim")\n            ),\n            // TODO: xxxpedro - confirm this on Firebug\n            //FOR("prop", "$object|shortPropIterator",\n            //        " $prop.name=",\n            //        SPAN({"class": "objectPropValue"}, "$prop.value|cropString")\n            //),\n            SPAN({"class": "arrayRightBracket"}, "]")\n        ),\n\n    arrayIterator: function(array)\n    {\n        var items = [];\n        for (var i = 0; i < array.length; ++i)\n        {\n            var value = array[i];\n            var rep = Firebug.getRep(value);\n            var tag = rep.shortTag ? rep.shortTag : rep.tag;\n            var delim = (i == array.length-1 ? "" : ", ");\n\n            items.push({object: value, tag: tag, delim: delim});\n        }\n\n        return items;\n    },\n\n    shortArrayIterator: function(array)\n    {\n        var items = [];\n        for (var i = 0; i < array.length && i < 3; ++i)\n        {\n            var value = array[i];\n            var rep = Firebug.getRep(value);\n            var tag = rep.shortTag ? rep.shortTag : rep.tag;\n            var delim = (i == array.length-1 ? "" : ", ");\n\n            items.push({object: value, tag: tag, delim: delim});\n        }\n\n        if (array.length > 3)\n            items.push({object: (array.length-3) + " more...", tag: FirebugReps.Caption.tag, delim: ""});\n\n        return items;\n    },\n\n    shortPropIterator:    this.Obj.propIterator,\n\n    getItemIndex: function(child)\n    {\n        var arrayIndex = 0;\n        for (child = child.previousSibling; child; child = child.previousSibling)\n        {\n            if (child.repObject)\n                ++arrayIndex;\n        }\n        return arrayIndex;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "array",\n\n    supportsObject: function(object)\n    {\n        return this.isArray(object);\n    },\n\n    // http://code.google.com/p/fbug/issues/detail?id=874\n    // BEGIN Yahoo BSD Source (modified here)  YAHOO.lang.isArray, YUI 2.2.2 June 2007\n    isArray: function(obj) {\n        try {\n            if (!obj)\n                return false;\n            else if (isIE && !isFunction(obj) && typeof obj == "object" && isFinite(obj.length) && obj.nodeType != 8)\n                return true;\n            else if (isFinite(obj.length) && isFunction(obj.splice))\n                return true;\n            else if (isFinite(obj.length) && isFunction(obj.callee)) // arguments\n                return true;\n            else if (instanceOf(obj, "HTMLCollection"))\n                return true;\n            else if (instanceOf(obj, "NodeList"))\n                return true;\n            else\n                return false;\n        }\n        catch(exc)\n        {\n            if (FBTrace.DBG_ERRORS)\n            {\n                FBTrace.sysout("isArray FAILS:", exc);  /* Something weird: without the try/catch, OOM, with no exception?? */\n                FBTrace.sysout("isArray Fails on obj", obj);\n            }\n        }\n\n        return false;\n    },\n    // END Yahoo BSD SOURCE See license below.\n\n    getTitle: function(object, context)\n    {\n        return "[" + object.length + "]";\n    }\n});\n\n// ************************************************************************************************\n\nthis.Property = domplate(Firebug.Rep,\n{\n    supportsObject: function(object)\n    {\n        return object instanceof Property;\n    },\n\n    getRealObject: function(prop, context)\n    {\n        return prop.object[prop.name];\n    },\n\n    getTitle: function(prop, context)\n    {\n        return prop.name;\n    }\n});\n\n// ************************************************************************************************\n\nthis.NetFile = domplate(this.Obj,\n{\n    supportsObject: function(object)\n    {\n        return object instanceof Firebug.NetFile;\n    },\n\n    browseObject: function(file, context)\n    {\n        openNewTab(file.href);\n        return true;\n    },\n\n    getRealObject: function(file, context)\n    {\n        return null;\n    }\n});\n\n// ************************************************************************************************\n\nthis.Except = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTBOX({_repObject: "$object"}, "$object.message"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "exception",\n\n    supportsObject: function(object)\n    {\n        return object instanceof ErrorCopy;\n    }\n});\n\n\n// ************************************************************************************************\n\nthis.Element = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK(\n            "&lt;",\n            SPAN({"class": "nodeTag"}, "$object.nodeName|toLowerCase"),\n            FOR("attr", "$object|attrIterator",\n                "&nbsp;$attr.nodeName=&quot;", SPAN({"class": "nodeValue"}, "$attr.nodeValue"), "&quot;"\n            ),\n            "&gt;"\n         ),\n\n    shortTag:\n        OBJECTLINK(\n            SPAN({"class": "$object|getVisible"},\n                SPAN({"class": "selectorTag"}, "$object|getSelectorTag"),\n                SPAN({"class": "selectorId"}, "$object|getSelectorId"),\n                SPAN({"class": "selectorClass"}, "$object|getSelectorClass"),\n                SPAN({"class": "selectorValue"}, "$object|getValue")\n            )\n         ),\n\n     getVisible: function(elt)\n     {\n         return isVisible(elt) ? "" : "selectorHidden";\n     },\n\n     getSelectorTag: function(elt)\n     {\n         return elt.nodeName.toLowerCase();\n     },\n\n     getSelectorId: function(elt)\n     {\n         return elt.id ? "#" + elt.id : "";\n     },\n\n     getSelectorClass: function(elt)\n     {\n         return elt.className ? "." + elt.className.split(" ")[0] : "";\n     },\n\n     getValue: function(elt)\n     {\n         // TODO: xxxpedro\n         return "";\n         var value;\n         if (elt instanceof HTMLImageElement)\n             value = getFileName(elt.src);\n         else if (elt instanceof HTMLAnchorElement)\n             value = getFileName(elt.href);\n         else if (elt instanceof HTMLInputElement)\n             value = elt.value;\n         else if (elt instanceof HTMLFormElement)\n             value = getFileName(elt.action);\n         else if (elt instanceof HTMLScriptElement)\n             value = getFileName(elt.src);\n\n         return value ? " " + cropString(value, 20) : "";\n     },\n\n     attrIterator: function(elt)\n     {\n         var attrs = [];\n         var idAttr, classAttr;\n         if (elt.attributes)\n         {\n             for (var i = 0; i < elt.attributes.length; ++i)\n             {\n                 var attr = elt.attributes[i];\n\n                 // we must check if the attribute is specified otherwise IE will show them\n                 if (!attr.specified || attr.nodeName && attr.nodeName.indexOf("firebug-") != -1)\n                    continue;\n                 else if (attr.nodeName == "id")\n                    idAttr = attr;\n                 else if (attr.nodeName == "class")\n                    classAttr = attr;\n                 else if (attr.nodeName == "style")\n                    attrs.push({\n                        nodeName: attr.nodeName,\n                        nodeValue: attr.nodeValue ||\n                        // IE won\'t recognize the attr.nodeValue of <style> nodes ...\n                        // and will return CSS property names in upper case, so we need to convert them\n                        elt.style.cssText.replace(/([^\\s]+)\\s*:/g,\n                                function(m,g){return g.toLowerCase()+":"})\n                    });\n                 else\n                    attrs.push(attr);\n             }\n         }\n         if (classAttr)\n            attrs.splice(0, 0, classAttr);\n         if (idAttr)\n            attrs.splice(0, 0, idAttr);\n\n         return attrs;\n     },\n\n     shortAttrIterator: function(elt)\n     {\n         var attrs = [];\n         if (elt.attributes)\n         {\n             for (var i = 0; i < elt.attributes.length; ++i)\n             {\n                 var attr = elt.attributes[i];\n                 if (attr.nodeName == "id" || attr.nodeName == "class")\n                     attrs.push(attr);\n             }\n         }\n\n         return attrs;\n     },\n\n     getHidden: function(elt)\n     {\n         return isVisible(elt) ? "" : "nodeHidden";\n     },\n\n     getXPath: function(elt)\n     {\n         return getElementTreeXPath(elt);\n     },\n\n     // TODO: xxxpedro remove this?\n     getNodeText: function(element)\n     {\n         var text = element.textContent;\n         if (Firebug.showFullTextNodes)\n            return text;\n        else\n            return cropString(text, 50);\n     },\n     /**/\n\n     getNodeTextGroups: function(element)\n     {\n         var text =  element.textContent;\n         if (!Firebug.showFullTextNodes)\n         {\n             text=cropString(text,50);\n         }\n\n         var escapeGroups=[];\n\n         if (Firebug.showTextNodesWithWhitespace)\n             escapeGroups.push({\n                \'group\': \'whitespace\',\n                \'class\': \'nodeWhiteSpace\',\n                \'extra\': {\n                    \'\\t\': \'_Tab\',\n                    \'\\n\': \'_Para\',\n                    \' \' : \'_Space\'\n                }\n             });\n         if (Firebug.showTextNodesWithEntities)\n             escapeGroups.push({\n                 \'group\':\'text\',\n                 \'class\':\'nodeTextEntity\',\n                 \'extra\':{}\n             });\n\n         if (escapeGroups.length)\n             return escapeGroupsForEntities(text, escapeGroups);\n         else\n             return [{str:text,\'class\':\'\',extra:\'\'}];\n     },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    copyHTML: function(elt)\n    {\n        var html = getElementXML(elt);\n        copyToClipboard(html);\n    },\n\n    copyInnerHTML: function(elt)\n    {\n        copyToClipboard(elt.innerHTML);\n    },\n\n    copyXPath: function(elt)\n    {\n        var xpath = getElementXPath(elt);\n        copyToClipboard(xpath);\n    },\n\n    persistor: function(context, xpath)\n    {\n        var elts = xpath\n            ? getElementsByXPath(context.window.document, xpath)\n            : null;\n\n        return elts && elts.length ? elts[0] : null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "element",\n\n    supportsObject: function(object)\n    {\n        //return object instanceof Element || object.nodeType == 1 && typeof object.nodeName == "string";\n        return instanceOf(object, "Element");\n    },\n\n    browseObject: function(elt, context)\n    {\n        var tag = elt.nodeName.toLowerCase();\n        if (tag == "script")\n            openNewTab(elt.src);\n        else if (tag == "link")\n            openNewTab(elt.href);\n        else if (tag == "a")\n            openNewTab(elt.href);\n        else if (tag == "img")\n            openNewTab(elt.src);\n\n        return true;\n    },\n\n    persistObject: function(elt, context)\n    {\n        var xpath = getElementXPath(elt);\n\n        return bind(this.persistor, top, xpath);\n    },\n\n    getTitle: function(element, context)\n    {\n        return getElementCSSSelector(element);\n    },\n\n    getTooltip: function(elt)\n    {\n        return this.getXPath(elt);\n    },\n\n    getContextMenuItems: function(elt, target, context)\n    {\n        var monitored = areEventsMonitored(elt, null, context);\n\n        return [\n            {label: "CopyHTML", command: bindFixed(this.copyHTML, this, elt) },\n            {label: "CopyInnerHTML", command: bindFixed(this.copyInnerHTML, this, elt) },\n            {label: "CopyXPath", command: bindFixed(this.copyXPath, this, elt) },\n            "-",\n            {label: "ShowEventsInConsole", type: "checkbox", checked: monitored,\n             command: bindFixed(toggleMonitorEvents, FBL, elt, null, monitored, context) },\n            "-",\n            {label: "ScrollIntoView", command: bindFixed(elt.scrollIntoView, elt) }\n        ];\n    }\n});\n\n// ************************************************************************************************\n\nthis.TextNode = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK(\n            "&lt;",\n            SPAN({"class": "nodeTag"}, "TextNode"),\n            "&nbsp;textContent=&quot;", SPAN({"class": "nodeValue"}, "$object.textContent|cropString"), "&quot;",\n            "&gt;"\n            ),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "textNode",\n\n    supportsObject: function(object)\n    {\n        return object instanceof Text;\n    }\n});\n\n// ************************************************************************************************\n\nthis.Document = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK("Document ", SPAN({"class": "objectPropValue"}, "$object|getLocation")),\n\n    getLocation: function(doc)\n    {\n        return doc.location ? getFileName(doc.location.href) : "";\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "object",\n\n    supportsObject: function(object)\n    {\n        //return object instanceof Document || object instanceof XMLDocument;\n        return instanceOf(object, "Document");\n    },\n\n    browseObject: function(doc, context)\n    {\n        openNewTab(doc.location.href);\n        return true;\n    },\n\n    persistObject: function(doc, context)\n    {\n        return this.persistor;\n    },\n\n    persistor: function(context)\n    {\n        return context.window.document;\n    },\n\n    getTitle: function(win, context)\n    {\n        return "document";\n    },\n\n    getTooltip: function(doc)\n    {\n        return doc.location.href;\n    }\n});\n\n// ************************************************************************************************\n\nthis.StyleSheet = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK("StyleSheet ", SPAN({"class": "objectPropValue"}, "$object|getLocation")),\n\n    getLocation: function(styleSheet)\n    {\n        return getFileName(styleSheet.href);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    copyURL: function(styleSheet)\n    {\n        copyToClipboard(styleSheet.href);\n    },\n\n    openInTab: function(styleSheet)\n    {\n        openNewTab(styleSheet.href);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "object",\n\n    supportsObject: function(object)\n    {\n        //return object instanceof CSSStyleSheet;\n        return instanceOf(object, "CSSStyleSheet");\n    },\n\n    browseObject: function(styleSheet, context)\n    {\n        openNewTab(styleSheet.href);\n        return true;\n    },\n\n    persistObject: function(styleSheet, context)\n    {\n        return bind(this.persistor, top, styleSheet.href);\n    },\n\n    getTooltip: function(styleSheet)\n    {\n        return styleSheet.href;\n    },\n\n    getContextMenuItems: function(styleSheet, target, context)\n    {\n        return [\n            {label: "CopyLocation", command: bindFixed(this.copyURL, this, styleSheet) },\n            "-",\n            {label: "OpenInTab", command: bindFixed(this.openInTab, this, styleSheet) }\n        ];\n    },\n\n    persistor: function(context, href)\n    {\n        return getStyleSheetByHref(href, context);\n    }\n});\n\n// ************************************************************************************************\n\nthis.Window = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK("Window ", SPAN({"class": "objectPropValue"}, "$object|getLocation")),\n\n    getLocation: function(win)\n    {\n        try\n        {\n            return (win && win.location && !win.closed) ? getFileName(win.location.href) : "";\n        }\n        catch (exc)\n        {\n            if (FBTrace.DBG_ERRORS)\n                FBTrace.sysout("reps.Window window closed?");\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "object",\n\n    supportsObject: function(object)\n    {\n        return instanceOf(object, "Window");\n    },\n\n    browseObject: function(win, context)\n    {\n        openNewTab(win.location.href);\n        return true;\n    },\n\n    persistObject: function(win, context)\n    {\n        return this.persistor;\n    },\n\n    persistor: function(context)\n    {\n        return context.window;\n    },\n\n    getTitle: function(win, context)\n    {\n        return "window";\n    },\n\n    getTooltip: function(win)\n    {\n        if (win && !win.closed)\n            return win.location.href;\n    }\n});\n\n// ************************************************************************************************\n\nthis.Event = domplate(Firebug.Rep,\n{\n    tag: TAG("$copyEventTag", {object: "$object|copyEvent"}),\n\n    copyEventTag:\n        OBJECTLINK("$object|summarizeEvent"),\n\n    summarizeEvent: function(event)\n    {\n        var info = [event.type, \' \'];\n\n        var eventFamily = getEventFamily(event.type);\n        if (eventFamily == "mouse")\n            info.push("clientX=", event.clientX, ", clientY=", event.clientY);\n        else if (eventFamily == "key")\n            info.push("charCode=", event.charCode, ", keyCode=", event.keyCode);\n\n        return info.join("");\n    },\n\n    copyEvent: function(event)\n    {\n        return new EventCopy(event);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "object",\n\n    supportsObject: function(object)\n    {\n        //return object instanceof Event || object instanceof EventCopy;\n        return instanceOf(object, "Event") || instanceOf(object, "EventCopy");\n    },\n\n    getTitle: function(event, context)\n    {\n        return "Event " + event.type;\n    }\n});\n\n// ************************************************************************************************\n\nthis.SourceLink = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTLINK({$collapsed: "$object|hideSourceLink"}, "$object|getSourceLinkTitle"),\n\n    hideSourceLink: function(sourceLink)\n    {\n        return sourceLink ? sourceLink.href.indexOf("XPCSafeJSObjectWrapper") != -1 : true;\n    },\n\n    getSourceLinkTitle: function(sourceLink)\n    {\n        if (!sourceLink)\n            return "";\n\n        try\n        {\n            var fileName = getFileName(sourceLink.href);\n            fileName = decodeURIComponent(fileName);\n            fileName = cropString(fileName, 17);\n        }\n        catch(exc)\n        {\n            if (FBTrace.DBG_ERRORS)\n                FBTrace.sysout("reps.getSourceLinkTitle decodeURIComponent fails for \\\'"+fileName+"\\\': "+exc, exc);\n        }\n\n        return typeof sourceLink.line == "number" ?\n                fileName + " (line " + sourceLink.line + ")" :\n                fileName;\n\n        // TODO: xxxpedro\n        //return $STRF("Line", [fileName, sourceLink.line]);\n    },\n\n    copyLink: function(sourceLink)\n    {\n        copyToClipboard(sourceLink.href);\n    },\n\n    openInTab: function(sourceLink)\n    {\n        openNewTab(sourceLink.href);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "sourceLink",\n\n    supportsObject: function(object)\n    {\n        return object instanceof SourceLink;\n    },\n\n    getTooltip: function(sourceLink)\n    {\n        return decodeURI(sourceLink.href);\n    },\n\n    inspectObject: function(sourceLink, context)\n    {\n        if (sourceLink.type == "js")\n        {\n            var scriptFile = getSourceFileByHref(sourceLink.href, context);\n            if (scriptFile)\n                return Firebug.chrome.select(sourceLink);\n        }\n        else if (sourceLink.type == "css")\n        {\n            // If an object is defined, treat it as the highest priority for\n            // inspect actions\n            if (sourceLink.object) {\n                Firebug.chrome.select(sourceLink.object);\n                return;\n            }\n\n            var stylesheet = getStyleSheetByHref(sourceLink.href, context);\n            if (stylesheet)\n            {\n                var ownerNode = stylesheet.ownerNode;\n                if (ownerNode)\n                {\n                    Firebug.chrome.select(sourceLink, "html");\n                    return;\n                }\n\n                var panel = context.getPanel("stylesheet");\n                if (panel && panel.getRuleByLine(stylesheet, sourceLink.line))\n                    return Firebug.chrome.select(sourceLink);\n            }\n        }\n\n        // Fallback is to just open the view-source window on the file\n        viewSource(sourceLink.href, sourceLink.line);\n    },\n\n    browseObject: function(sourceLink, context)\n    {\n        openNewTab(sourceLink.href);\n        return true;\n    },\n\n    getContextMenuItems: function(sourceLink, target, context)\n    {\n        return [\n            {label: "CopyLocation", command: bindFixed(this.copyLink, this, sourceLink) },\n            "-",\n            {label: "OpenInTab", command: bindFixed(this.openInTab, this, sourceLink) }\n        ];\n    }\n});\n\n// ************************************************************************************************\n\nthis.SourceFile = domplate(this.SourceLink,\n{\n    tag:\n        OBJECTLINK({$collapsed: "$object|hideSourceLink"}, "$object|getSourceLinkTitle"),\n\n    persistor: function(context, href)\n    {\n        return getSourceFileByHref(href, context);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "sourceFile",\n\n    supportsObject: function(object)\n    {\n        return object instanceof SourceFile;\n    },\n\n    persistObject: function(sourceFile)\n    {\n        return bind(this.persistor, top, sourceFile.href);\n    },\n\n    browseObject: function(sourceLink, context)\n    {\n    },\n\n    getTooltip: function(sourceFile)\n    {\n        return sourceFile.href;\n    }\n});\n\n// ************************************************************************************************\n\nthis.StackFrame = domplate(Firebug.Rep,  // XXXjjb Since the repObject is fn the stack does not have correct line numbers\n{\n    tag:\n        OBJECTBLOCK(\n            A({"class": "objectLink objectLink-function focusRow a11yFocus", _repObject: "$object.fn"}, "$object|getCallName"),\n            " ( ",\n            FOR("arg", "$object|argIterator",\n                TAG("$arg.tag", {object: "$arg.value"}),\n                SPAN({"class": "arrayComma"}, "$arg.delim")\n            ),\n            " )",\n            SPAN({"class": "objectLink-sourceLink objectLink"}, "$object|getSourceLinkTitle")\n        ),\n\n    getCallName: function(frame)\n    {\n        //TODO: xxxpedro reps StackFrame\n        return frame.name || "anonymous";\n\n        //return getFunctionName(frame.script, frame.context);\n    },\n\n    getSourceLinkTitle: function(frame)\n    {\n        //TODO: xxxpedro reps StackFrame\n        var fileName = cropString(getFileName(frame.href), 20);\n        return fileName + (frame.lineNo ? " (line " + frame.lineNo + ")" : "");\n\n        var fileName = cropString(getFileName(frame.href), 17);\n        return $STRF("Line", [fileName, frame.lineNo]);\n    },\n\n    argIterator: function(frame)\n    {\n        if (!frame.args)\n            return [];\n\n        var items = [];\n\n        for (var i = 0; i < frame.args.length; ++i)\n        {\n            var arg = frame.args[i];\n\n            if (!arg)\n                break;\n\n            var rep = Firebug.getRep(arg.value);\n            var tag = rep.shortTag ? rep.shortTag : rep.tag;\n\n            var delim = (i == frame.args.length-1 ? "" : ", ");\n\n            items.push({name: arg.name, value: arg.value, tag: tag, delim: delim});\n        }\n\n        return items;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "stackFrame",\n\n    supportsObject: function(object)\n    {\n        return object instanceof StackFrame;\n    },\n\n    inspectObject: function(stackFrame, context)\n    {\n        var sourceLink = new SourceLink(stackFrame.href, stackFrame.lineNo, "js");\n        Firebug.chrome.select(sourceLink);\n    },\n\n    getTooltip: function(stackFrame, context)\n    {\n        return $STRF("Line", [stackFrame.href, stackFrame.lineNo]);\n    }\n\n});\n\n// ************************************************************************************************\n\nthis.StackTrace = domplate(Firebug.Rep,\n{\n    tag:\n        FOR("frame", "$object.frames focusRow",\n            TAG(this.StackFrame.tag, {object: "$frame"})\n        ),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "stackTrace",\n\n    supportsObject: function(object)\n    {\n        return object instanceof StackTrace;\n    }\n});\n\n// ************************************************************************************************\n\nthis.jsdStackFrame = domplate(Firebug.Rep,\n{\n    inspectable: false,\n\n    supportsObject: function(object)\n    {\n        return (object instanceof jsdIStackFrame) && (object.isValid);\n    },\n\n    getTitle: function(frame, context)\n    {\n        if (!frame.isValid) return "(invalid frame)"; // XXXjjb avoid frame.script == null\n        return getFunctionName(frame.script, context);\n    },\n\n    getTooltip: function(frame, context)\n    {\n        if (!frame.isValid) return "(invalid frame)";  // XXXjjb avoid frame.script == null\n        var sourceInfo = FBL.getSourceFileAndLineByScript(context, frame.script, frame);\n        if (sourceInfo)\n            return $STRF("Line", [sourceInfo.sourceFile.href, sourceInfo.lineNo]);\n        else\n            return $STRF("Line", [frame.script.fileName, frame.line]);\n    },\n\n    getContextMenuItems: function(frame, target, context)\n    {\n        var fn = frame.script.functionObject.getWrappedValue();\n        return FirebugReps.Func.getContextMenuItems(fn, target, context, frame.script);\n    }\n});\n\n// ************************************************************************************************\n\nthis.ErrorMessage = domplate(Firebug.Rep,\n{\n    tag:\n        OBJECTBOX({\n                $hasTwisty: "$object|hasStackTrace",\n                $hasBreakSwitch: "$object|hasBreakSwitch",\n                $breakForError: "$object|hasErrorBreak",\n                _repObject: "$object",\n                _stackTrace: "$object|getLastErrorStackTrace",\n                onclick: "$onToggleError"},\n\n            DIV({"class": "errorTitle a11yFocus", role : \'checkbox\', \'aria-checked\' : \'false\'},\n                "$object.message|getMessage"\n            ),\n            DIV({"class": "errorTrace"}),\n            DIV({"class": "errorSourceBox errorSource-$object|getSourceType"},\n                IMG({"class": "errorBreak a11yFocus", src:"blank.gif", role : \'checkbox\', \'aria-checked\':\'false\', title: "Break on this error"}),\n                A({"class": "errorSource a11yFocus"}, "$object|getLine")\n            ),\n            TAG(this.SourceLink.tag, {object: "$object|getSourceLink"})\n        ),\n\n    getLastErrorStackTrace: function(error)\n    {\n        return error.trace;\n    },\n\n    hasStackTrace: function(error)\n    {\n        var url = error.href.toString();\n        var fromCommandLine = (url.indexOf("XPCSafeJSObjectWrapper") != -1);\n        return !fromCommandLine && error.trace;\n    },\n\n    hasBreakSwitch: function(error)\n    {\n        return error.href && error.lineNo > 0;\n    },\n\n    hasErrorBreak: function(error)\n    {\n        return fbs.hasErrorBreakpoint(error.href, error.lineNo);\n    },\n\n    getMessage: function(message)\n    {\n        var re = /\\[Exception... "(.*?)" nsresult:/;\n        var m = re.exec(message);\n        return m ? m[1] : message;\n    },\n\n    getLine: function(error)\n    {\n        if (error.category == "js")\n        {\n            if (error.source)\n                return cropString(error.source, 80);\n            else if (error.href && error.href.indexOf("XPCSafeJSObjectWrapper") == -1)\n                return cropString(error.getSourceLine(), 80);\n        }\n    },\n\n    getSourceLink: function(error)\n    {\n        var ext = error.category == "css" ? "css" : "js";\n        return error.lineNo ? new SourceLink(error.href, error.lineNo, ext) : null;\n    },\n\n    getSourceType: function(error)\n    {\n        // Errors occurring inside of HTML event handlers look like "foo.html (line 1)"\n        // so let\'s try to skip those\n        if (error.source)\n            return "syntax";\n        else if (error.lineNo == 1 && getFileExtension(error.href) != "js")\n            return "none";\n        else if (error.category == "css")\n            return "none";\n        else if (!error.href || !error.lineNo)\n            return "none";\n        else\n            return "exec";\n    },\n\n    onToggleError: function(event)\n    {\n        var target = event.currentTarget;\n        if (hasClass(event.target, "errorBreak"))\n        {\n            this.breakOnThisError(target.repObject);\n        }\n        else if (hasClass(event.target, "errorSource"))\n        {\n            var panel = Firebug.getElementPanel(event.target);\n            this.inspectObject(target.repObject, panel.context);\n        }\n        else if (hasClass(event.target, "errorTitle"))\n        {\n            var traceBox = target.childNodes[1];\n            toggleClass(target, "opened");\n            event.target.setAttribute(\'aria-checked\', hasClass(target, "opened"));\n            if (hasClass(target, "opened"))\n            {\n                if (target.stackTrace)\n                    var node = FirebugReps.StackTrace.tag.append({object: target.stackTrace}, traceBox);\n                if (Firebug.A11yModel.enabled)\n                {\n                    var panel = Firebug.getElementPanel(event.target);\n                    dispatch([Firebug.A11yModel], "onLogRowContentCreated", [panel , traceBox]);\n                }\n            }\n            else\n                clearNode(traceBox);\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    copyError: function(error)\n    {\n        var message = [\n            this.getMessage(error.message),\n            error.href,\n            "Line " +  error.lineNo\n        ];\n        copyToClipboard(message.join("\\n"));\n    },\n\n    breakOnThisError: function(error)\n    {\n        if (this.hasErrorBreak(error))\n            Firebug.Debugger.clearErrorBreakpoint(error.href, error.lineNo);\n        else\n            Firebug.Debugger.setErrorBreakpoint(error.href, error.lineNo);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "errorMessage",\n    inspectable: false,\n\n    supportsObject: function(object)\n    {\n        return object instanceof ErrorMessage;\n    },\n\n    inspectObject: function(error, context)\n    {\n        var sourceLink = this.getSourceLink(error);\n        FirebugReps.SourceLink.inspectObject(sourceLink, context);\n    },\n\n    getContextMenuItems: function(error, target, context)\n    {\n        var breakOnThisError = this.hasErrorBreak(error);\n\n        var items = [\n            {label: "CopyError", command: bindFixed(this.copyError, this, error) }\n        ];\n\n        if (error.category == "css")\n        {\n            items.push(\n                "-",\n                {label: "BreakOnThisError", type: "checkbox", checked: breakOnThisError,\n                 command: bindFixed(this.breakOnThisError, this, error) },\n\n                optionMenu("BreakOnAllErrors", "breakOnErrors")\n            );\n        }\n\n        return items;\n    }\n});\n\n// ************************************************************************************************\n\nthis.Assert = domplate(Firebug.Rep,\n{\n    tag:\n        DIV(\n            DIV({"class": "errorTitle"}),\n            DIV({"class": "assertDescription"})\n        ),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "assert",\n\n    inspectObject: function(error, context)\n    {\n        var sourceLink = this.getSourceLink(error);\n        Firebug.chrome.select(sourceLink);\n    },\n\n    getContextMenuItems: function(error, target, context)\n    {\n        var breakOnThisError = this.hasErrorBreak(error);\n\n        return [\n            {label: "CopyError", command: bindFixed(this.copyError, this, error) },\n            "-",\n            {label: "BreakOnThisError", type: "checkbox", checked: breakOnThisError,\n             command: bindFixed(this.breakOnThisError, this, error) },\n            {label: "BreakOnAllErrors", type: "checkbox", checked: Firebug.breakOnErrors,\n             command: bindFixed(this.breakOnAllErrors, this, error) }\n        ];\n    }\n});\n\n// ************************************************************************************************\n\nthis.SourceText = domplate(Firebug.Rep,\n{\n    tag:\n        DIV(\n            FOR("line", "$object|lineIterator",\n                DIV({"class": "sourceRow", role : "presentation"},\n                    SPAN({"class": "sourceLine", role : "presentation"}, "$line.lineNo"),\n                    SPAN({"class": "sourceRowText", role : "presentation"}, "$line.text")\n                )\n            )\n        ),\n\n    lineIterator: function(sourceText)\n    {\n        var maxLineNoChars = (sourceText.lines.length + "").length;\n        var list = [];\n\n        for (var i = 0; i < sourceText.lines.length; ++i)\n        {\n            // Make sure all line numbers are the same width (with a fixed-width font)\n            var lineNo = (i+1) + "";\n            while (lineNo.length < maxLineNoChars)\n                lineNo = " " + lineNo;\n\n            list.push({lineNo: lineNo, text: sourceText.lines[i]});\n        }\n\n        return list;\n    },\n\n    getHTML: function(sourceText)\n    {\n        return getSourceLineRange(sourceText, 1, sourceText.lines.length);\n    }\n});\n\n//************************************************************************************************\nthis.nsIDOMHistory = domplate(Firebug.Rep,\n{\n    tag:OBJECTBOX({onclick: "$showHistory"},\n            OBJECTLINK("$object|summarizeHistory")\n        ),\n\n    className: "nsIDOMHistory",\n\n    summarizeHistory: function(history)\n    {\n        try\n        {\n            var items = history.length;\n            return items + " history entries";\n        }\n        catch(exc)\n        {\n            return "object does not support history (nsIDOMHistory)";\n        }\n    },\n\n    showHistory: function(history)\n    {\n        try\n        {\n            var items = history.length;  // if this throws, then unsupported\n            Firebug.chrome.select(history);\n        }\n        catch (exc)\n        {\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    supportsObject: function(object, type)\n    {\n        return (object instanceof Ci.nsIDOMHistory);\n    }\n});\n\n// ************************************************************************************************\nthis.ApplicationCache = domplate(Firebug.Rep,\n{\n    tag:OBJECTBOX({onclick: "$showApplicationCache"},\n            OBJECTLINK("$object|summarizeCache")\n        ),\n\n    summarizeCache: function(applicationCache)\n    {\n        try\n        {\n            return applicationCache.length + " items in offline cache";\n        }\n        catch(exc)\n        {\n            return "https://bugzilla.mozilla.org/show_bug.cgi?id=422264";\n        }\n    },\n\n    showApplicationCache: function(event)\n    {\n        openNewTab("https://bugzilla.mozilla.org/show_bug.cgi?id=422264");\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "applicationCache",\n\n    supportsObject: function(object, type)\n    {\n        if (Ci.nsIDOMOfflineResourceList)\n            return (object instanceof Ci.nsIDOMOfflineResourceList);\n    }\n\n});\n\nthis.Storage = domplate(Firebug.Rep,\n{\n    tag: OBJECTBOX({onclick: "$show"}, OBJECTLINK("$object|summarize")),\n\n    summarize: function(storage)\n    {\n        return storage.length +" items in Storage";\n    },\n    show: function(storage)\n    {\n        openNewTab("http://dev.w3.org/html5/webstorage/#storage-0");\n    },\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    className: "Storage",\n\n    supportsObject: function(object, type)\n    {\n        return (object instanceof Storage);\n    }\n\n});\n\n// ************************************************************************************************\nFirebug.registerRep(\n    //this.nsIDOMHistory, // make this early to avoid exceptions\n    this.Undefined,\n    this.Null,\n    this.Number,\n    this.String,\n    this.Window,\n    //this.ApplicationCache, // must come before Arr (array) else exceptions.\n    //this.ErrorMessage,\n    this.Element,\n    //this.TextNode,\n    this.Document,\n    this.StyleSheet,\n    this.Event,\n    //this.SourceLink,\n    //this.SourceFile,\n    //this.StackTrace,\n    //this.StackFrame,\n    //this.jsdStackFrame,\n    //this.jsdScript,\n    //this.NetFile,\n    this.Property,\n    this.Except,\n    this.Arr\n);\n\nFirebug.setDefaultReps(this.Func, this.Obj);\n\n}});\n\n// ************************************************************************************************\n/*\n * The following is http://developer.yahoo.com/yui/license.txt and applies to only code labeled "Yahoo BSD Source"\n * in only this file reps.js.  John J. Barton June 2007.\n *\nSoftware License Agreement (BSD License)\n\nCopyright (c) 2006, Yahoo! Inc.\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, with or without modification, are\npermitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of Yahoo! Inc. nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of Yahoo! Inc.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * /\n */\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// Constants\n\nvar saveTimeout = 400;\nvar pageAmount = 10;\n\n// ************************************************************************************************\n// Globals\n\nvar currentTarget = null;\nvar currentGroup = null;\nvar currentPanel = null;\nvar currentEditor = null;\n\nvar defaultEditor = null;\n\nvar originalClassName = null;\n\nvar originalValue = null;\nvar defaultValue = null;\nvar previousValue = null;\n\nvar invalidEditor = false;\nvar ignoreNextInput = false;\n\n// ************************************************************************************************\n\nFirebug.Editor = extend(Firebug.Module,\n{\n    supportsStopEvent: true,\n\n    dispatchName: "editor",\n    tabCharacter: "    ",\n\n    startEditing: function(target, value, editor)\n    {\n        this.stopEditing();\n\n        if (hasClass(target, "insertBefore") || hasClass(target, "insertAfter"))\n            return;\n\n        var panel = Firebug.getElementPanel(target);\n        if (!panel.editable)\n            return;\n\n        if (FBTrace.DBG_EDITOR)\n            FBTrace.sysout("editor.startEditing " + value, target);\n\n        defaultValue = target.getAttribute("defaultValue");\n        if (value == undefined)\n        {\n            var textContent = isIE ? "innerText" : "textContent";\n            value = target[textContent];\n            if (value == defaultValue)\n                value = "";\n        }\n\n        originalValue = previousValue = value;\n\n        invalidEditor = false;\n        currentTarget = target;\n        currentPanel = panel;\n        currentGroup = getAncestorByClass(target, "editGroup");\n\n        currentPanel.editing = true;\n\n        var panelEditor = currentPanel.getEditor(target, value);\n        currentEditor = editor ? editor : panelEditor;\n        if (!currentEditor)\n            currentEditor = getDefaultEditor(currentPanel);\n\n        var inlineParent = getInlineParent(target);\n        var targetSize = getOffsetSize(inlineParent);\n\n        setClass(panel.panelNode, "editing");\n        setClass(target, "editing");\n        if (currentGroup)\n            setClass(currentGroup, "editing");\n\n        currentEditor.show(target, currentPanel, value, targetSize);\n        //dispatch(this.fbListeners, "onBeginEditing", [currentPanel, currentEditor, target, value]);\n        currentEditor.beginEditing(target, value);\n        if (FBTrace.DBG_EDITOR)\n            FBTrace.sysout("Editor start panel "+currentPanel.name);\n        this.attachListeners(currentEditor, panel.context);\n    },\n\n    stopEditing: function(cancel)\n    {\n        if (!currentTarget)\n            return;\n\n        if (FBTrace.DBG_EDITOR)\n            FBTrace.sysout("editor.stopEditing cancel:" + cancel+" saveTimeout: "+this.saveTimeout);\n\n        clearTimeout(this.saveTimeout);\n        delete this.saveTimeout;\n\n        this.detachListeners(currentEditor, currentPanel.context);\n\n        removeClass(currentPanel.panelNode, "editing");\n        removeClass(currentTarget, "editing");\n        if (currentGroup)\n            removeClass(currentGroup, "editing");\n\n        var value = currentEditor.getValue();\n        if (value == defaultValue)\n            value = "";\n\n        var removeGroup = currentEditor.endEditing(currentTarget, value, cancel);\n\n        try\n        {\n            if (cancel)\n            {\n                //dispatch([Firebug.A11yModel], \'onInlineEditorClose\', [currentPanel, currentTarget, removeGroup && !originalValue]);\n                if (value != originalValue)\n                    this.saveEditAndNotifyListeners(currentTarget, originalValue, previousValue);\n\n                if (removeGroup && !originalValue && currentGroup)\n                    currentGroup.parentNode.removeChild(currentGroup);\n            }\n            else if (!value)\n            {\n                this.saveEditAndNotifyListeners(currentTarget, null, previousValue);\n\n                if (removeGroup && currentGroup)\n                    currentGroup.parentNode.removeChild(currentGroup);\n            }\n            else\n                this.save(value);\n        }\n        catch (exc)\n        {\n            //throw exc.message;\n            //ERROR(exc);\n        }\n\n        currentEditor.hide();\n        currentPanel.editing = false;\n\n        //dispatch(this.fbListeners, "onStopEdit", [currentPanel, currentEditor, currentTarget]);\n        //if (FBTrace.DBG_EDITOR)\n        //    FBTrace.sysout("Editor stop panel "+currentPanel.name);\n\n        currentTarget = null;\n        currentGroup = null;\n        currentPanel = null;\n        currentEditor = null;\n        originalValue = null;\n        invalidEditor = false;\n\n        return value;\n    },\n\n    cancelEditing: function()\n    {\n        return this.stopEditing(true);\n    },\n\n    update: function(saveNow)\n    {\n        if (this.saveTimeout)\n            clearTimeout(this.saveTimeout);\n\n        invalidEditor = true;\n\n        currentEditor.layout();\n\n        if (saveNow)\n            this.save();\n        else\n        {\n            var context = currentPanel.context;\n            this.saveTimeout = context.setTimeout(bindFixed(this.save, this), saveTimeout);\n            if (FBTrace.DBG_EDITOR)\n                FBTrace.sysout("editor.update saveTimeout: "+this.saveTimeout);\n        }\n    },\n\n    save: function(value)\n    {\n        if (!invalidEditor)\n            return;\n\n        if (value == undefined)\n            value = currentEditor.getValue();\n        if (FBTrace.DBG_EDITOR)\n            FBTrace.sysout("editor.save saveTimeout: "+this.saveTimeout+" currentPanel: "+(currentPanel?currentPanel.name:"null"));\n        try\n        {\n            this.saveEditAndNotifyListeners(currentTarget, value, previousValue);\n\n            previousValue = value;\n            invalidEditor = false;\n        }\n        catch (exc)\n        {\n            if (FBTrace.DBG_ERRORS)\n                FBTrace.sysout("editor.save FAILS "+exc, exc);\n        }\n    },\n\n    saveEditAndNotifyListeners: function(currentTarget, value, previousValue)\n    {\n        currentEditor.saveEdit(currentTarget, value, previousValue);\n        //dispatch(this.fbListeners, "onSaveEdit", [currentPanel, currentEditor, currentTarget, value, previousValue]);\n    },\n\n    setEditTarget: function(element)\n    {\n        if (!element)\n        {\n            dispatch([Firebug.A11yModel], \'onInlineEditorClose\', [currentPanel, currentTarget, true]);\n            this.stopEditing();\n        }\n        else if (hasClass(element, "insertBefore"))\n            this.insertRow(element, "before");\n        else if (hasClass(element, "insertAfter"))\n            this.insertRow(element, "after");\n        else\n            this.startEditing(element);\n    },\n\n    tabNextEditor: function()\n    {\n        if (!currentTarget)\n            return;\n\n        var value = currentEditor.getValue();\n        var nextEditable = currentTarget;\n        do\n        {\n            nextEditable = !value && currentGroup\n                ? getNextOutsider(nextEditable, currentGroup)\n                : getNextByClass(nextEditable, "editable");\n        }\n        while (nextEditable && !nextEditable.offsetHeight);\n\n        this.setEditTarget(nextEditable);\n    },\n\n    tabPreviousEditor: function()\n    {\n        if (!currentTarget)\n            return;\n\n        var value = currentEditor.getValue();\n        var prevEditable = currentTarget;\n        do\n        {\n            prevEditable = !value && currentGroup\n                ? getPreviousOutsider(prevEditable, currentGroup)\n                : getPreviousByClass(prevEditable, "editable");\n        }\n        while (prevEditable && !prevEditable.offsetHeight);\n\n        this.setEditTarget(prevEditable);\n    },\n\n    insertRow: function(relative, insertWhere)\n    {\n        var group =\n            relative || getAncestorByClass(currentTarget, "editGroup") || currentTarget;\n        var value = this.stopEditing();\n\n        currentPanel = Firebug.getElementPanel(group);\n\n        currentEditor = currentPanel.getEditor(group, value);\n        if (!currentEditor)\n            currentEditor = getDefaultEditor(currentPanel);\n\n        currentGroup = currentEditor.insertNewRow(group, insertWhere);\n        if (!currentGroup)\n            return;\n\n        var editable = hasClass(currentGroup, "editable")\n            ? currentGroup\n            : getNextByClass(currentGroup, "editable");\n\n        if (editable)\n            this.setEditTarget(editable);\n    },\n\n    insertRowForObject: function(relative)\n    {\n        var container = getAncestorByClass(relative, "insertInto");\n        if (container)\n        {\n            relative = getChildByClass(container, "insertBefore");\n            if (relative)\n                this.insertRow(relative, "before");\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    attachListeners: function(editor, context)\n    {\n        var win = isIE ?\n                currentTarget.ownerDocument.parentWindow :\n                currentTarget.ownerDocument.defaultView;\n\n        addEvent(win, "resize", this.onResize);\n        addEvent(win, "blur", this.onBlur);\n\n        var chrome = Firebug.chrome;\n\n        this.listeners = [\n            chrome.keyCodeListen("ESCAPE", null, bind(this.cancelEditing, this))\n        ];\n\n        if (editor.arrowCompletion)\n        {\n            this.listeners.push(\n                chrome.keyCodeListen("UP", null, bindFixed(editor.completeValue, editor, -1)),\n                chrome.keyCodeListen("DOWN", null, bindFixed(editor.completeValue, editor, 1)),\n                chrome.keyCodeListen("PAGE_UP", null, bindFixed(editor.completeValue, editor, -pageAmount)),\n                chrome.keyCodeListen("PAGE_DOWN", null, bindFixed(editor.completeValue, editor, pageAmount))\n            );\n        }\n\n        if (currentEditor.tabNavigation)\n        {\n            this.listeners.push(\n                chrome.keyCodeListen("RETURN", null, bind(this.tabNextEditor, this)),\n                chrome.keyCodeListen("RETURN", isControl, bind(this.insertRow, this, null, "after")),\n                chrome.keyCodeListen("TAB", null, bind(this.tabNextEditor, this)),\n                chrome.keyCodeListen("TAB", isShift, bind(this.tabPreviousEditor, this))\n            );\n        }\n        else if (currentEditor.multiLine)\n        {\n            this.listeners.push(\n                chrome.keyCodeListen("TAB", null, insertTab)\n            );\n        }\n        else\n        {\n            this.listeners.push(\n                chrome.keyCodeListen("RETURN", null, bindFixed(this.stopEditing, this))\n            );\n\n            if (currentEditor.tabCompletion)\n            {\n                this.listeners.push(\n                    chrome.keyCodeListen("TAB", null, bind(editor.completeValue, editor, 1)),\n                    chrome.keyCodeListen("TAB", isShift, bind(editor.completeValue, editor, -1))\n                );\n            }\n        }\n    },\n\n    detachListeners: function(editor, context)\n    {\n        if (!this.listeners)\n            return;\n\n        var win = isIE ?\n                currentTarget.ownerDocument.parentWindow :\n                currentTarget.ownerDocument.defaultView;\n\n        removeEvent(win, "resize", this.onResize);\n        removeEvent(win, "blur", this.onBlur);\n\n        var chrome = Firebug.chrome;\n        if (chrome)\n        {\n            for (var i = 0; i < this.listeners.length; ++i)\n                chrome.keyIgnore(this.listeners[i]);\n        }\n\n        delete this.listeners;\n    },\n\n    onResize: function(event)\n    {\n        currentEditor.layout(true);\n    },\n\n    onBlur: function(event)\n    {\n        if (currentEditor.enterOnBlur && isAncestor(event.target, currentEditor.box))\n            this.stopEditing();\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Module\n\n    initialize: function()\n    {\n        Firebug.Module.initialize.apply(this, arguments);\n\n        this.onResize = bindFixed(this.onResize, this);\n        this.onBlur = bind(this.onBlur, this);\n    },\n\n    disable: function()\n    {\n        this.stopEditing();\n    },\n\n    showContext: function(browser, context)\n    {\n        this.stopEditing();\n    },\n\n    showPanel: function(browser, panel)\n    {\n        this.stopEditing();\n    }\n});\n\n// ************************************************************************************************\n// BaseEditor\n\nFirebug.BaseEditor = extend(Firebug.MeasureBox,\n{\n    getValue: function()\n    {\n    },\n\n    setValue: function(value)\n    {\n    },\n\n    show: function(target, panel, value, textSize, targetSize)\n    {\n    },\n\n    hide: function()\n    {\n    },\n\n    layout: function(forceAll)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Support for context menus within inline editors.\n\n    getContextMenuItems: function(target)\n    {\n        var items = [];\n        items.push({label: "Cut", commandID: "cmd_cut"});\n        items.push({label: "Copy", commandID: "cmd_copy"});\n        items.push({label: "Paste", commandID: "cmd_paste"});\n        return items;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Editor Module listeners will get "onBeginEditing" just before this call\n\n    beginEditing: function(target, value)\n    {\n    },\n\n    // Editor Module listeners will get "onSaveEdit" just after this call\n    saveEdit: function(target, value, previousValue)\n    {\n    },\n\n    endEditing: function(target, value, cancel)\n    {\n        // Remove empty groups by default\n        return true;\n    },\n\n    insertNewRow: function(target, insertWhere)\n    {\n    }\n});\n\n// ************************************************************************************************\n// InlineEditor\n\n// basic inline editor attributes\nvar inlineEditorAttributes = {\n    "class": "textEditorInner",\n\n    type: "text",\n    spellcheck: "false",\n\n    onkeypress: "$onKeyPress",\n\n    onoverflow: "$onOverflow",\n    oncontextmenu: "$onContextMenu"\n};\n\n// IE does not support the oninput event, so we\'re using the onkeydown to signalize\n// the relevant keyboard events, and the onpropertychange to actually handle the\n// input event, which should happen after the onkeydown event is fired and after the\n// value of the input is updated, but before the onkeyup and before the input (with the\n// new value) is rendered\nif (isIE)\n{\n    inlineEditorAttributes.onpropertychange = "$onInput";\n    inlineEditorAttributes.onkeydown = "$onKeyDown";\n}\n// for other browsers we use the oninput event\nelse\n{\n    inlineEditorAttributes.oninput = "$onInput";\n}\n\nFirebug.InlineEditor = function(doc)\n{\n    this.initializeInline(doc);\n};\n\nFirebug.InlineEditor.prototype = domplate(Firebug.BaseEditor,\n{\n    enterOnBlur: true,\n    outerMargin: 8,\n    shadowExpand: 7,\n\n    tag:\n        DIV({"class": "inlineEditor"},\n            DIV({"class": "textEditorTop1"},\n                DIV({"class": "textEditorTop2"})\n            ),\n            DIV({"class": "textEditorInner1"},\n                DIV({"class": "textEditorInner2"},\n                    INPUT(\n                        inlineEditorAttributes\n                    )\n                )\n            ),\n            DIV({"class": "textEditorBottom1"},\n                DIV({"class": "textEditorBottom2"})\n            )\n        ),\n\n    inputTag :\n        INPUT({"class": "textEditorInner", type: "text",\n            /*oninput: "$onInput",*/ onkeypress: "$onKeyPress", onoverflow: "$onOverflow"}\n        ),\n\n    expanderTag:\n        IMG({"class": "inlineExpander", src: "blank.gif"}),\n\n    initialize: function()\n    {\n        this.fixedWidth = false;\n        this.completeAsYouType = true;\n        this.tabNavigation = true;\n        this.multiLine = false;\n        this.tabCompletion = false;\n        this.arrowCompletion = true;\n        this.noWrap = true;\n        this.numeric = false;\n    },\n\n    destroy: function()\n    {\n        this.destroyInput();\n    },\n\n    initializeInline: function(doc)\n    {\n        if (FBTrace.DBG_EDITOR)\n            FBTrace.sysout("Firebug.InlineEditor initializeInline()");\n\n        //this.box = this.tag.replace({}, doc, this);\n        this.box = this.tag.append({}, doc.body, this);\n\n        //this.input = this.box.childNodes[1].firstChild.firstChild;  // XXXjjb childNode[1] required\n        this.input = this.box.getElementsByTagName("input")[0];\n\n        if (isIElt8)\n        {\n            this.input.style.top = "-8px";\n        }\n\n        this.expander = this.expanderTag.replace({}, doc, this);\n        this.initialize();\n    },\n\n    destroyInput: function()\n    {\n        // XXXjoe Need to remove input/keypress handlers to avoid leaks\n    },\n\n    getValue: function()\n    {\n        return this.input.value;\n    },\n\n    setValue: function(value)\n    {\n        // It\'s only a one-line editor, so new lines shouldn\'t be allowed\n        return this.input.value = stripNewLines(value);\n    },\n\n    show: function(target, panel, value, targetSize)\n    {\n        //dispatch([Firebug.A11yModel], "onInlineEditorShow", [panel, this]);\n        this.target = target;\n        this.panel = panel;\n\n        this.targetSize = targetSize;\n\n        // TODO: xxxpedro editor\n        //this.targetOffset = getClientOffset(target);\n\n        // Some browsers (IE, Google Chrome and Safari) will have problem trying to get the\n        // offset values of invisible elements, or empty elements. So, in order to get the\n        // correct values, we temporary inject a character in the innerHTML of the empty element,\n        // then we get the offset values, and next, we restore the original innerHTML value.\n        var innerHTML = target.innerHTML;\n        var isEmptyElement = !innerHTML;\n        if (isEmptyElement)\n            target.innerHTML = ".";\n\n        // Get the position of the target element (that is about to be edited)\n        this.targetOffset =\n        {\n            x: target.offsetLeft,\n            y: target.offsetTop\n        };\n\n        // Restore the original innerHTML value of the empty element\n        if (isEmptyElement)\n            target.innerHTML = innerHTML;\n\n        this.originalClassName = this.box.className;\n\n        var classNames = target.className.split(" ");\n        for (var i = 0; i < classNames.length; ++i)\n            setClass(this.box, "editor-" + classNames[i]);\n\n        // Make the editor match the target\'s font style\n        copyTextStyles(target, this.box);\n\n        this.setValue(value);\n\n        if (this.fixedWidth)\n            this.updateLayout(true);\n        else\n        {\n            this.startMeasuring(target);\n            this.textSize = this.measureInputText(value);\n\n            // Correct the height of the box to make the funky CSS drop-shadow line up\n            var parent = this.input.parentNode;\n            if (hasClass(parent, "textEditorInner2"))\n            {\n                var yDiff = this.textSize.height - this.shadowExpand;\n\n                // IE6 height offset\n                if (isIE6)\n                    yDiff -= 2;\n\n                parent.style.height = yDiff + "px";\n                parent.parentNode.style.height = yDiff + "px";\n            }\n\n            this.updateLayout(true);\n        }\n\n        this.getAutoCompleter().reset();\n\n        if (isIElt8)\n            panel.panelNode.appendChild(this.box);\n        else\n            target.offsetParent.appendChild(this.box);\n\n        //console.log(target);\n        //this.input.select(); // it\'s called bellow, with setTimeout\n\n        if (isIE)\n        {\n            // reset input style\n            this.input.style.fontFamily = "Monospace";\n            this.input.style.fontSize = "11px";\n        }\n\n        // Insert the "expander" to cover the target element with white space\n        if (!this.fixedWidth)\n        {\n            copyBoxStyles(target, this.expander);\n\n            target.parentNode.replaceChild(this.expander, target);\n            collapse(target, true);\n            this.expander.parentNode.insertBefore(target, this.expander);\n        }\n\n        //TODO: xxxpedro\n        //scrollIntoCenterView(this.box, null, true);\n\n        // Display the editor after change its size and position to avoid flickering\n        this.box.style.display = "block";\n\n        // we need to call input.focus() and input.select() with a timeout,\n        // otherwise it won\'t work on all browsers due to timing issues\n        var self = this;\n        setTimeout(function(){\n            self.input.focus();\n            self.input.select();\n        },0);\n    },\n\n    hide: function()\n    {\n        this.box.className = this.originalClassName;\n\n        if (!this.fixedWidth)\n        {\n            this.stopMeasuring();\n\n            collapse(this.target, false);\n\n            if (this.expander.parentNode)\n                this.expander.parentNode.removeChild(this.expander);\n        }\n\n        if (this.box.parentNode)\n        {\n            ///setSelectionRange(this.input, 0, 0);\n            this.input.blur();\n\n            this.box.parentNode.removeChild(this.box);\n        }\n\n        delete this.target;\n        delete this.panel;\n    },\n\n    layout: function(forceAll)\n    {\n        if (!this.fixedWidth)\n            this.textSize = this.measureInputText(this.input.value);\n\n        if (forceAll)\n            this.targetOffset = getClientOffset(this.expander);\n\n        this.updateLayout(false, forceAll);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    beginEditing: function(target, value)\n    {\n    },\n\n    saveEdit: function(target, value, previousValue)\n    {\n    },\n\n    endEditing: function(target, value, cancel)\n    {\n        // Remove empty groups by default\n        return true;\n    },\n\n    insertNewRow: function(target, insertWhere)\n    {\n    },\n\n    advanceToNext: function(target, charCode)\n    {\n        return false;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getAutoCompleteRange: function(value, offset)\n    {\n    },\n\n    getAutoCompleteList: function(preExpr, expr, postExpr)\n    {\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getAutoCompleter: function()\n    {\n        if (!this.autoCompleter)\n        {\n            this.autoCompleter = new Firebug.AutoCompleter(null,\n                bind(this.getAutoCompleteRange, this), bind(this.getAutoCompleteList, this),\n                true, false);\n        }\n\n        return this.autoCompleter;\n    },\n\n    completeValue: function(amt)\n    {\n        //console.log("completeValue");\n\n        var selectRangeCallback = this.getAutoCompleter().complete(currentPanel.context, this.input, true, amt < 0);\n\n        if (selectRangeCallback)\n        {\n            Firebug.Editor.update(true);\n\n            // We need to select the editor text after calling update in Safari/Chrome,\n            // otherwise the text won\'t be selected\n            if (isSafari)\n                setTimeout(selectRangeCallback,0);\n            else\n                selectRangeCallback();\n        }\n        else\n            this.incrementValue(amt);\n    },\n\n    incrementValue: function(amt)\n    {\n        var value = this.input.value;\n\n        // TODO: xxxpedro editor\n        if (isIE)\n            var start = getInputSelectionStart(this.input), end = start;\n        else\n            var start = this.input.selectionStart, end = this.input.selectionEnd;\n\n        //debugger;\n        var range = this.getAutoCompleteRange(value, start);\n        if (!range || range.type != "int")\n            range = {start: 0, end: value.length-1};\n\n        var expr = value.substr(range.start, range.end-range.start+1);\n        preExpr = value.substr(0, range.start);\n        postExpr = value.substr(range.end+1);\n\n        // See if the value is an integer, and if so increment it\n        var intValue = parseInt(expr);\n        if (!!intValue || intValue == 0)\n        {\n            var m = /\\d+/.exec(expr);\n            var digitPost = expr.substr(m.index+m[0].length);\n\n            var completion = intValue-amt;\n            this.input.value = preExpr + completion + digitPost + postExpr;\n\n            setSelectionRange(this.input, start, end);\n\n            Firebug.Editor.update(true);\n\n            return true;\n        }\n        else\n            return false;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onKeyPress: function(event)\n    {\n        //console.log("onKeyPress", event);\n        if (event.keyCode == 27 && !this.completeAsYouType)\n        {\n            var reverted = this.getAutoCompleter().revert(this.input);\n            if (reverted)\n                cancelEvent(event);\n        }\n        else if (event.charCode && this.advanceToNext(this.target, event.charCode))\n        {\n            Firebug.Editor.tabNextEditor();\n            cancelEvent(event);\n        }\n        else\n        {\n            if (this.numeric && event.charCode && (event.charCode < 48 || event.charCode > 57)\n                && event.charCode != 45 && event.charCode != 46)\n                FBL.cancelEvent(event);\n            else\n            {\n                // If the user backspaces, don\'t autocomplete after the upcoming input event\n                this.ignoreNextInput = event.keyCode == 8;\n            }\n        }\n    },\n\n    onOverflow: function()\n    {\n        this.updateLayout(false, false, 3);\n    },\n\n    onKeyDown: function(event)\n    {\n        //console.log("onKeyDown", event.keyCode);\n        if (event.keyCode > 46 || event.keyCode == 32 || event.keyCode == 8)\n        {\n            this.keyDownPressed = true;\n        }\n    },\n\n    onInput: function(event)\n    {\n        //debugger;\n\n        // skip not relevant onpropertychange calls on IE\n        if (isIE)\n        {\n            if (event.propertyName != "value" || !isVisible(this.input) || !this.keyDownPressed)\n                return;\n\n            this.keyDownPressed = false;\n        }\n\n        //console.log("onInput", event);\n        //console.trace();\n\n        var selectRangeCallback;\n\n        if (this.ignoreNextInput)\n        {\n            this.ignoreNextInput = false;\n            this.getAutoCompleter().reset();\n        }\n        else if (this.completeAsYouType)\n            selectRangeCallback = this.getAutoCompleter().complete(currentPanel.context, this.input, false);\n        else\n            this.getAutoCompleter().reset();\n\n        Firebug.Editor.update();\n\n        if (selectRangeCallback)\n        {\n            // We need to select the editor text after calling update in Safari/Chrome,\n            // otherwise the text won\'t be selected\n            if (isSafari)\n                setTimeout(selectRangeCallback,0);\n            else\n                selectRangeCallback();\n        }\n    },\n\n    onContextMenu: function(event)\n    {\n        cancelEvent(event);\n\n        var popup = $("fbInlineEditorPopup");\n        FBL.eraseNode(popup);\n\n        var target = event.target || event.srcElement;\n        var menu = this.getContextMenuItems(target);\n        if (menu)\n        {\n            for (var i = 0; i < menu.length; ++i)\n                FBL.createMenuItem(popup, menu[i]);\n        }\n\n        if (!popup.firstChild)\n            return false;\n\n        popup.openPopupAtScreen(event.screenX, event.screenY, true);\n        return true;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    updateLayout: function(initial, forceAll, extraWidth)\n    {\n        if (this.fixedWidth)\n        {\n            this.box.style.left = (this.targetOffset.x) + "px";\n            this.box.style.top = (this.targetOffset.y) + "px";\n\n            var w = this.target.offsetWidth;\n            var h = this.target.offsetHeight;\n            this.input.style.width = w + "px";\n            this.input.style.height = (h-3) + "px";\n        }\n        else\n        {\n            if (initial || forceAll)\n            {\n                this.box.style.left = this.targetOffset.x + "px";\n                this.box.style.top = this.targetOffset.y + "px";\n            }\n\n            var approxTextWidth = this.textSize.width;\n            var maxWidth = (currentPanel.panelNode.scrollWidth - this.targetOffset.x)\n                - this.outerMargin;\n\n            var wrapped = initial\n                ? this.noWrap && this.targetSize.height > this.textSize.height+3\n                : this.noWrap && approxTextWidth > maxWidth;\n\n            if (wrapped)\n            {\n                var style = isIE ?\n                        this.target.currentStyle :\n                        this.target.ownerDocument.defaultView.getComputedStyle(this.target, "");\n\n                targetMargin = parseInt(style.marginLeft) + parseInt(style.marginRight);\n\n                // Make the width fit the remaining x-space from the offset to the far right\n                approxTextWidth = maxWidth - targetMargin;\n\n                this.input.style.width = "100%";\n                this.box.style.width = approxTextWidth + "px";\n            }\n            else\n            {\n                // Make the input one character wider than the text value so that\n                // typing does not ever cause the textbox to scroll\n                var charWidth = this.measureInputText(\'m\').width;\n\n                // Sometimes we need to make the editor a little wider, specifically when\n                // an overflow happens, otherwise it will scroll off some text on the left\n                if (extraWidth)\n                    charWidth *= extraWidth;\n\n                var inputWidth = approxTextWidth + charWidth;\n\n                if (initial)\n                {\n                    if (isIE)\n                    {\n                        // TODO: xxxpedro\n                        var xDiff = 13;\n                        this.box.style.width = (inputWidth + xDiff) + "px";\n                    }\n                    else\n                        this.box.style.width = "auto";\n                }\n                else\n                {\n                    // TODO: xxxpedro\n                    var xDiff = isIE ? 13: this.box.scrollWidth - this.input.offsetWidth;\n                    this.box.style.width = (inputWidth + xDiff) + "px";\n                }\n\n                this.input.style.width = inputWidth + "px";\n            }\n\n            this.expander.style.width = approxTextWidth + "px";\n            this.expander.style.height = Math.max(this.textSize.height-3,0) + "px";\n        }\n\n        if (forceAll)\n            scrollIntoCenterView(this.box, null, true);\n    }\n});\n\n// ************************************************************************************************\n// Autocompletion\n\nFirebug.AutoCompleter = function(getExprOffset, getRange, evaluator, selectMode, caseSensitive)\n{\n    var candidates = null;\n    var originalValue = null;\n    var originalOffset = -1;\n    var lastExpr = null;\n    var lastOffset = -1;\n    var exprOffset = 0;\n    var lastIndex = 0;\n    var preParsed = null;\n    var preExpr = null;\n    var postExpr = null;\n\n    this.revert = function(textBox)\n    {\n        if (originalOffset != -1)\n        {\n            textBox.value = originalValue;\n\n            setSelectionRange(textBox, originalOffset, originalOffset);\n\n            this.reset();\n            return true;\n        }\n        else\n        {\n            this.reset();\n            return false;\n        }\n    };\n\n    this.reset = function()\n    {\n        candidates = null;\n        originalValue = null;\n        originalOffset = -1;\n        lastExpr = null;\n        lastOffset = 0;\n        exprOffset = 0;\n    };\n\n    this.complete = function(context, textBox, cycle, reverse)\n    {\n        //console.log("complete", context, textBox, cycle, reverse);\n        // TODO: xxxpedro important port to firebug (variable leak)\n        //var value = lastValue = textBox.value;\n        var value = textBox.value;\n\n        //var offset = textBox.selectionStart;\n        var offset = getInputSelectionStart(textBox);\n\n        // The result of selectionStart() in Safari/Chrome is 1 unit less than the result\n        // in Firefox. Therefore, we need to manually adjust the value here.\n        if (isSafari && !cycle && offset >= 0) offset++;\n\n        if (!selectMode && originalOffset != -1)\n            offset = originalOffset;\n\n        if (!candidates || !cycle || offset != lastOffset)\n        {\n            originalOffset = offset;\n            originalValue = value;\n\n            // Find the part of the string that will be parsed\n            var parseStart = getExprOffset ? getExprOffset(value, offset, context) : 0;\n            preParsed = value.substr(0, parseStart);\n            var parsed = value.substr(parseStart);\n\n            // Find the part of the string that is being completed\n            var range = getRange ? getRange(parsed, offset-parseStart, context) : null;\n            if (!range)\n                range = {start: 0, end: parsed.length-1 };\n\n            var expr = parsed.substr(range.start, range.end-range.start+1);\n            preExpr = parsed.substr(0, range.start);\n            postExpr = parsed.substr(range.end+1);\n            exprOffset = parseStart + range.start;\n\n            if (!cycle)\n            {\n                if (!expr)\n                    return;\n                else if (lastExpr && lastExpr.indexOf(expr) != 0)\n                {\n                    candidates = null;\n                }\n                else if (lastExpr && lastExpr.length >= expr.length)\n                {\n                    candidates = null;\n                    lastExpr = expr;\n                    return;\n                }\n            }\n\n            lastExpr = expr;\n            lastOffset = offset;\n\n            var searchExpr;\n\n            // Check if the cursor is at the very right edge of the expression, or\n            // somewhere in the middle of it\n            if (expr && offset != parseStart+range.end+1)\n            {\n                if (cycle)\n                {\n                    // We are in the middle of the expression, but we can\n                    // complete by cycling to the next item in the values\n                    // list after the expression\n                    offset = range.start;\n                    searchExpr = expr;\n                    expr = "";\n                }\n                else\n                {\n                    // We can\'t complete unless we are at the ridge edge\n                    return;\n                }\n            }\n\n            var values = evaluator(preExpr, expr, postExpr, context);\n            if (!values)\n                return;\n\n            if (expr)\n            {\n                // Filter the list of values to those which begin with expr. We\n                // will then go on to complete the first value in the resulting list\n                candidates = [];\n\n                if (caseSensitive)\n                {\n                    for (var i = 0; i < values.length; ++i)\n                    {\n                        var name = values[i];\n                        if (name.indexOf && name.indexOf(expr) == 0)\n                            candidates.push(name);\n                    }\n                }\n                else\n                {\n                    var lowerExpr = caseSensitive ? expr : expr.toLowerCase();\n                    for (var i = 0; i < values.length; ++i)\n                    {\n                        var name = values[i];\n                        if (name.indexOf && name.toLowerCase().indexOf(lowerExpr) == 0)\n                            candidates.push(name);\n                    }\n                }\n\n                lastIndex = reverse ? candidates.length-1 : 0;\n            }\n            else if (searchExpr)\n            {\n                var searchIndex = -1;\n\n                // Find the first instance of searchExpr in the values list. We\n                // will then complete the string that is found\n                if (caseSensitive)\n                {\n                    searchIndex = values.indexOf(expr);\n                }\n                else\n                {\n                    var lowerExpr = searchExpr.toLowerCase();\n                    for (var i = 0; i < values.length; ++i)\n                    {\n                        var name = values[i];\n                        if (name && name.toLowerCase().indexOf(lowerExpr) == 0)\n                        {\n                            searchIndex = i;\n                            break;\n                        }\n                    }\n                }\n\n                // Nothing found, so there\'s nothing to complete to\n                if (searchIndex == -1)\n                    return this.reset();\n\n                expr = searchExpr;\n                candidates = cloneArray(values);\n                lastIndex = searchIndex;\n            }\n            else\n            {\n                expr = "";\n                candidates = [];\n                for (var i = 0; i < values.length; ++i)\n                {\n                    if (values[i].substr)\n                        candidates.push(values[i]);\n                }\n                lastIndex = -1;\n            }\n        }\n\n        if (cycle)\n        {\n            expr = lastExpr;\n            lastIndex += reverse ? -1 : 1;\n        }\n\n        if (!candidates.length)\n            return;\n\n        if (lastIndex >= candidates.length)\n            lastIndex = 0;\n        else if (lastIndex < 0)\n            lastIndex = candidates.length-1;\n\n        var completion = candidates[lastIndex];\n        var preCompletion = expr.substr(0, offset-exprOffset);\n        var postCompletion = completion.substr(offset-exprOffset);\n\n        textBox.value = preParsed + preExpr + preCompletion + postCompletion + postExpr;\n        var offsetEnd = preParsed.length + preExpr.length + completion.length;\n\n        // TODO: xxxpedro remove the following commented code, if the lib.setSelectionRange()\n        // is working well.\n        /*\n        if (textBox.setSelectionRange)\n        {\n            // we must select the range with a timeout, otherwise the text won\'t\n            // be properly selected (because after this function executes, the editor\'s\n            // input will be resized to fit the whole text)\n            setTimeout(function(){\n                if (selectMode)\n                    textBox.setSelectionRange(offset, offsetEnd);\n                else\n                    textBox.setSelectionRange(offsetEnd, offsetEnd);\n            },0);\n        }\n        /**/\n\n        // we must select the range with a timeout, otherwise the text won\'t\n        // be properly selected (because after this function executes, the editor\'s\n        // input will be resized to fit the whole text)\n        /*\n        setTimeout(function(){\n            if (selectMode)\n                setSelectionRange(textBox, offset, offsetEnd);\n            else\n                setSelectionRange(textBox, offsetEnd, offsetEnd);\n        },0);\n\n        return true;\n        /**/\n\n        // The editor text should be selected only after calling the editor.update()\n        // in Safari/Chrome, otherwise the text won\'t be selected. So, we\'re returning\n        // a function to be called later (in the proper time for all browsers).\n        //\n        // TODO: xxxpedro see if we can move the editor.update() calls to here, and avoid\n        // returning a closure. the complete() function seems to be called only twice in\n        // editor.js. See if this function is called anywhere else (like css.js for example).\n        return function(){\n            //console.log("autocomplete ", textBox, offset, offsetEnd);\n\n            if (selectMode)\n                setSelectionRange(textBox, offset, offsetEnd);\n            else\n                setSelectionRange(textBox, offsetEnd, offsetEnd);\n        };\n        /**/\n    };\n};\n\n// ************************************************************************************************\n// Local Helpers\n\nvar getDefaultEditor = function getDefaultEditor(panel)\n{\n    if (!defaultEditor)\n    {\n        var doc = panel.document;\n        defaultEditor = new Firebug.InlineEditor(doc);\n    }\n\n    return defaultEditor;\n}\n\n/**\n * An outsider is the first element matching the stepper element that\n * is not an child of group. Elements tagged with insertBefore or insertAfter\n * classes are also excluded from these results unless they are the sibling\n * of group, relative to group\'s parent editGroup. This allows for the proper insertion\n * rows when groups are nested.\n */\nvar getOutsider = function getOutsider(element, group, stepper)\n{\n    var parentGroup = getAncestorByClass(group.parentNode, "editGroup");\n    var next;\n    do\n    {\n        next = stepper(next || element);\n    }\n    while (isAncestor(next, group) || isGroupInsert(next, parentGroup));\n\n    return next;\n}\n\nvar isGroupInsert = function isGroupInsert(next, group)\n{\n    return (!group || isAncestor(next, group))\n        && (hasClass(next, "insertBefore") || hasClass(next, "insertAfter"));\n}\n\nvar getNextOutsider = function getNextOutsider(element, group)\n{\n    return getOutsider(element, group, bind(getNextByClass, FBL, "editable"));\n}\n\nvar getPreviousOutsider = function getPreviousOutsider(element, group)\n{\n    return getOutsider(element, group, bind(getPreviousByClass, FBL, "editable"));\n}\n\nvar getInlineParent = function getInlineParent(element)\n{\n    var lastInline = element;\n    for (; element; element = element.parentNode)\n    {\n        //var s = element.ownerDocument.defaultView.getComputedStyle(element, "");\n        var s = isIE ?\n                element.currentStyle :\n                element.ownerDocument.defaultView.getComputedStyle(element, "");\n\n        if (s.display != "inline")\n            return lastInline;\n        else\n            lastInline = element;\n    }\n    return null;\n}\n\nvar insertTab = function insertTab()\n{\n    insertTextIntoElement(currentEditor.input, Firebug.Editor.tabCharacter);\n}\n\n// ************************************************************************************************\n\nFirebug.registerModule(Firebug.Editor);\n\n// ************************************************************************************************\n\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nif (Env.Options.disableXHRListener)\n    return;\n\n// ************************************************************************************************\n// XHRSpy\n\nvar XHRSpy = function()\n{\n    this.requestHeaders = [];\n    this.responseHeaders = [];\n};\n\nXHRSpy.prototype =\n{\n    method: null,\n    url: null,\n    async: null,\n\n    xhrRequest: null,\n\n    href: null,\n\n    loaded: false,\n\n    logRow: null,\n\n    responseText: null,\n\n    requestHeaders: null,\n    responseHeaders: null,\n\n    sourceLink: null, // {href:"file.html", line: 22}\n\n    getURL: function()\n    {\n        return this.href;\n    }\n};\n\n// ************************************************************************************************\n// XMLHttpRequestWrapper\n\nvar XMLHttpRequestWrapper = function(activeXObject)\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // XMLHttpRequestWrapper internal variables\n\n    var xhrRequest = typeof activeXObject != "undefined" ?\n                activeXObject :\n                new _XMLHttpRequest(),\n\n        spy = new XHRSpy(),\n\n        self = this,\n\n        reqType,\n        reqUrl,\n        reqStartTS;\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // XMLHttpRequestWrapper internal methods\n\n    var updateSelfPropertiesIgnore = {\n        abort: 1,\n        channel: 1,\n        getAllResponseHeaders: 1,\n        getInterface: 1,\n        getResponseHeader: 1,\n        mozBackgroundRequest: 1,\n        multipart: 1,\n        onreadystatechange: 1,\n        open: 1,\n        send: 1,\n        setRequestHeader: 1\n    };\n\n    var updateSelfProperties = function()\n    {\n        if (supportsXHRIterator)\n        {\n            for (var propName in xhrRequest)\n            {\n                if (propName in updateSelfPropertiesIgnore)\n                    continue;\n\n                try\n                {\n                    var propValue = xhrRequest[propName];\n\n                    if (propValue && !isFunction(propValue))\n                        self[propName] = propValue;\n                }\n                catch(E)\n                {\n                    //console.log(propName, E.message);\n                }\n            }\n        }\n        else\n        {\n            // will fail to read these xhrRequest properties if the request is not completed\n            if (xhrRequest.readyState == 4)\n            {\n                self.status = xhrRequest.status;\n                self.statusText = xhrRequest.statusText;\n                self.responseText = xhrRequest.responseText;\n                self.responseXML = xhrRequest.responseXML;\n            }\n        }\n    };\n\n    var updateXHRPropertiesIgnore = {\n        channel: 1,\n        onreadystatechange: 1,\n        readyState: 1,\n        responseBody: 1,\n        responseText: 1,\n        responseXML: 1,\n        status: 1,\n        statusText: 1,\n        upload: 1\n    };\n\n    var updateXHRProperties = function()\n    {\n        for (var propName in self)\n        {\n            if (propName in updateXHRPropertiesIgnore)\n                continue;\n\n            try\n            {\n                var propValue = self[propName];\n\n                if (propValue && !xhrRequest[propName])\n                {\n                    xhrRequest[propName] = propValue;\n                }\n            }\n            catch(E)\n            {\n                //console.log(propName, E.message);\n            }\n        }\n    };\n\n    var logXHR = function()\n    {\n        var row = Firebug.Console.log(spy, null, "spy", Firebug.Spy.XHR);\n\n        if (row)\n        {\n            setClass(row, "loading");\n            spy.logRow = row;\n        }\n    };\n\n    var finishXHR = function()\n    {\n        var duration = new Date().getTime() - reqStartTS;\n        var success = xhrRequest.status == 200;\n\n        var responseHeadersText = xhrRequest.getAllResponseHeaders();\n        var responses = responseHeadersText ? responseHeadersText.split(/[\\n\\r]/) : [];\n        var reHeader = /^(\\S+):\\s*(.*)/;\n\n        for (var i=0, l=responses.length; i<l; i++)\n        {\n            var text = responses[i];\n            var match = text.match(reHeader);\n\n            if (match)\n            {\n                var name = match[1];\n                var value = match[2];\n\n                // update the spy mimeType property so we can detect when to show\n                // custom response viewers (such as HTML, XML or JSON viewer)\n                if (name == "Content-Type")\n                    spy.mimeType = value;\n\n                /*\n                if (name == "Last Modified")\n                {\n                    if (!spy.cacheEntry)\n                        spy.cacheEntry = [];\n\n                    spy.cacheEntry.push({\n                       name: [name],\n                       value: [value]\n                    });\n                }\n                /**/\n\n                spy.responseHeaders.push({\n                   name: [name],\n                   value: [value]\n                });\n            }\n        }\n\n        with({\n            row: spy.logRow,\n            status: xhrRequest.status == 0 ?\n                        // if xhrRequest.status == 0 then accessing xhrRequest.statusText\n                        // will cause an error, so we must handle this case (Issue 3504)\n                        "" : xhrRequest.status + " " + xhrRequest.statusText,\n            time: duration,\n            success: success\n        })\n        {\n            setTimeout(function(){\n\n                spy.responseText = xhrRequest.responseText;\n\n                // update row information to avoid "ethernal spinning gif" bug in IE\n                row = row || spy.logRow;\n\n                // if chrome document is not loaded, there will be no row yet, so just ignore\n                if (!row) return;\n\n                // update the XHR representation data\n                handleRequestStatus(success, status, time);\n\n            },200);\n        }\n\n        spy.loaded = true;\n        /*\n        // commented because they are being updated by the updateSelfProperties() function\n        self.status = xhrRequest.status;\n        self.statusText = xhrRequest.statusText;\n        self.responseText = xhrRequest.responseText;\n        self.responseXML = xhrRequest.responseXML;\n        /**/\n        updateSelfProperties();\n    };\n\n    var handleStateChange = function()\n    {\n        //Firebug.Console.log(["onreadystatechange", xhrRequest.readyState, xhrRequest.readyState == 4 && xhrRequest.status]);\n\n        self.readyState = xhrRequest.readyState;\n\n        if (xhrRequest.readyState == 4)\n        {\n            finishXHR();\n\n            xhrRequest.onreadystatechange = function(){};\n        }\n\n        //Firebug.Console.log(spy.url + ": " + xhrRequest.readyState);\n\n        self.onreadystatechange();\n    };\n\n    // update the XHR representation data\n    var handleRequestStatus = function(success, status, time)\n    {\n        var row = spy.logRow;\n        FBL.removeClass(row, "loading");\n\n        if (!success)\n            FBL.setClass(row, "error");\n\n        var item = FBL.$$(".spyStatus", row)[0];\n        item.innerHTML = status;\n\n        if (time)\n        {\n            var item = FBL.$$(".spyTime", row)[0];\n            item.innerHTML = time + "ms";\n        }\n    };\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // XMLHttpRequestWrapper public properties and handlers\n\n    this.readyState = 0;\n\n    this.onreadystatechange = function(){};\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // XMLHttpRequestWrapper public methods\n\n    this.open = function(method, url, async, user, password)\n    {\n        //Firebug.Console.log("xhrRequest open");\n\n        updateSelfProperties();\n\n        if (spy.loaded)\n            spy = new XHRSpy();\n\n        spy.method = method;\n        spy.url = url;\n        spy.async = async;\n        spy.href = url;\n        spy.xhrRequest = xhrRequest;\n        spy.urlParams = parseURLParamsArray(url);\n\n        try\n        {\n            // xhrRequest.open.apply may not be available in IE\n            if (supportsApply)\n                xhrRequest.open.apply(xhrRequest, arguments);\n            else\n                xhrRequest.open(method, url, async, user, password);\n        }\n        catch(e)\n        {\n        }\n\n        xhrRequest.onreadystatechange = handleStateChange;\n\n    };\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    this.send = function(data)\n    {\n        //Firebug.Console.log("xhrRequest send");\n        spy.data = data;\n\n        reqStartTS = new Date().getTime();\n\n        updateXHRProperties();\n\n        try\n        {\n            xhrRequest.send(data);\n        }\n        catch(e)\n        {\n            // TODO: xxxpedro XHR throws or not?\n            //throw e;\n        }\n        finally\n        {\n            logXHR();\n\n            if (!spy.async)\n            {\n                self.readyState = xhrRequest.readyState;\n\n                // sometimes an error happens when calling finishXHR()\n                // Issue 3422: Firebug Lite breaks Google Instant Search\n                try\n                {\n                    finishXHR();\n                }\n                catch(E)\n                {\n                }\n            }\n        }\n    };\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    this.setRequestHeader = function(header, value)\n    {\n        spy.requestHeaders.push({name: [header], value: [value]});\n        return xhrRequest.setRequestHeader(header, value);\n    };\n\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    this.abort = function()\n    {\n        xhrRequest.abort();\n        updateSelfProperties();\n        handleRequestStatus(false, "Aborted");\n    };\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    this.getResponseHeader = function(header)\n    {\n        return xhrRequest.getResponseHeader(header);\n    };\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    this.getAllResponseHeaders = function()\n    {\n        return xhrRequest.getAllResponseHeaders();\n    };\n\n    /**/\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Clone XHR object\n\n    // xhrRequest.open.apply not available in IE and will throw an error in\n    // IE6 by simply reading xhrRequest.open so we must sniff it\n    var supportsApply = !isIE6 &&\n            xhrRequest &&\n            xhrRequest.open &&\n            typeof xhrRequest.open.apply != "undefined";\n\n    var numberOfXHRProperties = 0;\n    for (var propName in xhrRequest)\n    {\n        numberOfXHRProperties++;\n\n        if (propName in updateSelfPropertiesIgnore)\n            continue;\n\n        try\n        {\n            var propValue = xhrRequest[propName];\n\n            if (isFunction(propValue))\n            {\n                if (typeof self[propName] == "undefined")\n                {\n                    this[propName] = (function(name, xhr){\n\n                        return supportsApply ?\n                            // if the browser supports apply\n                            function()\n                            {\n                                return xhr[name].apply(xhr, arguments);\n                            }\n                            :\n                            function(a,b,c,d,e)\n                            {\n                                return xhr[name](a,b,c,d,e);\n                            };\n\n                    })(propName, xhrRequest);\n                }\n            }\n            else\n                this[propName] = propValue;\n        }\n        catch(E)\n        {\n            //console.log(propName, E.message);\n        }\n    }\n\n    // IE6 does not support for (var prop in XHR)\n    var supportsXHRIterator = numberOfXHRProperties > 0;\n\n    /**/\n\n    return this;\n};\n\n// ************************************************************************************************\n// ActiveXObject Wrapper (IE6 only)\n\nvar _ActiveXObject;\nvar isIE6 =  /msie 6/i.test(navigator.appVersion);\n\nif (isIE6)\n{\n    _ActiveXObject = window.ActiveXObject;\n\n    var xhrObjects = " MSXML2.XMLHTTP.5.0 MSXML2.XMLHTTP.4.0 MSXML2.XMLHTTP.3.0 MSXML2.XMLHTTP Microsoft.XMLHTTP ";\n\n    window.ActiveXObject = function(name)\n    {\n        var error = null;\n\n        try\n        {\n            var activeXObject = new _ActiveXObject(name);\n        }\n        catch(e)\n        {\n            error = e;\n        }\n        finally\n        {\n            if (!error)\n            {\n                if (xhrObjects.indexOf(" " + name + " ") != -1)\n                    return new XMLHttpRequestWrapper(activeXObject);\n                else\n                    return activeXObject;\n            }\n            else\n                throw error.message;\n        }\n    };\n}\n\n// ************************************************************************************************\n\n// Register the XMLHttpRequestWrapper for non-IE6 browsers\nif (!isIE6)\n{\n    var _XMLHttpRequest = XMLHttpRequest;\n    window.XMLHttpRequest = function()\n    {\n        return new XMLHttpRequestWrapper();\n    };\n}\n\n//************************************************************************************************\n\nFBL.getNativeXHRObject = function()\n{\n    var xhrObj = false;\n    try\n    {\n        xhrObj = new _XMLHttpRequest();\n    }\n    catch(e)\n    {\n        var progid = [\n                "MSXML2.XMLHTTP.5.0", "MSXML2.XMLHTTP.4.0",\n                "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"\n            ];\n\n        for ( var i=0; i < progid.length; ++i ) {\n            try\n            {\n                xhrObj = new _ActiveXObject(progid[i]);\n            }\n            catch(e)\n            {\n                continue;\n            }\n            break;\n        }\n    }\n    finally\n    {\n        return xhrObj;\n    }\n};\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar reIgnore = /about:|javascript:|resource:|chrome:|jar:/;\nvar layoutInterval = 300;\nvar indentWidth = 18;\n\nvar cacheSession = null;\nvar contexts = new Array();\nvar panelName = "net";\nvar maxQueueRequests = 500;\n//var panelBar1 = $("fbPanelBar1"); // chrome not available at startup\nvar activeRequests = [];\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar mimeExtensionMap =\n{\n    "txt": "text/plain",\n    "html": "text/html",\n    "htm": "text/html",\n    "xhtml": "text/html",\n    "xml": "text/xml",\n    "css": "text/css",\n    "js": "application/x-javascript",\n    "jss": "application/x-javascript",\n    "jpg": "image/jpg",\n    "jpeg": "image/jpeg",\n    "gif": "image/gif",\n    "png": "image/png",\n    "bmp": "image/bmp",\n    "swf": "application/x-shockwave-flash",\n    "flv": "video/x-flv"\n};\n\nvar fileCategories =\n{\n    "undefined": 1,\n    "html": 1,\n    "css": 1,\n    "js": 1,\n    "xhr": 1,\n    "image": 1,\n    "flash": 1,\n    "txt": 1,\n    "bin": 1\n};\n\nvar textFileCategories =\n{\n    "txt": 1,\n    "html": 1,\n    "xhr": 1,\n    "css": 1,\n    "js": 1\n};\n\nvar binaryFileCategories =\n{\n    "bin": 1,\n    "flash": 1\n};\n\nvar mimeCategoryMap =\n{\n    "text/plain": "txt",\n    "application/octet-stream": "bin",\n    "text/html": "html",\n    "text/xml": "html",\n    "text/css": "css",\n    "application/x-javascript": "js",\n    "text/javascript": "js",\n    "application/javascript" : "js",\n    "image/jpeg": "image",\n    "image/jpg": "image",\n    "image/gif": "image",\n    "image/png": "image",\n    "image/bmp": "image",\n    "application/x-shockwave-flash": "flash",\n    "video/x-flv": "flash"\n};\n\nvar binaryCategoryMap =\n{\n    "image": 1,\n    "flash" : 1\n};\n\n// ************************************************************************************************\n\n/**\n * @module Represents a module object for the Net panel. This object is derived\n * from <code>Firebug.ActivableModule</code> in order to support activation (enable/disable).\n * This allows to avoid (performance) expensive features if the functionality is not necessary\n * for the user.\n */\nFirebug.NetMonitor = extend(Firebug.ActivableModule,\n{\n    dispatchName: "netMonitor",\n\n    clear: function(context)\n    {\n        // The user pressed a Clear button so, remove content of the panel...\n        var panel = context.getPanel(panelName, true);\n        if (panel)\n            panel.clear();\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Module\n\n    initialize: function()\n    {\n        return;\n\n        this.panelName = panelName;\n\n        Firebug.ActivableModule.initialize.apply(this, arguments);\n\n        if (Firebug.TraceModule)\n            Firebug.TraceModule.addListener(this.TraceListener);\n\n        // HTTP observer must be registered now (and not in monitorContext, since if a\n        // page is opened in a new tab the top document request would be missed otherwise.\n        NetHttpObserver.registerObserver();\n        NetHttpActivityObserver.registerObserver();\n\n        Firebug.Debugger.addListener(this.DebuggerListener);\n    },\n\n    shutdown: function()\n    {\n        return;\n\n        prefs.removeObserver(Firebug.prefDomain, this, false);\n        if (Firebug.TraceModule)\n            Firebug.TraceModule.removeListener(this.TraceListener);\n\n        NetHttpObserver.unregisterObserver();\n        NetHttpActivityObserver.unregisterObserver();\n\n        Firebug.Debugger.removeListener(this.DebuggerListener);\n    }\n});\n\n\n/**\n * @domplate Represents a template that is used to reneder detailed info about a request.\n * This template is rendered when a request is expanded.\n */\nFirebug.NetMonitor.NetInfoBody = domplate(Firebug.Rep, new Firebug.Listener(),\n{\n    tag:\n        DIV({"class": "netInfoBody", _repObject: "$file"},\n            TAG("$infoTabs", {file: "$file"}),\n            TAG("$infoBodies", {file: "$file"})\n        ),\n\n    infoTabs:\n        DIV({"class": "netInfoTabs focusRow subFocusRow", "role": "tablist"},\n            A({"class": "netInfoParamsTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n                view: "Params",\n                $collapsed: "$file|hideParams"},\n                $STR("URLParameters")\n            ),\n            A({"class": "netInfoHeadersTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n                view: "Headers"},\n                $STR("Headers")\n            ),\n            A({"class": "netInfoPostTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n                view: "Post",\n                $collapsed: "$file|hidePost"},\n                $STR("Post")\n            ),\n            A({"class": "netInfoPutTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n                view: "Put",\n                $collapsed: "$file|hidePut"},\n                $STR("Put")\n            ),\n            A({"class": "netInfoResponseTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n                view: "Response",\n                $collapsed: "$file|hideResponse"},\n                $STR("Response")\n            ),\n            A({"class": "netInfoCacheTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n               view: "Cache",\n               $collapsed: "$file|hideCache"},\n               $STR("Cache")\n            ),\n            A({"class": "netInfoHtmlTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",\n               view: "Html",\n               $collapsed: "$file|hideHtml"},\n               $STR("HTML")\n            )\n        ),\n\n    infoBodies:\n        DIV({"class": "netInfoBodies outerFocusRow"},\n            TABLE({"class": "netInfoParamsText netInfoText netInfoParamsTable", "role": "tabpanel",\n                    cellpadding: 0, cellspacing: 0}, TBODY()),\n            DIV({"class": "netInfoHeadersText netInfoText", "role": "tabpanel"}),\n            DIV({"class": "netInfoPostText netInfoText", "role": "tabpanel"}),\n            DIV({"class": "netInfoPutText netInfoText", "role": "tabpanel"}),\n            PRE({"class": "netInfoResponseText netInfoText", "role": "tabpanel"}),\n            DIV({"class": "netInfoCacheText netInfoText", "role": "tabpanel"},\n                TABLE({"class": "netInfoCacheTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},\n                    TBODY({"role": "list", "aria-label": $STR("Cache")})\n                )\n            ),\n            DIV({"class": "netInfoHtmlText netInfoText", "role": "tabpanel"},\n                IFRAME({"class": "netInfoHtmlPreview", "role": "document"})\n            )\n        ),\n\n    headerDataTag:\n        FOR("param", "$headers",\n            TR({"role": "listitem"},\n                TD({"class": "netInfoParamName", "role": "presentation"},\n                    TAG("$param|getNameTag", {param: "$param"})\n                ),\n                TD({"class": "netInfoParamValue", "role": "list", "aria-label": "$param.name"},\n                    FOR("line", "$param|getParamValueIterator",\n                        CODE({"class": "focusRow subFocusRow", "role": "listitem"}, "$line")\n                    )\n                )\n            )\n        ),\n\n    customTab:\n        A({"class": "netInfo$tabId\\\\Tab netInfoTab", onclick: "$onClickTab", view: "$tabId", "role": "tab"},\n            "$tabTitle"\n        ),\n\n    customBody:\n        DIV({"class": "netInfo$tabId\\\\Text netInfoText", "role": "tabpanel"}),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    nameTag:\n        SPAN("$param|getParamName"),\n\n    nameWithTooltipTag:\n        SPAN({title: "$param.name"}, "$param|getParamName"),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getNameTag: function(param)\n    {\n        return (this.getParamName(param) == param.name) ? this.nameTag : this.nameWithTooltipTag;\n    },\n\n    getParamName: function(param)\n    {\n        var limit = 25;\n        var name = param.name;\n        if (name.length > limit)\n            name = name.substr(0, limit) + "...";\n        return name;\n    },\n\n    getParamTitle: function(param)\n    {\n        var limit = 25;\n        var name = param.name;\n        if (name.length > limit)\n            return name;\n        return "";\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    hideParams: function(file)\n    {\n        return !file.urlParams || !file.urlParams.length;\n    },\n\n    hidePost: function(file)\n    {\n        return file.method.toUpperCase() != "POST";\n    },\n\n    hidePut: function(file)\n    {\n        return file.method.toUpperCase() != "PUT";\n    },\n\n    hideResponse: function(file)\n    {\n        return false;\n        //return file.category in binaryFileCategories;\n    },\n\n    hideCache: function(file)\n    {\n        return true;\n        //xxxHonza: I don\'t see any reason why not to display the cache also info for images.\n        return !file.cacheEntry; // || file.category=="image";\n    },\n\n    hideHtml: function(file)\n    {\n        return (file.mimeType != "text/html") && (file.mimeType != "application/xhtml+xml");\n    },\n\n    onClickTab: function(event)\n    {\n        this.selectTab(event.currentTarget || event.srcElement);\n    },\n\n    getParamValueIterator: function(param)\n    {\n        // TODO: xxxpedro console2\n        return param.value;\n\n        // This value is inserted into CODE element and so, make sure the HTML isn\'t escaped (1210).\n        // This is why the second parameter is true.\n        // The CODE (with style white-space:pre) element preserves whitespaces so they are\n        // displayed the same, as they come from the server (1194).\n        // In case of a long header values of post parameters the value must be wrapped (2105).\n        return wrapText(param.value, true);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    appendTab: function(netInfoBox, tabId, tabTitle)\n    {\n        // Create new tab and body.\n        var args = {tabId: tabId, tabTitle: tabTitle};\n        ///this.customTab.append(args, netInfoBox.getElementsByClassName("netInfoTabs").item(0));\n        ///this.customBody.append(args, netInfoBox.getElementsByClassName("netInfoBodies").item(0));\n        this.customTab.append(args, $$(".netInfoTabs", netInfoBox)[0]);\n        this.customBody.append(args, $$(".netInfoBodies", netInfoBox)[0]);\n    },\n\n    selectTabByName: function(netInfoBox, tabName)\n    {\n        var tab = getChildByClass(netInfoBox, "netInfoTabs", "netInfo"+tabName+"Tab");\n        if (tab)\n            this.selectTab(tab);\n    },\n\n    selectTab: function(tab)\n    {\n        var view = tab.getAttribute("view");\n\n        var netInfoBox = getAncestorByClass(tab, "netInfoBody");\n\n        var selectedTab = netInfoBox.selectedTab;\n\n        if (selectedTab)\n        {\n            //netInfoBox.selectedText.removeAttribute("selected");\n            removeClass(netInfoBox.selectedText, "netInfoTextSelected");\n\n            removeClass(selectedTab, "netInfoTabSelected");\n            //selectedTab.removeAttribute("selected");\n            selectedTab.setAttribute("aria-selected", "false");\n        }\n\n        var textBodyName = "netInfo" + view + "Text";\n\n        selectedTab = netInfoBox.selectedTab = tab;\n\n        netInfoBox.selectedText = $$("."+textBodyName, netInfoBox)[0];\n        //netInfoBox.selectedText = netInfoBox.getElementsByClassName(textBodyName).item(0);\n\n        //netInfoBox.selectedText.setAttribute("selected", "true");\n        setClass(netInfoBox.selectedText, "netInfoTextSelected");\n\n        setClass(selectedTab, "netInfoTabSelected");\n        selectedTab.setAttribute("selected", "true");\n        selectedTab.setAttribute("aria-selected", "true");\n\n        var file = Firebug.getRepObject(netInfoBox);\n\n        //var context = Firebug.getElementPanel(netInfoBox).context;\n        var context = Firebug.chrome;\n\n        this.updateInfo(netInfoBox, file, context);\n    },\n\n    updateInfo: function(netInfoBox, file, context)\n    {\n        if (FBTrace.DBG_NET)\n            FBTrace.sysout("net.updateInfo; file", file);\n\n        if (!netInfoBox)\n        {\n            if (FBTrace.DBG_NET || FBTrace.DBG_ERRORS)\n                FBTrace.sysout("net.updateInfo; ERROR netInfo == null " + file.href, file);\n            return;\n        }\n\n        var tab = netInfoBox.selectedTab;\n\n        if (hasClass(tab, "netInfoParamsTab"))\n        {\n            if (file.urlParams && !netInfoBox.urlParamsPresented)\n            {\n                netInfoBox.urlParamsPresented = true;\n                this.insertHeaderRows(netInfoBox, file.urlParams, "Params");\n            }\n        }\n\n        else if (hasClass(tab, "netInfoHeadersTab"))\n        {\n            var headersText = $$(".netInfoHeadersText", netInfoBox)[0];\n            //var headersText = netInfoBox.getElementsByClassName("netInfoHeadersText").item(0);\n\n            if (file.responseHeaders && !netInfoBox.responseHeadersPresented)\n            {\n                netInfoBox.responseHeadersPresented = true;\n                NetInfoHeaders.renderHeaders(headersText, file.responseHeaders, "ResponseHeaders");\n            }\n\n            if (file.requestHeaders && !netInfoBox.requestHeadersPresented)\n            {\n                netInfoBox.requestHeadersPresented = true;\n                NetInfoHeaders.renderHeaders(headersText, file.requestHeaders, "RequestHeaders");\n            }\n        }\n\n        else if (hasClass(tab, "netInfoPostTab"))\n        {\n            if (!netInfoBox.postPresented)\n            {\n                netInfoBox.postPresented  = true;\n                //var postText = netInfoBox.getElementsByClassName("netInfoPostText").item(0);\n                var postText = $$(".netInfoPostText", netInfoBox)[0];\n                NetInfoPostData.render(context, postText, file);\n            }\n        }\n\n        else if (hasClass(tab, "netInfoPutTab"))\n        {\n            if (!netInfoBox.putPresented)\n            {\n                netInfoBox.putPresented  = true;\n                //var putText = netInfoBox.getElementsByClassName("netInfoPutText").item(0);\n                var putText = $$(".netInfoPutText", netInfoBox)[0];\n                NetInfoPostData.render(context, putText, file);\n            }\n        }\n\n        else if (hasClass(tab, "netInfoResponseTab") && file.loaded && !netInfoBox.responsePresented)\n        {\n            ///var responseTextBox = netInfoBox.getElementsByClassName("netInfoResponseText").item(0);\n            var responseTextBox = $$(".netInfoResponseText", netInfoBox)[0];\n            if (file.category == "image")\n            {\n                netInfoBox.responsePresented = true;\n\n                var responseImage = netInfoBox.ownerDocument.createElement("img");\n                responseImage.src = file.href;\n\n                clearNode(responseTextBox);\n                responseTextBox.appendChild(responseImage, responseTextBox);\n            }\n            else ///if (!(binaryCategoryMap.hasOwnProperty(file.category)))\n            {\n                this.setResponseText(file, netInfoBox, responseTextBox, context);\n            }\n        }\n\n        else if (hasClass(tab, "netInfoCacheTab") && file.loaded && !netInfoBox.cachePresented)\n        {\n            var responseTextBox = netInfoBox.getElementsByClassName("netInfoCacheText").item(0);\n            if (file.cacheEntry) {\n                netInfoBox.cachePresented = true;\n                this.insertHeaderRows(netInfoBox, file.cacheEntry, "Cache");\n            }\n        }\n\n        else if (hasClass(tab, "netInfoHtmlTab") && file.loaded && !netInfoBox.htmlPresented)\n        {\n            netInfoBox.htmlPresented = true;\n\n            var text = Utils.getResponseText(file, context);\n\n            ///var iframe = netInfoBox.getElementsByClassName("netInfoHtmlPreview").item(0);\n            var iframe = $$(".netInfoHtmlPreview", netInfoBox)[0];\n\n            ///iframe.contentWindow.document.body.innerHTML = text;\n\n            // TODO: xxxpedro net - remove scripts\n            var reScript = /<script(.|\\s)*?\\/script>/gi;\n\n            text = text.replace(reScript, "");\n\n            iframe.contentWindow.document.write(text);\n            iframe.contentWindow.document.close();\n        }\n\n        // Notify listeners about update so, content of custom tabs can be updated.\n        dispatch(NetInfoBody.fbListeners, "updateTabBody", [netInfoBox, file, context]);\n    },\n\n    setResponseText: function(file, netInfoBox, responseTextBox, context)\n    {\n        //**********************************************\n        //**********************************************\n        //**********************************************\n        netInfoBox.responsePresented = true;\n        // line breaks somehow are different in IE\n        // make this only once in the initialization? we don\'t have net panels and modules yet.\n        if (isIE)\n            responseTextBox.style.whiteSpace = "nowrap";\n\n        responseTextBox[\n                typeof responseTextBox.textContent != "undefined" ?\n                        "textContent" :\n                        "innerText"\n            ] = file.responseText;\n\n        return;\n        //**********************************************\n        //**********************************************\n        //**********************************************\n\n        // Get response text and make sure it doesn\'t exceed the max limit.\n        var text = Utils.getResponseText(file, context);\n        var limit = Firebug.netDisplayedResponseLimit + 15;\n        var limitReached = text ? (text.length > limit) : false;\n        if (limitReached)\n            text = text.substr(0, limit) + "...";\n\n        // Insert the response into the UI.\n        if (text)\n            insertWrappedText(text, responseTextBox);\n        else\n            insertWrappedText("", responseTextBox);\n\n        // Append a message informing the user that the response isn\'t fully displayed.\n        if (limitReached)\n        {\n            var object = {\n                text: $STR("net.responseSizeLimitMessage"),\n                onClickLink: function() {\n                    var panel = context.getPanel("net", true);\n                    panel.openResponseInTab(file);\n                }\n            };\n            Firebug.NetMonitor.ResponseSizeLimit.append(object, responseTextBox);\n        }\n\n        netInfoBox.responsePresented = true;\n\n        if (FBTrace.DBG_NET)\n            FBTrace.sysout("net.setResponseText; response text updated");\n    },\n\n    insertHeaderRows: function(netInfoBox, headers, tableName, rowName)\n    {\n        if (!headers.length)\n            return;\n\n        var headersTable = $$(".netInfo"+tableName+"Table", netInfoBox)[0];\n        //var headersTable = netInfoBox.getElementsByClassName("netInfo"+tableName+"Table").item(0);\n        var tbody = getChildByClass(headersTable, "netInfo" + rowName + "Body");\n        if (!tbody)\n            tbody = headersTable.firstChild;\n        var titleRow = getChildByClass(tbody, "netInfo" + rowName + "Title");\n\n        this.headerDataTag.insertRows({headers: headers}, titleRow ? titleRow : tbody);\n        removeClass(titleRow, "collapsed");\n    }\n});\n\nvar NetInfoBody = Firebug.NetMonitor.NetInfoBody;\n\n// ************************************************************************************************\n\n/**\n * @domplate Used within the Net panel to display raw source of request and response headers\n * as well as pretty-formatted summary of these headers.\n */\nFirebug.NetMonitor.NetInfoHeaders = domplate(Firebug.Rep, //new Firebug.Listener(),\n{\n    tag:\n        DIV({"class": "netInfoHeadersTable", "role": "tabpanel"},\n            DIV({"class": "netInfoHeadersGroup netInfoResponseHeadersTitle"},\n                SPAN($STR("ResponseHeaders")),\n                SPAN({"class": "netHeadersViewSource response collapsed", onclick: "$onViewSource",\n                    _sourceDisplayed: false, _rowName: "ResponseHeaders"},\n                    $STR("net.headers.view source")\n                )\n            ),\n            TABLE({cellpadding: 0, cellspacing: 0},\n                TBODY({"class": "netInfoResponseHeadersBody", "role": "list",\n                    "aria-label": $STR("ResponseHeaders")})\n            ),\n            DIV({"class": "netInfoHeadersGroup netInfoRequestHeadersTitle"},\n                SPAN($STR("RequestHeaders")),\n                SPAN({"class": "netHeadersViewSource request collapsed", onclick: "$onViewSource",\n                    _sourceDisplayed: false, _rowName: "RequestHeaders"},\n                    $STR("net.headers.view source")\n                )\n            ),\n            TABLE({cellpadding: 0, cellspacing: 0},\n                TBODY({"class": "netInfoRequestHeadersBody", "role": "list",\n                    "aria-label": $STR("RequestHeaders")})\n            )\n        ),\n\n    sourceTag:\n        TR({"role": "presentation"},\n            TD({colspan: 2, "role": "presentation"},\n                PRE({"class": "source"})\n            )\n        ),\n\n    onViewSource: function(event)\n    {\n        var target = event.target;\n        var requestHeaders = (target.rowName == "RequestHeaders");\n\n        var netInfoBox = getAncestorByClass(target, "netInfoBody");\n        var file = netInfoBox.repObject;\n\n        if (target.sourceDisplayed)\n        {\n            var headers = requestHeaders ? file.requestHeaders : file.responseHeaders;\n            this.insertHeaderRows(netInfoBox, headers, target.rowName);\n            target.innerHTML = $STR("net.headers.view source");\n        }\n        else\n        {\n            var source = requestHeaders ? file.requestHeadersText : file.responseHeadersText;\n            this.insertSource(netInfoBox, source, target.rowName);\n            target.innerHTML = $STR("net.headers.pretty print");\n        }\n\n        target.sourceDisplayed = !target.sourceDisplayed;\n\n        cancelEvent(event);\n    },\n\n    insertSource: function(netInfoBox, source, rowName)\n    {\n        // This breaks copy to clipboard.\n        //if (source)\n        //    source = source.replace(/\\r\\n/gm, "<span style=\'color:lightgray\'>\\\\r\\\\n</span>\\r\\n");\n\n        ///var tbody = netInfoBox.getElementsByClassName("netInfo" + rowName + "Body").item(0);\n        var tbody = $$(".netInfo" + rowName + "Body", netInfoBox)[0];\n        var node = this.sourceTag.replace({}, tbody);\n        ///var sourceNode = node.getElementsByClassName("source").item(0);\n        var sourceNode = $$(".source", node)[0];\n        sourceNode.innerHTML = source;\n    },\n\n    insertHeaderRows: function(netInfoBox, headers, rowName)\n    {\n        var headersTable = $$(".netInfoHeadersTable", netInfoBox)[0];\n        var tbody = $$(".netInfo" + rowName + "Body", headersTable)[0];\n\n        //var headersTable = netInfoBox.getElementsByClassName("netInfoHeadersTable").item(0);\n        //var tbody = headersTable.getElementsByClassName("netInfo" + rowName + "Body").item(0);\n\n        clearNode(tbody);\n\n        if (!headers.length)\n            return;\n\n        NetInfoBody.headerDataTag.insertRows({headers: headers}, tbody);\n\n        var titleRow = getChildByClass(headersTable, "netInfo" + rowName + "Title");\n        removeClass(titleRow, "collapsed");\n    },\n\n    init: function(parent)\n    {\n        var rootNode = this.tag.append({}, parent);\n\n        var netInfoBox = getAncestorByClass(parent, "netInfoBody");\n        var file = netInfoBox.repObject;\n\n        var viewSource;\n\n        viewSource = $$(".request", rootNode)[0];\n        //viewSource = rootNode.getElementsByClassName("netHeadersViewSource request").item(0);\n        if (file.requestHeadersText)\n            removeClass(viewSource, "collapsed");\n\n        viewSource = $$(".response", rootNode)[0];\n        //viewSource = rootNode.getElementsByClassName("netHeadersViewSource response").item(0);\n        if (file.responseHeadersText)\n            removeClass(viewSource, "collapsed");\n    },\n\n    renderHeaders: function(parent, headers, rowName)\n    {\n        if (!parent.firstChild)\n            this.init(parent);\n\n        this.insertHeaderRows(parent, headers, rowName);\n    }\n});\n\nvar NetInfoHeaders = Firebug.NetMonitor.NetInfoHeaders;\n\n// ************************************************************************************************\n\n/**\n * @domplate Represents posted data within request info (the info, which is visible when\n * a request entry is expanded. This template renders content of the Post tab.\n */\nFirebug.NetMonitor.NetInfoPostData = domplate(Firebug.Rep, /*new Firebug.Listener(),*/\n{\n    // application/x-www-form-urlencoded\n    paramsTable:\n        TABLE({"class": "netInfoPostParamsTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},\n            TBODY({"role": "list", "aria-label": $STR("net.label.Parameters")},\n                TR({"class": "netInfoPostParamsTitle", "role": "presentation"},\n                    TD({colspan: 3, "role": "presentation"},\n                        DIV({"class": "netInfoPostParams"},\n                            $STR("net.label.Parameters"),\n                            SPAN({"class": "netInfoPostContentType"},\n                                "application/x-www-form-urlencoded"\n                            )\n                        )\n                    )\n                )\n            )\n        ),\n\n    // multipart/form-data\n    partsTable:\n        TABLE({"class": "netInfoPostPartsTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},\n            TBODY({"role": "list", "aria-label": $STR("net.label.Parts")},\n                TR({"class": "netInfoPostPartsTitle", "role": "presentation"},\n                    TD({colspan: 2, "role":"presentation" },\n                        DIV({"class": "netInfoPostParams"},\n                            $STR("net.label.Parts"),\n                            SPAN({"class": "netInfoPostContentType"},\n                                "multipart/form-data"\n                            )\n                        )\n                    )\n                )\n            )\n        ),\n\n    // application/json\n    jsonTable:\n        TABLE({"class": "netInfoPostJSONTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},\n            ///TBODY({"role": "list", "aria-label": $STR("jsonviewer.tab.JSON")},\n            TBODY({"role": "list", "aria-label": $STR("JSON")},\n                TR({"class": "netInfoPostJSONTitle", "role": "presentation"},\n                    TD({"role": "presentation" },\n                        DIV({"class": "netInfoPostParams"},\n                            ///$STR("jsonviewer.tab.JSON")\n                            $STR("JSON")\n                        )\n                    )\n                ),\n                TR(\n                    TD({"class": "netInfoPostJSONBody"})\n                )\n            )\n        ),\n\n    // application/xml\n    xmlTable:\n        TABLE({"class": "netInfoPostXMLTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},\n            TBODY({"role": "list", "aria-label": $STR("xmlviewer.tab.XML")},\n                TR({"class": "netInfoPostXMLTitle", "role": "presentation"},\n                    TD({"role": "presentation" },\n                        DIV({"class": "netInfoPostParams"},\n                            $STR("xmlviewer.tab.XML")\n                        )\n                    )\n                ),\n                TR(\n                    TD({"class": "netInfoPostXMLBody"})\n                )\n            )\n        ),\n\n    sourceTable:\n        TABLE({"class": "netInfoPostSourceTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},\n            TBODY({"role": "list", "aria-label": $STR("net.label.Source")},\n                TR({"class": "netInfoPostSourceTitle", "role": "presentation"},\n                    TD({colspan: 2, "role": "presentation"},\n                        DIV({"class": "netInfoPostSource"},\n                            $STR("net.label.Source")\n                        )\n                    )\n                )\n            )\n        ),\n\n    sourceBodyTag:\n        TR({"role": "presentation"},\n            TD({colspan: 2, "role": "presentation"},\n                FOR("line", "$param|getParamValueIterator",\n                    CODE({"class":"focusRow subFocusRow" , "role": "listitem"},"$line")\n                )\n            )\n        ),\n\n    getParamValueIterator: function(param)\n    {\n        return NetInfoBody.getParamValueIterator(param);\n    },\n\n    render: function(context, parentNode, file)\n    {\n        //debugger;\n        var spy = getAncestorByClass(parentNode, "spyHead");\n        var spyObject = spy.repObject;\n        var data = spyObject.data;\n\n        ///var contentType = Utils.findHeader(file.requestHeaders, "content-type");\n        var contentType = file.mimeType;\n\n        ///var text = Utils.getPostText(file, context, true);\n        ///if (text == undefined)\n        ///    return;\n\n        ///if (Utils.isURLEncodedRequest(file, context))\n        // fake Utils.isURLEncodedRequest identification\n        if (contentType && contentType == "application/x-www-form-urlencoded" ||\n            data && data.indexOf("=") != -1)\n        {\n            ///var lines = text.split("\\n");\n            ///var params = parseURLEncodedText(lines[lines.length-1]);\n            var params = parseURLEncodedTextArray(data);\n            if (params)\n                this.insertParameters(parentNode, params);\n        }\n\n        ///if (Utils.isMultiPartRequest(file, context))\n        ///{\n        ///    var data = this.parseMultiPartText(file, context);\n        ///    if (data)\n        ///        this.insertParts(parentNode, data);\n        ///}\n\n        // moved to the top\n        ///var contentType = Utils.findHeader(file.requestHeaders, "content-type");\n\n        ///if (Firebug.JSONViewerModel.isJSON(contentType))\n        var jsonData = {\n            responseText: data\n        };\n\n        if (Firebug.JSONViewerModel.isJSON(contentType, data))\n            ///this.insertJSON(parentNode, file, context);\n            this.insertJSON(parentNode, jsonData, context);\n\n        ///if (Firebug.XMLViewerModel.isXML(contentType))\n        ///    this.insertXML(parentNode, file, context);\n\n        ///var postText = Utils.getPostText(file, context);\n        ///postText = Utils.formatPostText(postText);\n        var postText = data;\n        if (postText)\n            this.insertSource(parentNode, postText);\n    },\n\n    insertParameters: function(parentNode, params)\n    {\n        if (!params || !params.length)\n            return;\n\n        var paramTable = this.paramsTable.append({object:{}}, parentNode);\n        var row = $$(".netInfoPostParamsTitle", paramTable)[0];\n        //var paramTable = this.paramsTable.append(null, parentNode);\n        //var row = paramTable.getElementsByClassName("netInfoPostParamsTitle").item(0);\n\n        var tbody = paramTable.getElementsByTagName("tbody")[0];\n\n        NetInfoBody.headerDataTag.insertRows({headers: params}, row);\n    },\n\n    insertParts: function(parentNode, data)\n    {\n        if (!data.params || !data.params.length)\n            return;\n\n        var partsTable = this.partsTable.append({object:{}}, parentNode);\n        var row = $$(".netInfoPostPartsTitle", paramTable)[0];\n        //var partsTable = this.partsTable.append(null, parentNode);\n        //var row = partsTable.getElementsByClassName("netInfoPostPartsTitle").item(0);\n\n        NetInfoBody.headerDataTag.insertRows({headers: data.params}, row);\n    },\n\n    insertJSON: function(parentNode, file, context)\n    {\n        ///var text = Utils.getPostText(file, context);\n        var text = file.responseText;\n        ///var data = parseJSONString(text, "http://" + file.request.originalURI.host);\n        var data = parseJSONString(text);\n        if (!data)\n            return;\n\n        ///var jsonTable = this.jsonTable.append(null, parentNode);\n        var jsonTable = this.jsonTable.append({}, parentNode);\n        ///var jsonBody = jsonTable.getElementsByClassName("netInfoPostJSONBody").item(0);\n        var jsonBody = $$(".netInfoPostJSONBody", jsonTable)[0];\n\n        if (!this.toggles)\n            this.toggles = {};\n\n        Firebug.DOMPanel.DirTable.tag.replace(\n            {object: data, toggles: this.toggles}, jsonBody);\n    },\n\n    insertXML: function(parentNode, file, context)\n    {\n        var text = Utils.getPostText(file, context);\n\n        var jsonTable = this.xmlTable.append(null, parentNode);\n        ///var jsonBody = jsonTable.getElementsByClassName("netInfoPostXMLBody").item(0);\n        var jsonBody = $$(".netInfoPostXMLBody", jsonTable)[0];\n\n        Firebug.XMLViewerModel.insertXML(jsonBody, text);\n    },\n\n    insertSource: function(parentNode, text)\n    {\n        var sourceTable = this.sourceTable.append({object:{}}, parentNode);\n        var row = $$(".netInfoPostSourceTitle", sourceTable)[0];\n        //var sourceTable = this.sourceTable.append(null, parentNode);\n        //var row = sourceTable.getElementsByClassName("netInfoPostSourceTitle").item(0);\n\n        var param = {value: [text]};\n        this.sourceBodyTag.insertRows({param: param}, row);\n    },\n\n    parseMultiPartText: function(file, context)\n    {\n        var text = Utils.getPostText(file, context);\n        if (text == undefined)\n            return null;\n\n        FBTrace.sysout("net.parseMultiPartText; boundary: ", text);\n\n        var boundary = text.match(/\\s*boundary=\\s*(.*)/)[1];\n\n        var divider = "\\r\\n\\r\\n";\n        var bodyStart = text.indexOf(divider);\n        var body = text.substr(bodyStart + divider.length);\n\n        var postData = {};\n        postData.mimeType = "multipart/form-data";\n        postData.params = [];\n\n        var parts = body.split("--" + boundary);\n        for (var i=0; i<parts.length; i++)\n        {\n            var part = parts[i].split(divider);\n            if (part.length != 2)\n                continue;\n\n            var m = part[0].match(/\\s*name=\\"(.*)\\"(;|$)/);\n            postData.params.push({\n                name: (m && m.length > 1) ? m[1] : "",\n                value: trim(part[1])\n            });\n        }\n\n        return postData;\n    }\n});\n\nvar NetInfoPostData = Firebug.NetMonitor.NetInfoPostData;\n\n// ************************************************************************************************\n\n\n// TODO: xxxpedro net i18n\nvar $STRP = function(a){return a;};\n\nFirebug.NetMonitor.NetLimit = domplate(Firebug.Rep,\n{\n    collapsed: true,\n\n    tableTag:\n        DIV(\n            TABLE({width: "100%", cellpadding: 0, cellspacing: 0},\n                TBODY()\n            )\n        ),\n\n    limitTag:\n        TR({"class": "netRow netLimitRow", $collapsed: "$isCollapsed"},\n            TD({"class": "netCol netLimitCol", colspan: 6},\n                TABLE({cellpadding: 0, cellspacing: 0},\n                    TBODY(\n                        TR(\n                            TD(\n                                SPAN({"class": "netLimitLabel"},\n                                    $STRP("plural.Limit_Exceeded", [0])\n                                )\n                            ),\n                            TD({style: "width:100%"}),\n                            TD(\n                                BUTTON({"class": "netLimitButton", title: "$limitPrefsTitle",\n                                    onclick: "$onPreferences"},\n                                  $STR("LimitPrefs")\n                                )\n                            ),\n                            TD("&nbsp;")\n                        )\n                    )\n                )\n            )\n        ),\n\n    isCollapsed: function()\n    {\n        return this.collapsed;\n    },\n\n    onPreferences: function(event)\n    {\n        openNewTab("about:config");\n    },\n\n    updateCounter: function(row)\n    {\n        removeClass(row, "collapsed");\n\n        // Update info within the limit row.\n        var limitLabel = row.getElementsByClassName("netLimitLabel").item(0);\n        limitLabel.firstChild.nodeValue = $STRP("plural.Limit_Exceeded", [row.limitInfo.totalCount]);\n    },\n\n    createTable: function(parent, limitInfo)\n    {\n        var table = this.tableTag.replace({}, parent);\n        var row = this.createRow(table.firstChild.firstChild, limitInfo);\n        return [table, row];\n    },\n\n    createRow: function(parent, limitInfo)\n    {\n        var row = this.limitTag.insertRows(limitInfo, parent, this)[0];\n        row.limitInfo = limitInfo;\n        return row;\n    },\n\n    // nsIPrefObserver\n    observe: function(subject, topic, data)\n    {\n        // We\'re observing preferences only.\n        if (topic != "nsPref:changed")\n          return;\n\n        if (data.indexOf("net.logLimit") != -1)\n            this.updateMaxLimit();\n    },\n\n    updateMaxLimit: function()\n    {\n        var value = Firebug.getPref(Firebug.prefDomain, "net.logLimit");\n        maxQueueRequests = value ? value : maxQueueRequests;\n    }\n});\n\nvar NetLimit = Firebug.NetMonitor.NetLimit;\n\n// ************************************************************************************************\n\nFirebug.NetMonitor.ResponseSizeLimit = domplate(Firebug.Rep,\n{\n    tag:\n        DIV({"class": "netInfoResponseSizeLimit"},\n            SPAN("$object.beforeLink"),\n            A({"class": "objectLink", onclick: "$onClickLink"},\n                "$object.linkText"\n            ),\n            SPAN("$object.afterLink")\n        ),\n\n    reLink: /^(.*)<a>(.*)<\\/a>(.*$)/,\n    append: function(obj, parent)\n    {\n        var m = obj.text.match(this.reLink);\n        return this.tag.append({onClickLink: obj.onClickLink,\n            object: {\n            beforeLink: m[1],\n            linkText: m[2],\n            afterLink: m[3]\n        }}, parent, this);\n    }\n});\n\n// ************************************************************************************************\n// ************************************************************************************************\n\nFirebug.NetMonitor.Utils =\n{\n    findHeader: function(headers, name)\n    {\n        if (!headers)\n            return null;\n\n        name = name.toLowerCase();\n        for (var i = 0; i < headers.length; ++i)\n        {\n            var headerName = headers[i].name.toLowerCase();\n            if (headerName == name)\n                return headers[i].value;\n        }\n    },\n\n    formatPostText: function(text)\n    {\n        if (text instanceof XMLDocument)\n            return getElementXML(text.documentElement);\n        else\n            return text;\n    },\n\n    getPostText: function(file, context, noLimit)\n    {\n        if (!file.postText)\n        {\n            file.postText = readPostTextFromRequest(file.request, context);\n\n            if (!file.postText && context)\n                file.postText = readPostTextFromPage(file.href, context);\n        }\n\n        if (!file.postText)\n            return file.postText;\n\n        var limit = Firebug.netDisplayedPostBodyLimit;\n        if (file.postText.length > limit && !noLimit)\n        {\n            return cropString(file.postText, limit,\n                "\\n\\n... " + $STR("net.postDataSizeLimitMessage") + " ...\\n\\n");\n        }\n\n        return file.postText;\n    },\n\n    getResponseText: function(file, context)\n    {\n        // The response can be also empty string so, check agains "undefined".\n        return (typeof(file.responseText) != "undefined")? file.responseText :\n            context.sourceCache.loadText(file.href, file.method, file);\n    },\n\n    isURLEncodedRequest: function(file, context)\n    {\n        var text = Utils.getPostText(file, context);\n        if (text && text.toLowerCase().indexOf("content-type: application/x-www-form-urlencoded") == 0)\n            return true;\n\n        // The header value doesn\'t have to be always exactly "application/x-www-form-urlencoded",\n        // there can be even charset specified. So, use indexOf rather than just "==".\n        var headerValue = Utils.findHeader(file.requestHeaders, "content-type");\n        if (headerValue && headerValue.indexOf("application/x-www-form-urlencoded") == 0)\n            return true;\n\n        return false;\n    },\n\n    isMultiPartRequest: function(file, context)\n    {\n        var text = Utils.getPostText(file, context);\n        if (text && text.toLowerCase().indexOf("content-type: multipart/form-data") == 0)\n            return true;\n        return false;\n    },\n\n    getMimeType: function(mimeType, uri)\n    {\n        if (!mimeType || !(mimeCategoryMap.hasOwnProperty(mimeType)))\n        {\n            var ext = getFileExtension(uri);\n            if (!ext)\n                return mimeType;\n            else\n            {\n                var extMimeType = mimeExtensionMap[ext.toLowerCase()];\n                return extMimeType ? extMimeType : mimeType;\n            }\n        }\n        else\n            return mimeType;\n    },\n\n    getDateFromSeconds: function(s)\n    {\n        var d = new Date();\n        d.setTime(s*1000);\n        return d;\n    },\n\n    getHttpHeaders: function(request, file)\n    {\n        try\n        {\n            var http = QI(request, Ci.nsIHttpChannel);\n            file.status = request.responseStatus;\n\n            // xxxHonza: is there any problem to do this in requestedFile method?\n            file.method = http.requestMethod;\n            file.urlParams = parseURLParams(file.href);\n            file.mimeType = Utils.getMimeType(request.contentType, request.name);\n\n            if (!file.responseHeaders && Firebug.collectHttpHeaders)\n            {\n                var requestHeaders = [], responseHeaders = [];\n\n                http.visitRequestHeaders({\n                    visitHeader: function(name, value)\n                    {\n                        requestHeaders.push({name: name, value: value});\n                    }\n                });\n                http.visitResponseHeaders({\n                    visitHeader: function(name, value)\n                    {\n                        responseHeaders.push({name: name, value: value});\n                    }\n                });\n\n                file.requestHeaders = requestHeaders;\n                file.responseHeaders = responseHeaders;\n            }\n        }\n        catch (exc)\n        {\n            // An exception can be throwed e.g. when the request is aborted and\n            // request.responseStatus is accessed.\n            if (FBTrace.DBG_ERRORS)\n                FBTrace.sysout("net.getHttpHeaders FAILS " + file.href, exc);\n        }\n    },\n\n    isXHR: function(request)\n    {\n        try\n        {\n            var callbacks = request.notificationCallbacks;\n            var xhrRequest = callbacks ? callbacks.getInterface(Ci.nsIXMLHttpRequest) : null;\n            if (FBTrace.DBG_NET)\n                FBTrace.sysout("net.isXHR; " + (xhrRequest != null) + ", " + safeGetName(request));\n\n            return (xhrRequest != null);\n        }\n        catch (exc)\n        {\n        }\n\n       return false;\n    },\n\n    getFileCategory: function(file)\n    {\n        if (file.category)\n        {\n            if (FBTrace.DBG_NET)\n                FBTrace.sysout("net.getFileCategory; current: " + file.category + " for: " + file.href, file);\n            return file.category;\n        }\n\n        if (file.isXHR)\n        {\n            if (FBTrace.DBG_NET)\n                FBTrace.sysout("net.getFileCategory; XHR for: " + file.href, file);\n            return file.category = "xhr";\n        }\n\n        if (!file.mimeType)\n        {\n            var ext = getFileExtension(file.href);\n            if (ext)\n                file.mimeType = mimeExtensionMap[ext.toLowerCase()];\n        }\n\n        /*if (FBTrace.DBG_NET)\n            FBTrace.sysout("net.getFileCategory; " + mimeCategoryMap[file.mimeType] +\n                ", mimeType: " + file.mimeType + " for: " + file.href, file);*/\n\n        if (!file.mimeType)\n            return "";\n\n        // Solve cases when charset is also specified, eg "text/html; charset=UTF-8".\n        var mimeType = file.mimeType;\n        if (mimeType)\n            mimeType = mimeType.split(";")[0];\n\n        return (file.category = mimeCategoryMap[mimeType]);\n    }\n};\n\nvar Utils = Firebug.NetMonitor.Utils;\n\n// ************************************************************************************************\n\n//Firebug.registerRep(Firebug.NetMonitor.NetRequestTable);\n//Firebug.registerActivableModule(Firebug.NetMonitor);\n//Firebug.registerPanel(NetPanel);\n\nFirebug.registerModule(Firebug.NetMonitor);\n//Firebug.registerRep(Firebug.NetMonitor.BreakpointRep);\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// Constants\n\n//const Cc = Components.classes;\n//const Ci = Components.interfaces;\n\n// List of contexts with XHR spy attached.\nvar contexts = [];\n\n// ************************************************************************************************\n// Spy Module\n\n/**\n * @module Represents a XHR Spy module. The main purpose of the XHR Spy feature is to monitor\n * XHR activity of the current page and create appropriate log into the Console panel.\n * This feature can be controlled by an option <i>Show XMLHttpRequests</i> (from within the\n * console panel).\n *\n * The module is responsible for attaching/detaching a HTTP Observers when Firebug is\n * activated/deactivated for a site.\n */\nFirebug.Spy = extend(Firebug.Module,\n/** @lends Firebug.Spy */\n{\n    dispatchName: "spy",\n\n    initialize: function()\n    {\n        if (Firebug.TraceModule)\n            Firebug.TraceModule.addListener(this.TraceListener);\n\n        Firebug.Module.initialize.apply(this, arguments);\n    },\n\n    shutdown: function()\n    {\n        Firebug.Module.shutdown.apply(this, arguments);\n\n        if (Firebug.TraceModule)\n            Firebug.TraceModule.removeListener(this.TraceListener);\n    },\n\n    initContext: function(context)\n    {\n        context.spies = [];\n\n        if (Firebug.showXMLHttpRequests && Firebug.Console.isAlwaysEnabled())\n            this.attachObserver(context, context.window);\n\n        if (FBTrace.DBG_SPY)\n            FBTrace.sysout("spy.initContext " + contexts.length + " ", context.getName());\n    },\n\n    destroyContext: function(context)\n    {\n        // For any spies that are in progress, remove our listeners so that they don\'t leak\n        this.detachObserver(context, null);\n\n        if (FBTrace.DBG_SPY && context.spies.length)\n            FBTrace.sysout("spy.destroyContext; ERROR There are leaking Spies ("\n                + context.spies.length + ") " + context.getName());\n\n        delete context.spies;\n\n        if (FBTrace.DBG_SPY)\n            FBTrace.sysout("spy.destroyContext " + contexts.length + " ", context.getName());\n    },\n\n    watchWindow: function(context, win)\n    {\n        if (Firebug.showXMLHttpRequests && Firebug.Console.isAlwaysEnabled())\n            this.attachObserver(context, win);\n    },\n\n    unwatchWindow: function(context, win)\n    {\n        try\n        {\n            // This make sure that the existing context is properly removed from "contexts" array.\n            this.detachObserver(context, win);\n        }\n        catch (ex)\n        {\n            // Get exceptions here sometimes, so let\'s just ignore them\n            // since the window is going away anyhow\n            ERROR(ex);\n        }\n    },\n\n    updateOption: function(name, value)\n    {\n        // XXXjjb Honza, if Console.isEnabled(context) false, then this can\'t be called,\n        // but somehow seems not correct\n        if (name == "showXMLHttpRequests")\n        {\n            var tach = value ? this.attachObserver : this.detachObserver;\n            for (var i = 0; i < TabWatcher.contexts.length; ++i)\n            {\n                var context = TabWatcher.contexts[i];\n                iterateWindows(context.window, function(win)\n                {\n                    tach.apply(this, [context, win]);\n                });\n            }\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Attaching Spy to XHR requests.\n\n    /**\n     * Returns false if Spy should not be attached to XHRs executed by the specified window.\n     */\n    skipSpy: function(win)\n    {\n        if (!win)\n            return true;\n\n        // Don\'t attach spy to chrome.\n        var uri = safeGetWindowLocation(win);\n        if (uri && (uri.indexOf("about:") == 0 || uri.indexOf("chrome:") == 0))\n            return true;\n    },\n\n    attachObserver: function(context, win)\n    {\n        if (Firebug.Spy.skipSpy(win))\n            return;\n\n        for (var i=0; i<contexts.length; ++i)\n        {\n            if ((contexts[i].context == context) && (contexts[i].win == win))\n                return;\n        }\n\n        // Register HTTP observers only once.\n        if (contexts.length == 0)\n        {\n            httpObserver.addObserver(SpyHttpObserver, "firebug-http-event", false);\n            SpyHttpActivityObserver.registerObserver();\n        }\n\n        contexts.push({context: context, win: win});\n\n        if (FBTrace.DBG_SPY)\n            FBTrace.sysout("spy.attachObserver (HTTP) " + contexts.length + " ", context.getName());\n    },\n\n    detachObserver: function(context, win)\n    {\n        for (var i=0; i<contexts.length; ++i)\n        {\n            if (contexts[i].context == context)\n            {\n                if (win && (contexts[i].win != win))\n                    continue;\n\n                contexts.splice(i, 1);\n\n                // If no context is using spy, remvove the (only one) HTTP observer.\n                if (contexts.length == 0)\n                {\n                    httpObserver.removeObserver(SpyHttpObserver, "firebug-http-event");\n                    SpyHttpActivityObserver.unregisterObserver();\n                }\n\n                if (FBTrace.DBG_SPY)\n                    FBTrace.sysout("spy.detachObserver (HTTP) " + contexts.length + " ",\n                        context.getName());\n                return;\n            }\n        }\n    },\n\n    /**\n     * Return XHR object that is associated with specified request <i>nsIHttpChannel</i>.\n     * Returns null if the request doesn\'t represent XHR.\n     */\n    getXHR: function(request)\n    {\n        // Does also query-interface for nsIHttpChannel.\n        if (!(request instanceof Ci.nsIHttpChannel))\n            return null;\n\n        try\n        {\n            var callbacks = request.notificationCallbacks;\n            return (callbacks ? callbacks.getInterface(Ci.nsIXMLHttpRequest) : null);\n        }\n        catch (exc)\n        {\n            if (exc.name == "NS_NOINTERFACE")\n            {\n                if (FBTrace.DBG_SPY)\n                    FBTrace.sysout("spy.getXHR; Request is not nsIXMLHttpRequest: " +\n                        safeGetRequestName(request));\n            }\n        }\n\n       return null;\n    }\n});\n\n\n\n\n\n// ************************************************************************************************\n\n/*\nfunction getSpyForXHR(request, xhrRequest, context, noCreate)\n{\n    var spy = null;\n\n    // Iterate all existing spy objects in this context and look for one that is\n    // already created for this request.\n    var length = context.spies.length;\n    for (var i=0; i<length; i++)\n    {\n        spy = context.spies[i];\n        if (spy.request == request)\n            return spy;\n    }\n\n    if (noCreate)\n        return null;\n\n    spy = new Firebug.Spy.XMLHttpRequestSpy(request, xhrRequest, context);\n    context.spies.push(spy);\n\n    var name = request.URI.asciiSpec;\n    var origName = request.originalURI.asciiSpec;\n\n    // Attach spy only to the original request. Notice that there can be more network requests\n    // made by the same XHR if redirects are involved.\n    if (name == origName)\n        spy.attach();\n\n    if (FBTrace.DBG_SPY)\n        FBTrace.sysout("spy.getSpyForXHR; New spy object created (" +\n            (name == origName ? "new XHR" : "redirected XHR") + ") for: " + name, spy);\n\n    return spy;\n}\n/**/\n\n// ************************************************************************************************\n\n/**\n * @class This class represents a Spy object that is attached to XHR. This object\n * registers various listeners into the XHR in order to monitor various events fired\n * during the request process (onLoad, onAbort, etc.)\n */\n/*\nFirebug.Spy.XMLHttpRequestSpy = function(request, xhrRequest, context)\n{\n    this.request = request;\n    this.xhrRequest = xhrRequest;\n    this.context = context;\n    this.responseText = "";\n\n    // For compatibility with the Net templates.\n    this.isXHR = true;\n\n    // Support for activity-observer\n    this.transactionStarted = false;\n    this.transactionClosed = false;\n};\n/**/\n\n//Firebug.Spy.XMLHttpRequestSpy.prototype =\n/** @lends Firebug.Spy.XMLHttpRequestSpy */\n/*\n{\n    attach: function()\n    {\n        var spy = this;\n        this.onReadyStateChange = function(event) { onHTTPSpyReadyStateChange(spy, event); };\n        this.onLoad = function() { onHTTPSpyLoad(spy); };\n        this.onError = function() { onHTTPSpyError(spy); };\n        this.onAbort = function() { onHTTPSpyAbort(spy); };\n\n        // xxxHonza: #502959 is still failing on Fx 3.5\n        // Use activity distributor to identify 3.6\n        if (SpyHttpActivityObserver.getActivityDistributor())\n        {\n            this.onreadystatechange = this.xhrRequest.onreadystatechange;\n            this.xhrRequest.onreadystatechange = this.onReadyStateChange;\n        }\n\n        this.xhrRequest.addEventListener("load", this.onLoad, false);\n        this.xhrRequest.addEventListener("error", this.onError, false);\n        this.xhrRequest.addEventListener("abort", this.onAbort, false);\n\n        // xxxHonza: should be removed from FB 3.6\n        if (!SpyHttpActivityObserver.getActivityDistributor())\n            this.context.sourceCache.addListener(this);\n    },\n\n    detach: function()\n    {\n        // Bubble out if already detached.\n        if (!this.onLoad)\n            return;\n\n        // If the activity distributor is available, let\'s detach it when the XHR\n        // transaction is closed. Since, in case of multipart XHRs the onLoad method\n        // (readyState == 4) can be called mutliple times.\n        // Keep in mind:\n        // 1) It can happen that that the TRANSACTION_CLOSE event comes before\n        // the onLoad (if the XHR is made as part of the page load) so, detach if\n        // it\'s already closed.\n        // 2) In case of immediate cache responses, the transaction doesn\'t have to\n        // be started at all (or the activity observer is no available in Firefox 3.5).\n        // So, also detach in this case.\n        if (this.transactionStarted && !this.transactionClosed)\n            return;\n\n        if (FBTrace.DBG_SPY)\n            FBTrace.sysout("spy.detach; " + this.href);\n\n        // Remove itself from the list of active spies.\n        remove(this.context.spies, this);\n\n        if (this.onreadystatechange)\n            this.xhrRequest.onreadystatechange = this.onreadystatechange;\n\n        try { this.xhrRequest.removeEventListener("load", this.onLoad, false); } catch (e) {}\n        try { this.xhrRequest.removeEventListener("error", this.onError, false); } catch (e) {}\n        try { this.xhrRequest.removeEventListener("abort", this.onAbort, false); } catch (e) {}\n\n        this.onreadystatechange = null;\n        this.onLoad = null;\n        this.onError = null;\n        this.onAbort = null;\n\n        // xxxHonza: shouuld be removed from FB 1.6\n        if (!SpyHttpActivityObserver.getActivityDistributor())\n            this.context.sourceCache.removeListener(this);\n    },\n\n    getURL: function()\n    {\n        return this.xhrRequest.channel ? this.xhrRequest.channel.name : this.href;\n    },\n\n    // Cache listener\n    onStopRequest: function(context, request, responseText)\n    {\n        if (!responseText)\n            return;\n\n        if (request == this.request)\n            this.responseText = responseText;\n    },\n};\n/**/\n// ************************************************************************************************\n/*\nfunction onHTTPSpyReadyStateChange(spy, event)\n{\n    if (FBTrace.DBG_SPY)\n        FBTrace.sysout("spy.onHTTPSpyReadyStateChange " + spy.xhrRequest.readyState +\n            " (multipart: " + spy.xhrRequest.multipart + ")");\n\n    // Remember just in case spy is detached (readyState == 4).\n    var originalHandler = spy.onreadystatechange;\n\n    // Force response text to be updated in the UI (in case the console entry\n    // has been already expanded and the response tab selected).\n    if (spy.logRow && spy.xhrRequest.readyState >= 3)\n    {\n        var netInfoBox = getChildByClass(spy.logRow, "spyHead", "netInfoBody");\n        if (netInfoBox)\n        {\n            netInfoBox.htmlPresented = false;\n            netInfoBox.responsePresented = false;\n        }\n    }\n\n    // If the request is loading update the end time.\n    if (spy.xhrRequest.readyState == 3)\n    {\n        spy.responseTime = spy.endTime - spy.sendTime;\n        updateTime(spy);\n    }\n\n    // Request loaded. Get all the info from the request now, just in case the\n    // XHR would be aborted in the original onReadyStateChange handler.\n    if (spy.xhrRequest.readyState == 4)\n    {\n        // Cumulate response so, multipart response content is properly displayed.\n        if (SpyHttpActivityObserver.getActivityDistributor())\n            spy.responseText += spy.xhrRequest.responseText;\n        else\n        {\n            // xxxHonza: remove from FB 1.6\n            if (!spy.responseText)\n                spy.responseText = spy.xhrRequest.responseText;\n        }\n\n        // The XHR is loaded now (used also by the activity observer).\n        spy.loaded = true;\n\n        // Update UI.\n        updateHttpSpyInfo(spy);\n\n        // Notify Net pane about a request beeing loaded.\n        // xxxHonza: I don\'t think this is necessary.\n        var netProgress = spy.context.netProgress;\n        if (netProgress)\n            netProgress.post(netProgress.stopFile, [spy.request, spy.endTime, spy.postText, spy.responseText]);\n\n        // Notify registered listeners about finish of the XHR.\n        dispatch(Firebug.Spy.fbListeners, "onLoad", [spy.context, spy]);\n    }\n\n    // Pass the event to the original page handler.\n    callPageHandler(spy, event, originalHandler);\n}\n\nfunction onHTTPSpyLoad(spy)\n{\n    if (FBTrace.DBG_SPY)\n        FBTrace.sysout("spy.onHTTPSpyLoad: " + spy.href, spy);\n\n    // Detach must be done in onLoad (not in onreadystatechange) otherwise\n    // onAbort would not be handled.\n    spy.detach();\n\n    // xxxHonza: Still needed for Fx 3.5 (#502959)\n    if (!SpyHttpActivityObserver.getActivityDistributor())\n        onHTTPSpyReadyStateChange(spy, null);\n}\n\nfunction onHTTPSpyError(spy)\n{\n    if (FBTrace.DBG_SPY)\n        FBTrace.sysout("spy.onHTTPSpyError; " + spy.href, spy);\n\n    spy.detach();\n    spy.loaded = true;\n\n    if (spy.logRow)\n    {\n        removeClass(spy.logRow, "loading");\n        setClass(spy.logRow, "error");\n    }\n}\n\nfunction onHTTPSpyAbort(spy)\n{\n    if (FBTrace.DBG_SPY)\n        FBTrace.sysout("spy.onHTTPSpyAbort: " + spy.href, spy);\n\n    spy.detach();\n    spy.loaded = true;\n\n    if (spy.logRow)\n    {\n        removeClass(spy.logRow, "loading");\n        setClass(spy.logRow, "error");\n    }\n\n    spy.statusText = "Aborted";\n    updateLogRow(spy);\n\n    // Notify Net pane about a request beeing aborted.\n    // xxxHonza: the net panel shoud find out this itself.\n    var netProgress = spy.context.netProgress;\n    if (netProgress)\n        netProgress.post(netProgress.abortFile, [spy.request, spy.endTime, spy.postText, spy.responseText]);\n}\n/**/\n\n// ************************************************************************************************\n\n/**\n * @domplate Represents a template for XHRs logged in the Console panel. The body of the\n * log (displayed when expanded) is rendered using {@link Firebug.NetMonitor.NetInfoBody}.\n */\n\nFirebug.Spy.XHR = domplate(Firebug.Rep,\n/** @lends Firebug.Spy.XHR */\n\n{\n    tag:\n        DIV({"class": "spyHead", _repObject: "$object"},\n            TABLE({"class": "spyHeadTable focusRow outerFocusRow", cellpadding: 0, cellspacing: 0,\n                "role": "listitem", "aria-expanded": "false"},\n                TBODY({"role": "presentation"},\n                    TR({"class": "spyRow"},\n                        TD({"class": "spyTitleCol spyCol", onclick: "$onToggleBody"},\n                            DIV({"class": "spyTitle"},\n                                "$object|getCaption"\n                            ),\n                            DIV({"class": "spyFullTitle spyTitle"},\n                                "$object|getFullUri"\n                            )\n                        ),\n                        TD({"class": "spyCol"},\n                            DIV({"class": "spyStatus"}, "$object|getStatus")\n                        ),\n                        TD({"class": "spyCol"},\n                            SPAN({"class": "spyIcon"})\n                        ),\n                        TD({"class": "spyCol"},\n                            SPAN({"class": "spyTime"})\n                        ),\n                        TD({"class": "spyCol"},\n                            TAG(FirebugReps.SourceLink.tag, {object: "$object.sourceLink"})\n                        )\n                    )\n                )\n            )\n        ),\n\n    getCaption: function(spy)\n    {\n        return spy.method.toUpperCase() + " " + cropString(spy.getURL(), 100);\n    },\n\n    getFullUri: function(spy)\n    {\n        return spy.method.toUpperCase() + " " + spy.getURL();\n    },\n\n    getStatus: function(spy)\n    {\n        var text = "";\n        if (spy.statusCode)\n            text += spy.statusCode + " ";\n\n        if (spy.statusText)\n            return text += spy.statusText;\n\n        return text;\n    },\n\n    onToggleBody: function(event)\n    {\n        var target = event.currentTarget || event.srcElement;\n        var logRow = getAncestorByClass(target, "logRow-spy");\n\n        if (isLeftClick(event))\n        {\n            toggleClass(logRow, "opened");\n\n            var spy = getChildByClass(logRow, "spyHead").repObject;\n            var spyHeadTable = getAncestorByClass(target, "spyHeadTable");\n\n            if (hasClass(logRow, "opened"))\n            {\n                updateHttpSpyInfo(spy, logRow);\n                if (spyHeadTable)\n                    spyHeadTable.setAttribute(\'aria-expanded\', \'true\');\n            }\n            else\n            {\n                //var netInfoBox = getChildByClass(spy.logRow, "spyHead", "netInfoBody");\n                //dispatch(Firebug.NetMonitor.NetInfoBody.fbListeners, "destroyTabBody", [netInfoBox, spy]);\n                //if (spyHeadTable)\n                //    spyHeadTable.setAttribute(\'aria-expanded\', \'false\');\n            }\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    copyURL: function(spy)\n    {\n        copyToClipboard(spy.getURL());\n    },\n\n    copyParams: function(spy)\n    {\n        var text = spy.postText;\n        if (!text)\n            return;\n\n        var url = reEncodeURL(spy, text, true);\n        copyToClipboard(url);\n    },\n\n    copyResponse: function(spy)\n    {\n        copyToClipboard(spy.responseText);\n    },\n\n    openInTab: function(spy)\n    {\n        openNewTab(spy.getURL(), spy.postText);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    supportsObject: function(object)\n    {\n        // TODO: xxxpedro spy xhr\n        return false;\n\n        return object instanceof Firebug.Spy.XMLHttpRequestSpy;\n    },\n\n    browseObject: function(spy, context)\n    {\n        var url = spy.getURL();\n        openNewTab(url);\n        return true;\n    },\n\n    getRealObject: function(spy, context)\n    {\n        return spy.xhrRequest;\n    },\n\n    getContextMenuItems: function(spy)\n    {\n        var items = [\n            {label: "CopyLocation", command: bindFixed(this.copyURL, this, spy) }\n        ];\n\n        if (spy.postText)\n        {\n            items.push(\n                {label: "CopyLocationParameters", command: bindFixed(this.copyParams, this, spy) }\n            );\n        }\n\n        items.push(\n            {label: "CopyResponse", command: bindFixed(this.copyResponse, this, spy) },\n            "-",\n            {label: "OpenInTab", command: bindFixed(this.openInTab, this, spy) }\n        );\n\n        return items;\n    }\n});\n\n// ************************************************************************************************\n\nfunction updateTime(spy)\n{\n    var timeBox = spy.logRow.getElementsByClassName("spyTime").item(0);\n    if (spy.responseTime)\n        timeBox.textContent = " " + formatTime(spy.responseTime);\n}\n\nfunction updateLogRow(spy)\n{\n    updateTime(spy);\n\n    var statusBox = spy.logRow.getElementsByClassName("spyStatus").item(0);\n    statusBox.textContent = Firebug.Spy.XHR.getStatus(spy);\n\n    removeClass(spy.logRow, "loading");\n    setClass(spy.logRow, "loaded");\n\n    try\n    {\n        var errorRange = Math.floor(spy.xhrRequest.status/100);\n        if (errorRange == 4 || errorRange == 5)\n            setClass(spy.logRow, "error");\n    }\n    catch (exc)\n    {\n    }\n}\n\nvar updateHttpSpyInfo = function updateHttpSpyInfo(spy, logRow)\n{\n    if (!spy.logRow && logRow)\n        spy.logRow = logRow;\n\n    if (!spy.logRow || !hasClass(spy.logRow, "opened"))\n        return;\n\n    if (!spy.params)\n        //spy.params = parseURLParams(spy.href+"");\n        spy.params = parseURLParams(spy.href+"");\n\n    if (!spy.requestHeaders)\n        spy.requestHeaders = getRequestHeaders(spy);\n\n    if (!spy.responseHeaders && spy.loaded)\n        spy.responseHeaders = getResponseHeaders(spy);\n\n    var template = Firebug.NetMonitor.NetInfoBody;\n    var netInfoBox = getChildByClass(spy.logRow, "spyHead", "netInfoBody");\n    if (!netInfoBox)\n    {\n        var head = getChildByClass(spy.logRow, "spyHead");\n        netInfoBox = template.tag.append({"file": spy}, head);\n        dispatch(template.fbListeners, "initTabBody", [netInfoBox, spy]);\n        template.selectTabByName(netInfoBox, "Response");\n    }\n    else\n    {\n        template.updateInfo(netInfoBox, spy, spy.context);\n    }\n};\n\n\n\n// ************************************************************************************************\n\nfunction getRequestHeaders(spy)\n{\n    var headers = [];\n\n    var channel = spy.xhrRequest.channel;\n    if (channel instanceof Ci.nsIHttpChannel)\n    {\n        channel.visitRequestHeaders({\n            visitHeader: function(name, value)\n            {\n                headers.push({name: name, value: value});\n            }\n        });\n    }\n\n    return headers;\n}\n\nfunction getResponseHeaders(spy)\n{\n    var headers = [];\n\n    try\n    {\n        var channel = spy.xhrRequest.channel;\n        if (channel instanceof Ci.nsIHttpChannel)\n        {\n            channel.visitResponseHeaders({\n                visitHeader: function(name, value)\n                {\n                    headers.push({name: name, value: value});\n                }\n            });\n        }\n    }\n    catch (exc)\n    {\n        if (FBTrace.DBG_SPY || FBTrace.DBG_ERRORS)\n            FBTrace.sysout("spy.getResponseHeaders; EXCEPTION " +\n                safeGetRequestName(spy.request), exc);\n    }\n\n    return headers;\n}\n\n// ************************************************************************************************\n// Registration\n\nFirebug.registerModule(Firebug.Spy);\n//Firebug.registerRep(Firebug.Spy.XHR);\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n\n// List of JSON content types.\nvar contentTypes =\n{\n    // TODO: create issue: jsonViewer will not try to evaluate the contents of the requested file\n    // if the content-type is set to "text/plain"\n    //"text/plain": 1,\n    "text/javascript": 1,\n    "text/x-javascript": 1,\n    "text/json": 1,\n    "text/x-json": 1,\n    "application/json": 1,\n    "application/x-json": 1,\n    "application/javascript": 1,\n    "application/x-javascript": 1,\n    "application/json-rpc": 1\n};\n\n// ************************************************************************************************\n// Model implementation\n\nFirebug.JSONViewerModel = extend(Firebug.Module,\n{\n    dispatchName: "jsonViewer",\n    initialize: function()\n    {\n        Firebug.NetMonitor.NetInfoBody.addListener(this);\n\n        // Used by Firebug.DOMPanel.DirTable domplate.\n        this.toggles = {};\n    },\n\n    shutdown: function()\n    {\n        Firebug.NetMonitor.NetInfoBody.removeListener(this);\n    },\n\n    initTabBody: function(infoBox, file)\n    {\n        if (FBTrace.DBG_JSONVIEWER)\n            FBTrace.sysout("jsonviewer.initTabBody", infoBox);\n\n        // Let listeners to parse the JSON.\n        dispatch(this.fbListeners, "onParseJSON", [file]);\n\n        // The JSON is still no there, try to parse most common cases.\n        if (!file.jsonObject)\n        {\n            ///if (this.isJSON(safeGetContentType(file.request), file.responseText))\n            if (this.isJSON(file.mimeType, file.responseText))\n                file.jsonObject = this.parseJSON(file);\n        }\n\n        // The jsonObject is created so, the JSON tab can be displayed.\n        if (file.jsonObject && hasProperties(file.jsonObject))\n        {\n            Firebug.NetMonitor.NetInfoBody.appendTab(infoBox, "JSON",\n                ///$STR("jsonviewer.tab.JSON"));\n                $STR("JSON"));\n\n            if (FBTrace.DBG_JSONVIEWER)\n                FBTrace.sysout("jsonviewer.initTabBody; JSON object available " +\n                    (typeof(file.jsonObject) != "undefined"), file.jsonObject);\n        }\n    },\n\n    isJSON: function(contentType, data)\n    {\n        // Workaround for JSON responses without proper content type\n        // Let\'s consider all responses starting with "{" as JSON. In the worst\n        // case there will be an exception when parsing. This means that no-JSON\n        // responses (and post data) (with "{") can be parsed unnecessarily,\n        // which represents a little overhead, but this happens only if the request\n        // is actually expanded by the user in the UI (Net & Console panels).\n\n        ///var responseText = data ? trimLeft(data) : null;\n        ///if (responseText && responseText.indexOf("{") == 0)\n        ///    return true;\n        var responseText = data ? trim(data) : null;\n        if (responseText && responseText.indexOf("{") == 0)\n            return true;\n\n        if (!contentType)\n            return false;\n\n        contentType = contentType.split(";")[0];\n        contentType = trim(contentType);\n        return contentTypes[contentType];\n    },\n\n    // Update listener for TabView\n    updateTabBody: function(infoBox, file, context)\n    {\n        var tab = infoBox.selectedTab;\n        ///var tabBody = infoBox.getElementsByClassName("netInfoJSONText").item(0);\n        var tabBody = $$(".netInfoJSONText", infoBox)[0];\n        if (!hasClass(tab, "netInfoJSONTab") || tabBody.updated)\n            return;\n\n        tabBody.updated = true;\n\n        if (file.jsonObject) {\n            Firebug.DOMPanel.DirTable.tag.replace(\n                 {object: file.jsonObject, toggles: this.toggles}, tabBody);\n        }\n    },\n\n    parseJSON: function(file)\n    {\n        var jsonString = new String(file.responseText);\n        ///return parseJSONString(jsonString, "http://" + file.request.originalURI.host);\n        return parseJSONString(jsonString);\n    }\n});\n\n// ************************************************************************************************\n// Registration\n\nFirebug.registerModule(Firebug.JSONViewerModel);\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// Constants\n\n// List of XML related content types.\nvar xmlContentTypes =\n[\n    "text/xml",\n    "application/xml",\n    "application/xhtml+xml",\n    "application/rss+xml",\n    "application/atom+xml",,\n    "application/vnd.mozilla.maybe.feed",\n    "application/rdf+xml",\n    "application/vnd.mozilla.xul+xml"\n];\n\n// ************************************************************************************************\n// Model implementation\n\n/**\n * @module Implements viewer for XML based network responses. In order to create a new\n * tab wihin network request detail, a listener is registered into\n * <code>Firebug.NetMonitor.NetInfoBody</code> object.\n */\nFirebug.XMLViewerModel = extend(Firebug.Module,\n{\n    dispatchName: "xmlViewer",\n\n    initialize: function()\n    {\n        ///Firebug.ActivableModule.initialize.apply(this, arguments);\n        Firebug.Module.initialize.apply(this, arguments);\n        Firebug.NetMonitor.NetInfoBody.addListener(this);\n    },\n\n    shutdown: function()\n    {\n        ///Firebug.ActivableModule.shutdown.apply(this, arguments);\n        Firebug.Module.shutdown.apply(this, arguments);\n        Firebug.NetMonitor.NetInfoBody.removeListener(this);\n    },\n\n    /**\n     * Check response\'s content-type and if it\'s a XML, create a new tab with XML preview.\n     */\n    initTabBody: function(infoBox, file)\n    {\n        if (FBTrace.DBG_XMLVIEWER)\n            FBTrace.sysout("xmlviewer.initTabBody", infoBox);\n\n        // If the response is XML let\'s display a pretty preview.\n        ///if (this.isXML(safeGetContentType(file.request)))\n        if (this.isXML(file.mimeType, file.responseText))\n        {\n            Firebug.NetMonitor.NetInfoBody.appendTab(infoBox, "XML",\n                ///$STR("xmlviewer.tab.XML"));\n                $STR("XML"));\n\n            if (FBTrace.DBG_XMLVIEWER)\n                FBTrace.sysout("xmlviewer.initTabBody; XML response available");\n        }\n    },\n\n    isXML: function(contentType)\n    {\n        if (!contentType)\n            return false;\n\n        // Look if the response is XML based.\n        for (var i=0; i<xmlContentTypes.length; i++)\n        {\n            if (contentType.indexOf(xmlContentTypes[i]) == 0)\n                return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Parse XML response and render pretty printed preview.\n     */\n    updateTabBody: function(infoBox, file, context)\n    {\n        var tab = infoBox.selectedTab;\n        ///var tabBody = infoBox.getElementsByClassName("netInfoXMLText").item(0);\n        var tabBody = $$(".netInfoXMLText", infoBox)[0];\n        if (!hasClass(tab, "netInfoXMLTab") || tabBody.updated)\n            return;\n\n        tabBody.updated = true;\n\n        this.insertXML(tabBody, Firebug.NetMonitor.Utils.getResponseText(file, context));\n    },\n\n    insertXML: function(parentNode, text)\n    {\n        var xmlText = text.replace(/^\\s*<?.+?>\\s*/, "");\n\n        var div = parentNode.ownerDocument.createElement("div");\n        div.innerHTML = xmlText;\n\n        var root = div.getElementsByTagName("*")[0];\n\n        /***\n        var parser = CCIN("@mozilla.org/xmlextras/domparser;1", "nsIDOMParser");\n        var doc = parser.parseFromString(text, "text/xml");\n        var root = doc.documentElement;\n\n        // Error handling\n        var nsURI = "http://www.mozilla.org/newlayout/xml/parsererror.xml";\n        if (root.namespaceURI == nsURI && root.nodeName == "parsererror")\n        {\n            this.ParseError.tag.replace({error: {\n                message: root.firstChild.nodeValue,\n                source: root.lastChild.textContent\n            }}, parentNode);\n            return;\n        }\n        /**/\n\n        if (FBTrace.DBG_XMLVIEWER)\n            FBTrace.sysout("xmlviewer.updateTabBody; XML response parsed", doc);\n\n        // Override getHidden in these templates. The parsed XML documen is\n        // hidden, but we want to display it using \'visible\' styling.\n        /*\n        var templates = [\n            Firebug.HTMLPanel.CompleteElement,\n            Firebug.HTMLPanel.Element,\n            Firebug.HTMLPanel.TextElement,\n            Firebug.HTMLPanel.EmptyElement,\n            Firebug.HTMLPanel.XEmptyElement,\n        ];\n\n        var originals = [];\n        for (var i=0; i<templates.length; i++)\n        {\n            originals[i] = templates[i].getHidden;\n            templates[i].getHidden = function() {\n                return "";\n            }\n        }\n        /**/\n\n        // Generate XML preview.\n        ///Firebug.HTMLPanel.CompleteElement.tag.replace({object: doc.documentElement}, parentNode);\n\n        // TODO: xxxpedro html3\n        ///Firebug.HTMLPanel.CompleteElement.tag.replace({object: root}, parentNode);\n        var html = [];\n        Firebug.Reps.appendNode(root, html);\n        parentNode.innerHTML = html.join("");\n\n\n        /*\n        for (var i=0; i<originals.length; i++)\n            templates[i].getHidden = originals[i];/**/\n    }\n});\n\n// ************************************************************************************************\n// Domplate\n\n/**\n * @domplate Represents a template for displaying XML parser errors. Used by\n * <code>Firebug.XMLViewerModel</code>.\n */\nFirebug.XMLViewerModel.ParseError = domplate(Firebug.Rep,\n{\n    tag:\n        DIV({"class": "xmlInfoError"},\n            DIV({"class": "xmlInfoErrorMsg"}, "$error.message"),\n            PRE({"class": "xmlInfoErrorSource"}, "$error|getSource")\n        ),\n\n    getSource: function(error)\n    {\n        var parts = error.source.split("\\n");\n        if (parts.length != 2)\n            return error.source;\n\n        var limit = 50;\n        var column = parts[1].length;\n        if (column >= limit) {\n            parts[0] = "..." + parts[0].substr(column - limit);\n            parts[1] = "..." + parts[1].substr(column - limit);\n        }\n\n        if (parts[0].length > 80)\n            parts[0] = parts[0].substr(0, 80) + "...";\n\n        return parts.join("\\n");\n    }\n});\n\n// ************************************************************************************************\n// Registration\n\nFirebug.registerModule(Firebug.XMLViewerModel);\n\n}});\n\n\n/* See license.txt for terms of usage */\n\n// next-generation Console Panel (will override consoje.js)\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Constants\n\n/*\nconst Cc = Components.classes;\nconst Ci = Components.interfaces;\nconst nsIPrefBranch2 = Ci.nsIPrefBranch2;\nconst PrefService = Cc["@mozilla.org/preferences-service;1"];\nconst prefs = PrefService.getService(nsIPrefBranch2);\n/**/\n/*\n\n// new offline message handler\no = {x:1,y:2};\n\nr = Firebug.getRep(o);\n\nr.tag.tag.compile();\n\noutputs = [];\nhtml = r.tag.renderHTML({object:o}, outputs);\n\n\n// finish rendering the template (the DOM part)\ntarget = $("build");\ntarget.innerHTML = html;\nroot = target.firstChild;\n\ndomArgs = [root, r.tag.context, 0];\ndomArgs.push.apply(domArgs, r.tag.domArgs);\ndomArgs.push.apply(domArgs, outputs);\nr.tag.tag.renderDOM.apply(self ? self : r.tag.subject, domArgs);\n\n\n */\nvar consoleQueue = [];\nvar lastHighlightedObject;\nvar FirebugContext = Env.browser;\n\n// ************************************************************************************************\n\nvar maxQueueRequests = 500;\n\n// ************************************************************************************************\n\nFirebug.ConsoleBase =\n{\n    log: function(object, context, className, rep, noThrottle, sourceLink)\n    {\n        //dispatch(this.fbListeners,"log",[context, object, className, sourceLink]);\n        return this.logRow(appendObject, object, context, className, rep, sourceLink, noThrottle);\n    },\n\n    logFormatted: function(objects, context, className, noThrottle, sourceLink)\n    {\n        //dispatch(this.fbListeners,"logFormatted",[context, objects, className, sourceLink]);\n        return this.logRow(appendFormatted, objects, context, className, null, sourceLink, noThrottle);\n    },\n\n    openGroup: function(objects, context, className, rep, noThrottle, sourceLink, noPush)\n    {\n        return this.logRow(appendOpenGroup, objects, context, className, rep, sourceLink, noThrottle);\n    },\n\n    closeGroup: function(context, noThrottle)\n    {\n        return this.logRow(appendCloseGroup, null, context, null, null, null, noThrottle, true);\n    },\n\n    logRow: function(appender, objects, context, className, rep, sourceLink, noThrottle, noRow)\n    {\n        // TODO: xxxpedro console console2\n        noThrottle = true; // xxxpedro forced because there is no TabContext yet\n\n        if (!context)\n            context = FirebugContext;\n\n        if (FBTrace.DBG_ERRORS && !context)\n            FBTrace.sysout("Console.logRow has no context, skipping objects", objects);\n\n        if (!context)\n            return;\n\n        if (noThrottle || !context)\n        {\n            var panel = this.getPanel(context);\n            if (panel)\n            {\n                var row = panel.append(appender, objects, className, rep, sourceLink, noRow);\n                var container = panel.panelNode;\n\n                // TODO: xxxpedro what is this? console console2\n                /*\n                var template = Firebug.NetMonitor.NetLimit;\n\n                while (container.childNodes.length > maxQueueRequests + 1)\n                {\n                    clearDomplate(container.firstChild.nextSibling);\n                    container.removeChild(container.firstChild.nextSibling);\n                    panel.limit.limitInfo.totalCount++;\n                    template.updateCounter(panel.limit);\n                }\n                dispatch([Firebug.A11yModel], "onLogRowCreated", [panel , row]);\n                /**/\n                return row;\n            }\n            else\n            {\n                consoleQueue.push([appender, objects, context, className, rep, sourceLink, noThrottle, noRow]);\n            }\n        }\n        else\n        {\n            if (!context.throttle)\n            {\n                //FBTrace.sysout("console.logRow has not context.throttle! ");\n                return;\n            }\n            var args = [appender, objects, context, className, rep, sourceLink, true, noRow];\n            context.throttle(this.logRow, this, args);\n        }\n    },\n\n    appendFormatted: function(args, row, context)\n    {\n        if (!context)\n            context = FirebugContext;\n\n        var panel = this.getPanel(context);\n        panel.appendFormatted(args, row);\n    },\n\n    clear: function(context)\n    {\n        if (!context)\n            //context = FirebugContext;\n            context = Firebug.context;\n\n        /*\n        if (context)\n            Firebug.Errors.clear(context);\n        /**/\n\n        var panel = this.getPanel(context, true);\n        if (panel)\n        {\n            panel.clear();\n        }\n    },\n\n    // Override to direct output to your panel\n    getPanel: function(context, noCreate)\n    {\n        //return context.getPanel("console", noCreate);\n        // TODO: xxxpedro console console2\n        return Firebug.chrome ? Firebug.chrome.getPanel("Console") : null;\n    }\n\n};\n\n// ************************************************************************************************\n\n//TODO: xxxpedro\n//var ActivableConsole = extend(Firebug.ActivableModule, Firebug.ConsoleBase);\nvar ActivableConsole = extend(Firebug.ConsoleBase,\n{\n    isAlwaysEnabled: function()\n    {\n        return true;\n    }\n});\n\nFirebug.Console = Firebug.Console = extend(ActivableConsole,\n//Firebug.Console = extend(ActivableConsole,\n{\n    dispatchName: "console",\n\n    error: function()\n    {\n        Firebug.Console.logFormatted(arguments, Firebug.browser, "error");\n    },\n\n    flush: function()\n    {\n        dispatch(this.fbListeners,"flush",[]);\n\n        for (var i=0, length=consoleQueue.length; i<length; i++)\n        {\n            var args = consoleQueue[i];\n            this.logRow.apply(this, args);\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Module\n\n    showPanel: function(browser, panel)\n    {\n    },\n\n    getFirebugConsoleElement: function(context, win)\n    {\n        var element = win.document.getElementById("_firebugConsole");\n        if (!element)\n        {\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("getFirebugConsoleElement forcing element");\n            var elementForcer = "(function(){var r=null; try { r = window._getFirebugConsoleElement();}catch(exc){r=exc;} return r;})();";  // we could just add the elements here\n\n            if (context.stopped)\n                Firebug.Console.injector.evaluateConsoleScript(context);  // todo evaluate consoleForcer on stack\n            else\n                var r = Firebug.CommandLine.evaluateInWebPage(elementForcer, context, win);\n\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("getFirebugConsoleElement forcing element result "+r, r);\n\n            var element = win.document.getElementById("_firebugConsole");\n            if (!element) // elementForce fails\n            {\n                if (FBTrace.DBG_ERRORS) FBTrace.sysout("console.getFirebugConsoleElement: no _firebugConsole in win:", win);\n                Firebug.Console.logFormatted(["Firebug cannot find _firebugConsole element", r, win], context, "error", true);\n            }\n        }\n\n        return element;\n    },\n\n    isReadyElsePreparing: function(context, win) // this is the only code that should call injector.attachIfNeeded\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.isReadyElsePreparing, win is " +\n                (win?"an argument: ":"null, context.window: ") +\n                (win?win.location:context.window.location), (win?win:context.window));\n\n        if (win)\n            return this.injector.attachIfNeeded(context, win);\n        else\n        {\n            var attached = true;\n            for (var i = 0; i < context.windows.length; i++)\n                attached = attached && this.injector.attachIfNeeded(context, context.windows[i]);\n            // already in the list above attached = attached && this.injector.attachIfNeeded(context, context.window);\n            if (context.windows.indexOf(context.window) == -1)\n                FBTrace.sysout("isReadyElsePreparing ***************** context.window not in context.windows");\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("console.isReadyElsePreparing attached to "+context.windows.length+" and returns "+attached);\n            return attached;\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends ActivableModule\n\n    initialize: function()\n    {\n        this.panelName = "console";\n\n        //TODO: xxxpedro\n        //Firebug.ActivableModule.initialize.apply(this, arguments);\n        //Firebug.Debugger.addListener(this);\n    },\n\n    enable: function()\n    {\n        if (Firebug.Console.isAlwaysEnabled())\n            this.watchForErrors();\n    },\n\n    disable: function()\n    {\n        if (Firebug.Console.isAlwaysEnabled())\n            this.unwatchForErrors();\n    },\n\n    initContext: function(context, persistedState)\n    {\n        Firebug.ActivableModule.initContext.apply(this, arguments);\n        context.consoleReloadWarning = true;  // mark as need to warn.\n    },\n\n    loadedContext: function(context)\n    {\n        for (var url in context.sourceFileMap)\n            return;  // if there are any sourceFiles, then do nothing\n\n        // else we saw no JS, so the reload warning it not needed.\n        this.clearReloadWarning(context);\n    },\n\n    clearReloadWarning: function(context) // remove the warning about reloading.\n    {\n         if (context.consoleReloadWarning)\n         {\n             var panel = context.getPanel(this.panelName);\n             panel.clearReloadWarning();\n             delete context.consoleReloadWarning;\n         }\n    },\n\n    togglePersist: function(context)\n    {\n        var panel = context.getPanel(this.panelName);\n        panel.persistContent = panel.persistContent ? false : true;\n        Firebug.chrome.setGlobalAttribute("cmd_togglePersistConsole", "checked", panel.persistContent);\n    },\n\n    showContext: function(browser, context)\n    {\n        Firebug.chrome.setGlobalAttribute("cmd_clearConsole", "disabled", !context);\n\n        Firebug.ActivableModule.showContext.apply(this, arguments);\n    },\n\n    destroyContext: function(context, persistedState)\n    {\n        Firebug.Console.injector.detachConsole(context, context.window);  // TODO iterate windows?\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onPanelEnable: function(panelName)\n    {\n        if (panelName != this.panelName)  // we don\'t care about other panels\n            return;\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.onPanelEnable**************");\n\n        this.watchForErrors();\n        Firebug.Debugger.addDependentModule(this); // we inject the console during JS compiles so we need jsd\n    },\n\n    onPanelDisable: function(panelName)\n    {\n        if (panelName != this.panelName)  // we don\'t care about other panels\n            return;\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.onPanelDisable**************");\n\n        Firebug.Debugger.removeDependentModule(this); // we inject the console during JS compiles so we need jsd\n        this.unwatchForErrors();\n\n        // Make sure possible errors coming from the page and displayed in the Firefox\n        // status bar are removed.\n        this.clear();\n    },\n\n    onSuspendFirebug: function()\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.onSuspendFirebug\\n");\n        if (Firebug.Console.isAlwaysEnabled())\n            this.unwatchForErrors();\n    },\n\n    onResumeFirebug: function()\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.onResumeFirebug\\n");\n        if (Firebug.Console.isAlwaysEnabled())\n            this.watchForErrors();\n    },\n\n    watchForErrors: function()\n    {\n        Firebug.Errors.checkEnabled();\n        $(\'fbStatusIcon\').setAttribute("console", "on");\n    },\n\n    unwatchForErrors: function()\n    {\n        Firebug.Errors.checkEnabled();\n        $(\'fbStatusIcon\').removeAttribute("console");\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Firebug.Debugger listener\n\n    onMonitorScript: function(context, frame)\n    {\n        Firebug.Console.log(frame, context);\n    },\n\n    onFunctionCall: function(context, frame, depth, calling)\n    {\n        if (calling)\n            Firebug.Console.openGroup([frame, "depth:"+depth], context);\n        else\n            Firebug.Console.closeGroup(context);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    logRow: function(appender, objects, context, className, rep, sourceLink, noThrottle, noRow)\n    {\n        if (!context)\n            context = FirebugContext;\n\n        if (FBTrace.DBG_WINDOWS && !context) FBTrace.sysout("Console.logRow: no context \\n");\n\n        if (this.isAlwaysEnabled())\n            return Firebug.ConsoleBase.logRow.apply(this, arguments);\n    }\n});\n\nFirebug.ConsoleListener =\n{\n    log: function(context, object, className, sourceLink)\n    {\n    },\n\n    logFormatted: function(context, objects, className, sourceLink)\n    {\n    }\n};\n\n// ************************************************************************************************\n\nFirebug.ConsolePanel = function () {} // XXjjb attach Firebug so this panel can be extended.\n\n//TODO: xxxpedro\n//Firebug.ConsolePanel.prototype = extend(Firebug.ActivablePanel,\nFirebug.ConsolePanel.prototype = extend(Firebug.Panel,\n{\n    wasScrolledToBottom: false,\n    messageCount: 0,\n    lastLogTime: 0,\n    groups: null,\n    limit: null,\n\n    append: function(appender, objects, className, rep, sourceLink, noRow)\n    {\n        var container = this.getTopContainer();\n\n        if (noRow)\n        {\n            appender.apply(this, [objects]);\n        }\n        else\n        {\n            // xxxHonza: Don\'t update the this.wasScrolledToBottom flag now.\n            // At the beginning (when the first log is created) the isScrolledToBottom\n            // always returns true.\n            //if (this.panelNode.offsetHeight)\n            //    this.wasScrolledToBottom = isScrolledToBottom(this.panelNode);\n\n            var row = this.createRow("logRow", className);\n            appender.apply(this, [objects, row, rep]);\n\n            if (sourceLink)\n                FirebugReps.SourceLink.tag.append({object: sourceLink}, row);\n\n            container.appendChild(row);\n\n            this.filterLogRow(row, this.wasScrolledToBottom);\n\n            if (this.wasScrolledToBottom)\n                scrollToBottom(this.panelNode);\n\n            return row;\n        }\n    },\n\n    clear: function()\n    {\n        if (this.panelNode)\n        {\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("ConsolePanel.clear");\n            clearNode(this.panelNode);\n            this.insertLogLimit(this.context);\n        }\n    },\n\n    insertLogLimit: function()\n    {\n        // Create limit row. This row is the first in the list of entries\n        // and initially hidden. It\'s displayed as soon as the number of\n        // entries reaches the limit.\n        var row = this.createRow("limitRow");\n\n        var limitInfo = {\n            totalCount: 0,\n            limitPrefsTitle: $STRF("LimitPrefsTitle", [Firebug.prefDomain+".console.logLimit"])\n        };\n\n        //TODO: xxxpedro console net limit!?\n        return;\n        var netLimitRep = Firebug.NetMonitor.NetLimit;\n        var nodes = netLimitRep.createTable(row, limitInfo);\n\n        this.limit = nodes[1];\n\n        var container = this.panelNode;\n        container.insertBefore(nodes[0], container.firstChild);\n    },\n\n    insertReloadWarning: function()\n    {\n        // put the message in, we will clear if the window console is injected.\n        this.warningRow = this.append(appendObject, $STR("message.Reload to activate window console"), "info");\n    },\n\n    clearReloadWarning: function()\n    {\n        if (this.warningRow)\n        {\n            this.warningRow.parentNode.removeChild(this.warningRow);\n            delete this.warningRow;\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    appendObject: function(object, row, rep)\n    {\n        if (!rep)\n            rep = Firebug.getRep(object);\n        return rep.tag.append({object: object}, row);\n    },\n\n    appendFormatted: function(objects, row, rep)\n    {\n        if (!objects || !objects.length)\n            return;\n\n        function logText(text, row)\n        {\n            var node = row.ownerDocument.createTextNode(text);\n            row.appendChild(node);\n        }\n\n        var format = objects[0];\n        var objIndex = 0;\n\n        if (typeof(format) != "string")\n        {\n            format = "";\n            objIndex = -1;\n        }\n        else  // a string\n        {\n            if (objects.length === 1) // then we have only a string...\n            {\n                if (format.length < 1) { // ...and it has no characters.\n                    logText("(an empty string)", row);\n                    return;\n                }\n            }\n        }\n\n        var parts = parseFormat(format);\n        var trialIndex = objIndex;\n        for (var i= 0; i < parts.length; i++)\n        {\n            var part = parts[i];\n            if (part && typeof(part) == "object")\n            {\n                if (++trialIndex > objects.length)  // then too few parameters for format, assume unformatted.\n                {\n                    format = "";\n                    objIndex = -1;\n                    parts.length = 0;\n                    break;\n                }\n            }\n\n        }\n        for (var i = 0; i < parts.length; ++i)\n        {\n            var part = parts[i];\n            if (part && typeof(part) == "object")\n            {\n                var object = objects[++objIndex];\n                if (typeof(object) != "undefined")\n                    this.appendObject(object, row, part.rep);\n                else\n                    this.appendObject(part.type, row, FirebugReps.Text);\n            }\n            else\n                FirebugReps.Text.tag.append({object: part}, row);\n        }\n\n        for (var i = objIndex+1; i < objects.length; ++i)\n        {\n            logText(" ", row);\n            var object = objects[i];\n            if (typeof(object) == "string")\n                FirebugReps.Text.tag.append({object: object}, row);\n            else\n                this.appendObject(object, row);\n        }\n    },\n\n    appendOpenGroup: function(objects, row, rep)\n    {\n        if (!this.groups)\n            this.groups = [];\n\n        setClass(row, "logGroup");\n        setClass(row, "opened");\n\n        var innerRow = this.createRow("logRow");\n        setClass(innerRow, "logGroupLabel");\n        if (rep)\n            rep.tag.replace({"objects": objects}, innerRow);\n        else\n            this.appendFormatted(objects, innerRow, rep);\n        row.appendChild(innerRow);\n        //dispatch([Firebug.A11yModel], \'onLogRowCreated\', [this, innerRow]);\n        var groupBody = this.createRow("logGroupBody");\n        row.appendChild(groupBody);\n        groupBody.setAttribute(\'role\', \'group\');\n        this.groups.push(groupBody);\n\n        addEvent(innerRow, "mousedown", function(event)\n        {\n            if (isLeftClick(event))\n            {\n                //console.log(event.currentTarget == event.target);\n\n                var target = event.target || event.srcElement;\n\n                target = getAncestorByClass(target, "logGroupLabel");\n\n                var groupRow = target.parentNode;\n\n                if (hasClass(groupRow, "opened"))\n                {\n                    removeClass(groupRow, "opened");\n                    target.setAttribute(\'aria-expanded\', \'false\');\n                }\n                else\n                {\n                    setClass(groupRow, "opened");\n                    target.setAttribute(\'aria-expanded\', \'true\');\n                }\n            }\n        });\n    },\n\n    appendCloseGroup: function(object, row, rep)\n    {\n        if (this.groups)\n            this.groups.pop();\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // TODO: xxxpedro console2\n    onMouseMove: function(event)\n    {\n        if (!Firebug.Inspector) return;\n\n        var target = event.srcElement || event.target;\n\n        var object = getAncestorByClass(target, "objectLink-element");\n        object = object ? object.repObject : null;\n\n        if(object && instanceOf(object, "Element") && object.nodeType == 1)\n        {\n            if(object != lastHighlightedObject)\n            {\n                Firebug.Inspector.drawBoxModel(object);\n                object = lastHighlightedObject;\n            }\n        }\n        else\n            Firebug.Inspector.hideBoxModel();\n\n    },\n\n    onMouseDown: function(event)\n    {\n        var target = event.srcElement || event.target;\n\n        var object = getAncestorByClass(target, "objectLink");\n        var repObject = object ? object.repObject : null;\n\n        if (!repObject)\n        {\n            return;\n        }\n\n        if (hasClass(object, "objectLink-object"))\n        {\n            Firebug.chrome.selectPanel("DOM");\n            Firebug.chrome.getPanel("DOM").select(repObject, true);\n        }\n        else if (hasClass(object, "objectLink-element"))\n        {\n            Firebug.chrome.selectPanel("HTML");\n            Firebug.chrome.getPanel("HTML").select(repObject, true);\n        }\n\n        /*\n        if(object && instanceOf(object, "Element") && object.nodeType == 1)\n        {\n            if(object != lastHighlightedObject)\n            {\n                Firebug.Inspector.drawBoxModel(object);\n                object = lastHighlightedObject;\n            }\n        }\n        else\n            Firebug.Inspector.hideBoxModel();\n        /**/\n\n    },\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    name: "Console",\n    title: "Console",\n    //searchable: true,\n    //breakable: true,\n    //editable: false,\n\n    options:\n    {\n        hasCommandLine: true,\n        hasToolButtons: true,\n        isPreRendered: true\n    },\n\n    create: function()\n    {\n        Firebug.Panel.create.apply(this, arguments);\n\n        this.context = Firebug.browser.window;\n        this.document = Firebug.chrome.document;\n        this.onMouseMove = bind(this.onMouseMove, this);\n        this.onMouseDown = bind(this.onMouseDown, this);\n\n        this.clearButton = new Button({\n            element: $("fbConsole_btClear"),\n            owner: Firebug.Console,\n            onClick: Firebug.Console.clear\n        });\n    },\n\n    initialize: function()\n    {\n        Firebug.Panel.initialize.apply(this, arguments);  // loads persisted content\n        //Firebug.ActivablePanel.initialize.apply(this, arguments);  // loads persisted content\n\n        if (!this.persistedContent && Firebug.Console.isAlwaysEnabled())\n        {\n            this.insertLogLimit(this.context);\n\n            // Initialize log limit and listen for changes.\n            this.updateMaxLimit();\n\n            if (this.context.consoleReloadWarning)  // we have not yet injected the console\n                this.insertReloadWarning();\n        }\n\n        //Firebug.Console.injector.install(Firebug.browser.window);\n\n        addEvent(this.panelNode, "mouseover", this.onMouseMove);\n        addEvent(this.panelNode, "mousedown", this.onMouseDown);\n\n        this.clearButton.initialize();\n\n        //consolex.trace();\n        //TODO: xxxpedro remove this\n        /*\n        Firebug.Console.openGroup(["asd"], null, "group", null, false);\n        Firebug.Console.log("asd");\n        Firebug.Console.log("asd");\n        Firebug.Console.log("asd");\n        /**/\n\n        //TODO: xxxpedro preferences prefs\n        //prefs.addObserver(Firebug.prefDomain, this, false);\n    },\n\n    initializeNode : function()\n    {\n        //dispatch([Firebug.A11yModel], \'onInitializeNode\', [this]);\n        if (FBTrace.DBG_CONSOLE)\n        {\n            this.onScroller = bind(this.onScroll, this);\n            addEvent(this.panelNode, "scroll", this.onScroller);\n        }\n\n        this.onResizer = bind(this.onResize, this);\n        this.resizeEventTarget = Firebug.chrome.$(\'fbContentBox\');\n        addEvent(this.resizeEventTarget, "resize", this.onResizer);\n    },\n\n    destroyNode : function()\n    {\n        //dispatch([Firebug.A11yModel], \'onDestroyNode\', [this]);\n        if (this.onScroller)\n            removeEvent(this.panelNode, "scroll", this.onScroller);\n\n        //removeEvent(this.resizeEventTarget, "resize", this.onResizer);\n    },\n\n    shutdown: function()\n    {\n        //TODO: xxxpedro console console2\n        this.clearButton.shutdown();\n\n        removeEvent(this.panelNode, "mousemove", this.onMouseMove);\n        removeEvent(this.panelNode, "mousedown", this.onMouseDown);\n\n        this.destroyNode();\n\n        Firebug.Panel.shutdown.apply(this, arguments);\n\n        //TODO: xxxpedro preferences prefs\n        //prefs.removeObserver(Firebug.prefDomain, this, false);\n    },\n\n    ishow: function(state)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("Console.panel show; " + this.context.getName(), state);\n\n        var enabled = Firebug.Console.isAlwaysEnabled();\n        if (enabled)\n        {\n             Firebug.Console.disabledPanelPage.hide(this);\n             this.showCommandLine(true);\n             this.showToolbarButtons("fbConsoleButtons", true);\n             Firebug.chrome.setGlobalAttribute("cmd_togglePersistConsole", "checked", this.persistContent);\n\n             if (state && state.wasScrolledToBottom)\n             {\n                 this.wasScrolledToBottom = state.wasScrolledToBottom;\n                 delete state.wasScrolledToBottom;\n             }\n\n             if (this.wasScrolledToBottom)\n                 scrollToBottom(this.panelNode);\n\n             if (FBTrace.DBG_CONSOLE)\n                 FBTrace.sysout("console.show ------------------ wasScrolledToBottom: " +\n                    this.wasScrolledToBottom + ", " + this.context.getName());\n        }\n        else\n        {\n            this.hide(state);\n            Firebug.Console.disabledPanelPage.show(this);\n        }\n    },\n\n    ihide: function(state)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("Console.panel hide; " + this.context.getName(), state);\n\n        this.showToolbarButtons("fbConsoleButtons", false);\n        this.showCommandLine(false);\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.hide ------------------ wasScrolledToBottom: " +\n                this.wasScrolledToBottom + ", " + this.context.getName());\n    },\n\n    destroy: function(state)\n    {\n        if (this.panelNode.offsetHeight)\n            this.wasScrolledToBottom = isScrolledToBottom(this.panelNode);\n\n        if (state)\n            state.wasScrolledToBottom = this.wasScrolledToBottom;\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.destroy ------------------ wasScrolledToBottom: " +\n                this.wasScrolledToBottom + ", " + this.context.getName());\n    },\n\n    shouldBreakOnNext: function()\n    {\n        // xxxHonza: shouldn\'t the breakOnErrors be context related?\n        // xxxJJB, yes, but we can\'t support it because we can\'t yet tell\n        // which window the error is on.\n        return Firebug.getPref(Firebug.servicePrefDomain, "breakOnErrors");\n    },\n\n    getBreakOnNextTooltip: function(enabled)\n    {\n        return (enabled ? $STR("console.Disable Break On All Errors") :\n            $STR("console.Break On All Errors"));\n    },\n\n    enablePanel: function(module)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.ConsolePanel.enablePanel; " + this.context.getName());\n\n        Firebug.ActivablePanel.enablePanel.apply(this, arguments);\n\n        this.showCommandLine(true);\n\n        if (this.wasScrolledToBottom)\n            scrollToBottom(this.panelNode);\n    },\n\n    disablePanel: function(module)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.ConsolePanel.disablePanel; " + this.context.getName());\n\n        Firebug.ActivablePanel.disablePanel.apply(this, arguments);\n\n        this.showCommandLine(false);\n    },\n\n    getOptionsMenuItems: function()\n    {\n        return [\n            optionMenu("ShowJavaScriptErrors", "showJSErrors"),\n            optionMenu("ShowJavaScriptWarnings", "showJSWarnings"),\n            optionMenu("ShowCSSErrors", "showCSSErrors"),\n            optionMenu("ShowXMLErrors", "showXMLErrors"),\n            optionMenu("ShowXMLHttpRequests", "showXMLHttpRequests"),\n            optionMenu("ShowChromeErrors", "showChromeErrors"),\n            optionMenu("ShowChromeMessages", "showChromeMessages"),\n            optionMenu("ShowExternalErrors", "showExternalErrors"),\n            optionMenu("ShowNetworkErrors", "showNetworkErrors"),\n            this.getShowStackTraceMenuItem(),\n            this.getStrictOptionMenuItem(),\n            "-",\n            optionMenu("LargeCommandLine", "largeCommandLine")\n        ];\n    },\n\n    getShowStackTraceMenuItem: function()\n    {\n        var menuItem = serviceOptionMenu("ShowStackTrace", "showStackTrace");\n        if (FirebugContext && !Firebug.Debugger.isAlwaysEnabled())\n            menuItem.disabled = true;\n        return menuItem;\n    },\n\n    getStrictOptionMenuItem: function()\n    {\n        var strictDomain = "javascript.options";\n        var strictName = "strict";\n        var strictValue = prefs.getBoolPref(strictDomain+"."+strictName);\n        return {label: "JavascriptOptionsStrict", type: "checkbox", checked: strictValue,\n            command: bindFixed(Firebug.setPref, Firebug, strictDomain, strictName, !strictValue) };\n    },\n\n    getBreakOnMenuItems: function()\n    {\n        //xxxHonza: no BON options for now.\n        /*return [\n            optionMenu("console.option.Persist Break On Error", "persistBreakOnError")\n        ];*/\n       return [];\n    },\n\n    search: function(text)\n    {\n        if (!text)\n            return;\n\n        // Make previously visible nodes invisible again\n        if (this.matchSet)\n        {\n            for (var i in this.matchSet)\n                removeClass(this.matchSet[i], "matched");\n        }\n\n        this.matchSet = [];\n\n        function findRow(node) { return getAncestorByClass(node, "logRow"); }\n        var search = new TextSearch(this.panelNode, findRow);\n\n        var logRow = search.find(text);\n        if (!logRow)\n        {\n            dispatch([Firebug.A11yModel], \'onConsoleSearchMatchFound\', [this, text, []]);\n            return false;\n        }\n        for (; logRow; logRow = search.findNext())\n        {\n            setClass(logRow, "matched");\n            this.matchSet.push(logRow);\n        }\n        dispatch([Firebug.A11yModel], \'onConsoleSearchMatchFound\', [this, text, this.matchSet]);\n        return true;\n    },\n\n    breakOnNext: function(breaking)\n    {\n        Firebug.setPref(Firebug.servicePrefDomain, "breakOnErrors", breaking);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // private\n\n    createRow: function(rowName, className)\n    {\n        var elt = this.document.createElement("div");\n        elt.className = rowName + (className ? " " + rowName + "-" + className : "");\n        return elt;\n    },\n\n    getTopContainer: function()\n    {\n        if (this.groups && this.groups.length)\n            return this.groups[this.groups.length-1];\n        else\n            return this.panelNode;\n    },\n\n    filterLogRow: function(logRow, scrolledToBottom)\n    {\n        if (this.searchText)\n        {\n            setClass(logRow, "matching");\n            setClass(logRow, "matched");\n\n            // Search after a delay because we must wait for a frame to be created for\n            // the new logRow so that the finder will be able to locate it\n            setTimeout(bindFixed(function()\n            {\n                if (this.searchFilter(this.searchText, logRow))\n                    this.matchSet.push(logRow);\n                else\n                    removeClass(logRow, "matched");\n\n                removeClass(logRow, "matching");\n\n                if (scrolledToBottom)\n                    scrollToBottom(this.panelNode);\n            }, this), 100);\n        }\n    },\n\n    searchFilter: function(text, logRow)\n    {\n        var count = this.panelNode.childNodes.length;\n        var searchRange = this.document.createRange();\n        searchRange.setStart(this.panelNode, 0);\n        searchRange.setEnd(this.panelNode, count);\n\n        var startPt = this.document.createRange();\n        startPt.setStartBefore(logRow);\n\n        var endPt = this.document.createRange();\n        endPt.setStartAfter(logRow);\n\n        return finder.Find(text, searchRange, startPt, endPt) != null;\n    },\n\n    // nsIPrefObserver\n    observe: function(subject, topic, data)\n    {\n        // We\'re observing preferences only.\n        if (topic != "nsPref:changed")\n          return;\n\n        // xxxHonza check this out.\n        var prefDomain = "Firebug.extension.";\n        var prefName = data.substr(prefDomain.length);\n        if (prefName == "console.logLimit")\n            this.updateMaxLimit();\n    },\n\n    updateMaxLimit: function()\n    {\n        var value = 1000;\n        //TODO: xxxpedro preferences log limit?\n        //var value = Firebug.getPref(Firebug.prefDomain, "console.logLimit");\n        maxQueueRequests =  value ? value : maxQueueRequests;\n    },\n\n    showCommandLine: function(shouldShow)\n    {\n        //TODO: xxxpedro show command line important\n        return;\n\n        if (shouldShow)\n        {\n            collapse(Firebug.chrome.$("fbCommandBox"), false);\n            Firebug.CommandLine.setMultiLine(Firebug.largeCommandLine, Firebug.chrome);\n        }\n        else\n        {\n            // Make sure that entire content of the Console panel is hidden when\n            // the panel is disabled.\n            Firebug.CommandLine.setMultiLine(false, Firebug.chrome, Firebug.largeCommandLine);\n            collapse(Firebug.chrome.$("fbCommandBox"), true);\n        }\n    },\n\n    onScroll: function(event)\n    {\n        // Update the scroll position flag if the position changes.\n        this.wasScrolledToBottom = FBL.isScrolledToBottom(this.panelNode);\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.onScroll ------------------ wasScrolledToBottom: " +\n                this.wasScrolledToBottom + ", wasScrolledToBottom: " +\n                this.context.getName(), event);\n    },\n\n    onResize: function(event)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("console.onResize ------------------ wasScrolledToBottom: " +\n                this.wasScrolledToBottom + ", offsetHeight: " + this.panelNode.offsetHeight +\n                ", scrollTop: " + this.panelNode.scrollTop + ", scrollHeight: " +\n                this.panelNode.scrollHeight + ", " + this.context.getName(), event);\n\n        if (this.wasScrolledToBottom)\n            scrollToBottom(this.panelNode);\n    }\n});\n\n// ************************************************************************************************\n\nfunction parseFormat(format)\n{\n    var parts = [];\n    if (format.length <= 0)\n        return parts;\n\n    var reg = /((^%|.%)(\\d+)?(\\.)([a-zA-Z]))|((^%|.%)([a-zA-Z]))/;\n    for (var m = reg.exec(format); m; m = reg.exec(format))\n    {\n        if (m[0].substr(0, 2) == "%%")\n        {\n            parts.push(format.substr(0, m.index));\n            parts.push(m[0].substr(1));\n        }\n        else\n        {\n            var type = m[8] ? m[8] : m[5];\n            var precision = m[3] ? parseInt(m[3]) : (m[4] == "." ? -1 : 0);\n\n            var rep = null;\n            switch (type)\n            {\n                case "s":\n                    rep = FirebugReps.Text;\n                    break;\n                case "f":\n                case "i":\n                case "d":\n                    rep = FirebugReps.Number;\n                    break;\n                case "o":\n                    rep = null;\n                    break;\n            }\n\n            parts.push(format.substr(0, m[0][0] == "%" ? m.index : m.index+1));\n            parts.push({rep: rep, precision: precision, type: ("%" + type)});\n        }\n\n        format = format.substr(m.index+m[0].length);\n    }\n\n    parts.push(format);\n    return parts;\n}\n\n// ************************************************************************************************\n\nvar appendObject = Firebug.ConsolePanel.prototype.appendObject;\nvar appendFormatted = Firebug.ConsolePanel.prototype.appendFormatted;\nvar appendOpenGroup = Firebug.ConsolePanel.prototype.appendOpenGroup;\nvar appendCloseGroup = Firebug.ConsolePanel.prototype.appendCloseGroup;\n\n// ************************************************************************************************\n\n//Firebug.registerActivableModule(Firebug.Console);\nFirebug.registerModule(Firebug.Console);\nFirebug.registerPanel(Firebug.ConsolePanel);\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// Constants\n\n//const Cc = Components.classes;\n//const Ci = Components.interfaces;\n\nvar frameCounters = {};\nvar traceRecursion = 0;\n\nFirebug.Console.injector =\n{\n    install: function(context)\n    {\n        var win = context.window;\n\n        var consoleHandler = new FirebugConsoleHandler(context, win);\n\n        var properties =\n        [\n            "log",\n            "debug",\n            "info",\n            "warn",\n            "error",\n            "assert",\n            "dir",\n            "dirxml",\n            "group",\n            "groupCollapsed",\n            "groupEnd",\n            "time",\n            "timeEnd",\n            "count",\n            "trace",\n            "profile",\n            "profileEnd",\n            "clear",\n            "open",\n            "close"\n        ];\n\n        var Handler = function(name)\n        {\n            var c = consoleHandler;\n            var f = consoleHandler[name];\n            return function(){return f.apply(c,arguments);};\n        };\n\n        var installer = function(c)\n        {\n            for (var i=0, l=properties.length; i<l; i++)\n            {\n                var name = properties[i];\n                c[name] = new Handler(name);\n                c.firebuglite = Firebug.version;\n            }\n        };\n\n        var sandbox;\n\n        if (win.console)\n        {\n            if (Env.Options.overrideConsole)\n                sandbox = new win.Function("arguments.callee.install(window.console={})");\n            else\n                // if there\'s a console object and overrideConsole is false we should just quit\n                return;\n        }\n        else\n        {\n            try\n            {\n                // try overriding the console object\n                sandbox = new win.Function("arguments.callee.install(window.console={})");\n            }\n            catch(E)\n            {\n                // if something goes wrong create the firebug object instead\n                sandbox = new win.Function("arguments.callee.install(window.firebug={})");\n            }\n        }\n\n        sandbox.install = installer;\n        sandbox();\n    },\n\n    isAttached: function(context, win)\n    {\n        if (win.wrappedJSObject)\n        {\n            var attached = (win.wrappedJSObject._getFirebugConsoleElement ? true : false);\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("Console.isAttached:"+attached+" to win.wrappedJSObject "+safeGetWindowLocation(win.wrappedJSObject));\n\n            return attached;\n        }\n        else\n        {\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("Console.isAttached? to win "+win.location+" fnc:"+win._getFirebugConsoleElement);\n            return (win._getFirebugConsoleElement ? true : false);\n        }\n    },\n\n    attachIfNeeded: function(context, win)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("Console.attachIfNeeded has win "+(win? ((win.wrappedJSObject?"YES":"NO")+" wrappedJSObject"):"null") );\n\n        if (this.isAttached(context, win))\n            return true;\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("Console.attachIfNeeded found isAttached false ");\n\n        this.attachConsoleInjector(context, win);\n        this.addConsoleListener(context, win);\n\n        Firebug.Console.clearReloadWarning(context);\n\n        var attached =  this.isAttached(context, win);\n        if (attached)\n            dispatch(Firebug.Console.fbListeners, "onConsoleInjected", [context, win]);\n\n        return attached;\n    },\n\n    attachConsoleInjector: function(context, win)\n    {\n        var consoleInjection = this.getConsoleInjectionScript();  // Do it all here.\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("attachConsoleInjector evaluating in "+win.location, consoleInjection);\n\n        Firebug.CommandLine.evaluateInWebPage(consoleInjection, context, win);\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("attachConsoleInjector evaluation completed for "+win.location);\n    },\n\n    getConsoleInjectionScript: function() {\n        if (!this.consoleInjectionScript)\n        {\n            var script = "";\n            script += "window.__defineGetter__(\'console\', function() {\\n";\n            script += " return (window._firebug ? window._firebug : window.loadFirebugConsole()); })\\n\\n";\n\n            script += "window.loadFirebugConsole = function() {\\n";\n            script += "window._firebug =  new _FirebugConsole();";\n\n            if (FBTrace.DBG_CONSOLE)\n                script += " window.dump(\'loadFirebugConsole \'+window.location+\'\\\\n\');\\n";\n\n            script += " return window._firebug };\\n";\n\n            var theFirebugConsoleScript = getResource("chrome://firebug/content/consoleInjected.js");\n            script += theFirebugConsoleScript;\n\n\n            this.consoleInjectionScript = script;\n        }\n        return this.consoleInjectionScript;\n    },\n\n    forceConsoleCompilationInPage: function(context, win)\n    {\n        if (!win)\n        {\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("no win in forceConsoleCompilationInPage!");\n            return;\n        }\n\n        var consoleForcer = "window.loadFirebugConsole();";\n\n        if (context.stopped)\n            Firebug.Console.injector.evaluateConsoleScript(context);  // todo evaluate consoleForcer on stack\n        else\n            Firebug.CommandLine.evaluateInWebPage(consoleForcer, context, win);\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("forceConsoleCompilationInPage "+win.location, consoleForcer);\n    },\n\n    evaluateConsoleScript: function(context)\n    {\n        var scriptSource = this.getConsoleInjectionScript(); // TODO XXXjjb this should be getConsoleInjectionScript\n        Firebug.Debugger.evaluate(scriptSource, context);\n    },\n\n    addConsoleListener: function(context, win)\n    {\n        if (!context.activeConsoleHandlers)  // then we have not been this way before\n            context.activeConsoleHandlers = [];\n        else\n        {   // we\'ve been this way before...\n            for (var i=0; i<context.activeConsoleHandlers.length; i++)\n            {\n                if (context.activeConsoleHandlers[i].window == win)\n                {\n                    context.activeConsoleHandlers[i].detach();\n                    if (FBTrace.DBG_CONSOLE)\n                        FBTrace.sysout("consoleInjector addConsoleListener removed handler("+context.activeConsoleHandlers[i].handler_name+") from _firebugConsole in : "+win.location+"\\n");\n                    context.activeConsoleHandlers.splice(i,1);\n                }\n            }\n        }\n\n        // We need the element to attach our event listener.\n        var element = Firebug.Console.getFirebugConsoleElement(context, win);\n        if (element)\n            element.setAttribute("FirebugVersion", Firebug.version); // Initialize Firebug version.\n        else\n            return false;\n\n        var handler = new FirebugConsoleHandler(context, win);\n        handler.attachTo(element);\n\n        context.activeConsoleHandlers.push(handler);\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("consoleInjector addConsoleListener attached handler("+handler.handler_name+") to _firebugConsole in : "+win.location+"\\n");\n        return true;\n    },\n\n    detachConsole: function(context, win)\n    {\n        if (win && win.document)\n        {\n            var element = win.document.getElementById("_firebugConsole");\n            if (element)\n                element.parentNode.removeChild(element);\n        }\n    }\n};\n\nvar total_handlers = 0;\nvar FirebugConsoleHandler = function FirebugConsoleHandler(context, win)\n{\n    this.window = win;\n\n    this.attachTo = function(element)\n    {\n        this.element = element;\n        // When raised on our injected element, callback to Firebug and append to console\n        this.boundHandler = bind(this.handleEvent, this);\n        this.element.addEventListener(\'firebugAppendConsole\', this.boundHandler, true); // capturing\n    };\n\n    this.detach = function()\n    {\n        this.element.removeEventListener(\'firebugAppendConsole\', this.boundHandler, true);\n    };\n\n    this.handler_name = ++total_handlers;\n    this.handleEvent = function(event)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("FirebugConsoleHandler("+this.handler_name+") "+event.target.getAttribute("methodName")+", event", event);\n        if (!Firebug.CommandLine.CommandHandler.handle(event, this, win))\n        {\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("FirebugConsoleHandler", this);\n\n            var methodName = event.target.getAttribute("methodName");\n            Firebug.Console.log($STRF("console.MethodNotSupported", [methodName]));\n        }\n    };\n\n    this.firebuglite = Firebug.version;\n\n    this.init = function()\n    {\n        var consoleElement = win.document.getElementById(\'_firebugConsole\');\n        consoleElement.setAttribute("FirebugVersion", Firebug.version);\n    };\n\n    this.log = function()\n    {\n        logFormatted(arguments, "log");\n    };\n\n    this.debug = function()\n    {\n        logFormatted(arguments, "debug", true);\n    };\n\n    this.info = function()\n    {\n        logFormatted(arguments, "info", true);\n    };\n\n    this.warn = function()\n    {\n        logFormatted(arguments, "warn", true);\n    };\n\n    this.error = function()\n    {\n        //TODO: xxxpedro console error\n        //if (arguments.length == 1)\n        //{\n        //    logAssert("error", arguments);  // add more info based on stack trace\n        //}\n        //else\n        //{\n            //Firebug.Errors.increaseCount(context);\n            logFormatted(arguments, "error", true);  // user already added info\n        //}\n    };\n\n    this.exception = function()\n    {\n        logAssert("error", arguments);\n    };\n\n    this.assert = function(x)\n    {\n        if (!x)\n        {\n            var rest = [];\n            for (var i = 1; i < arguments.length; i++)\n                rest.push(arguments[i]);\n            logAssert("assert", rest);\n        }\n    };\n\n    this.dir = function(o)\n    {\n        Firebug.Console.log(o, context, "dir", Firebug.DOMPanel.DirTable);\n    };\n\n    this.dirxml = function(o)\n    {\n        ///if (o instanceof Window)\n        if (instanceOf(o, "Window"))\n            o = o.document.documentElement;\n        ///else if (o instanceof Document)\n        else if (instanceOf(o, "Document"))\n            o = o.documentElement;\n\n        Firebug.Console.log(o, context, "dirxml", Firebug.HTMLPanel.SoloElement);\n    };\n\n    this.group = function()\n    {\n        //TODO: xxxpedro;\n        //var sourceLink = getStackLink();\n        var sourceLink = null;\n        Firebug.Console.openGroup(arguments, null, "group", null, false, sourceLink);\n    };\n\n    this.groupEnd = function()\n    {\n        Firebug.Console.closeGroup(context);\n    };\n\n    this.groupCollapsed = function()\n    {\n        var sourceLink = getStackLink();\n        // noThrottle true is probably ok, openGroups will likely be short strings.\n        var row = Firebug.Console.openGroup(arguments, null, "group", null, true, sourceLink);\n        removeClass(row, "opened");\n    };\n\n    this.profile = function(title)\n    {\n        logFormatted(["console.profile() not supported."], "warn", true);\n\n        //Firebug.Profiler.startProfiling(context, title);\n    };\n\n    this.profileEnd = function()\n    {\n        logFormatted(["console.profile() not supported."], "warn", true);\n\n        //Firebug.Profiler.stopProfiling(context);\n    };\n\n    this.count = function(key)\n    {\n        // TODO: xxxpedro console2: is there a better way to find a unique ID for the coun() call?\n        var frameId = "0";\n        //var frameId = FBL.getStackFrameId();\n        if (frameId)\n        {\n            if (!frameCounters)\n                frameCounters = {};\n\n            if (key != undefined)\n                frameId += key;\n\n            var frameCounter = frameCounters[frameId];\n            if (!frameCounter)\n            {\n                var logRow = logFormatted(["0"], null, true, true);\n\n                frameCounter = {logRow: logRow, count: 1};\n                frameCounters[frameId] = frameCounter;\n            }\n            else\n                ++frameCounter.count;\n\n            var label = key == undefined\n                ? frameCounter.count\n                : key + " " + frameCounter.count;\n\n            frameCounter.logRow.firstChild.firstChild.nodeValue = label;\n        }\n    };\n\n    this.trace = function()\n    {\n        var getFuncName = function getFuncName (f)\n        {\n            if (f.getName instanceof Function)\n            {\n                return f.getName();\n            }\n            if (f.name) // in FireFox, Function objects have a name property...\n            {\n                return f.name;\n            }\n\n            var name = f.toString().match(/function\\s*([_$\\w\\d]*)/)[1];\n            return name || "anonymous";\n        };\n\n        var wasVisited = function(fn)\n        {\n            for (var i=0, l=frames.length; i<l; i++)\n            {\n                if (frames[i].fn == fn)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n\n        traceRecursion++;\n\n        if (traceRecursion > 1)\n        {\n            traceRecursion--;\n            return;\n        }\n\n        var frames = [];\n\n        for (var fn = arguments.callee.caller.caller; fn; fn = fn.caller)\n        {\n            if (wasVisited(fn)) break;\n\n            var args = [];\n\n            for (var i = 0, l = fn.arguments.length; i < l; ++i)\n            {\n                args.push({value: fn.arguments[i]});\n            }\n\n            frames.push({fn: fn, name: getFuncName(fn), args: args});\n        }\n\n\n        // ****************************************************************************************\n\n        try\n        {\n            (0)();\n        }\n        catch(e)\n        {\n            var result = e;\n\n            var stack =\n                result.stack || // Firefox / Google Chrome\n                result.stacktrace || // Opera\n                "";\n\n            stack = stack.replace(/\\n\\r|\\r\\n/g, "\\n"); // normalize line breaks\n            var items = stack.split(/[\\n\\r]/);\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            // Google Chrome\n            if (FBL.isSafari)\n            {\n                //var reChromeStackItem = /^\\s+at\\s+([^\\(]+)\\s\\((.*)\\)$/;\n                //var reChromeStackItem = /^\\s+at\\s+(.*)((?:http|https|ftp|file):\\/\\/.*)$/;\n                var reChromeStackItem = /^\\s+at\\s+(.*)((?:http|https|ftp|file):\\/\\/.*)$/;\n\n                var reChromeStackItemName = /\\s*\\($/;\n                var reChromeStackItemValue = /^(.+)\\:(\\d+\\:\\d+)\\)?$/;\n\n                var framePos = 0;\n                for (var i=4, length=items.length; i<length; i++, framePos++)\n                {\n                    var frame = frames[framePos];\n                    var item = items[i];\n                    var match = item.match(reChromeStackItem);\n\n                    //Firebug.Console.log("["+ framePos +"]--------------------------");\n                    //Firebug.Console.log(item);\n                    //Firebug.Console.log("................");\n\n                    if (match)\n                    {\n                        var name = match[1];\n                        if (name)\n                        {\n                            name = name.replace(reChromeStackItemName, "");\n                            frame.name = name;\n                        }\n\n                        //Firebug.Console.log("name: "+name);\n\n                        var value = match[2].match(reChromeStackItemValue);\n                        if (value)\n                        {\n                            frame.href = value[1];\n                            frame.lineNo = value[2];\n\n                            //Firebug.Console.log("url: "+value[1]);\n                            //Firebug.Console.log("line: "+value[2]);\n                        }\n                        //else\n                        //    Firebug.Console.log(match[2]);\n\n                    }\n                }\n            }\n            /**/\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            else if (FBL.isFirefox)\n            {\n                // Firefox\n                var reFirefoxStackItem = /^(.*)@(.*)$/;\n                var reFirefoxStackItemValue = /^(.+)\\:(\\d+)$/;\n\n                var framePos = 0;\n                for (var i=2, length=items.length; i<length; i++, framePos++)\n                {\n                    var frame = frames[framePos] || {};\n                    var item = items[i];\n                    var match = item.match(reFirefoxStackItem);\n\n                    if (match)\n                    {\n                        var name = match[1];\n\n                        //Firebug.Console.logFormatted("name: "+name);\n\n                        var value = match[2].match(reFirefoxStackItemValue);\n                        if (value)\n                        {\n                            frame.href = value[1];\n                            frame.lineNo = value[2];\n\n                            //Firebug.Console.log("href: "+ value[1]);\n                            //Firebug.Console.log("line: " + value[2]);\n                        }\n                        //else\n                        //    Firebug.Console.logFormatted([match[2]]);\n                    }\n                }\n            }\n            /**/\n\n            // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n            /*\n            else if (FBL.isOpera)\n            {\n                // Opera\n                var reOperaStackItem = /^\\s\\s(?:\\.\\.\\.\\s\\s)?Line\\s(\\d+)\\sof\\s(.+)$/;\n                var reOperaStackItemValue = /^linked\\sscript\\s(.+)$/;\n\n                for (var i=0, length=items.length; i<length; i+=2)\n                {\n                    var item = items[i];\n\n                    var match = item.match(reOperaStackItem);\n\n                    if (match)\n                    {\n                        //Firebug.Console.log(match[1]);\n\n                        var value = match[2].match(reOperaStackItemValue);\n\n                        if (value)\n                        {\n                            //Firebug.Console.log(value[1]);\n                        }\n                        //else\n                        //    Firebug.Console.log(match[2]);\n\n                        //Firebug.Console.log("--------------------------");\n                    }\n                }\n            }\n            /**/\n        }\n\n        //console.log(stack);\n        //console.dir(frames);\n        Firebug.Console.log({frames: frames}, context, "stackTrace", FirebugReps.StackTrace);\n\n        traceRecursion--;\n    };\n\n    this.trace_ok = function()\n    {\n        var getFuncName = function getFuncName (f)\n        {\n            if (f.getName instanceof Function)\n                return f.getName();\n            if (f.name) // in FireFox, Function objects have a name property...\n                return f.name;\n\n            var name = f.toString().match(/function\\s*([_$\\w\\d]*)/)[1];\n            return name || "anonymous";\n        };\n\n        var wasVisited = function(fn)\n        {\n            for (var i=0, l=frames.length; i<l; i++)\n            {\n                if (frames[i].fn == fn)\n                    return true;\n            }\n\n            return false;\n        };\n\n        var frames = [];\n\n        for (var fn = arguments.callee.caller; fn; fn = fn.caller)\n        {\n            if (wasVisited(fn)) break;\n\n            var args = [];\n\n            for (var i = 0, l = fn.arguments.length; i < l; ++i)\n            {\n                args.push({value: fn.arguments[i]});\n            }\n\n            frames.push({fn: fn, name: getFuncName(fn), args: args});\n        }\n\n        Firebug.Console.log({frames: frames}, context, "stackTrace", FirebugReps.StackTrace);\n    };\n\n    this.clear = function()\n    {\n        Firebug.Console.clear(context);\n    };\n\n    this.time = function(name, reset)\n    {\n        if (!name)\n            return;\n\n        var time = new Date().getTime();\n\n        if (!this.timeCounters)\n            this.timeCounters = {};\n\n        var key = "KEY"+name.toString();\n\n        if (!reset && this.timeCounters[key])\n            return;\n\n        this.timeCounters[key] = time;\n    };\n\n    this.timeEnd = function(name)\n    {\n        var time = new Date().getTime();\n\n        if (!this.timeCounters)\n            return;\n\n        var key = "KEY"+name.toString();\n\n        var timeCounter = this.timeCounters[key];\n        if (timeCounter)\n        {\n            var diff = time - timeCounter;\n            var label = name + ": " + diff + "ms";\n\n            this.info(label);\n\n            delete this.timeCounters[key];\n        }\n        return diff;\n    };\n\n    // These functions are over-ridden by commandLine\n    this.evaluated = function(result, context)\n    {\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("consoleInjector.FirebugConsoleHandler evalutated default called", result);\n\n        Firebug.Console.log(result, context);\n    };\n    this.evaluateError = function(result, context)\n    {\n        Firebug.Console.log(result, context, "errorMessage");\n    };\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    function logFormatted(args, className, linkToSource, noThrottle)\n    {\n        var sourceLink = linkToSource ? getStackLink() : null;\n        return Firebug.Console.logFormatted(args, context, className, noThrottle, sourceLink);\n    }\n\n    function logAssert(category, args)\n    {\n        Firebug.Errors.increaseCount(context);\n\n        if (!args || !args.length || args.length == 0)\n            var msg = [FBL.$STR("Assertion")];\n        else\n            var msg = args[0];\n\n        if (Firebug.errorStackTrace)\n        {\n            var trace = Firebug.errorStackTrace;\n            delete Firebug.errorStackTrace;\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("logAssert trace from errorStackTrace", trace);\n        }\n        else if (msg.stack)\n        {\n            var trace = parseToStackTrace(msg.stack);\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("logAssert trace from msg.stack", trace);\n        }\n        else\n        {\n            var trace = getJSDUserStack();\n            if (FBTrace.DBG_CONSOLE)\n                FBTrace.sysout("logAssert trace from getJSDUserStack", trace);\n        }\n\n        var errorObject = new FBL.ErrorMessage(msg, (msg.fileName?msg.fileName:win.location), (msg.lineNumber?msg.lineNumber:0), "", category, context, trace);\n\n\n        if (trace && trace.frames && trace.frames[0])\n           errorObject.correctWithStackTrace(trace);\n\n        errorObject.resetSource();\n\n        var objects = errorObject;\n        if (args.length > 1)\n        {\n            objects = [errorObject];\n            for (var i = 1; i < args.length; i++)\n                objects.push(args[i]);\n        }\n\n        var row = Firebug.Console.log(objects, context, "errorMessage", null, true); // noThrottle\n        row.scrollIntoView();\n    }\n\n    function getComponentsStackDump()\n    {\n        // Starting with our stack, walk back to the user-level code\n        var frame = Components.stack;\n        var userURL = win.location.href.toString();\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("consoleInjector.getComponentsStackDump initial stack for userURL "+userURL, frame);\n\n        // Drop frames until we get into user code.\n        while (frame && FBL.isSystemURL(frame.filename) )\n            frame = frame.caller;\n\n        // Drop two more frames, the injected console function and firebugAppendConsole()\n        if (frame)\n            frame = frame.caller;\n        if (frame)\n            frame = frame.caller;\n\n        if (FBTrace.DBG_CONSOLE)\n            FBTrace.sysout("consoleInjector.getComponentsStackDump final stack for userURL "+userURL, frame);\n\n        return frame;\n    }\n\n    function getStackLink()\n    {\n        // TODO: xxxpedro console2\n        return;\n        //return FBL.getFrameSourceLink(getComponentsStackDump());\n    }\n\n    function getJSDUserStack()\n    {\n        var trace = FBL.getCurrentStackTrace(context);\n\n        var frames = trace ? trace.frames : null;\n        if (frames && (frames.length > 0) )\n        {\n            var oldest = frames.length - 1;  // 6 - 1 = 5\n            for (var i = 0; i < frames.length; i++)\n            {\n                if (frames[oldest - i].href.indexOf("chrome:") == 0) break;\n                var fn = frames[oldest - i].fn + "";\n                if (fn && (fn.indexOf("_firebugEvalEvent") != -1) ) break;  // command line\n            }\n            FBTrace.sysout("consoleInjector getJSDUserStack: "+frames.length+" oldest: "+oldest+" i: "+i+" i - oldest + 2: "+(i - oldest + 2), trace);\n            trace.frames = trace.frames.slice(2 - i);  // take the oldest frames, leave 2 behind they are injection code\n\n            return trace;\n        }\n        else\n            return "Firebug failed to get stack trace with any frames";\n    }\n};\n\n// ************************************************************************************************\n// Register console namespace\n\nFBL.registerConsole = function()\n{\n    var win = Env.browser.window;\n    Firebug.Console.injector.install(win);\n};\n\nregisterConsole();\n\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n\n// ************************************************************************************************\n// Globals\n\nvar commandPrefix = ">>>";\nvar reOpenBracket = /[\\[\\(\\{]/;\nvar reCloseBracket = /[\\]\\)\\}]/;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar commandHistory = [];\nvar commandPointer = -1;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar isAutoCompleting = null;\nvar autoCompletePrefix = null;\nvar autoCompleteExpr = null;\nvar autoCompleteBuffer = null;\nvar autoCompletePosition = null;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar fbCommandLine = null;\nvar fbLargeCommandLine = null;\nvar fbLargeCommandButtons = null;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar _completion =\n{\n    window:\n    [\n        "console"\n    ],\n\n    document:\n    [\n        "getElementById",\n        "getElementsByTagName"\n    ]\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar _stack = function(command)\n{\n    Firebug.context.persistedState.commandHistory.push(command);\n    Firebug.context.persistedState.commandPointer =\n        Firebug.context.persistedState.commandHistory.length;\n};\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n// ************************************************************************************************\n// CommandLine\n\nFirebug.CommandLine = extend(Firebug.Module,\n{\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    element: null,\n    isMultiLine: false,\n    isActive: false,\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    initialize: function(doc)\n    {\n        this.clear = bind(this.clear, this);\n        this.enter = bind(this.enter, this);\n\n        this.onError = bind(this.onError, this);\n        this.onKeyDown = bind(this.onKeyDown, this);\n        this.onMultiLineKeyDown = bind(this.onMultiLineKeyDown, this);\n\n        addEvent(Firebug.browser.window, "error", this.onError);\n        addEvent(Firebug.chrome.window, "error", this.onError);\n    },\n\n    shutdown: function(doc)\n    {\n        this.deactivate();\n\n        removeEvent(Firebug.browser.window, "error", this.onError);\n        removeEvent(Firebug.chrome.window, "error", this.onError);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    activate: function(multiLine, hideToggleIcon, onRun)\n    {\n        defineCommandLineAPI();\n\n         Firebug.context.persistedState.commandHistory =\n             Firebug.context.persistedState.commandHistory || [];\n\n         Firebug.context.persistedState.commandPointer =\n             Firebug.context.persistedState.commandPointer || -1;\n\n        if (this.isActive)\n        {\n            if (this.isMultiLine == multiLine) return;\n\n            this.deactivate();\n        }\n\n        fbCommandLine = $("fbCommandLine");\n        fbLargeCommandLine = $("fbLargeCommandLine");\n        fbLargeCommandButtons = $("fbLargeCommandButtons");\n\n        if (multiLine)\n        {\n            onRun = onRun || this.enter;\n\n            this.isMultiLine = true;\n\n            this.element = fbLargeCommandLine;\n\n            addEvent(this.element, "keydown", this.onMultiLineKeyDown);\n\n            addEvent($("fbSmallCommandLineIcon"), "click", Firebug.chrome.hideLargeCommandLine);\n\n            this.runButton = new Button({\n                element: $("fbCommand_btRun"),\n                owner: Firebug.CommandLine,\n                onClick: onRun\n            });\n\n            this.runButton.initialize();\n\n            this.clearButton = new Button({\n                element: $("fbCommand_btClear"),\n                owner: Firebug.CommandLine,\n                onClick: this.clear\n            });\n\n            this.clearButton.initialize();\n        }\n        else\n        {\n            this.isMultiLine = false;\n            this.element = fbCommandLine;\n\n            if (!fbCommandLine)\n                return;\n\n            addEvent(this.element, "keydown", this.onKeyDown);\n        }\n\n        //Firebug.Console.log("activate", this.element);\n\n        if (isOpera)\n          fixOperaTabKey(this.element);\n\n        if(this.lastValue)\n            this.element.value = this.lastValue;\n\n        this.isActive = true;\n    },\n\n    deactivate: function()\n    {\n        if (!this.isActive) return;\n\n        //Firebug.Console.log("deactivate", this.element);\n\n        this.isActive = false;\n\n        this.lastValue = this.element.value;\n\n        if (this.isMultiLine)\n        {\n            removeEvent(this.element, "keydown", this.onMultiLineKeyDown);\n\n            removeEvent($("fbSmallCommandLineIcon"), "click", Firebug.chrome.hideLargeCommandLine);\n\n            this.runButton.destroy();\n            this.clearButton.destroy();\n        }\n        else\n        {\n            removeEvent(this.element, "keydown", this.onKeyDown);\n        }\n\n        this.element = null;\n        delete this.element;\n\n        fbCommandLine = null;\n        fbLargeCommandLine = null;\n        fbLargeCommandButtons = null;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    focus: function()\n    {\n        this.element.focus();\n    },\n\n    blur: function()\n    {\n        this.element.blur();\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    clear: function()\n    {\n        this.element.value = "";\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    evaluate: function(expr)\n    {\n        // TODO: need to register the API in console.firebug.commandLineAPI\n        var api = "Firebug.CommandLine.API";\n\n        var result = Firebug.context.evaluate(expr, "window", api, Firebug.Console.error);\n\n        return result;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    enter: function()\n    {\n        var command = this.element.value;\n\n        if (!command) return;\n\n        _stack(command);\n\n        Firebug.Console.log(commandPrefix + " " + stripNewLines(command),\n                Firebug.browser, "command", FirebugReps.Text);\n\n        var result = this.evaluate(command);\n\n        Firebug.Console.log(result);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    prevCommand: function()\n    {\n        if (Firebug.context.persistedState.commandPointer > 0 &&\n            Firebug.context.persistedState.commandHistory.length > 0)\n        {\n            this.element.value = Firebug.context.persistedState.commandHistory\n                                    [--Firebug.context.persistedState.commandPointer];\n        }\n    },\n\n    nextCommand: function()\n    {\n        var element = this.element;\n\n        var limit = Firebug.context.persistedState.commandHistory.length -1;\n        var i = Firebug.context.persistedState.commandPointer;\n\n        if (i < limit)\n          element.value = Firebug.context.persistedState.commandHistory\n                              [++Firebug.context.persistedState.commandPointer];\n\n        else if (i == limit)\n        {\n            ++Firebug.context.persistedState.commandPointer;\n            element.value = "";\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    autocomplete: function(reverse)\n    {\n        var element = this.element;\n\n        var command = element.value;\n        var offset = getExpressionOffset(command);\n\n        var valBegin = offset ? command.substr(0, offset) : "";\n        var val = command.substr(offset);\n\n        var buffer, obj, objName, commandBegin, result, prefix;\n\n        // if it is the beginning of the completion\n        if(!isAutoCompleting)\n        {\n\n            // group1 - command begin\n            // group2 - base object\n            // group3 - property prefix\n            var reObj = /(.*[^_$\\w\\d\\.])?((?:[_$\\w][_$\\w\\d]*\\.)*)([_$\\w][_$\\w\\d]*)?$/;\n            var r = reObj.exec(val);\n\n            // parse command\n            if (r[1] || r[2] || r[3])\n            {\n                commandBegin = r[1] || "";\n                objName = r[2] || "";\n                prefix = r[3] || "";\n            }\n            else if (val == "")\n            {\n                commandBegin = objName = prefix = "";\n            } else\n                return;\n\n            isAutoCompleting = true;\n\n            // find base object\n            if(objName == "")\n                obj = window;\n\n            else\n            {\n                objName = objName.replace(/\\.$/, "");\n\n                var n = objName.split(".");\n                var target = window, o;\n\n                for (var i=0, ni; ni = n[i]; i++)\n                {\n                    if (o = target[ni])\n                      target = o;\n\n                    else\n                    {\n                        target = null;\n                        break;\n                    }\n                }\n                obj = target;\n            }\n\n            // map base object\n            if(obj)\n            {\n                autoCompletePrefix = prefix;\n                autoCompleteExpr = valBegin + commandBegin + (objName ? objName + "." : "");\n                autoCompletePosition = -1;\n\n                buffer = autoCompleteBuffer = isIE ?\n                    _completion[objName || "window"] || [] : [];\n\n                for(var p in obj)\n                    buffer.push(p);\n            }\n\n        // if it is the continuation of the last completion\n        } else\n          buffer = autoCompleteBuffer;\n\n        if (buffer)\n        {\n            prefix = autoCompletePrefix;\n\n            var diff = reverse ? -1 : 1;\n\n            for(var i=autoCompletePosition+diff, l=buffer.length, bi; i>=0 && i<l; i+=diff)\n            {\n                bi = buffer[i];\n\n                if (bi.indexOf(prefix) == 0)\n                {\n                    autoCompletePosition = i;\n                    result = bi;\n                    break;\n                }\n            }\n        }\n\n        if (result)\n            element.value = autoCompleteExpr + result;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    setMultiLine: function(multiLine)\n    {\n        if (multiLine == this.isMultiLine) return;\n\n        this.activate(multiLine);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onError: function(msg, href, lineNo)\n    {\n        href = href || "";\n\n        var lastSlash = href.lastIndexOf("/");\n        var fileName = lastSlash == -1 ? href : href.substr(lastSlash+1);\n        var html = [\n            \'<span class="errorMessage">\', msg, \'</span>\',\n            \'<div class="objectBox-sourceLink">\', fileName, \' (line \', lineNo, \')</div>\'\n          ];\n\n        // TODO: xxxpedro ajust to Console2\n        //Firebug.Console.writeRow(html, "error");\n    },\n\n    onKeyDown: function(e)\n    {\n        e = e || event;\n\n        var code = e.keyCode;\n\n        /*tab, shift, control, alt*/\n        if (code != 9 && code != 16 && code != 17 && code != 18)\n        {\n            isAutoCompleting = false;\n        }\n\n        if (code == 13 /* enter */)\n        {\n            this.enter();\n            this.clear();\n        }\n        else if (code == 27 /* ESC */)\n        {\n            setTimeout(this.clear, 0);\n        }\n        else if (code == 38 /* up */)\n        {\n            this.prevCommand();\n        }\n        else if (code == 40 /* down */)\n        {\n            this.nextCommand();\n        }\n        else if (code == 9 /* tab */)\n        {\n            this.autocomplete(e.shiftKey);\n        }\n        else\n            return;\n\n        cancelEvent(e, true);\n        return false;\n    },\n\n    onMultiLineKeyDown: function(e)\n    {\n        e = e || event;\n\n        var code = e.keyCode;\n\n        if (code == 13 /* enter */ && e.ctrlKey)\n        {\n            this.enter();\n        }\n    }\n});\n\nFirebug.registerModule(Firebug.CommandLine);\n\n\n// ************************************************************************************************\n//\n\nfunction getExpressionOffset(command)\n{\n    // XXXjoe This is kind of a poor-man\'s JavaScript parser - trying\n    // to find the start of the expression that the cursor is inside.\n    // Not 100% fool proof, but hey...\n\n    var bracketCount = 0;\n\n    var start = command.length-1;\n    for (; start >= 0; --start)\n    {\n        var c = command[start];\n        if ((c == "," || c == ";" || c == " ") && !bracketCount)\n            break;\n        if (reOpenBracket.test(c))\n        {\n            if (bracketCount)\n                --bracketCount;\n            else\n                break;\n        }\n        else if (reCloseBracket.test(c))\n            ++bracketCount;\n    }\n\n    return start + 1;\n}\n\n// ************************************************************************************************\n// CommandLine API\n\nvar CommandLineAPI =\n{\n    $: function(id)\n    {\n        return Firebug.browser.document.getElementById(id);\n    },\n\n    $$: function(selector, context)\n    {\n        context = context || Firebug.browser.document;\n        return Firebug.Selector ?\n                Firebug.Selector(selector, context) :\n                Firebug.Console.error("Firebug.Selector module not loaded.");\n    },\n\n    $0: null,\n\n    $1: null,\n\n    dir: function(o)\n    {\n        Firebug.Console.log(o, Firebug.context, "dir", Firebug.DOMPanel.DirTable);\n    },\n\n    dirxml: function(o)\n    {\n        ///if (o instanceof Window)\n        if (instanceOf(o, "Window"))\n            o = o.document.documentElement;\n        ///else if (o instanceof Document)\n        else if (instanceOf(o, "Document"))\n            o = o.documentElement;\n\n        Firebug.Console.log(o, Firebug.context, "dirxml", Firebug.HTMLPanel.SoloElement);\n    }\n};\n\n// ************************************************************************************************\n\nvar defineCommandLineAPI = function defineCommandLineAPI()\n{\n    Firebug.CommandLine.API = {};\n    for (var m in CommandLineAPI)\n        if (!Env.browser.window[m])\n            Firebug.CommandLine.API[m] = CommandLineAPI[m];\n\n    var stack = FirebugChrome.htmlSelectionStack;\n    if (stack)\n    {\n        Firebug.CommandLine.API.$0 = stack[0];\n        Firebug.CommandLine.API.$1 = stack[1];\n    }\n};\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Globals\n\nvar ElementCache = Firebug.Lite.Cache.Element;\nvar cacheID = Firebug.Lite.Cache.ID;\n\nvar ignoreHTMLProps =\n{\n    // ignores the attributes injected by Sizzle, otherwise it will\n    // be visible on IE (when enumerating element.attributes)\n    sizcache: 1,\n    sizset: 1\n};\n\nif (Firebug.ignoreFirebugElements)\n    // ignores also the cache property injected by firebug\n    ignoreHTMLProps[cacheID] = 1;\n\n\n// ************************************************************************************************\n// HTML Module\n\nFirebug.HTML = extend(Firebug.Module,\n{\n    appendTreeNode: function(nodeArray, html)\n    {\n        var reTrim = /^\\s+|\\s+$/g;\n\n        if (!nodeArray.length) nodeArray = [nodeArray];\n\n        for (var n=0, node; node=nodeArray[n]; n++)\n        {\n            if (node.nodeType == 1)\n            {\n                if (Firebug.ignoreFirebugElements && node.firebugIgnore) continue;\n\n                var uid = ElementCache(node);\n                var child = node.childNodes;\n                var childLength = child.length;\n\n                var nodeName = node.nodeName.toLowerCase();\n\n                var nodeVisible = isVisible(node);\n\n                var hasSingleTextChild = childLength == 1 && node.firstChild.nodeType == 3 &&\n                        nodeName != "script" && nodeName != "style";\n\n                var nodeControl = !hasSingleTextChild && childLength > 0 ?\n                    (\'<div class="nodeControl"></div>\') : \'\';\n\n                // FIXME xxxpedro remove this\n                //var isIE = false;\n\n                if(isIE && nodeControl)\n                    html.push(nodeControl);\n\n                if (typeof uid != \'undefined\')\n                    html.push(\n                        \'<div class="objectBox-element" \',\n                        \'id="\', uid,\n                        \'">\',\n                        !isIE && nodeControl ? nodeControl: "",\n                        \'<span \',\n                        cacheID,\n                        \'="\', uid,\n                        \'"  class="nodeBox\',\n                        nodeVisible ? "" : " nodeHidden",\n                        \'">&lt;<span class="nodeTag">\', nodeName, \'</span>\'\n                    );\n                else\n                    html.push(\n                        \'<div class="objectBox-element"><span class="nodeBox\',\n                        nodeVisible ? "" : " nodeHidden",\n                        \'">&lt;<span class="nodeTag">\',\n                        nodeName, \'</span>\'\n                    );\n\n                for (var i = 0; i < node.attributes.length; ++i)\n                {\n                    var attr = node.attributes[i];\n                    if (!attr.specified ||\n                        // Issue 4432:  Firebug Lite: HTML is mixed-up with functions\n                        // The problem here is that expando properties added to DOM elements in\n                        // IE < 9 will behave like DOM attributes and so they\'ll show up when\n                        // looking at element.attributes list.\n                        isIE && (browserVersion-0<9) && typeof attr.nodeValue != "string" ||\n                        Firebug.ignoreFirebugElements && ignoreHTMLProps.hasOwnProperty(attr.nodeName))\n                            continue;\n\n                    var name = attr.nodeName.toLowerCase();\n                    var value = name == "style" ? formatStyles(node.style.cssText) : attr.nodeValue;\n\n                    html.push(\'&nbsp;<span class="nodeName">\', name,\n                        \'</span>=&quot;<span class="nodeValue">\', escapeHTML(value),\n                        \'</span>&quot;\');\n                }\n\n                /*\n                // source code nodes\n                if (nodeName == \'script\' || nodeName == \'style\')\n                {\n\n                    if(document.all){\n                        var src = node.innerHTML+\'\\n\';\n\n                    }else {\n                        var src = \'\\n\'+node.innerHTML+\'\\n\';\n                    }\n\n                    var match = src.match(/\\n/g);\n                    var num = match ? match.length : 0;\n                    var s = [], sl = 0;\n\n                    for(var c=1; c<num; c++){\n                        s[sl++] = \'<div line="\'+c+\'">\' + c + \'</div>\';\n                    }\n\n                    html.push(\'&gt;</div><div class="nodeGroup"><div class="nodeChildren"><div class="lineNo">\',\n                            s.join(\'\'),\n                            \'</div><pre class="nodeCode">\',\n                            escapeHTML(src),\n                            \'</pre>\',\n                            \'</div><div class="objectBox-element">&lt;/<span class="nodeTag">\',\n                            nodeName,\n                            \'</span>&gt;</div>\',\n                            \'</div>\'\n                        );\n\n\n                }/**/\n\n                // Just a single text node child\n                if (hasSingleTextChild)\n                {\n                    var value = child[0].nodeValue.replace(reTrim, \'\');\n                    if(value)\n                    {\n                        html.push(\n                                \'&gt;<span class="nodeText">\',\n                                escapeHTML(value),\n                                \'</span>&lt;/<span class="nodeTag">\',\n                                nodeName,\n                                \'</span>&gt;</span></div>\'\n                            );\n                    }\n                    else\n                      html.push(\'/&gt;</span></div>\'); // blank text, print as childless node\n\n                }\n                else if (childLength > 0)\n                {\n                    html.push(\'&gt;</span></div>\');\n                }\n                else\n                    html.push(\'/&gt;</span></div>\');\n\n            }\n            else if (node.nodeType == 3)\n            {\n                if ( node.parentNode && ( node.parentNode.nodeName.toLowerCase() == "script" ||\n                     node.parentNode.nodeName.toLowerCase() == "style" ) )\n                {\n                    var value = node.nodeValue.replace(reTrim, \'\');\n\n                    if(isIE){\n                        var src = value+\'\\n\';\n\n                    }else {\n                        var src = \'\\n\'+value+\'\\n\';\n                    }\n\n                    var match = src.match(/\\n/g);\n                    var num = match ? match.length : 0;\n                    var s = [], sl = 0;\n\n                    for(var c=1; c<num; c++){\n                        s[sl++] = \'<div line="\'+c+\'">\' + c + \'</div>\';\n                    }\n\n                    html.push(\'<div class="lineNo">\',\n                            s.join(\'\'),\n                            \'</div><pre class="sourceCode">\',\n                            escapeHTML(src),\n                            \'</pre>\'\n                        );\n\n                }\n                else\n                {\n                    var value = node.nodeValue.replace(reTrim, \'\');\n                    if (value)\n                        html.push(\'<div class="nodeText">\', escapeHTML(value),\'</div>\');\n                }\n            }\n        }\n    },\n\n    appendTreeChildren: function(treeNode)\n    {\n        var doc = Firebug.chrome.document;\n        var uid = treeNode.id;\n        var parentNode = ElementCache.get(uid);\n\n        if (parentNode.childNodes.length == 0) return;\n\n        var treeNext = treeNode.nextSibling;\n        var treeParent = treeNode.parentNode;\n\n        // FIXME xxxpedro remove this\n        //var isIE = false;\n        var control = isIE ? treeNode.previousSibling : treeNode.firstChild;\n        control.className = \'nodeControl nodeMaximized\';\n\n        var html = [];\n        var children = doc.createElement("div");\n        children.className = "nodeChildren";\n        this.appendTreeNode(parentNode.childNodes, html);\n        children.innerHTML = html.join("");\n\n        treeParent.insertBefore(children, treeNext);\n\n        var closeElement = doc.createElement("div");\n        closeElement.className = "objectBox-element";\n        closeElement.innerHTML = \'&lt;/<span class="nodeTag">\' +\n            parentNode.nodeName.toLowerCase() + \'&gt;</span>\';\n\n        treeParent.insertBefore(closeElement, treeNext);\n\n    },\n\n    removeTreeChildren: function(treeNode)\n    {\n        var children = treeNode.nextSibling;\n        var closeTag = children.nextSibling;\n\n        // FIXME xxxpedro remove this\n        //var isIE = false;\n        var control = isIE ? treeNode.previousSibling : treeNode.firstChild;\n        control.className = \'nodeControl\';\n\n        children.parentNode.removeChild(children);\n        closeTag.parentNode.removeChild(closeTag);\n    },\n\n    isTreeNodeVisible: function(id)\n    {\n        return $(id);\n    },\n\n    select: function(el)\n    {\n        var id = el && ElementCache(el);\n        if (id)\n            this.selectTreeNode(id);\n    },\n\n    selectTreeNode: function(id)\n    {\n        id = ""+id;\n        var node, stack = [];\n        while(id && !this.isTreeNodeVisible(id))\n        {\n            stack.push(id);\n\n            var node = ElementCache.get(id).parentNode;\n\n            if (node)\n                id = ElementCache(node);\n            else\n                break;\n        }\n\n        stack.push(id);\n\n        while(stack.length > 0)\n        {\n            id = stack.pop();\n            node = $(id);\n\n            if (stack.length > 0 && ElementCache.get(id).childNodes.length > 0)\n              this.appendTreeChildren(node);\n        }\n\n        selectElement(node);\n\n        // TODO: xxxpedro\n        if (fbPanel1)\n            fbPanel1.scrollTop = Math.round(node.offsetTop - fbPanel1.clientHeight/2);\n    }\n\n});\n\nFirebug.registerModule(Firebug.HTML);\n\n// ************************************************************************************************\n// HTML Panel\n\nfunction HTMLPanel(){};\n\nHTMLPanel.prototype = extend(Firebug.Panel,\n{\n    name: "HTML",\n    title: "HTML",\n\n    options: {\n        hasSidePanel: true,\n        //hasToolButtons: true,\n        isPreRendered: !Firebug.flexChromeEnabled /* FIXME xxxpedro chromenew */,\n        innerHTMLSync: true\n    },\n\n    create: function(){\n        Firebug.Panel.create.apply(this, arguments);\n\n        this.panelNode.style.padding = "4px 3px 1px 15px";\n        this.panelNode.style.minWidth = "500px";\n\n        if (Env.Options.enablePersistent || Firebug.chrome.type != "popup")\n            this.createUI();\n\n        if(this.sidePanelBar && !this.sidePanelBar.selectedPanel)\n        {\n            this.sidePanelBar.selectPanel("css");\n        }\n    },\n\n    destroy: function()\n    {\n        selectedElement = null;\n        fbPanel1 = null;\n\n        selectedSidePanelTS = null;\n        selectedSidePanelTimer = null;\n\n        Firebug.Panel.destroy.apply(this, arguments);\n    },\n\n    createUI: function()\n    {\n        var rootNode = Firebug.browser.document.documentElement;\n        var html = [];\n        Firebug.HTML.appendTreeNode(rootNode, html);\n\n        this.panelNode.innerHTML = html.join("");\n    },\n\n    initialize: function()\n    {\n        Firebug.Panel.initialize.apply(this, arguments);\n        addEvent(this.panelNode, \'click\', Firebug.HTML.onTreeClick);\n\n        fbPanel1 = $("fbPanel1");\n\n        if(!selectedElement)\n        {\n            Firebug.context.persistedState.selectedHTMLElementId =\n                Firebug.context.persistedState.selectedHTMLElementId &&\n                ElementCache.get(Firebug.context.persistedState.selectedHTMLElementId) ?\n                Firebug.context.persistedState.selectedHTMLElementId :\n                ElementCache(Firebug.browser.document.body);\n\n            Firebug.HTML.selectTreeNode(Firebug.context.persistedState.selectedHTMLElementId);\n        }\n\n        // TODO: xxxpedro\n        addEvent(fbPanel1, \'mousemove\', Firebug.HTML.onListMouseMove);\n        addEvent($("fbContent"), \'mouseout\', Firebug.HTML.onListMouseMove);\n        addEvent(Firebug.chrome.node, \'mouseout\', Firebug.HTML.onListMouseMove);\n    },\n\n    shutdown: function()\n    {\n        // TODO: xxxpedro\n        removeEvent(fbPanel1, \'mousemove\', Firebug.HTML.onListMouseMove);\n        removeEvent($("fbContent"), \'mouseout\', Firebug.HTML.onListMouseMove);\n        removeEvent(Firebug.chrome.node, \'mouseout\', Firebug.HTML.onListMouseMove);\n\n        removeEvent(this.panelNode, \'click\', Firebug.HTML.onTreeClick);\n\n        fbPanel1 = null;\n\n        Firebug.Panel.shutdown.apply(this, arguments);\n    },\n\n    reattach: function()\n    {\n        // TODO: panel reattach\n        if(Firebug.context.persistedState.selectedHTMLElementId)\n            Firebug.HTML.selectTreeNode(Firebug.context.persistedState.selectedHTMLElementId);\n    },\n\n    updateSelection: function(object)\n    {\n        var id = ElementCache(object);\n\n        if (id)\n        {\n            Firebug.HTML.selectTreeNode(id);\n        }\n    }\n});\n\nFirebug.registerPanel(HTMLPanel);\n\n// ************************************************************************************************\n\nvar formatStyles = function(styles)\n{\n    return isIE ?\n        // IE return CSS property names in upper case, so we need to convert them\n        styles.replace(/([^\\s]+)\\s*:/g, function(m,g){return g.toLowerCase()+":";}) :\n        // other browsers are just fine\n        styles;\n};\n\n// ************************************************************************************************\n\nvar selectedElement = null;\nvar fbPanel1 = null;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nvar selectedSidePanelTS, selectedSidePanelTimer;\n\nvar selectElement= function selectElement(e)\n{\n    if (e != selectedElement)\n    {\n        if (selectedElement)\n            selectedElement.className = "objectBox-element";\n\n        e.className = e.className + " selectedElement";\n\n        if (FBL.isFirefox)\n            e.style.MozBorderRadius = "2px";\n\n        else if (FBL.isSafari)\n            e.style.WebkitBorderRadius = "2px";\n\n        e.style.borderRadius = "2px";\n\n        selectedElement = e;\n\n        Firebug.context.persistedState.selectedHTMLElementId = e.id;\n\n        var target = ElementCache.get(e.id);\n        var sidePanelBar = Firebug.chrome.getPanel("HTML").sidePanelBar;\n        var selectedSidePanel = sidePanelBar ? sidePanelBar.selectedPanel : null;\n\n        var stack = FirebugChrome.htmlSelectionStack;\n\n        stack.unshift(target);\n\n        if (stack.length > 2)\n            stack.pop();\n\n        var lazySelect = function()\n        {\n            selectedSidePanelTS = new Date().getTime();\n\n            if (selectedSidePanel)\n                selectedSidePanel.select(target, true);\n        };\n\n        if (selectedSidePanelTimer)\n        {\n            clearTimeout(selectedSidePanelTimer);\n            selectedSidePanelTimer = null;\n        }\n\n        if (new Date().getTime() - selectedSidePanelTS > 100)\n            setTimeout(lazySelect, 0);\n        else\n            selectedSidePanelTimer = setTimeout(lazySelect, 150);\n    }\n};\n\n\n// ************************************************************************************************\n// ***  TODO:  REFACTOR  **************************************************************************\n// ************************************************************************************************\nFirebug.HTML.onTreeClick = function (e)\n{\n    e = e || event;\n    var targ;\n\n    if (e.target) targ = e.target;\n    else if (e.srcElement) targ = e.srcElement;\n    if (targ.nodeType == 3) // defeat Safari bug\n        targ = targ.parentNode;\n\n\n    if (targ.className.indexOf(\'nodeControl\') != -1 || targ.className == \'nodeTag\')\n    {\n        // FIXME xxxpedro remove this\n        //var isIE = false;\n\n        if(targ.className == \'nodeTag\')\n        {\n            var control = isIE ? (targ.parentNode.previousSibling || targ) :\n                          (targ.parentNode.previousSibling || targ);\n\n            selectElement(targ.parentNode.parentNode);\n\n            if (control.className.indexOf(\'nodeControl\') == -1)\n                return;\n\n        } else\n            control = targ;\n\n        FBL.cancelEvent(e);\n\n        var treeNode = isIE ? control.nextSibling : control.parentNode;\n\n        //FBL.Firebug.Console.log(treeNode);\n\n        if (control.className.indexOf(\' nodeMaximized\') != -1) {\n            FBL.Firebug.HTML.removeTreeChildren(treeNode);\n        } else {\n            FBL.Firebug.HTML.appendTreeChildren(treeNode);\n        }\n    }\n    else if (targ.className == \'nodeValue\' || targ.className == \'nodeName\')\n    {\n        /*\n        var input = FBL.Firebug.chrome.document.getElementById(\'treeInput\');\n\n        input.style.display = "block";\n        input.style.left = targ.offsetLeft + \'px\';\n        input.style.top = FBL.topHeight + targ.offsetTop - FBL.fbPanel1.scrollTop + \'px\';\n        input.style.width = targ.offsetWidth + 6 + \'px\';\n        input.value = targ.textContent || targ.innerText;\n        input.focus();\n        /**/\n    }\n};\n\nfunction onListMouseOut(e)\n{\n    e = e || event || window;\n    var targ;\n\n    if (e.target) targ = e.target;\n    else if (e.srcElement) targ = e.srcElement;\n    if (targ.nodeType == 3) // defeat Safari bug\n      targ = targ.parentNode;\n\n      if (hasClass(targ, "fbPanel")) {\n          FBL.Firebug.Inspector.hideBoxModel();\n          hoverElement = null;\n      }\n};\n\nvar hoverElement = null;\nvar hoverElementTS = 0;\n\nFirebug.HTML.onListMouseMove = function onListMouseMove(e)\n{\n    try\n    {\n        e = e || event || window;\n        var targ;\n\n        if (e.target) targ = e.target;\n        else if (e.srcElement) targ = e.srcElement;\n        if (targ.nodeType == 3) // defeat Safari bug\n            targ = targ.parentNode;\n\n        var found = false;\n        while (targ && !found) {\n            if (!/\\snodeBox\\s|\\sobjectBox-selector\\s/.test(" " + targ.className + " "))\n                targ = targ.parentNode;\n            else\n                found = true;\n        }\n\n        if (!targ)\n        {\n            FBL.Firebug.Inspector.hideBoxModel();\n            hoverElement = null;\n            return;\n        }\n\n        /*\n        if (typeof targ.attributes[cacheID] == \'undefined\') return;\n\n        var uid = targ.attributes[cacheID];\n        if (!uid) return;\n        /**/\n\n        if (typeof targ.attributes[cacheID] == \'undefined\') return;\n\n        var uid = targ.attributes[cacheID];\n        if (!uid) return;\n\n        var el = ElementCache.get(uid.value);\n\n        var nodeName = el.nodeName.toLowerCase();\n\n        if (FBL.isIE && " meta title script link ".indexOf(" "+nodeName+" ") != -1)\n            return;\n\n        if (!/\\snodeBox\\s|\\sobjectBox-selector\\s/.test(" " + targ.className + " ")) return;\n\n        if (el.id == "FirebugUI" || " html head body br script link iframe ".indexOf(" "+nodeName+" ") != -1) {\n            FBL.Firebug.Inspector.hideBoxModel();\n            hoverElement = null;\n            return;\n        }\n\n        if ((new Date().getTime() - hoverElementTS > 40) && hoverElement != el) {\n            hoverElementTS = new Date().getTime();\n            hoverElement = el;\n            FBL.Firebug.Inspector.drawBoxModel(el);\n        }\n    }\n    catch(E)\n    {\n    }\n};\n\n\n// ************************************************************************************************\n\nFirebug.Reps = {\n\n    appendText: function(object, html)\n    {\n        html.push(escapeHTML(objectToString(object)));\n    },\n\n    appendNull: function(object, html)\n    {\n        html.push(\'<span class="objectBox-null">\', escapeHTML(objectToString(object)), \'</span>\');\n    },\n\n    appendString: function(object, html)\n    {\n        html.push(\'<span class="objectBox-string">&quot;\', escapeHTML(objectToString(object)),\n            \'&quot;</span>\');\n    },\n\n    appendInteger: function(object, html)\n    {\n        html.push(\'<span class="objectBox-number">\', escapeHTML(objectToString(object)), \'</span>\');\n    },\n\n    appendFloat: function(object, html)\n    {\n        html.push(\'<span class="objectBox-number">\', escapeHTML(objectToString(object)), \'</span>\');\n    },\n\n    appendFunction: function(object, html)\n    {\n        var reName = /function ?(.*?)\\(/;\n        var m = reName.exec(objectToString(object));\n        var name = m && m[1] ? m[1] : "function";\n        html.push(\'<span class="objectBox-function">\', escapeHTML(name), \'()</span>\');\n    },\n\n    appendObject: function(object, html)\n    {\n        /*\n        var rep = Firebug.getRep(object);\n        var outputs = [];\n\n        rep.tag.tag.compile();\n\n        var str = rep.tag.renderHTML({object: object}, outputs);\n        html.push(str);\n        /**/\n\n        try\n        {\n            if (object == undefined)\n                this.appendNull("undefined", html);\n            else if (object == null)\n                this.appendNull("null", html);\n            else if (typeof object == "string")\n                this.appendString(object, html);\n            else if (typeof object == "number")\n                this.appendInteger(object, html);\n            else if (typeof object == "boolean")\n                this.appendInteger(object, html);\n            else if (typeof object == "function")\n                this.appendFunction(object, html);\n            else if (object.nodeType == 1)\n                this.appendSelector(object, html);\n            else if (typeof object == "object")\n            {\n                if (typeof object.length != "undefined")\n                    this.appendArray(object, html);\n                else\n                    this.appendObjectFormatted(object, html);\n            }\n            else\n                this.appendText(object, html);\n        }\n        catch (exc)\n        {\n        }\n        /**/\n    },\n\n    appendObjectFormatted: function(object, html)\n    {\n        var text = objectToString(object);\n        var reObject = /\\[object (.*?)\\]/;\n\n        var m = reObject.exec(text);\n        html.push(\'<span class="objectBox-object">\', m ? m[1] : text, \'</span>\');\n    },\n\n    appendSelector: function(object, html)\n    {\n        var uid = ElementCache(object);\n        var uidString = uid ? [cacheID, \'="\', uid, \'"\'].join("") : "";\n\n        html.push(\'<span class="objectBox-selector"\', uidString, \'>\');\n\n        html.push(\'<span class="selectorTag">\', escapeHTML(object.nodeName.toLowerCase()), \'</span>\');\n        if (object.id)\n            html.push(\'<span class="selectorId">#\', escapeHTML(object.id), \'</span>\');\n        if (object.className)\n            html.push(\'<span class="selectorClass">.\', escapeHTML(object.className), \'</span>\');\n\n        html.push(\'</span>\');\n    },\n\n    appendNode: function(node, html)\n    {\n        if (node.nodeType == 1)\n        {\n            var uid = ElementCache(node);\n            var uidString = uid ? [cacheID, \'="\', uid, \'"\'].join("") : "";\n\n            html.push(\n                \'<div class="objectBox-element"\', uidString, \'">\',\n                \'<span \', cacheID, \'="\', uid, \'" class="nodeBox">\',\n                \'&lt;<span class="nodeTag">\', node.nodeName.toLowerCase(), \'</span>\');\n\n            for (var i = 0; i < node.attributes.length; ++i)\n            {\n                var attr = node.attributes[i];\n                if (!attr.specified || attr.nodeName == cacheID)\n                    continue;\n\n                var name = attr.nodeName.toLowerCase();\n                var value = name == "style" ? node.style.cssText : attr.nodeValue;\n\n                html.push(\'&nbsp;<span class="nodeName">\', name,\n                    \'</span>=&quot;<span class="nodeValue">\', escapeHTML(value),\n                    \'</span>&quot;\');\n            }\n\n            if (node.firstChild)\n            {\n                html.push(\'&gt;</div><div class="nodeChildren">\');\n\n                for (var child = node.firstChild; child; child = child.nextSibling)\n                    this.appendNode(child, html);\n\n                html.push(\'</div><div class="objectBox-element">&lt;/<span class="nodeTag">\',\n                    node.nodeName.toLowerCase(), \'&gt;</span></span></div>\');\n            }\n            else\n                html.push(\'/&gt;</span></div>\');\n        }\n        else if (node.nodeType == 3)\n        {\n            var value = trim(node.nodeValue);\n            if (value)\n                html.push(\'<div class="nodeText">\', escapeHTML(value),\'</div>\');\n        }\n    },\n\n    appendArray: function(object, html)\n    {\n        html.push(\'<span class="objectBox-array"><b>[</b> \');\n\n        for (var i = 0, l = object.length, obj; i < l; ++i)\n        {\n            this.appendObject(object[i], html);\n\n            if (i < l-1)\n            html.push(\', \');\n        }\n\n        html.push(\' <b>]</b></span>\');\n    }\n\n};\n\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\n/*\n\nHack:\nFirebug.chrome.currentPanel = Firebug.chrome.selectedPanel;\nFirebug.showInfoTips = true;\nFirebug.InfoTip.initializeBrowser(Firebug.chrome);\n\n/**/\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// Constants\n\nvar maxWidth = 100, maxHeight = 80;\nvar infoTipMargin = 10;\nvar infoTipWindowPadding = 25;\n\n// ************************************************************************************************\n\nFirebug.InfoTip = extend(Firebug.Module,\n{\n    dispatchName: "infoTip",\n    tags: domplate(\n    {\n        infoTipTag: DIV({"class": "infoTip"}),\n\n        colorTag:\n            DIV({style: "background: $rgbValue; width: 100px; height: 40px"}, "&nbsp;"),\n\n        imgTag:\n            DIV({"class": "infoTipImageBox infoTipLoading"},\n                IMG({"class": "infoTipImage", src: "$urlValue", repeat: "$repeat",\n                    onload: "$onLoadImage"}),\n                IMG({"class": "infoTipBgImage", collapsed: true, src: "blank.gif"}),\n                DIV({"class": "infoTipCaption"})\n            ),\n\n        onLoadImage: function(event)\n        {\n            var img = event.currentTarget || event.srcElement;\n            ///var bgImg = img.nextSibling;\n            ///if (!bgImg)\n            ///    return; // Sometimes gets called after element is dead\n\n            ///var caption = bgImg.nextSibling;\n            var innerBox = img.parentNode;\n\n            /// TODO: xxxpedro infoTip hack\n            var caption = getElementByClass(innerBox, "infoTipCaption");\n            var bgImg = getElementByClass(innerBox, "infoTipBgImage");\n            if (!bgImg)\n                return; // Sometimes gets called after element is dead\n\n            // TODO: xxxpedro infoTip IE and timing issue\n            // TODO: use offline document to avoid flickering\n            if (isIE)\n                removeClass(innerBox, "infoTipLoading");\n\n            var updateInfoTip = function(){\n\n            var w = img.naturalWidth || img.width || 10,\n                h = img.naturalHeight || img.height || 10;\n\n            var repeat = img.getAttribute("repeat");\n\n            if (repeat == "repeat-x" || (w == 1 && h > 1))\n            {\n                collapse(img, true);\n                collapse(bgImg, false);\n                bgImg.style.background = "url(" + img.src + ") repeat-x";\n                bgImg.style.width = maxWidth + "px";\n                if (h > maxHeight)\n                    bgImg.style.height = maxHeight + "px";\n                else\n                    bgImg.style.height = h + "px";\n            }\n            else if (repeat == "repeat-y" || (h == 1 && w > 1))\n            {\n                collapse(img, true);\n                collapse(bgImg, false);\n                bgImg.style.background = "url(" + img.src + ") repeat-y";\n                bgImg.style.height = maxHeight + "px";\n                if (w > maxWidth)\n                    bgImg.style.width = maxWidth + "px";\n                else\n                    bgImg.style.width = w + "px";\n            }\n            else if (repeat == "repeat" || (w == 1 && h == 1))\n            {\n                collapse(img, true);\n                collapse(bgImg, false);\n                bgImg.style.background = "url(" + img.src + ") repeat";\n                bgImg.style.width = maxWidth + "px";\n                bgImg.style.height = maxHeight + "px";\n            }\n            else\n            {\n                if (w > maxWidth || h > maxHeight)\n                {\n                    if (w > h)\n                    {\n                        img.style.width = maxWidth + "px";\n                        img.style.height = Math.round((h / w) * maxWidth) + "px";\n                    }\n                    else\n                    {\n                        img.style.width = Math.round((w / h) * maxHeight) + "px";\n                        img.style.height = maxHeight + "px";\n                    }\n                }\n            }\n\n            //caption.innerHTML = $STRF("Dimensions", [w, h]);\n            caption.innerHTML = $STRF(w + " x " + h);\n\n\n            };\n\n            if (isIE)\n                setTimeout(updateInfoTip, 0);\n            else\n            {\n                updateInfoTip();\n                removeClass(innerBox, "infoTipLoading");\n            }\n\n            ///\n        }\n\n        /*\n        /// onLoadImage original\n        onLoadImage: function(event)\n        {\n            var img = event.currentTarget;\n            var bgImg = img.nextSibling;\n            if (!bgImg)\n                return; // Sometimes gets called after element is dead\n\n            var caption = bgImg.nextSibling;\n            var innerBox = img.parentNode;\n\n            var w = img.naturalWidth, h = img.naturalHeight;\n            var repeat = img.getAttribute("repeat");\n\n            if (repeat == "repeat-x" || (w == 1 && h > 1))\n            {\n                collapse(img, true);\n                collapse(bgImg, false);\n                bgImg.style.background = "url(" + img.src + ") repeat-x";\n                bgImg.style.width = maxWidth + "px";\n                if (h > maxHeight)\n                    bgImg.style.height = maxHeight + "px";\n                else\n                    bgImg.style.height = h + "px";\n            }\n            else if (repeat == "repeat-y" || (h == 1 && w > 1))\n            {\n                collapse(img, true);\n                collapse(bgImg, false);\n                bgImg.style.background = "url(" + img.src + ") repeat-y";\n                bgImg.style.height = maxHeight + "px";\n                if (w > maxWidth)\n                    bgImg.style.width = maxWidth + "px";\n                else\n                    bgImg.style.width = w + "px";\n            }\n            else if (repeat == "repeat" || (w == 1 && h == 1))\n            {\n                collapse(img, true);\n                collapse(bgImg, false);\n                bgImg.style.background = "url(" + img.src + ") repeat";\n                bgImg.style.width = maxWidth + "px";\n                bgImg.style.height = maxHeight + "px";\n            }\n            else\n            {\n                if (w > maxWidth || h > maxHeight)\n                {\n                    if (w > h)\n                    {\n                        img.style.width = maxWidth + "px";\n                        img.style.height = Math.round((h / w) * maxWidth) + "px";\n                    }\n                    else\n                    {\n                        img.style.width = Math.round((w / h) * maxHeight) + "px";\n                        img.style.height = maxHeight + "px";\n                    }\n                }\n            }\n\n            caption.innerHTML = $STRF("Dimensions", [w, h]);\n\n            removeClass(innerBox, "infoTipLoading");\n        }\n        /**/\n\n    }),\n\n    initializeBrowser: function(browser)\n    {\n        browser.onInfoTipMouseOut = bind(this.onMouseOut, this, browser);\n        browser.onInfoTipMouseMove = bind(this.onMouseMove, this, browser);\n\n        ///var doc = browser.contentDocument;\n        var doc = browser.document;\n        if (!doc)\n            return;\n\n        ///doc.addEventListener("mouseover", browser.onInfoTipMouseMove, true);\n        ///doc.addEventListener("mouseout", browser.onInfoTipMouseOut, true);\n        ///doc.addEventListener("mousemove", browser.onInfoTipMouseMove, true);\n        addEvent(doc, "mouseover", browser.onInfoTipMouseMove);\n        addEvent(doc, "mouseout", browser.onInfoTipMouseOut);\n        addEvent(doc, "mousemove", browser.onInfoTipMouseMove);\n\n        return browser.infoTip = this.tags.infoTipTag.append({}, getBody(doc));\n    },\n\n    uninitializeBrowser: function(browser)\n    {\n        if (browser.infoTip)\n        {\n            ///var doc = browser.contentDocument;\n            var doc = browser.document;\n            ///doc.removeEventListener("mouseover", browser.onInfoTipMouseMove, true);\n            ///doc.removeEventListener("mouseout", browser.onInfoTipMouseOut, true);\n            ///doc.removeEventListener("mousemove", browser.onInfoTipMouseMove, true);\n            removeEvent(doc, "mouseover", browser.onInfoTipMouseMove);\n            removeEvent(doc, "mouseout", browser.onInfoTipMouseOut);\n            removeEvent(doc, "mousemove", browser.onInfoTipMouseMove);\n\n            browser.infoTip.parentNode.removeChild(browser.infoTip);\n            delete browser.infoTip;\n            delete browser.onInfoTipMouseMove;\n        }\n    },\n\n    showInfoTip: function(infoTip, panel, target, x, y, rangeParent, rangeOffset)\n    {\n        if (!Firebug.showInfoTips)\n            return;\n\n        var scrollParent = getOverflowParent(target);\n        var scrollX = x + (scrollParent ? scrollParent.scrollLeft : 0);\n\n        if (panel.showInfoTip(infoTip, target, scrollX, y, rangeParent, rangeOffset))\n        {\n            var htmlElt = infoTip.ownerDocument.documentElement;\n            var panelWidth = htmlElt.clientWidth;\n            var panelHeight = htmlElt.clientHeight;\n\n            if (x+infoTip.offsetWidth+infoTipMargin > panelWidth)\n            {\n                infoTip.style.left = Math.max(0, panelWidth-(infoTip.offsetWidth+infoTipMargin)) + "px";\n                infoTip.style.right = "auto";\n            }\n            else\n            {\n                infoTip.style.left = (x+infoTipMargin) + "px";\n                infoTip.style.right = "auto";\n            }\n\n            if (y+infoTip.offsetHeight+infoTipMargin > panelHeight)\n            {\n                infoTip.style.top = Math.max(0, panelHeight-(infoTip.offsetHeight+infoTipMargin)) + "px";\n                infoTip.style.bottom = "auto";\n            }\n            else\n            {\n                infoTip.style.top = (y+infoTipMargin) + "px";\n                infoTip.style.bottom = "auto";\n            }\n\n            if (FBTrace.DBG_INFOTIP)\n                FBTrace.sysout("infotip.showInfoTip; top: " + infoTip.style.top +\n                    ", left: " + infoTip.style.left + ", bottom: " + infoTip.style.bottom +\n                    ", right:" + infoTip.style.right + ", offsetHeight: " + infoTip.offsetHeight +\n                    ", offsetWidth: " + infoTip.offsetWidth +\n                    ", x: " + x + ", panelWidth: " + panelWidth +\n                    ", y: " + y + ", panelHeight: " + panelHeight);\n\n            infoTip.setAttribute("active", "true");\n        }\n        else\n            this.hideInfoTip(infoTip);\n    },\n\n    hideInfoTip: function(infoTip)\n    {\n        if (infoTip)\n            infoTip.removeAttribute("active");\n    },\n\n    onMouseOut: function(event, browser)\n    {\n        if (!event.relatedTarget)\n            this.hideInfoTip(browser.infoTip);\n    },\n\n    onMouseMove: function(event, browser)\n    {\n        // Ignore if the mouse is moving over the existing info tip.\n        if (getAncestorByClass(event.target, "infoTip"))\n            return;\n\n        if (browser.currentPanel)\n        {\n            var x = event.clientX, y = event.clientY, target = event.target || event.srcElement;\n            this.showInfoTip(browser.infoTip, browser.currentPanel, target, x, y, event.rangeParent, event.rangeOffset);\n        }\n        else\n            this.hideInfoTip(browser.infoTip);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    populateColorInfoTip: function(infoTip, color)\n    {\n        this.tags.colorTag.replace({rgbValue: color}, infoTip);\n        return true;\n    },\n\n    populateImageInfoTip: function(infoTip, url, repeat)\n    {\n        if (!repeat)\n            repeat = "no-repeat";\n\n        this.tags.imgTag.replace({urlValue: url, repeat: repeat}, infoTip);\n\n        return true;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Module\n\n    disable: function()\n    {\n        // XXXjoe For each browser, call uninitializeBrowser\n    },\n\n    showPanel: function(browser, panel)\n    {\n        if (panel)\n        {\n            var infoTip = panel.panelBrowser.infoTip;\n            if (!infoTip)\n                infoTip = this.initializeBrowser(panel.panelBrowser);\n            this.hideInfoTip(infoTip);\n        }\n\n    },\n\n    showSidePanel: function(browser, panel)\n    {\n        this.showPanel(browser, panel);\n    }\n});\n\n// ************************************************************************************************\n\nFirebug.registerModule(Firebug.InfoTip);\n\n// ************************************************************************************************\n\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nvar CssParser = null;\n\n// ************************************************************************************************\n\n// Simple CSS stylesheet parser from:\n// https://github.com/sergeche/webkit-css\n\n/**\n * Simple CSS stylesheet parser that remembers rule\'s lines in file\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nCssParser = (function(){\n    /**\n     * Returns rule object\n     * @param {Number} start Character index where CSS rule definition starts\n     * @param {Number} body_start Character index where CSS rule\'s body starts\n     * @param {Number} end Character index where CSS rule definition ends\n     */\n    function rule(start, body_start, end) {\n        return {\n            start: start || 0,\n            body_start: body_start || 0,\n            end: end || 0,\n            line: -1,\n            selector: null,\n            parent: null,\n\n            /** @type {rule[]} */\n            children: [],\n\n            addChild: function(start, body_start, end) {\n                var r = rule(start, body_start, end);\n                r.parent = this;\n                this.children.push(r);\n                return r;\n            },\n            /**\n             * Returns last child element\n             * @return {rule}\n             */\n            lastChild: function() {\n                return this.children[this.children.length - 1];\n            }\n        };\n    }\n\n    /**\n     * Replaces all occurances of substring defined by regexp\n     * @param {String} str\n     * @return {RegExp} re\n     * @return {String}\n     */\n    function removeAll(str, re) {\n        var m;\n        while (m = str.match(re)) {\n            str = str.substring(m[0].length);\n        }\n\n        return str;\n    }\n\n    /**\n     * Trims whitespace from the beginning and the end of string\n     * @param {String} str\n     * @return {String}\n     */\n    function trim(str) {\n        return str.replace(/^\\s+|\\s+$/g, \'\');\n    }\n\n    /**\n     * Normalizes CSS rules selector\n     * @param {String} selector\n     */\n    function normalizeSelector(selector) {\n        // remove newlines\n        selector = selector.replace(/[\\n\\r]/g, \' \');\n\n        selector = trim(selector);\n\n        // remove spaces after commas\n        selector = selector.replace(/\\s*,\\s*/g, \',\');\n\n        return selector;\n    }\n\n    /**\n     * Preprocesses parsed rules: adjusts char indexes, skipping whitespace and\n     * newlines, saves rule selector, removes comments, etc.\n     * @param {String} text CSS stylesheet\n     * @param {rule} rule_node CSS rule node\n     * @return {rule[]}\n     */\n    function preprocessRules(text, rule_node) {\n        for (var i = 0, il = rule_node.children.length; i < il; i++) {\n            var r = rule_node.children[i],\n                rule_start = text.substring(r.start, r.body_start),\n                cur_len = rule_start.length;\n\n            // remove newlines for better regexp matching\n            rule_start = rule_start.replace(/[\\n\\r]/g, \' \');\n\n            // remove @import rules\n//            rule_start = removeAll(rule_start, /^\\s*@import\\s*url\\(([\'"])?.+?\\1?\\)\\;?/g);\n\n            // remove comments\n            rule_start = removeAll(rule_start, /^\\s*\\/\\*.*?\\*\\/[\\s\\t]*/);\n\n            // remove whitespace\n            rule_start = rule_start.replace(/^[\\s\\t]+/, \'\');\n\n            r.start += (cur_len - rule_start.length);\n            r.selector = normalizeSelector(rule_start);\n        }\n\n        return rule_node;\n    }\n\n    /**\n     * Saves all lise starting indexes for faster search\n     * @param {String} text CSS stylesheet\n     * @return {Number[]}\n     */\n    function saveLineIndexes(text) {\n        var result = [0],\n            i = 0,\n            il = text.length,\n            ch, ch2;\n\n        while (i < il) {\n            ch = text.charAt(i);\n\n            if (ch == \'\\n\' || ch == \'\\r\') {\n                if (ch == \'\\r\' && i < il - 1 && text.charAt(i + 1) == \'\\n\') {\n                    // windows line ending: CRLF. Skip next character\n                    i++;\n                }\n\n                result.push(i + 1);\n            }\n\n            i++;\n        }\n\n        return result;\n    }\n\n    /**\n     * Saves line number for parsed rules\n     * @param {String} text CSS stylesheet\n     * @param {rule} rule_node Rule node\n     * @return {rule[]}\n     */\n    function saveLineNumbers(text, rule_node, line_indexes, startLine) {\n        preprocessRules(text, rule_node);\n\n        startLine = startLine || 0;\n\n        // remember lines start indexes, preserving line ending characters\n        if (!line_indexes)\n            var line_indexes = saveLineIndexes(text);\n\n        // now find each rule\'s line\n        for (var i = 0, il = rule_node.children.length; i < il; i++) {\n            var r = rule_node.children[i];\n            r.line = line_indexes.length + startLine;\n            for (var j = 0, jl = line_indexes.length - 1; j < jl; j++) {\n                var line_ix = line_indexes[j];\n                if (r.start >=  line_indexes[j] && r.start <  line_indexes[j + 1]) {\n                    r.line = j + 1 + startLine;\n                    break;\n                }\n            }\n\n            saveLineNumbers(text, r, line_indexes);\n        }\n\n        return rule_node;\n    }\n\n    return {\n        /**\n         * Parses text as CSS stylesheet, remembring each rule position inside\n         * text\n         * @param {String} text CSS stylesheet to parse\n         */\n        read: function(text, startLine) {\n            var rule_start = [],\n                rule_body_start = [],\n                rules = [],\n                in_comment = 0,\n                root = rule(),\n                cur_parent = root,\n                last_rule = null,\n                stack = [],\n                ch, ch2;\n\n            stack.last = function() {\n                return this[this.length - 1];\n            };\n\n            function hasStr(pos, substr) {\n                return text.substr(pos, substr.length) == substr;\n            }\n\n            for (var i = 0, il = text.length; i < il; i++) {\n                ch = text.charAt(i);\n                ch2 = i < il - 1 ? text.charAt(i + 1) : \'\';\n\n                if (!rule_start.length)\n                    rule_start.push(i);\n\n                switch (ch) {\n                    case \'@\':\n                        if (!in_comment) {\n                            if (hasStr(i, \'@import\')) {\n                                var m = text.substr(i).match(/^@import\\s*url\\(([\'"])?.+?\\1?\\)\\;?/);\n                                if (m) {\n                                    cur_parent.addChild(i, i + 7, i + m[0].length);\n                                    i += m[0].length;\n                                    rule_start.pop();\n                                }\n                                break;\n                            }\n                        }\n                    case \'/\':\n                        // xxxpedro allowing comment inside comment\n                        if (!in_comment && ch2 == \'*\') { // comment start\n                            in_comment++;\n                        }\n                        break;\n\n                    case \'*\':\n                        if (ch2 == \'/\') { // comment end\n                            in_comment--;\n                        }\n                        break;\n\n                    case \'{\':\n                        if (!in_comment) {\n                            rule_body_start.push(i);\n\n                            cur_parent = cur_parent.addChild(rule_start.pop());\n                            stack.push(cur_parent);\n                        }\n                        break;\n\n                    case \'}\':\n                        // found the end of the rule\n                        if (!in_comment) {\n                            /** @type {rule} */\n                            var last_rule = stack.pop();\n                            rule_start.pop();\n                            last_rule.body_start = rule_body_start.pop();\n                            last_rule.end = i;\n                            cur_parent = last_rule.parent || root;\n                        }\n                        break;\n                }\n\n            }\n\n            return saveLineNumbers(text, root, null, startLine);\n        },\n\n        normalizeSelector: normalizeSelector,\n\n        /**\n         * Find matched rule by selector.\n         * @param {rule} rule_node Parsed rule node\n         * @param {String} selector CSS selector\n         * @param {String} source CSS stylesheet source code\n         *\n         * @return {rule[]|null} Array of matched rules, sorted by priority (most\n         * recent on top)\n         */\n        findBySelector: function(rule_node, selector, source) {\n            var selector = normalizeSelector(selector),\n                result = [];\n\n            if (rule_node) {\n                for (var i = 0, il = rule_node.children.length; i < il; i++) {\n                    /** @type {rule} */\n                    var r = rule_node.children[i];\n                    if (r.selector == selector) {\n                        result.push(r);\n                    }\n                }\n            }\n\n            if (result.length) {\n                return result;\n            } else {\n                return null;\n            }\n        }\n    };\n})();\n\n\n// ************************************************************************************************\n\nFBL.CssParser = CssParser;\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// StyleSheet Parser\n\nvar CssAnalyzer = {};\n\n// ************************************************************************************************\n// Locals\n\nvar CSSRuleMap = {};\nvar ElementCSSRulesMap = {};\n\nvar internalStyleSheetIndex = -1;\n\nvar reSelectorTag = /(^|\\s)(?:\\w+)/g;\nvar reSelectorClass = /\\.[\\w\\d_-]+/g;\nvar reSelectorId = /#[\\w\\d_-]+/g;\n\nvar globalCSSRuleIndex;\n\nvar processAllStyleSheetsTimeout = null;\n\nvar externalStyleSheetURLs = [];\n\nvar ElementCache = Firebug.Lite.Cache.Element;\nvar StyleSheetCache = Firebug.Lite.Cache.StyleSheet;\n\n//************************************************************************************************\n// CSS Analyzer templates\n\nCssAnalyzer.externalStyleSheetWarning = domplate(Firebug.Rep,\n{\n    tag:\n        DIV({"class": "warning focusRow", style: "font-weight:normal;", role: \'listitem\'},\n            SPAN("$object|STR"),\n            A({"href": "$href", target:"_blank"}, "$link|STR")\n        )\n});\n\n// ************************************************************************************************\n// CSS Analyzer methods\n\nCssAnalyzer.processAllStyleSheets = function(doc, styleSheetIterator)\n{\n    try\n    {\n        processAllStyleSheets(doc, styleSheetIterator);\n    }\n    catch(e)\n    {\n        // TODO: FBTrace condition\n        FBTrace.sysout("CssAnalyzer.processAllStyleSheets fails: ", e);\n    }\n};\n\n/**\n *\n * @param element\n * @returns {String[]} Array of IDs of CSS Rules\n */\nCssAnalyzer.getElementCSSRules = function(element)\n{\n    try\n    {\n        return getElementCSSRules(element);\n    }\n    catch(e)\n    {\n        // TODO: FBTrace condition\n        FBTrace.sysout("CssAnalyzer.getElementCSSRules fails: ", e);\n    }\n};\n\nCssAnalyzer.getRuleData = function(ruleId)\n{\n    return CSSRuleMap[ruleId];\n};\n\n// TODO: do we need this?\nCssAnalyzer.getRuleLine = function()\n{\n};\n\nCssAnalyzer.hasExternalStyleSheet = function()\n{\n    return externalStyleSheetURLs.length > 0;\n};\n\nCssAnalyzer.parseStyleSheet = function(href)\n{\n    var sourceData = extractSourceData(href);\n    var parsedObj = CssParser.read(sourceData.source, sourceData.startLine);\n    var parsedRules = parsedObj.children;\n\n    // See: Issue 4776: [Firebug lite] CSS Media Types\n    //\n    // Ignore all special selectors like @media and @page\n    for(var i=0; i < parsedRules.length; )\n    {\n        if (parsedRules[i].selector.indexOf("@") != -1)\n        {\n            parsedRules.splice(i, 1);\n        }\n        else\n            i++;\n    }\n\n    return parsedRules;\n};\n\n//************************************************************************************************\n// Internals\n//************************************************************************************************\n\n// ************************************************************************************************\n// StyleSheet processing\n\nvar processAllStyleSheets = function(doc, styleSheetIterator)\n{\n    styleSheetIterator = styleSheetIterator || processStyleSheet;\n\n    globalCSSRuleIndex = -1;\n\n    var styleSheets = doc.styleSheets;\n    var importedStyleSheets = [];\n\n    if (FBTrace.DBG_CSS)\n        var start = new Date().getTime();\n\n    for(var i=0, length=styleSheets.length; i<length; i++)\n    {\n        try\n        {\n            var styleSheet = styleSheets[i];\n\n            if ("firebugIgnore" in styleSheet) continue;\n\n            // we must read the length to make sure we have permission to read\n            // the stylesheet\'s content. If an error occurs here, we cannot\n            // read the stylesheet due to access restriction policy\n            var rules = isIE ? styleSheet.rules : styleSheet.cssRules;\n            rules.length;\n        }\n        catch(e)\n        {\n            externalStyleSheetURLs.push(styleSheet.href);\n            styleSheet.restricted = true;\n            var ssid = StyleSheetCache(styleSheet);\n\n            /// TODO: xxxpedro external css\n            //loadExternalStylesheet(doc, styleSheetIterator, styleSheet);\n        }\n\n        // process internal and external styleSheets\n        styleSheetIterator(doc, styleSheet);\n\n        var importedStyleSheet, importedRules;\n\n        // process imported styleSheets in IE\n        if (isIE)\n        {\n            var imports = styleSheet.imports;\n\n            for(var j=0, importsLength=imports.length; j<importsLength; j++)\n            {\n                try\n                {\n                    importedStyleSheet = imports[j];\n                    // we must read the length to make sure we have permission\n                    // to read the imported stylesheet\'s content.\n                    importedRules = importedStyleSheet.rules;\n                    importedRules.length;\n                }\n                catch(e)\n                {\n                    externalStyleSheetURLs.push(styleSheet.href);\n                    importedStyleSheet.restricted = true;\n                    var ssid = StyleSheetCache(importedStyleSheet);\n                }\n\n                styleSheetIterator(doc, importedStyleSheet);\n            }\n        }\n        // process imported styleSheets in other browsers\n        else if (rules)\n        {\n            for(var j=0, rulesLength=rules.length; j<rulesLength; j++)\n            {\n                try\n                {\n                    var rule = rules[j];\n\n                    importedStyleSheet = rule.styleSheet;\n\n                    if (importedStyleSheet)\n                    {\n                        // we must read the length to make sure we have permission\n                        // to read the imported stylesheet\'s content.\n                        importedRules = importedStyleSheet.cssRules;\n                        importedRules.length;\n                    }\n                    else\n                        break;\n                }\n                catch(e)\n                {\n                    externalStyleSheetURLs.push(styleSheet.href);\n                    importedStyleSheet.restricted = true;\n                    var ssid = StyleSheetCache(importedStyleSheet);\n                }\n\n                styleSheetIterator(doc, importedStyleSheet);\n            }\n        }\n    };\n\n    if (FBTrace.DBG_CSS)\n    {\n        FBTrace.sysout("FBL.processAllStyleSheets", "all stylesheet rules processed in " + (new Date().getTime() - start) + "ms");\n    }\n};\n\n// ************************************************************************************************\n\nvar processStyleSheet = function(doc, styleSheet)\n{\n    if (styleSheet.restricted)\n        return;\n\n    var rules = isIE ? styleSheet.rules : styleSheet.cssRules;\n\n    var ssid = StyleSheetCache(styleSheet);\n\n    var href = styleSheet.href;\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // CSS Parser\n    var shouldParseCSS = typeof CssParser != "undefined" && !Firebug.disableResourceFetching;\n    if (shouldParseCSS)\n    {\n        try\n        {\n            var parsedRules = CssAnalyzer.parseStyleSheet(href);\n        }\n        catch(e)\n        {\n            if (FBTrace.DBG_ERRORS) FBTrace.sysout("processStyleSheet FAILS", e.message || e);\n            shouldParseCSS = false;\n        }\n        finally\n        {\n            var parsedRulesIndex = 0;\n\n            var dontSupportGroupedRules = isIE && browserVersion < 9;\n            var group = [];\n            var groupItem;\n        }\n    }\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    for (var i=0, length=rules.length; i<length; i++)\n    {\n        // TODO: xxxpedro is there a better way to cache CSS Rules? The problem is that\n        // we cannot add expando properties in the rule object in IE\n        var rid = ssid + ":" + i;\n        var rule = rules[i];\n        var selector = rule.selectorText || "";\n        var lineNo = null;\n\n        // See: Issue 4776: [Firebug lite] CSS Media Types\n        //\n        // Ignore all special selectors like @media and @page\n        if (!selector || selector.indexOf("@") != -1)\n            continue;\n\n        if (isIE)\n            selector = selector.replace(reSelectorTag, function(s){return s.toLowerCase();});\n\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n        // CSS Parser\n        if (shouldParseCSS)\n        {\n            var parsedRule = parsedRules[parsedRulesIndex];\n            var parsedSelector = parsedRule.selector;\n\n            if (dontSupportGroupedRules && parsedSelector.indexOf(",") != -1 && group.length == 0)\n                group = parsedSelector.split(",");\n\n            if (dontSupportGroupedRules && group.length > 0)\n            {\n                groupItem = group.shift();\n\n                if (CssParser.normalizeSelector(selector) == groupItem)\n                    lineNo = parsedRule.line;\n\n                if (group.length == 0)\n                    parsedRulesIndex++;\n            }\n            else if (CssParser.normalizeSelector(selector) == parsedRule.selector)\n            {\n                lineNo = parsedRule.line;\n                parsedRulesIndex++;\n            }\n        }\n        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n        CSSRuleMap[rid] =\n        {\n            styleSheetId: ssid,\n            styleSheetIndex: i,\n            order: ++globalCSSRuleIndex,\n            specificity:\n                // See: Issue 4777: [Firebug lite] Specificity of CSS Rules\n                //\n                // if it is a normal selector then calculate the specificity\n                selector && selector.indexOf(",") == -1 ?\n                getCSSRuleSpecificity(selector) :\n                // See: Issue 3262: [Firebug lite] Specificity of grouped CSS Rules\n                //\n                // if it is a grouped selector, do not calculate the specificity\n                // because the correct value will depend of the matched element.\n                // The proper specificity value for grouped selectors are calculated\n                // via getElementCSSRules(element)\n                0,\n\n            rule: rule,\n            lineNo: lineNo,\n            selector: selector,\n            cssText: rule.style ? rule.style.cssText : rule.cssText ? rule.cssText : ""\n        };\n\n        // TODO: what happens with elements added after this? Need to create a test case.\n        // Maybe we should place this at getElementCSSRules() but it will make the function\n        // a lot more expensive.\n        //\n        // Maybe add a "refresh" button?\n        var elements = Firebug.Selector(selector, doc);\n\n        for (var j=0, elementsLength=elements.length; j<elementsLength; j++)\n        {\n            var element = elements[j];\n            var eid = ElementCache(element);\n\n            if (!ElementCSSRulesMap[eid])\n                ElementCSSRulesMap[eid] = [];\n\n            ElementCSSRulesMap[eid].push(rid);\n        }\n\n        //console.log(selector, elements);\n    }\n};\n\n// ************************************************************************************************\n// External StyleSheet Loader\n\nvar loadExternalStylesheet = function(doc, styleSheetIterator, styleSheet)\n{\n    var url = styleSheet.href;\n    styleSheet.firebugIgnore = true;\n\n    var source = Firebug.Lite.Proxy.load(url);\n\n    // TODO: check for null and error responses\n\n    // remove comments\n    //var reMultiComment = /(\\/\\*([^\\*]|\\*(?!\\/))*\\*\\/)/g;\n    //source = source.replace(reMultiComment, "");\n\n    // convert relative addresses to absolute ones\n    source = source.replace(/url\\(([^\\)]+)\\)/g, function(a,name){\n\n        var hasDomain = /\\w+:\\/\\/./.test(name);\n\n        if (!hasDomain)\n        {\n            name = name.replace(/^(["\'])(.+)\\1$/, "$2");\n            var first = name.charAt(0);\n\n            // relative path, based on root\n            if (first == "/")\n            {\n                // TODO: xxxpedro move to lib or Firebug.Lite.something\n                // getURLRoot\n                var m = /^([^:]+:\\/{1,3}[^\\/]+)/.exec(url);\n\n                return m ?\n                    "url(" + m[1] + name + ")" :\n                    "url(" + name + ")";\n            }\n            // relative path, based on current location\n            else\n            {\n                // TODO: xxxpedro move to lib or Firebug.Lite.something\n                // getURLPath\n                var path = url.replace(/[^\\/]+\\.[\\w\\d]+(\\?.+|#.+)?$/g, "");\n\n                path = path + name;\n\n                var reBack = /[^\\/]+\\/\\.\\.\\//;\n                while(reBack.test(path))\n                {\n                    path = path.replace(reBack, "");\n                }\n\n                //console.log("url(" + path + ")");\n\n                return "url(" + path + ")";\n            }\n        }\n\n        // if it is an absolute path, there is nothing to do\n        return a;\n    });\n\n    var oldStyle = styleSheet.ownerNode;\n\n    if (!oldStyle) return;\n\n    if (!oldStyle.parentNode) return;\n\n    var style = createGlobalElement("style");\n    style.setAttribute("charset","utf-8");\n    style.setAttribute("type", "text/css");\n    style.innerHTML = source;\n\n    //debugger;\n    oldStyle.parentNode.insertBefore(style, oldStyle.nextSibling);\n    oldStyle.parentNode.removeChild(oldStyle);\n\n    doc.styleSheets[doc.styleSheets.length-1].externalURL = url;\n\n    console.log(url, "call " + externalStyleSheetURLs.length, source);\n\n    externalStyleSheetURLs.pop();\n\n    if (processAllStyleSheetsTimeout)\n    {\n        clearTimeout(processAllStyleSheetsTimeout);\n    }\n\n    processAllStyleSheetsTimeout = setTimeout(function(){\n        console.log("processing");\n        FBL.processAllStyleSheets(doc, styleSheetIterator);\n        processAllStyleSheetsTimeout = null;\n    },200);\n\n};\n\n//************************************************************************************************\n// getElementCSSRules\n\nvar getElementCSSRules = function(element)\n{\n    var eid = ElementCache(element);\n    var rules = ElementCSSRulesMap[eid];\n\n    if (!rules) return;\n\n    var arr = [element];\n    var Selector = Firebug.Selector;\n    var ruleId, rule;\n\n    // for the case of grouped selectors, we need to calculate the highest\n    // specificity within the selectors of the group that matches the element,\n    // so we can sort the rules properly without over estimating the specificity\n    // of grouped selectors\n    for (var i = 0, length = rules.length; i < length; i++)\n    {\n        ruleId = rules[i];\n        rule = CSSRuleMap[ruleId];\n\n        // check if it is a grouped selector\n        if (rule.selector.indexOf(",") != -1)\n        {\n            var selectors = rule.selector.split(",");\n            var maxSpecificity = -1;\n            var sel, spec, mostSpecificSelector;\n\n            // loop over all selectors in the group\n            for (var j, len = selectors.length; j < len; j++)\n            {\n                sel = selectors[j];\n\n                // find if the selector matches the element\n                if (Selector.matches(sel, arr).length == 1)\n                {\n                    spec = getCSSRuleSpecificity(sel);\n\n                    // find the most specific selector that macthes the element\n                    if (spec > maxSpecificity)\n                    {\n                        maxSpecificity = spec;\n                        mostSpecificSelector = sel;\n                    }\n                }\n            }\n\n            rule.specificity = maxSpecificity;\n        }\n    }\n\n    rules.sort(sortElementRules);\n    //rules.sort(solveRulesTied);\n\n    return rules;\n};\n\n// ************************************************************************************************\n// Rule Specificity\n\nvar sortElementRules = function(a, b)\n{\n    var ruleA = CSSRuleMap[a];\n    var ruleB = CSSRuleMap[b];\n\n    var specificityA = ruleA.specificity;\n    var specificityB = ruleB.specificity;\n\n    if (specificityA > specificityB)\n        return 1;\n\n    else if (specificityA < specificityB)\n        return -1;\n\n    else\n        return ruleA.order > ruleB.order ? 1 : -1;\n};\n\nvar solveRulesTied = function(a, b)\n{\n    var ruleA = CSSRuleMap[a];\n    var ruleB = CSSRuleMap[b];\n\n    if (ruleA.specificity == ruleB.specificity)\n        return ruleA.order > ruleB.order ? 1 : -1;\n\n    return null;\n};\n\nvar getCSSRuleSpecificity = function(selector)\n{\n    var match = selector.match(reSelectorTag);\n    var tagCount = match ? match.length : 0;\n\n    match = selector.match(reSelectorClass);\n    var classCount = match ? match.length : 0;\n\n    match = selector.match(reSelectorId);\n    var idCount = match ? match.length : 0;\n\n    return tagCount + 10*classCount + 100*idCount;\n};\n\n// ************************************************************************************************\n// StyleSheet data\n\nvar extractSourceData = function(href)\n{\n    var sourceData =\n    {\n        source: null,\n        startLine: 0\n    };\n\n    if (href)\n    {\n        sourceData.source = Firebug.Lite.Proxy.load(href);\n    }\n    else\n    {\n        // TODO: create extractInternalSourceData(index)\n        // TODO: pre process the position of the inline styles so this will happen only once\n        // in case of having multiple inline styles\n        var index = 0;\n        var ssIndex = ++internalStyleSheetIndex;\n        var reStyleTag = /\\<\\s*style.*\\>/gi;\n        var reEndStyleTag = /\\<\\/\\s*style.*\\>/gi;\n\n        var source = Firebug.Lite.Proxy.load(Env.browser.location.href);\n        source = source.replace(/\\n\\r|\\r\\n/g, "\\n"); // normalize line breaks\n\n        var startLine = 0;\n\n        do\n        {\n            var matchStyleTag = source.match(reStyleTag);\n            var i0 = source.indexOf(matchStyleTag[0]) + matchStyleTag[0].length;\n\n            for (var i=0; i < i0; i++)\n            {\n                if (source.charAt(i) == "\\n")\n                    startLine++;\n            }\n\n            source = source.substr(i0);\n\n            index++;\n        }\n        while (index <= ssIndex);\n\n        var matchEndStyleTag = source.match(reEndStyleTag);\n        var i1 = source.indexOf(matchEndStyleTag[0]);\n\n        var extractedSource = source.substr(0, i1);\n\n        sourceData.source = extractedSource;\n        sourceData.startLine = startLine;\n    }\n\n    return sourceData;\n};\n\n// ************************************************************************************************\n// Registration\n\nFBL.CssAnalyzer = CssAnalyzer;\n\n// ************************************************************************************************\n}});\n\n\n/* See license.txt for terms of usage */\n\n// move to FBL\n(function() {\n\n// ************************************************************************************************\n// XPath\n\n/**\n * Gets an XPath for an element which describes its hierarchical location.\n */\nthis.getElementXPath = function(element)\n{\n    try\n    {\n        if (element && element.id)\n            return \'//*[@id="\' + element.id + \'"]\';\n        else\n            return this.getElementTreeXPath(element);\n    }\n    catch(E)\n    {\n        // xxxpedro: trying to detect the mysterious error:\n        // Security error" code: "1000\n        //debugger;\n    }\n};\n\nthis.getElementTreeXPath = function(element)\n{\n    var paths = [];\n\n    for (; element && element.nodeType == 1; element = element.parentNode)\n    {\n        var index = 0;\n        var nodeName = element.nodeName;\n\n        for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling)\n        {\n            if (sibling.nodeType != 1) continue;\n\n            if (sibling.nodeName == nodeName)\n                ++index;\n        }\n\n        var tagName = element.nodeName.toLowerCase();\n        var pathIndex = (index ? "[" + (index+1) + "]" : "");\n        paths.splice(0, 0, tagName + pathIndex);\n    }\n\n    return paths.length ? "/" + paths.join("/") : null;\n};\n\nthis.getElementsByXPath = function(doc, xpath)\n{\n    var nodes = [];\n\n    try {\n        var result = doc.evaluate(xpath, doc, null, XPathResult.ANY_TYPE, null);\n        for (var item = result.iterateNext(); item; item = result.iterateNext())\n            nodes.push(item);\n    }\n    catch (exc)\n    {\n        // Invalid xpath expressions make their way here sometimes.  If that happens,\n        // we still want to return an empty set without an exception.\n    }\n\n    return nodes;\n};\n\nthis.getRuleMatchingElements = function(rule, doc)\n{\n    var css = rule.selectorText;\n    var xpath = this.cssToXPath(css);\n    return this.getElementsByXPath(doc, xpath);\n};\n\n\n}).call(FBL);\n\n\n\n\nFBL.ns(function() { with (FBL) {\n\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n\nvar toCamelCase = function toCamelCase(s)\n{\n    return s.replace(reSelectorCase, toCamelCaseReplaceFn);\n};\n\nvar toSelectorCase = function toSelectorCase(s)\n{\n  return s.replace(reCamelCase, "-$1").toLowerCase();\n\n};\n\nvar reCamelCase = /([A-Z])/g;\nvar reSelectorCase = /\\-(.)/g;\nvar toCamelCaseReplaceFn = function toCamelCaseReplaceFn(m,g)\n{\n    return g.toUpperCase();\n};\n\n// ************************************************************************************************\n\nvar ElementCache = Firebug.Lite.Cache.Element;\nvar StyleSheetCache = Firebug.Lite.Cache.StyleSheet;\n\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n// ************************************************************************************************\n\n\n// ************************************************************************************************\n// Constants\n\n//const Cc = Components.classes;\n//const Ci = Components.interfaces;\n//const nsIDOMCSSStyleRule = Ci.nsIDOMCSSStyleRule;\n//const nsIInterfaceRequestor = Ci.nsIInterfaceRequestor;\n//const nsISelectionDisplay = Ci.nsISelectionDisplay;\n//const nsISelectionController = Ci.nsISelectionController;\n\n// See: http://mxr.mozilla.org/mozilla1.9.2/source/content/events/public/nsIEventStateManager.h#153\n//const STATE_ACTIVE  = 0x01;\n//const STATE_FOCUS   = 0x02;\n//const STATE_HOVER   = 0x04;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nFirebug.SourceBoxPanel = Firebug.Panel;\n\nvar reSelectorTag = /(^|\\s)(?:\\w+)/g;\n\nvar domUtils = null;\n\nvar textContent = isIE ? "innerText" : "textContent";\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar CSSDomplateBase = {\n    isEditable: function(rule)\n    {\n        return !rule.isSystemSheet;\n    },\n    isSelectorEditable: function(rule)\n    {\n        return rule.isSelectorEditable && this.isEditable(rule);\n    }\n};\n\nvar CSSPropTag = domplate(CSSDomplateBase, {\n    tag: DIV({"class": "cssProp focusRow", $disabledStyle: "$prop.disabled",\n          $editGroup: "$rule|isEditable",\n          $cssOverridden: "$prop.overridden", role : "option"},\n        A({"class": "cssPropDisable"}, "&nbsp;&nbsp;"),\n        SPAN({"class": "cssPropName", $editable: "$rule|isEditable"}, "$prop.name"),\n        SPAN({"class": "cssColon"}, ":"),\n        SPAN({"class": "cssPropValue", $editable: "$rule|isEditable"}, "$prop.value$prop.important"),\n        SPAN({"class": "cssSemi"}, ";")\n    )\n});\n\nvar CSSRuleTag =\n    TAG("$rule.tag", {rule: "$rule"});\n\nvar CSSImportRuleTag = domplate({\n    tag: DIV({"class": "cssRule insertInto focusRow importRule", _repObject: "$rule.rule"},\n        "@import &quot;",\n        A({"class": "objectLink", _repObject: "$rule.rule.styleSheet"}, "$rule.rule.href"),\n        "&quot;;"\n    )\n});\n\nvar CSSStyleRuleTag = domplate(CSSDomplateBase, {\n    tag: DIV({"class": "cssRule insertInto",\n            $cssEditableRule: "$rule|isEditable",\n            $editGroup: "$rule|isSelectorEditable",\n            _repObject: "$rule.rule",\n            "ruleId": "$rule.id", role : \'presentation\'},\n        DIV({"class": "cssHead focusRow", role : \'listitem\'},\n            SPAN({"class": "cssSelector", $editable: "$rule|isSelectorEditable"}, "$rule.selector"), " {"\n        ),\n        DIV({role : \'group\'},\n            DIV({"class": "cssPropertyListBox", role : \'listbox\'},\n                FOR("prop", "$rule.props",\n                    TAG(CSSPropTag.tag, {rule: "$rule", prop: "$prop"})\n                )\n            )\n        ),\n        DIV({"class": "editable insertBefore", role:"presentation"}, "}")\n    )\n});\n\nvar reSplitCSS =  /(url\\("?[^"\\)]+?"?\\))|(rgb\\(.*?\\))|(#[\\dA-Fa-f]+)|(-?\\d+(\\.\\d+)?(%|[a-z]{1,2})?)|([^,\\s]+)|"(.*?)"/;\n\nvar reURL = /url\\("?([^"\\)]+)?"?\\)/;\n\nvar reRepeat = /no-repeat|repeat-x|repeat-y|repeat/;\n\n//const sothinkInstalled = !!$("swfcatcherKey_sidebar");\nvar sothinkInstalled = false;\nvar styleGroups =\n{\n    text: [\n        "font-family",\n        "font-size",\n        "font-weight",\n        "font-style",\n        "color",\n        "text-transform",\n        "text-decoration",\n        "letter-spacing",\n        "word-spacing",\n        "line-height",\n        "text-align",\n        "vertical-align",\n        "direction",\n        "column-count",\n        "column-gap",\n        "column-width"\n    ],\n\n    background: [\n        "background-color",\n        "background-image",\n        "background-repeat",\n        "background-position",\n        "background-attachment",\n        "opacity"\n    ],\n\n    box: [\n        "width",\n        "height",\n        "top",\n        "right",\n        "bottom",\n        "left",\n        "margin-top",\n        "margin-right",\n        "margin-bottom",\n        "margin-left",\n        "padding-top",\n        "padding-right",\n        "padding-bottom",\n        "padding-left",\n        "border-top-width",\n        "border-right-width",\n        "border-bottom-width",\n        "border-left-width",\n        "border-top-color",\n        "border-right-color",\n        "border-bottom-color",\n        "border-left-color",\n        "border-top-style",\n        "border-right-style",\n        "border-bottom-style",\n        "border-left-style",\n        "-moz-border-top-radius",\n        "-moz-border-right-radius",\n        "-moz-border-bottom-radius",\n        "-moz-border-left-radius",\n        "outline-top-width",\n        "outline-right-width",\n        "outline-bottom-width",\n        "outline-left-width",\n        "outline-top-color",\n        "outline-right-color",\n        "outline-bottom-color",\n        "outline-left-color",\n        "outline-top-style",\n        "outline-right-style",\n        "outline-bottom-style",\n        "outline-left-style"\n    ],\n\n    layout: [\n        "position",\n        "display",\n        "visibility",\n        "z-index",\n        "overflow-x",  // http://www.w3.org/TR/2002/WD-css3-box-20021024/#overflow\n        "overflow-y",\n        "overflow-clip",\n        "white-space",\n        "clip",\n        "float",\n        "clear",\n        "-moz-box-sizing"\n    ],\n\n    other: [\n        "cursor",\n        "list-style-image",\n        "list-style-position",\n        "list-style-type",\n        "marker-offset",\n        "user-focus",\n        "user-select",\n        "user-modify",\n        "user-input"\n    ]\n};\n\nvar styleGroupTitles =\n{\n    text: "Text",\n    background: "Background",\n    box: "Box Model",\n    layout: "Layout",\n    other: "Other"\n};\n\nFirebug.CSSModule = extend(Firebug.Module,\n{\n    freeEdit: function(styleSheet, value)\n    {\n        if (!styleSheet.editStyleSheet)\n        {\n            var ownerNode = getStyleSheetOwnerNode(styleSheet);\n            styleSheet.disabled = true;\n\n            var url = CCSV("@mozilla.org/network/standard-url;1", Components.interfaces.nsIURL);\n            url.spec = styleSheet.href;\n\n            var editStyleSheet = ownerNode.ownerDocument.createElementNS(\n                "http://www.w3.org/1999/xhtml",\n                "style");\n            unwrapObject(editStyleSheet).firebugIgnore = true;\n            editStyleSheet.setAttribute("type", "text/css");\n            editStyleSheet.setAttributeNS(\n                "http://www.w3.org/XML/1998/namespace",\n                "base",\n                url.directory);\n            if (ownerNode.hasAttribute("media"))\n            {\n              editStyleSheet.setAttribute("media", ownerNode.getAttribute("media"));\n            }\n\n            // Insert the edited stylesheet directly after the old one to ensure the styles\n            // cascade properly.\n            ownerNode.parentNode.insertBefore(editStyleSheet, ownerNode.nextSibling);\n\n            styleSheet.editStyleSheet = editStyleSheet;\n        }\n\n        styleSheet.editStyleSheet.innerHTML = value;\n        if (FBTrace.DBG_CSS)\n            FBTrace.sysout("css.saveEdit styleSheet.href:"+styleSheet.href+" got innerHTML:"+value+"\\n");\n\n        dispatch(this.fbListeners, "onCSSFreeEdit", [styleSheet, value]);\n    },\n\n    insertRule: function(styleSheet, cssText, ruleIndex)\n    {\n        if (FBTrace.DBG_CSS) FBTrace.sysout("Insert: " + ruleIndex + " " + cssText);\n        var insertIndex = styleSheet.insertRule(cssText, ruleIndex);\n\n        dispatch(this.fbListeners, "onCSSInsertRule", [styleSheet, cssText, ruleIndex]);\n\n        return insertIndex;\n    },\n\n    deleteRule: function(styleSheet, ruleIndex)\n    {\n        if (FBTrace.DBG_CSS) FBTrace.sysout("deleteRule: " + ruleIndex + " " + styleSheet.cssRules.length, styleSheet.cssRules);\n        dispatch(this.fbListeners, "onCSSDeleteRule", [styleSheet, ruleIndex]);\n\n        styleSheet.deleteRule(ruleIndex);\n    },\n\n    setProperty: function(rule, propName, propValue, propPriority)\n    {\n        var style = rule.style || rule;\n\n        // Record the original CSS text for the inline case so we can reconstruct at a later\n        // point for diffing purposes\n        var baseText = style.cssText;\n\n        // good browsers\n        if (style.getPropertyValue)\n        {\n            var prevValue = style.getPropertyValue(propName);\n            var prevPriority = style.getPropertyPriority(propName);\n\n            // XXXjoe Gecko bug workaround: Just changing priority doesn\'t have any effect\n            // unless we remove the property first\n            style.removeProperty(propName);\n\n            style.setProperty(propName, propValue, propPriority);\n        }\n        // sad browsers\n        else\n        {\n            // TODO: xxxpedro parse CSS rule to find property priority in IE?\n            //console.log(propName, propValue);\n            style[toCamelCase(propName)] = propValue;\n        }\n\n        if (propName) {\n            dispatch(this.fbListeners, "onCSSSetProperty", [style, propName, propValue, propPriority, prevValue, prevPriority, rule, baseText]);\n        }\n    },\n\n    removeProperty: function(rule, propName, parent)\n    {\n        var style = rule.style || rule;\n\n        // Record the original CSS text for the inline case so we can reconstruct at a later\n        // point for diffing purposes\n        var baseText = style.cssText;\n\n        if (style.getPropertyValue)\n        {\n\n            var prevValue = style.getPropertyValue(propName);\n            var prevPriority = style.getPropertyPriority(propName);\n\n            style.removeProperty(propName);\n        }\n        else\n        {\n            style[toCamelCase(propName)] = "";\n        }\n\n        if (propName) {\n            dispatch(this.fbListeners, "onCSSRemoveProperty", [style, propName, prevValue, prevPriority, rule, baseText]);\n        }\n    }/*,\n\n    cleanupSheets: function(doc, context)\n    {\n        // Due to the manner in which the layout engine handles multiple\n        // references to the same sheet we need to kick it a little bit.\n        // The injecting a simple stylesheet then removing it will force\n        // Firefox to regenerate it\'s CSS hierarchy.\n        //\n        // WARN: This behavior was determined anecdotally.\n        // See http://code.google.com/p/fbug/issues/detail?id=2440\n        var style = doc.createElementNS("http://www.w3.org/1999/xhtml", "style");\n        style.setAttribute("charset","utf-8");\n        unwrapObject(style).firebugIgnore = true;\n        style.setAttribute("type", "text/css");\n        style.innerHTML = "#fbIgnoreStyleDO_NOT_USE {}";\n        addStyleSheet(doc, style);\n        style.parentNode.removeChild(style);\n\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=500365\n        // This voodoo touches each style sheet to force some Firefox internal change to allow edits.\n        var styleSheets = getAllStyleSheets(context);\n        for(var i = 0; i < styleSheets.length; i++)\n        {\n            try\n            {\n                var rules = styleSheets[i].cssRules;\n                if (rules.length > 0)\n                    var touch = rules[0];\n                if (FBTrace.DBG_CSS && touch)\n                    FBTrace.sysout("css.show() touch "+typeof(touch)+" in "+(styleSheets[i].href?styleSheets[i].href:context.getName()));\n            }\n            catch(e)\n            {\n                if (FBTrace.DBG_ERRORS)\n                    FBTrace.sysout("css.show: sheet.cssRules FAILS for "+(styleSheets[i]?styleSheets[i].href:"null sheet")+e, e);\n            }\n        }\n    },\n    cleanupSheetHandler: function(event, context)\n    {\n        var target = event.target || event.srcElement,\n            tagName = (target.tagName || "").toLowerCase();\n        if (tagName == "link")\n        {\n            this.cleanupSheets(target.ownerDocument, context);\n        }\n    },\n    watchWindow: function(context, win)\n    {\n        var cleanupSheets = bind(this.cleanupSheets, this),\n            cleanupSheetHandler = bind(this.cleanupSheetHandler, this, context),\n            doc = win.document;\n\n        //doc.addEventListener("DOMAttrModified", cleanupSheetHandler, false);\n        //doc.addEventListener("DOMNodeInserted", cleanupSheetHandler, false);\n    },\n    loadedContext: function(context)\n    {\n        var self = this;\n        iterateWindows(context.browser.contentWindow, function(subwin)\n        {\n            self.cleanupSheets(subwin.document, context);\n        });\n    }\n    /**/\n});\n\n// ************************************************************************************************\n\nFirebug.CSSStyleSheetPanel = function() {};\n\nFirebug.CSSStyleSheetPanel.prototype = extend(Firebug.SourceBoxPanel,\n{\n    template: domplate(\n    {\n        tag:\n            DIV({"class": "cssSheet insertInto a11yCSSView"},\n                FOR("rule", "$rules",\n                    CSSRuleTag\n                ),\n                DIV({"class": "cssSheet editable insertBefore"}, "")\n                )\n    }),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    refresh: function()\n    {\n        if (this.location)\n            this.updateLocation(this.location);\n        else if (this.selection)\n            this.updateSelection(this.selection);\n    },\n\n    toggleEditing: function()\n    {\n        if (!this.stylesheetEditor)\n            this.stylesheetEditor = new StyleSheetEditor(this.document);\n\n        if (this.editing)\n            Firebug.Editor.stopEditing();\n        else\n        {\n            if (!this.location)\n                return;\n\n            var styleSheet = this.location.editStyleSheet\n                ? this.location.editStyleSheet.sheet\n                : this.location;\n\n            var css = getStyleSheetCSS(styleSheet, this.context);\n            //var topmost = getTopmostRuleLine(this.panelNode);\n\n            this.stylesheetEditor.styleSheet = this.location;\n            Firebug.Editor.startEditing(this.panelNode, css, this.stylesheetEditor);\n            //this.stylesheetEditor.scrollToLine(topmost.line, topmost.offset);\n        }\n    },\n\n    getStylesheetURL: function(rule)\n    {\n        if (this.location.href)\n            return this.location.href;\n        else\n            return this.context.window.location.href;\n    },\n\n    getRuleByLine: function(styleSheet, line)\n    {\n        if (!domUtils)\n            return null;\n\n        var cssRules = styleSheet.cssRules;\n        for (var i = 0; i < cssRules.length; ++i)\n        {\n            var rule = cssRules[i];\n            if (rule instanceof CSSStyleRule)\n            {\n                var ruleLine = domUtils.getRuleLine(rule);\n                if (ruleLine >= line)\n                    return rule;\n            }\n        }\n    },\n\n    highlightRule: function(rule)\n    {\n        var ruleElement = Firebug.getElementByRepObject(this.panelNode.firstChild, rule);\n        if (ruleElement)\n        {\n            scrollIntoCenterView(ruleElement, this.panelNode);\n            setClassTimed(ruleElement, "jumpHighlight", this.context);\n        }\n    },\n\n    getStyleSheetRules: function(context, styleSheet)\n    {\n        var isSystemSheet = isSystemStyleSheet(styleSheet);\n\n        function appendRules(cssRules)\n        {\n            for (var i = 0; i < cssRules.length; ++i)\n            {\n                var rule = cssRules[i];\n\n                // TODO: xxxpedro opera instanceof stylesheet remove the following comments when\n                // the issue with opera and style sheet Classes has been solved.\n\n                //if (rule instanceof CSSStyleRule)\n                if (instanceOf(rule, "CSSStyleRule"))\n                {\n                    var props = this.getRuleProperties(context, rule);\n                    //var line = domUtils.getRuleLine(rule);\n                    var line = null;\n\n                    var selector = rule.selectorText;\n\n                    if (isIE)\n                    {\n                        selector = selector.replace(reSelectorTag,\n                                function(s){return s.toLowerCase();});\n                    }\n\n                    var ruleId = rule.selectorText+"/"+line;\n                    rules.push({tag: CSSStyleRuleTag.tag, rule: rule, id: ruleId,\n                                selector: selector, props: props,\n                                isSystemSheet: isSystemSheet,\n                                isSelectorEditable: true});\n                }\n                //else if (rule instanceof CSSImportRule)\n                else if (instanceOf(rule, "CSSImportRule"))\n                    rules.push({tag: CSSImportRuleTag.tag, rule: rule});\n                //else if (rule instanceof CSSMediaRule)\n                else if (instanceOf(rule, "CSSMediaRule"))\n                    appendRules.apply(this, [rule.cssRules]);\n                else\n                {\n                    if (FBTrace.DBG_ERRORS || FBTrace.DBG_CSS)\n                        FBTrace.sysout("css getStyleSheetRules failed to classify a rule ", rule);\n                }\n            }\n        }\n\n        var rules = [];\n        appendRules.apply(this, [styleSheet.cssRules || styleSheet.rules]);\n        return rules;\n    },\n\n    parseCSSProps: function(style, inheritMode)\n    {\n        var props = [];\n\n        if (Firebug.expandShorthandProps)\n        {\n            var count = style.length-1,\n                index = style.length;\n            while (index--)\n            {\n                var propName = style.item(count - index);\n                this.addProperty(propName, style.getPropertyValue(propName), !!style.getPropertyPriority(propName), false, inheritMode, props);\n            }\n        }\n        else\n        {\n            var lines = style.cssText.match(/(?:[^;\\(]*(?:\\([^\\)]*?\\))?[^;\\(]*)*;?/g);\n            var propRE = /\\s*([^:\\s]*)\\s*:\\s*(.*?)\\s*(! important)?;?$/;\n            var line,i=0;\n            // TODO: xxxpedro port to firebug: variable leaked into global namespace\n            var m;\n\n            while(line=lines[i++]){\n                m = propRE.exec(line);\n                if(!m)\n                    continue;\n                //var name = m[1], value = m[2], important = !!m[3];\n                if (m[2])\n                    this.addProperty(m[1], m[2], !!m[3], false, inheritMode, props);\n            };\n        }\n\n        return props;\n    },\n\n    getRuleProperties: function(context, rule, inheritMode)\n    {\n        var props = this.parseCSSProps(rule.style, inheritMode);\n\n        // TODO: xxxpedro port to firebug: variable leaked into global namespace\n        //var line = domUtils.getRuleLine(rule);\n        var line;\n        var ruleId = rule.selectorText+"/"+line;\n        this.addOldProperties(context, ruleId, inheritMode, props);\n        sortProperties(props);\n\n        return props;\n    },\n\n    addOldProperties: function(context, ruleId, inheritMode, props)\n    {\n        if (context.selectorMap && context.selectorMap.hasOwnProperty(ruleId) )\n        {\n            var moreProps = context.selectorMap[ruleId];\n            for (var i = 0; i < moreProps.length; ++i)\n            {\n                var prop = moreProps[i];\n                this.addProperty(prop.name, prop.value, prop.important, true, inheritMode, props);\n            }\n        }\n    },\n\n    addProperty: function(name, value, important, disabled, inheritMode, props)\n    {\n        name = name.toLowerCase();\n\n        if (inheritMode && !inheritedStyleNames[name])\n            return;\n\n        name = this.translateName(name, value);\n        if (name)\n        {\n            value = stripUnits(rgbToHex(value));\n            important = important ? " !important" : "";\n\n            var prop = {name: name, value: value, important: important, disabled: disabled};\n            props.push(prop);\n        }\n    },\n\n    translateName: function(name, value)\n    {\n        // Don\'t show these proprietary Mozilla properties\n        if ((value == "-moz-initial"\n            && (name == "-moz-background-clip" || name == "-moz-background-origin"\n                || name == "-moz-background-inline-policy"))\n        || (value == "physical"\n            && (name == "margin-left-ltr-source" || name == "margin-left-rtl-source"\n                || name == "margin-right-ltr-source" || name == "margin-right-rtl-source"))\n        || (value == "physical"\n            && (name == "padding-left-ltr-source" || name == "padding-left-rtl-source"\n                || name == "padding-right-ltr-source" || name == "padding-right-rtl-source")))\n            return null;\n\n        // Translate these back to the form the user probably expects\n        if (name == "margin-left-value")\n            return "margin-left";\n        else if (name == "margin-right-value")\n            return "margin-right";\n        else if (name == "margin-top-value")\n            return "margin-top";\n        else if (name == "margin-bottom-value")\n            return "margin-bottom";\n        else if (name == "padding-left-value")\n            return "padding-left";\n        else if (name == "padding-right-value")\n            return "padding-right";\n        else if (name == "padding-top-value")\n            return "padding-top";\n        else if (name == "padding-bottom-value")\n            return "padding-bottom";\n        // XXXjoe What about border!\n        else\n            return name;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    editElementStyle: function()\n    {\n        ///var rulesBox = this.panelNode.getElementsByClassName("cssElementRuleContainer")[0];\n        var rulesBox = $$(".cssElementRuleContainer", this.panelNode)[0];\n        var styleRuleBox = rulesBox && Firebug.getElementByRepObject(rulesBox, this.selection);\n        if (!styleRuleBox)\n        {\n            var rule = {rule: this.selection, inherited: false, selector: "element.style", props: []};\n            if (!rulesBox)\n            {\n                // The element did not have any displayed styles. We need to create the whole tree and remove\n                // the no styles message\n                styleRuleBox = this.template.cascadedTag.replace({\n                    rules: [rule], inherited: [], inheritLabel: "Inherited from" // $STR("InheritedFrom")\n                }, this.panelNode);\n\n                ///styleRuleBox = styleRuleBox.getElementsByClassName("cssElementRuleContainer")[0];\n                styleRuleBox = $$(".cssElementRuleContainer", styleRuleBox)[0];\n            }\n            else\n                styleRuleBox = this.template.ruleTag.insertBefore({rule: rule}, rulesBox);\n\n            ///styleRuleBox = styleRuleBox.getElementsByClassName("insertInto")[0];\n            styleRuleBox = $$(".insertInto", styleRuleBox)[0];\n        }\n\n        Firebug.Editor.insertRowForObject(styleRuleBox);\n    },\n\n    insertPropertyRow: function(row)\n    {\n        Firebug.Editor.insertRowForObject(row);\n    },\n\n    insertRule: function(row)\n    {\n        var location = getAncestorByClass(row, "cssRule");\n        if (!location)\n        {\n            location = getChildByClass(this.panelNode, "cssSheet");\n            Firebug.Editor.insertRowForObject(location);\n        }\n        else\n        {\n            Firebug.Editor.insertRow(location, "before");\n        }\n    },\n\n    editPropertyRow: function(row)\n    {\n        var propValueBox = getChildByClass(row, "cssPropValue");\n        Firebug.Editor.startEditing(propValueBox);\n    },\n\n    deletePropertyRow: function(row)\n    {\n        var rule = Firebug.getRepObject(row);\n        var propName = getChildByClass(row, "cssPropName")[textContent];\n        Firebug.CSSModule.removeProperty(rule, propName);\n\n        // Remove the property from the selector map, if it was disabled\n        var ruleId = Firebug.getRepNode(row).getAttribute("ruleId");\n        if ( this.context.selectorMap && this.context.selectorMap.hasOwnProperty(ruleId) )\n        {\n            var map = this.context.selectorMap[ruleId];\n            for (var i = 0; i < map.length; ++i)\n            {\n                if (map[i].name == propName)\n                {\n                    map.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        if (this.name == "stylesheet")\n            dispatch([Firebug.A11yModel], \'onInlineEditorClose\', [this, row.firstChild, true]);\n        row.parentNode.removeChild(row);\n\n        this.markChange(this.name == "stylesheet");\n    },\n\n    disablePropertyRow: function(row)\n    {\n        toggleClass(row, "disabledStyle");\n\n        var rule = Firebug.getRepObject(row);\n        var propName = getChildByClass(row, "cssPropName")[textContent];\n\n        if (!this.context.selectorMap)\n            this.context.selectorMap = {};\n\n        // XXXjoe Generate unique key for elements too\n        var ruleId = Firebug.getRepNode(row).getAttribute("ruleId");\n        if (!(this.context.selectorMap.hasOwnProperty(ruleId)))\n            this.context.selectorMap[ruleId] = [];\n\n        var map = this.context.selectorMap[ruleId];\n        var propValue = getChildByClass(row, "cssPropValue")[textContent];\n        var parsedValue = parsePriority(propValue);\n        if (hasClass(row, "disabledStyle"))\n        {\n            Firebug.CSSModule.removeProperty(rule, propName);\n\n            map.push({"name": propName, "value": parsedValue.value,\n                "important": parsedValue.priority});\n        }\n        else\n        {\n            Firebug.CSSModule.setProperty(rule, propName, parsedValue.value, parsedValue.priority);\n\n            var index = findPropByName(map, propName);\n            map.splice(index, 1);\n        }\n\n        this.markChange(this.name == "stylesheet");\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onMouseDown: function(event)\n    {\n        //console.log("onMouseDown", event.target || event.srcElement, event);\n\n        // xxxpedro adjusting coordinates because the panel isn\'t a window yet\n        var offset = event.clientX - this.panelNode.parentNode.offsetLeft;\n\n        // XXjoe Hack to only allow clicking on the checkbox\n        if (!isLeftClick(event) || offset > 20)\n            return;\n\n        var target = event.target || event.srcElement;\n        if (hasClass(target, "textEditor"))\n            return;\n\n        var row = getAncestorByClass(target, "cssProp");\n        if (row && hasClass(row, "editGroup"))\n        {\n            this.disablePropertyRow(row);\n            cancelEvent(event);\n        }\n    },\n\n    onDoubleClick: function(event)\n    {\n        //console.log("onDoubleClick", event.target || event.srcElement, event);\n\n        // xxxpedro adjusting coordinates because the panel isn\'t a window yet\n        var offset = event.clientX - this.panelNode.parentNode.offsetLeft;\n\n        if (!isLeftClick(event) || offset <= 20)\n            return;\n\n        var target = event.target || event.srcElement;\n\n        //console.log("ok", target, hasClass(target, "textEditorInner"), !isLeftClick(event), offset <= 20);\n\n        // if the inline editor was clicked, don\'t insert a new rule\n        if (hasClass(target, "textEditorInner"))\n            return;\n\n        var row = getAncestorByClass(target, "cssRule");\n        if (row && !getAncestorByClass(target, "cssPropName")\n            && !getAncestorByClass(target, "cssPropValue"))\n        {\n            this.insertPropertyRow(row);\n            cancelEvent(event);\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    name: "stylesheet",\n    title: "CSS",\n    parentPanel: null,\n    searchable: true,\n    dependents: ["css", "stylesheet", "dom", "domSide", "layout"],\n\n    options:\n    {\n        hasToolButtons: true\n    },\n\n    create: function()\n    {\n        Firebug.Panel.create.apply(this, arguments);\n\n        this.onMouseDown = bind(this.onMouseDown, this);\n        this.onDoubleClick = bind(this.onDoubleClick, this);\n\n        if (this.name == "stylesheet")\n        {\n            this.onChangeSelect = bind(this.onChangeSelect, this);\n\n            var doc = Firebug.browser.document;\n            var selectNode = this.selectNode = createElement("select");\n\n            CssAnalyzer.processAllStyleSheets(doc, function(doc, styleSheet)\n            {\n                var key = StyleSheetCache.key(styleSheet);\n                var fileName = getFileName(styleSheet.href) || getFileName(doc.location.href);\n                var option = createElement("option", {value: key});\n\n                option.appendChild(Firebug.chrome.document.createTextNode(fileName));\n                selectNode.appendChild(option);\n            });\n\n            this.toolButtonsNode.appendChild(selectNode);\n        }\n        /**/\n    },\n\n    onChangeSelect: function(event)\n    {\n        event = event || window.event;\n        var target = event.srcElement || event.currentTarget;\n        var key = target.value;\n        var styleSheet = StyleSheetCache.get(key);\n\n        this.updateLocation(styleSheet);\n    },\n\n    initialize: function()\n    {\n        Firebug.Panel.initialize.apply(this, arguments);\n\n        //if (!domUtils)\n        //{\n        //    try {\n        //        domUtils = CCSV("@mozilla.org/inspector/dom-utils;1", "inIDOMUtils");\n        //    } catch (exc) {\n        //        if (FBTrace.DBG_ERRORS)\n        //            FBTrace.sysout("@mozilla.org/inspector/dom-utils;1 FAILED to load: "+exc, exc);\n        //    }\n        //}\n\n        //TODO: xxxpedro\n        this.context = Firebug.chrome; // TODO: xxxpedro css2\n        this.document = Firebug.chrome.document; // TODO: xxxpedro css2\n\n        this.initializeNode();\n\n        if (this.name == "stylesheet")\n        {\n            var styleSheets = Firebug.browser.document.styleSheets;\n\n            if (styleSheets.length > 0)\n            {\n                addEvent(this.selectNode, "change", this.onChangeSelect);\n\n                this.updateLocation(styleSheets[0]);\n            }\n        }\n\n        //Firebug.SourceBoxPanel.initialize.apply(this, arguments);\n    },\n\n    shutdown: function()\n    {\n        // must destroy the editor when we leave the panel to avoid problems (Issue 2981)\n        Firebug.Editor.stopEditing();\n\n        if (this.name == "stylesheet")\n        {\n            removeEvent(this.selectNode, "change", this.onChangeSelect);\n        }\n\n        this.destroyNode();\n\n        Firebug.Panel.shutdown.apply(this, arguments);\n    },\n\n    destroy: function(state)\n    {\n        //state.scrollTop = this.panelNode.scrollTop ? this.panelNode.scrollTop : this.lastScrollTop;\n\n        //persistObjects(this, state);\n\n        // xxxpedro we are stopping the editor in the shutdown method already\n        //Firebug.Editor.stopEditing();\n        Firebug.Panel.destroy.apply(this, arguments);\n    },\n\n    initializeNode: function(oldPanelNode)\n    {\n        addEvent(this.panelNode, "mousedown", this.onMouseDown);\n        addEvent(this.panelNode, "dblclick", this.onDoubleClick);\n        //Firebug.SourceBoxPanel.initializeNode.apply(this, arguments);\n        //dispatch([Firebug.A11yModel], \'onInitializeNode\', [this, \'css\']);\n    },\n\n    destroyNode: function()\n    {\n        removeEvent(this.panelNode, "mousedown", this.onMouseDown);\n        removeEvent(this.panelNode, "dblclick", this.onDoubleClick);\n        //Firebug.SourceBoxPanel.destroyNode.apply(this, arguments);\n        //dispatch([Firebug.A11yModel], \'onDestroyNode\', [this, \'css\']);\n    },\n\n    ishow: function(state)\n    {\n        Firebug.Inspector.stopInspecting(true);\n\n        this.showToolbarButtons("fbCSSButtons", true);\n\n        if (this.context.loaded && !this.location) // wait for loadedContext to restore the panel\n        {\n            restoreObjects(this, state);\n\n            if (!this.location)\n                this.location = this.getDefaultLocation();\n\n            if (state && state.scrollTop)\n                this.panelNode.scrollTop = state.scrollTop;\n        }\n    },\n\n    ihide: function()\n    {\n        this.showToolbarButtons("fbCSSButtons", false);\n\n        this.lastScrollTop = this.panelNode.scrollTop;\n    },\n\n    supportsObject: function(object)\n    {\n        if (object instanceof CSSStyleSheet)\n            return 1;\n        else if (object instanceof CSSStyleRule)\n            return 2;\n        else if (object instanceof CSSStyleDeclaration)\n            return 2;\n        else if (object instanceof SourceLink && object.type == "css" && reCSS.test(object.href))\n            return 2;\n        else\n            return 0;\n    },\n\n    updateLocation: function(styleSheet)\n    {\n        if (!styleSheet)\n            return;\n        if (styleSheet.editStyleSheet)\n            styleSheet = styleSheet.editStyleSheet.sheet;\n\n        // if it is a restricted stylesheet, show the warning message and abort the update process\n        if (styleSheet.restricted)\n        {\n            FirebugReps.Warning.tag.replace({object: "AccessRestricted"}, this.panelNode);\n\n            // TODO: xxxpedro remove when there the external resource problem is fixed\n            CssAnalyzer.externalStyleSheetWarning.tag.append({\n                object: "The stylesheet could not be loaded due to access restrictions. ",\n                link: "more...",\n                href: "http://getfirebug.com/wiki/index.php/Firebug_Lite_FAQ#I_keep_seeing_.22Access_to_restricted_URI_denied.22"\n            }, this.panelNode);\n\n            return;\n        }\n\n        var rules = this.getStyleSheetRules(this.context, styleSheet);\n\n        var result;\n        if (rules.length)\n            // FIXME xxxpedro chromenew this is making iPad\'s Safari to crash\n            result = this.template.tag.replace({rules: rules}, this.panelNode);\n        else\n            result = FirebugReps.Warning.tag.replace({object: "EmptyStyleSheet"}, this.panelNode);\n\n        // TODO: xxxpedro need to fix showToolbarButtons function\n        //this.showToolbarButtons("fbCSSButtons", !isSystemStyleSheet(this.location));\n\n        //dispatch([Firebug.A11yModel], \'onCSSRulesAdded\', [this, this.panelNode]);\n    },\n\n    updateSelection: function(object)\n    {\n        this.selection = null;\n\n        if (object instanceof CSSStyleDeclaration) {\n            object = object.parentRule;\n        }\n\n        if (object instanceof CSSStyleRule)\n        {\n            this.navigate(object.parentStyleSheet);\n            this.highlightRule(object);\n        }\n        else if (object instanceof CSSStyleSheet)\n        {\n            this.navigate(object);\n        }\n        else if (object instanceof SourceLink)\n        {\n            try\n            {\n                var sourceLink = object;\n\n                var sourceFile = getSourceFileByHref(sourceLink.href, this.context);\n                if (sourceFile)\n                {\n                    clearNode(this.panelNode);  // replace rendered stylesheets\n                    this.showSourceFile(sourceFile);\n\n                    var lineNo = object.line;\n                    if (lineNo)\n                        this.scrollToLine(lineNo, this.jumpHighlightFactory(lineNo, this.context));\n                }\n                else // XXXjjb we should not be taking this path\n                {\n                    var stylesheet = getStyleSheetByHref(sourceLink.href, this.context);\n                    if (stylesheet)\n                        this.navigate(stylesheet);\n                    else\n                    {\n                        if (FBTrace.DBG_CSS)\n                            FBTrace.sysout("css.updateSelection no sourceFile for "+sourceLink.href, sourceLink);\n                    }\n                }\n            }\n            catch(exc) {\n                if (FBTrace.DBG_CSS)\n                    FBTrace.sysout("css.upDateSelection FAILS "+exc, exc);\n            }\n        }\n    },\n\n    updateOption: function(name, value)\n    {\n        if (name == "expandShorthandProps")\n            this.refresh();\n    },\n\n    getLocationList: function()\n    {\n        var styleSheets = getAllStyleSheets(this.context);\n        return styleSheets;\n    },\n\n    getOptionsMenuItems: function()\n    {\n        return [\n            {label: "Expand Shorthand Properties", type: "checkbox", checked: Firebug.expandShorthandProps,\n                    command: bindFixed(Firebug.togglePref, Firebug, "expandShorthandProps") },\n            "-",\n            {label: "Refresh", command: bind(this.refresh, this) }\n        ];\n    },\n\n    getContextMenuItems: function(style, target)\n    {\n        var items = [];\n\n        if (this.infoTipType == "color")\n        {\n            items.push(\n                {label: "CopyColor",\n                    command: bindFixed(copyToClipboard, FBL, this.infoTipObject) }\n            );\n        }\n        else if (this.infoTipType == "image")\n        {\n            items.push(\n                {label: "CopyImageLocation",\n                    command: bindFixed(copyToClipboard, FBL, this.infoTipObject) },\n                {label: "OpenImageInNewTab",\n                    command: bindFixed(openNewTab, FBL, this.infoTipObject) }\n            );\n        }\n\n        ///if (this.selection instanceof Element)\n        if (isElement(this.selection))\n        {\n            items.push(\n                //"-",\n                {label: "EditStyle",\n                    command: bindFixed(this.editElementStyle, this) }\n            );\n        }\n        else if (!isSystemStyleSheet(this.selection))\n        {\n            items.push(\n                    //"-",\n                    {label: "NewRule",\n                        command: bindFixed(this.insertRule, this, target) }\n                );\n        }\n\n        var cssRule = getAncestorByClass(target, "cssRule");\n        if (cssRule && hasClass(cssRule, "cssEditableRule"))\n        {\n            items.push(\n                "-",\n                {label: "NewProp",\n                    command: bindFixed(this.insertPropertyRow, this, target) }\n            );\n\n            var propRow = getAncestorByClass(target, "cssProp");\n            if (propRow)\n            {\n                var propName = getChildByClass(propRow, "cssPropName")[textContent];\n                var isDisabled = hasClass(propRow, "disabledStyle");\n\n                items.push(\n                    {label: $STRF("EditProp", [propName]), nol10n: true,\n                        command: bindFixed(this.editPropertyRow, this, propRow) },\n                    {label: $STRF("DeleteProp", [propName]), nol10n: true,\n                        command: bindFixed(this.deletePropertyRow, this, propRow) },\n                    {label: $STRF("DisableProp", [propName]), nol10n: true,\n                        type: "checkbox", checked: isDisabled,\n                        command: bindFixed(this.disablePropertyRow, this, propRow) }\n                );\n            }\n        }\n\n        items.push(\n            "-",\n            {label: "Refresh", command: bind(this.refresh, this) }\n        );\n\n        return items;\n    },\n\n    browseObject: function(object)\n    {\n        if (this.infoTipType == "image")\n        {\n            openNewTab(this.infoTipObject);\n            return true;\n        }\n    },\n\n    showInfoTip: function(infoTip, target, x, y)\n    {\n        var propValue = getAncestorByClass(target, "cssPropValue");\n        if (propValue)\n        {\n            var offset = getClientOffset(propValue);\n            var offsetX = x-offset.x;\n\n            var text = propValue[textContent];\n            var charWidth = propValue.offsetWidth/text.length;\n            var charOffset = Math.floor(offsetX/charWidth);\n\n            var cssValue = parseCSSValue(text, charOffset);\n            if (cssValue)\n            {\n                if (cssValue.value == this.infoTipValue)\n                    return true;\n\n                this.infoTipValue = cssValue.value;\n\n                if (cssValue.type == "rgb" || (!cssValue.type && isColorKeyword(cssValue.value)))\n                {\n                    this.infoTipType = "color";\n                    this.infoTipObject = cssValue.value;\n\n                    return Firebug.InfoTip.populateColorInfoTip(infoTip, cssValue.value);\n                }\n                else if (cssValue.type == "url")\n                {\n                    ///var propNameNode = target.parentNode.getElementsByClassName("cssPropName").item(0);\n                    var propNameNode = getElementByClass(target.parentNode, "cssPropName");\n                    if (propNameNode && isImageRule(propNameNode[textContent]))\n                    {\n                        var rule = Firebug.getRepObject(target);\n                        var baseURL = this.getStylesheetURL(rule);\n                        var relURL = parseURLValue(cssValue.value);\n                        var absURL = isDataURL(relURL) ? relURL:absoluteURL(relURL, baseURL);\n                        var repeat = parseRepeatValue(text);\n\n                        this.infoTipType = "image";\n                        this.infoTipObject = absURL;\n\n                        return Firebug.InfoTip.populateImageInfoTip(infoTip, absURL, repeat);\n                    }\n                }\n            }\n        }\n\n        delete this.infoTipType;\n        delete this.infoTipValue;\n        delete this.infoTipObject;\n    },\n\n    getEditor: function(target, value)\n    {\n        if (target == this.panelNode\n            || hasClass(target, "cssSelector") || hasClass(target, "cssRule")\n            || hasClass(target, "cssSheet"))\n        {\n            if (!this.ruleEditor)\n                this.ruleEditor = new CSSRuleEditor(this.document);\n\n            return this.ruleEditor;\n        }\n        else\n        {\n            if (!this.editor)\n                this.editor = new CSSEditor(this.document);\n\n            return this.editor;\n        }\n    },\n\n    getDefaultLocation: function()\n    {\n        try\n        {\n            var styleSheets = this.context.window.document.styleSheets;\n            if (styleSheets.length)\n            {\n                var sheet = styleSheets[0];\n                return (Firebug.filterSystemURLs && isSystemURL(getURLForStyleSheet(sheet))) ? null : sheet;\n            }\n        }\n        catch (exc)\n        {\n            if (FBTrace.DBG_LOCATIONS)\n                FBTrace.sysout("css.getDefaultLocation FAILS "+exc, exc);\n        }\n    },\n\n    getObjectDescription: function(styleSheet)\n    {\n        var url = getURLForStyleSheet(styleSheet);\n        var instance = getInstanceForStyleSheet(styleSheet);\n\n        var baseDescription = splitURLBase(url);\n        if (instance) {\n          baseDescription.name = baseDescription.name + " #" + (instance + 1);\n        }\n        return baseDescription;\n    },\n\n    search: function(text, reverse)\n    {\n        var curDoc = this.searchCurrentDoc(!Firebug.searchGlobal, text, reverse);\n        if (!curDoc && Firebug.searchGlobal)\n        {\n            return this.searchOtherDocs(text, reverse);\n        }\n        return curDoc;\n    },\n\n    searchOtherDocs: function(text, reverse)\n    {\n        var scanRE = Firebug.Search.getTestingRegex(text);\n        function scanDoc(styleSheet) {\n            // we don\'t care about reverse here as we are just looking for existence,\n            // if we do have a result we will handle the reverse logic on display\n            for (var i = 0; i < styleSheet.cssRules.length; i++)\n            {\n                if (scanRE.test(styleSheet.cssRules[i].cssText))\n                {\n                    return true;\n                }\n            }\n        }\n\n        if (this.navigateToNextDocument(scanDoc, reverse))\n        {\n            return this.searchCurrentDoc(true, text, reverse);\n        }\n    },\n\n    searchCurrentDoc: function(wrapSearch, text, reverse)\n    {\n        if (!text)\n        {\n            delete this.currentSearch;\n            return false;\n        }\n\n        var row;\n        if (this.currentSearch && text == this.currentSearch.text)\n        {\n            row = this.currentSearch.findNext(wrapSearch, false, reverse, Firebug.Search.isCaseSensitive(text));\n        }\n        else\n        {\n            if (this.editing)\n            {\n                this.currentSearch = new TextSearch(this.stylesheetEditor.box);\n                row = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));\n\n                if (row)\n                {\n                    var sel = this.document.defaultView.getSelection();\n                    sel.removeAllRanges();\n                    sel.addRange(this.currentSearch.range);\n                    scrollSelectionIntoView(this);\n                    return true;\n                }\n                else\n                    return false;\n            }\n            else\n            {\n                function findRow(node) { return node.nodeType == 1 ? node : node.parentNode; }\n                this.currentSearch = new TextSearch(this.panelNode, findRow);\n                row = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));\n            }\n        }\n\n        if (row)\n        {\n            this.document.defaultView.getSelection().selectAllChildren(row);\n            scrollIntoCenterView(row, this.panelNode);\n            dispatch([Firebug.A11yModel], \'onCSSSearchMatchFound\', [this, text, row]);\n            return true;\n        }\n        else\n        {\n            dispatch([Firebug.A11yModel], \'onCSSSearchMatchFound\', [this, text, null]);\n            return false;\n        }\n    },\n\n    getSearchOptionsMenuItems: function()\n    {\n        return [\n            Firebug.Search.searchOptionMenu("search.Case_Sensitive", "searchCaseSensitive"),\n            Firebug.Search.searchOptionMenu("search.Multiple_Files", "searchGlobal")\n        ];\n    }\n});\n/**/\n// ************************************************************************************************\n\nfunction CSSElementPanel() {}\n\nCSSElementPanel.prototype = extend(Firebug.CSSStyleSheetPanel.prototype,\n{\n    template: domplate(\n    {\n        cascadedTag:\n            DIV({"class": "a11yCSSView",  role : \'presentation\'},\n                DIV({role : \'list\', \'aria-label\' : $STR(\'aria.labels.style rules\') },\n                    FOR("rule", "$rules",\n                        TAG("$ruleTag", {rule: "$rule"})\n                    )\n                ),\n                DIV({role : "list", \'aria-label\' :$STR(\'aria.labels.inherited style rules\')},\n                    FOR("section", "$inherited",\n                        H1({"class": "cssInheritHeader groupHeader focusRow", role : \'listitem\' },\n                            SPAN({"class": "cssInheritLabel"}, "$inheritLabel"),\n                            TAG(FirebugReps.Element.shortTag, {object: "$section.element"})\n                        ),\n                        DIV({role : \'group\'},\n                            FOR("rule", "$section.rules",\n                                TAG("$ruleTag", {rule: "$rule"})\n                            )\n                        )\n                    )\n                 )\n            ),\n\n        ruleTag:\n            isIE ?\n            // IE needs the sourceLink first, otherwise it will be rendered outside the panel\n            DIV({"class": "cssElementRuleContainer"},\n                TAG(FirebugReps.SourceLink.tag, {object: "$rule.sourceLink"}),\n                TAG(CSSStyleRuleTag.tag, {rule: "$rule"})\n            )\n            :\n            // other browsers need the sourceLink last, otherwise it will cause an extra space\n            // before the rule representation\n            DIV({"class": "cssElementRuleContainer"},\n                TAG(CSSStyleRuleTag.tag, {rule: "$rule"}),\n                TAG(FirebugReps.SourceLink.tag, {object: "$rule.sourceLink"})\n            )\n    }),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    updateCascadeView: function(element)\n    {\n        //dispatch([Firebug.A11yModel], \'onBeforeCSSRulesAdded\', [this]);\n        var rules = [], sections = [], usedProps = {};\n        this.getInheritedRules(element, sections, usedProps);\n        this.getElementRules(element, rules, usedProps);\n\n        if (rules.length || sections.length)\n        {\n            var inheritLabel = "Inherited from"; // $STR("InheritedFrom");\n            var result = this.template.cascadedTag.replace({rules: rules, inherited: sections,\n                inheritLabel: inheritLabel}, this.panelNode);\n            //dispatch([Firebug.A11yModel], \'onCSSRulesAdded\', [this, result]);\n        }\n        else\n        {\n            var result = FirebugReps.Warning.tag.replace({object: "EmptyElementCSS"}, this.panelNode);\n            //dispatch([Firebug.A11yModel], \'onCSSRulesAdded\', [this, result]);\n        }\n\n        // TODO: xxxpedro remove when there the external resource problem is fixed\n        if (CssAnalyzer.hasExternalStyleSheet())\n            CssAnalyzer.externalStyleSheetWarning.tag.append({\n                object: "The results here may be inaccurate because some " +\n                        "stylesheets could not be loaded due to access restrictions. ",\n                link: "more...",\n                href: "http://getfirebug.com/wiki/index.php/Firebug_Lite_FAQ#I_keep_seeing_.22This_element_has_no_style_rules.22"\n            }, this.panelNode);\n    },\n\n    getStylesheetURL: function(rule)\n    {\n        // if the parentStyleSheet.href is null, CSS std says its inline style.\n        // TODO: xxxpedro IE doesn\'t have rule.parentStyleSheet so we must fall back to the doc.location\n        if (rule && rule.parentStyleSheet && rule.parentStyleSheet.href)\n            return rule.parentStyleSheet.href;\n        else\n            return this.selection.ownerDocument.location.href;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getInheritedRules: function(element, sections, usedProps)\n    {\n        var parent = element.parentNode;\n        if (parent && parent.nodeType == 1)\n        {\n            this.getInheritedRules(parent, sections, usedProps);\n\n            var rules = [];\n            this.getElementRules(parent, rules, usedProps, true);\n\n            if (rules.length)\n                sections.splice(0, 0, {element: parent, rules: rules});\n        }\n    },\n\n    getElementRules: function(element, rules, usedProps, inheritMode)\n    {\n        var inspectedRules, displayedRules = {};\n\n        inspectedRules = CssAnalyzer.getElementCSSRules(element);\n\n        if (inspectedRules)\n        {\n            for (var i = 0, length=inspectedRules.length; i < length; ++i)\n            {\n                var ruleId = inspectedRules[i];\n                var ruleData = CssAnalyzer.getRuleData(ruleId);\n                var rule = ruleData.rule;\n\n                var ssid = ruleData.styleSheetId;\n                var parentStyleSheet = StyleSheetCache.get(ssid);\n\n                var href = parentStyleSheet.externalURL ? parentStyleSheet.externalURL : parentStyleSheet.href;  // Null means inline\n\n                var instance = null;\n                //var instance = getInstanceForStyleSheet(rule.parentStyleSheet, element.ownerDocument);\n\n                var isSystemSheet = false;\n                //var isSystemSheet = isSystemStyleSheet(rule.parentStyleSheet);\n\n                if (!Firebug.showUserAgentCSS && isSystemSheet) // This removes user agent rules\n                    continue;\n\n                if (!href)\n                    href = element.ownerDocument.location.href; // http://code.google.com/p/fbug/issues/detail?id=452\n\n                var props = this.getRuleProperties(this.context, rule, inheritMode);\n                if (inheritMode && !props.length)\n                    continue;\n\n                //\n                //var line = domUtils.getRuleLine(rule);\n                // TODO: xxxpedro CSS line number\n                var line = ruleData.lineNo;\n\n                var ruleId = rule.selectorText+"/"+line;\n                var sourceLink = new SourceLink(href, line, "css", rule, instance);\n\n                this.markOverridenProps(props, usedProps, inheritMode);\n\n                rules.splice(0, 0, {rule: rule, id: ruleId,\n                        selector: ruleData.selector, sourceLink: sourceLink,\n                        props: props, inherited: inheritMode,\n                        isSystemSheet: isSystemSheet});\n            }\n        }\n\n        if (element.style)\n            this.getStyleProperties(element, rules, usedProps, inheritMode);\n\n        if (FBTrace.DBG_CSS)\n            FBTrace.sysout("getElementRules "+rules.length+" rules for "+getElementXPath(element), rules);\n    },\n    /*\n    getElementRules: function(element, rules, usedProps, inheritMode)\n    {\n        var inspectedRules, displayedRules = {};\n        try\n        {\n            inspectedRules = domUtils ? domUtils.getCSSStyleRules(element) : null;\n        } catch (exc) {}\n\n        if (inspectedRules)\n        {\n            for (var i = 0; i < inspectedRules.Count(); ++i)\n            {\n                var rule = QI(inspectedRules.GetElementAt(i), nsIDOMCSSStyleRule);\n\n                var href = rule.parentStyleSheet.href;  // Null means inline\n\n                var instance = getInstanceForStyleSheet(rule.parentStyleSheet, element.ownerDocument);\n\n                var isSystemSheet = isSystemStyleSheet(rule.parentStyleSheet);\n                if (!Firebug.showUserAgentCSS && isSystemSheet) // This removes user agent rules\n                    continue;\n                if (!href)\n                    href = element.ownerDocument.location.href; // http://code.google.com/p/fbug/issues/detail?id=452\n\n                var props = this.getRuleProperties(this.context, rule, inheritMode);\n                if (inheritMode && !props.length)\n                    continue;\n\n                var line = domUtils.getRuleLine(rule);\n                var ruleId = rule.selectorText+"/"+line;\n                var sourceLink = new SourceLink(href, line, "css", rule, instance);\n\n                this.markOverridenProps(props, usedProps, inheritMode);\n\n                rules.splice(0, 0, {rule: rule, id: ruleId,\n                        selector: rule.selectorText, sourceLink: sourceLink,\n                        props: props, inherited: inheritMode,\n                        isSystemSheet: isSystemSheet});\n            }\n        }\n\n        if (element.style)\n            this.getStyleProperties(element, rules, usedProps, inheritMode);\n\n        if (FBTrace.DBG_CSS)\n            FBTrace.sysout("getElementRules "+rules.length+" rules for "+getElementXPath(element), rules);\n    },\n    /**/\n    markOverridenProps: function(props, usedProps, inheritMode)\n    {\n        for (var i = 0; i < props.length; ++i)\n        {\n            var prop = props[i];\n            if ( usedProps.hasOwnProperty(prop.name) )\n            {\n                var deadProps = usedProps[prop.name]; // all previous occurrences of this property\n                for (var j = 0; j < deadProps.length; ++j)\n                {\n                    var deadProp = deadProps[j];\n                    if (!deadProp.disabled && !deadProp.wasInherited && deadProp.important && !prop.important)\n                        prop.overridden = true;  // new occurrence overridden\n                    else if (!prop.disabled)\n                        deadProp.overridden = true;  // previous occurrences overridden\n                }\n            }\n            else\n                usedProps[prop.name] = [];\n\n            prop.wasInherited = inheritMode ? true : false;\n            usedProps[prop.name].push(prop);  // all occurrences of a property seen so far, by name\n        }\n    },\n\n    getStyleProperties: function(element, rules, usedProps, inheritMode)\n    {\n        var props = this.parseCSSProps(element.style, inheritMode);\n        this.addOldProperties(this.context, getElementXPath(element), inheritMode, props);\n\n        sortProperties(props);\n        this.markOverridenProps(props, usedProps, inheritMode);\n\n        if (props.length)\n            rules.splice(0, 0,\n                    {rule: element, id: getElementXPath(element),\n                        selector: "element.style", props: props, inherited: inheritMode});\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    name: "css",\n    title: "Style",\n    parentPanel: "HTML",\n    order: 0,\n\n    initialize: function()\n    {\n        this.context = Firebug.chrome; // TODO: xxxpedro css2\n        this.document = Firebug.chrome.document; // TODO: xxxpedro css2\n\n        Firebug.CSSStyleSheetPanel.prototype.initialize.apply(this, arguments);\n\n        // TODO: xxxpedro css2\n        var selection = ElementCache.get(Firebug.context.persistedState.selectedHTMLElementId);\n        if (selection)\n            this.select(selection, true);\n\n        //this.updateCascadeView(document.getElementsByTagName("h1")[0]);\n        //this.updateCascadeView(document.getElementById("build"));\n\n        /*\n        this.onStateChange = bindFixed(this.contentStateCheck, this);\n        this.onHoverChange = bindFixed(this.contentStateCheck, this, STATE_HOVER);\n        this.onActiveChange = bindFixed(this.contentStateCheck, this, STATE_ACTIVE);\n        /**/\n    },\n\n    ishow: function(state)\n    {\n    },\n\n    watchWindow: function(win)\n    {\n        if (domUtils)\n        {\n            // Normally these would not be required, but in order to update after the state is set\n            // using the options menu we need to monitor these global events as well\n            var doc = win.document;\n            ///addEvent(doc, "mouseover", this.onHoverChange);\n            ///addEvent(doc, "mousedown", this.onActiveChange);\n        }\n    },\n    unwatchWindow: function(win)\n    {\n        var doc = win.document;\n        ///removeEvent(doc, "mouseover", this.onHoverChange);\n        ///removeEvent(doc, "mousedown", this.onActiveChange);\n\n        if (isAncestor(this.stateChangeEl, doc))\n        {\n            this.removeStateChangeHandlers();\n        }\n    },\n\n    supportsObject: function(object)\n    {\n        return object instanceof Element ? 1 : 0;\n    },\n\n    updateView: function(element)\n    {\n        this.updateCascadeView(element);\n        if (domUtils)\n        {\n            this.contentState = safeGetContentState(element);\n            this.addStateChangeHandlers(element);\n        }\n    },\n\n    updateSelection: function(element)\n    {\n        if ( !instanceOf(element , "Element") ) // html supports SourceLink\n            return;\n\n        if (sothinkInstalled)\n        {\n            FirebugReps.Warning.tag.replace({object: "SothinkWarning"}, this.panelNode);\n            return;\n        }\n\n        /*\n        if (!domUtils)\n        {\n            FirebugReps.Warning.tag.replace({object: "DOMInspectorWarning"}, this.panelNode);\n            return;\n        }\n        /**/\n\n        if (!element)\n            return;\n\n        this.updateView(element);\n    },\n\n    updateOption: function(name, value)\n    {\n        if (name == "showUserAgentCSS" || name == "expandShorthandProps")\n            this.refresh();\n    },\n\n    getOptionsMenuItems: function()\n    {\n        var ret = [\n            {label: "Show User Agent CSS", type: "checkbox", checked: Firebug.showUserAgentCSS,\n                    command: bindFixed(Firebug.togglePref, Firebug, "showUserAgentCSS") },\n            {label: "Expand Shorthand Properties", type: "checkbox", checked: Firebug.expandShorthandProps,\n                    command: bindFixed(Firebug.togglePref, Firebug, "expandShorthandProps") }\n        ];\n        if (domUtils && this.selection)\n        {\n            var state = safeGetContentState(this.selection);\n\n            ret.push("-");\n            ret.push({label: ":active", type: "checkbox", checked: state & STATE_ACTIVE,\n              command: bindFixed(this.updateContentState, this, STATE_ACTIVE, state & STATE_ACTIVE)});\n            ret.push({label: ":hover", type: "checkbox", checked: state & STATE_HOVER,\n              command: bindFixed(this.updateContentState, this, STATE_HOVER, state & STATE_HOVER)});\n        }\n        return ret;\n    },\n\n    updateContentState: function(state, remove)\n    {\n        domUtils.setContentState(remove ? this.selection.ownerDocument.documentElement : this.selection, state);\n        this.refresh();\n    },\n\n    addStateChangeHandlers: function(el)\n    {\n      this.removeStateChangeHandlers();\n\n      /*\n      addEvent(el, "focus", this.onStateChange);\n      addEvent(el, "blur", this.onStateChange);\n      addEvent(el, "mouseup", this.onStateChange);\n      addEvent(el, "mousedown", this.onStateChange);\n      addEvent(el, "mouseover", this.onStateChange);\n      addEvent(el, "mouseout", this.onStateChange);\n      /**/\n\n      this.stateChangeEl = el;\n    },\n\n    removeStateChangeHandlers: function()\n    {\n        var sel = this.stateChangeEl;\n        if (sel)\n        {\n            /*\n            removeEvent(sel, "focus", this.onStateChange);\n            removeEvent(sel, "blur", this.onStateChange);\n            removeEvent(sel, "mouseup", this.onStateChange);\n            removeEvent(sel, "mousedown", this.onStateChange);\n            removeEvent(sel, "mouseover", this.onStateChange);\n            removeEvent(sel, "mouseout", this.onStateChange);\n            /**/\n        }\n    },\n\n    contentStateCheck: function(state)\n    {\n        if (!state || this.contentState & state)\n        {\n            var timeoutRunner = bindFixed(function()\n            {\n                var newState = safeGetContentState(this.selection);\n                if (newState != this.contentState)\n                {\n                    this.context.invalidatePanels(this.name);\n                }\n            }, this);\n\n            // Delay exec until after the event has processed and the state has been updated\n            setTimeout(timeoutRunner, 0);\n        }\n    }\n});\n\nfunction safeGetContentState(selection)\n{\n    try\n    {\n        return domUtils.getContentState(selection);\n    }\n    catch (e)\n    {\n        if (FBTrace.DBG_ERRORS)\n            FBTrace.sysout("css.safeGetContentState; EXCEPTION", e);\n    }\n}\n\n// ************************************************************************************************\n\nfunction CSSComputedElementPanel() {}\n\nCSSComputedElementPanel.prototype = extend(CSSElementPanel.prototype,\n{\n    template: domplate(\n    {\n        computedTag:\n            DIV({"class": "a11yCSSView", role : "list", "aria-label" : $STR(\'aria.labels.computed styles\')},\n                FOR("group", "$groups",\n                    H1({"class": "cssInheritHeader groupHeader focusRow", role : "listitem"},\n                        SPAN({"class": "cssInheritLabel"}, "$group.title")\n                    ),\n                    TABLE({width: "100%", role : \'group\'},\n                        TBODY({role : \'presentation\'},\n                            FOR("prop", "$group.props",\n                                TR({"class": \'focusRow computedStyleRow\', role : \'listitem\'},\n                                    TD({"class": "stylePropName", role : \'presentation\'}, "$prop.name"),\n                                    TD({"class": "stylePropValue", role : \'presentation\'}, "$prop.value")\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n    }),\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    updateComputedView: function(element)\n    {\n        var win = isIE ?\n                element.ownerDocument.parentWindow :\n                element.ownerDocument.defaultView;\n\n        var style = isIE ?\n                element.currentStyle :\n                win.getComputedStyle(element, "");\n\n        var groups = [];\n\n        for (var groupName in styleGroups)\n        {\n            // TODO: xxxpedro i18n $STR\n            //var title = $STR("StyleGroup-" + groupName);\n            var title = styleGroupTitles[groupName];\n            var group = {title: title, props: []};\n            groups.push(group);\n\n            var props = styleGroups[groupName];\n            for (var i = 0; i < props.length; ++i)\n            {\n                var propName = props[i];\n                var propValue = style.getPropertyValue ?\n                        style.getPropertyValue(propName) :\n                        ""+style[toCamelCase(propName)];\n\n                if (propValue === undefined || propValue === null)\n                    continue;\n\n                propValue = stripUnits(rgbToHex(propValue));\n                if (propValue)\n                    group.props.push({name: propName, value: propValue});\n            }\n        }\n\n        var result = this.template.computedTag.replace({groups: groups}, this.panelNode);\n        //dispatch([Firebug.A11yModel], \'onCSSRulesAdded\', [this, result]);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    name: "computed",\n    title: "Computed",\n    parentPanel: "HTML",\n    order: 1,\n\n    updateView: function(element)\n    {\n        this.updateComputedView(element);\n    },\n\n    getOptionsMenuItems: function()\n    {\n        return [\n            {label: "Refresh", command: bind(this.refresh, this) }\n        ];\n    }\n});\n\n// ************************************************************************************************\n// CSSEditor\n\nfunction CSSEditor(doc)\n{\n    this.initializeInline(doc);\n}\n\nCSSEditor.prototype = domplate(Firebug.InlineEditor.prototype,\n{\n    insertNewRow: function(target, insertWhere)\n    {\n        var rule = Firebug.getRepObject(target);\n        var emptyProp =\n        {\n            // TODO: xxxpedro - uses charCode(255) to force the element being rendered,\n            // allowing webkit to get the correct position of the property name "span",\n            // when inserting a new CSS rule?\n            name: "",\n            value: "",\n            important: ""\n        };\n\n        if (insertWhere == "before")\n            return CSSPropTag.tag.insertBefore({prop: emptyProp, rule: rule}, target);\n        else\n            return CSSPropTag.tag.insertAfter({prop: emptyProp, rule: rule}, target);\n    },\n\n    saveEdit: function(target, value, previousValue)\n    {\n        // We need to check the value first in order to avoid a problem in IE8\n        // See Issue 3038: Empty (null) styles when adding CSS styles in Firebug Lite\n        if (!value) return;\n\n        target.innerHTML = escapeForCss(value);\n\n        var row = getAncestorByClass(target, "cssProp");\n        if (hasClass(row, "disabledStyle"))\n            toggleClass(row, "disabledStyle");\n\n        var rule = Firebug.getRepObject(target);\n\n        if (hasClass(target, "cssPropName"))\n        {\n            if (value && previousValue != value)  // name of property has changed.\n            {\n                var propValue = getChildByClass(row, "cssPropValue")[textContent];\n                var parsedValue = parsePriority(propValue);\n\n                if (propValue && propValue != "undefined") {\n                    if (FBTrace.DBG_CSS)\n                        FBTrace.sysout("CSSEditor.saveEdit : "+previousValue+"->"+value+" = "+propValue+"\\n");\n                    if (previousValue)\n                        Firebug.CSSModule.removeProperty(rule, previousValue);\n                    Firebug.CSSModule.setProperty(rule, value, parsedValue.value, parsedValue.priority);\n                }\n            }\n            else if (!value) // name of the property has been deleted, so remove the property.\n                Firebug.CSSModule.removeProperty(rule, previousValue);\n        }\n        else if (getAncestorByClass(target, "cssPropValue"))\n        {\n            var propName = getChildByClass(row, "cssPropName")[textContent];\n            var propValue = getChildByClass(row, "cssPropValue")[textContent];\n\n            if (FBTrace.DBG_CSS)\n            {\n                FBTrace.sysout("CSSEditor.saveEdit propName=propValue: "+propName +" = "+propValue+"\\n");\n               // FBTrace.sysout("CSSEditor.saveEdit BEFORE style:",style);\n            }\n\n            if (value && value != "null")\n            {\n                var parsedValue = parsePriority(value);\n                Firebug.CSSModule.setProperty(rule, propName, parsedValue.value, parsedValue.priority);\n            }\n            else if (previousValue && previousValue != "null")\n                Firebug.CSSModule.removeProperty(rule, propName);\n        }\n\n        this.panel.markChange(this.panel.name == "stylesheet");\n    },\n\n    advanceToNext: function(target, charCode)\n    {\n        if (charCode == 58 /*":"*/ && hasClass(target, "cssPropName"))\n            return true;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    getAutoCompleteRange: function(value, offset)\n    {\n        if (hasClass(this.target, "cssPropName"))\n            return {start: 0, end: value.length-1};\n        else\n            return parseCSSValue(value, offset);\n    },\n\n    getAutoCompleteList: function(preExpr, expr, postExpr)\n    {\n        if (hasClass(this.target, "cssPropName"))\n        {\n            return getCSSPropertyNames();\n        }\n        else\n        {\n            var row = getAncestorByClass(this.target, "cssProp");\n            var propName = getChildByClass(row, "cssPropName")[textContent];\n            return getCSSKeywordsByProperty(propName);\n        }\n    }\n});\n\n//************************************************************************************************\n//CSSRuleEditor\n\nfunction CSSRuleEditor(doc)\n{\n    this.initializeInline(doc);\n    this.completeAsYouType = false;\n}\nCSSRuleEditor.uniquifier = 0;\nCSSRuleEditor.prototype = domplate(Firebug.InlineEditor.prototype,\n{\n    insertNewRow: function(target, insertWhere)\n    {\n         var emptyRule = {\n                 selector: "",\n                 id: "",\n                 props: [],\n                 isSelectorEditable: true\n         };\n\n         if (insertWhere == "before")\n             return CSSStyleRuleTag.tag.insertBefore({rule: emptyRule}, target);\n         else\n             return CSSStyleRuleTag.tag.insertAfter({rule: emptyRule}, target);\n    },\n\n    saveEdit: function(target, value, previousValue)\n    {\n        if (FBTrace.DBG_CSS)\n            FBTrace.sysout("CSSRuleEditor.saveEdit: \'" + value + "\'  \'" + previousValue + "\'", target);\n\n        target.innerHTML = escapeForCss(value);\n\n        if (value === previousValue)     return;\n\n        var row = getAncestorByClass(target, "cssRule");\n        var styleSheet = this.panel.location;\n        styleSheet = styleSheet.editStyleSheet ? styleSheet.editStyleSheet.sheet : styleSheet;\n\n        var cssRules = styleSheet.cssRules;\n        var rule = Firebug.getRepObject(target), oldRule = rule;\n        var ruleIndex = cssRules.length;\n        if (rule || Firebug.getRepObject(row.nextSibling))\n        {\n            var searchRule = rule || Firebug.getRepObject(row.nextSibling);\n            for (ruleIndex=0; ruleIndex<cssRules.length && searchRule!=cssRules[ruleIndex]; ruleIndex++) {}\n        }\n\n        // Delete in all cases except for new add\n        // We want to do this before the insert to ease change tracking\n        if (oldRule)\n        {\n            Firebug.CSSModule.deleteRule(styleSheet, ruleIndex);\n        }\n\n        // Firefox does not follow the spec for the update selector text case.\n        // When attempting to update the value, firefox will silently fail.\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=37468 for the quite\n        // old discussion of this bug.\n        // As a result we need to recreate the style every time the selector\n        // changes.\n        if (value)\n        {\n            var cssText = [ value, "{" ];\n            var props = row.getElementsByClassName("cssProp");\n            for (var i = 0; i < props.length; i++) {\n                var propEl = props[i];\n                if (!hasClass(propEl, "disabledStyle")) {\n                    cssText.push(getChildByClass(propEl, "cssPropName")[textContent]);\n                    cssText.push(":");\n                    cssText.push(getChildByClass(propEl, "cssPropValue")[textContent]);\n                    cssText.push(";");\n                }\n            }\n            cssText.push("}");\n            cssText = cssText.join("");\n\n            try\n            {\n                var insertLoc = Firebug.CSSModule.insertRule(styleSheet, cssText, ruleIndex);\n                rule = cssRules[insertLoc];\n                ruleIndex++;\n            }\n            catch (err)\n            {\n                if (FBTrace.DBG_CSS || FBTrace.DBG_ERRORS)\n                    FBTrace.sysout("CSS Insert Error: "+err, err);\n\n                target.innerHTML = escapeForCss(previousValue);\n                row.repObject = undefined;\n                return;\n            }\n        } else {\n            rule = undefined;\n        }\n\n        // Update the rep object\n        row.repObject = rule;\n        if (!oldRule)\n        {\n            // Who knows what the domutils will return for rule line\n            // for a recently created rule. To be safe we just generate\n            // a unique value as this is only used as an internal key.\n            var ruleId = "new/"+value+"/"+(++CSSRuleEditor.uniquifier);\n            row.setAttribute("ruleId", ruleId);\n        }\n\n        this.panel.markChange(this.panel.name == "stylesheet");\n    }\n});\n\n// ************************************************************************************************\n// StyleSheetEditor\n\nfunction StyleSheetEditor(doc)\n{\n    this.box = this.tag.replace({}, doc, this);\n    this.input = this.box.firstChild;\n}\n\nStyleSheetEditor.prototype = domplate(Firebug.BaseEditor,\n{\n    multiLine: true,\n\n    tag: DIV(\n        TEXTAREA({"class": "styleSheetEditor fullPanelEditor", oninput: "$onInput"})\n    ),\n\n    getValue: function()\n    {\n        return this.input.value;\n    },\n\n    setValue: function(value)\n    {\n        return this.input.value = value;\n    },\n\n    show: function(target, panel, value, textSize, targetSize)\n    {\n        this.target = target;\n        this.panel = panel;\n\n        this.panel.panelNode.appendChild(this.box);\n\n        this.input.value = value;\n        this.input.focus();\n\n        var command = Firebug.chrome.$("cmd_toggleCSSEditing");\n        command.setAttribute("checked", true);\n    },\n\n    hide: function()\n    {\n        var command = Firebug.chrome.$("cmd_toggleCSSEditing");\n        command.setAttribute("checked", false);\n\n        if (this.box.parentNode == this.panel.panelNode)\n            this.panel.panelNode.removeChild(this.box);\n\n        delete this.target;\n        delete this.panel;\n        delete this.styleSheet;\n    },\n\n    saveEdit: function(target, value, previousValue)\n    {\n        Firebug.CSSModule.freeEdit(this.styleSheet, value);\n    },\n\n    endEditing: function()\n    {\n        this.panel.refresh();\n        return true;\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onInput: function()\n    {\n        Firebug.Editor.update();\n    },\n\n    scrollToLine: function(line, offset)\n    {\n        this.startMeasuring(this.input);\n        var lineHeight = this.measureText().height;\n        this.stopMeasuring();\n\n        this.input.scrollTop = (line * lineHeight) + offset;\n    }\n});\n\n// ************************************************************************************************\n// Local Helpers\n\nvar rgbToHex = function rgbToHex(value)\n{\n    return value.replace(/\\brgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)/gi, rgbToHexReplacer);\n};\n\nvar rgbToHexReplacer = function(_, r, g, b) {\n    return \'#\' + ((1 << 24) + (r << 16) + (g << 8) + (b << 0)).toString(16).substr(-6).toUpperCase();\n};\n\nvar stripUnits = function stripUnits(value)\n{\n    // remove units from \'0px\', \'0em\' etc. leave non-zero units in-tact.\n    return value.replace(/(url\\(.*?\\)|[^0]\\S*\\s*)|0(%|em|ex|px|in|cm|mm|pt|pc)(\\s|$)/gi, stripUnitsReplacer);\n};\n\nvar stripUnitsReplacer = function(_, skip, remove, whitespace) {\n    return skip || (\'0\' + whitespace);\n};\n\nfunction parsePriority(value)\n{\n    var rePriority = /(.*?)\\s*(!important)?$/;\n    var m = rePriority.exec(value);\n    var propValue = m ? m[1] : "";\n    var priority = m && m[2] ? "important" : "";\n    return {value: propValue, priority: priority};\n}\n\nfunction parseURLValue(value)\n{\n    var m = reURL.exec(value);\n    return m ? m[1] : "";\n}\n\nfunction parseRepeatValue(value)\n{\n    var m = reRepeat.exec(value);\n    return m ? m[0] : "";\n}\n\nfunction parseCSSValue(value, offset)\n{\n    var start = 0;\n    var m;\n    while (1)\n    {\n        m = reSplitCSS.exec(value);\n        if (m && m.index+m[0].length < offset)\n        {\n            value = value.substr(m.index+m[0].length);\n            start += m.index+m[0].length;\n            offset -= m.index+m[0].length;\n        }\n        else\n            break;\n    }\n\n    if (m)\n    {\n        var type;\n        if (m[1])\n            type = "url";\n        else if (m[2] || m[3])\n            type = "rgb";\n        else if (m[4])\n            type = "int";\n\n        return {value: m[0], start: start+m.index, end: start+m.index+(m[0].length-1), type: type};\n    }\n}\n\nfunction findPropByName(props, name)\n{\n    for (var i = 0; i < props.length; ++i)\n    {\n        if (props[i].name == name)\n            return i;\n    }\n}\n\nfunction sortProperties(props)\n{\n    props.sort(function(a, b)\n    {\n        return a.name > b.name ? 1 : -1;\n    });\n}\n\nfunction getTopmostRuleLine(panelNode)\n{\n    for (var child = panelNode.firstChild; child; child = child.nextSibling)\n    {\n        if (child.offsetTop+child.offsetHeight > panelNode.scrollTop)\n        {\n            var rule = child.repObject;\n            if (rule)\n                return {\n                    line: domUtils.getRuleLine(rule),\n                    offset: panelNode.scrollTop-child.offsetTop\n                };\n        }\n    }\n    return 0;\n}\n\nfunction getStyleSheetCSS(sheet, context)\n{\n    if (sheet.ownerNode instanceof HTMLStyleElement)\n        return sheet.ownerNode.innerHTML;\n    else\n        return context.sourceCache.load(sheet.href).join("");\n}\n\nfunction getStyleSheetOwnerNode(sheet) {\n    for (; sheet && !sheet.ownerNode; sheet = sheet.parentStyleSheet);\n\n    return sheet.ownerNode;\n}\n\nfunction scrollSelectionIntoView(panel)\n{\n    var selCon = getSelectionController(panel);\n    selCon.scrollSelectionIntoView(\n            nsISelectionController.SELECTION_NORMAL,\n            nsISelectionController.SELECTION_FOCUS_REGION, true);\n}\n\nfunction getSelectionController(panel)\n{\n    var browser = Firebug.chrome.getPanelBrowser(panel);\n    return browser.docShell.QueryInterface(nsIInterfaceRequestor)\n        .getInterface(nsISelectionDisplay)\n        .QueryInterface(nsISelectionController);\n}\n\n// ************************************************************************************************\n\nFirebug.registerModule(Firebug.CSSModule);\nFirebug.registerPanel(Firebug.CSSStyleSheetPanel);\nFirebug.registerPanel(CSSElementPanel);\nFirebug.registerPanel(CSSComputedElementPanel);\n\n// ************************************************************************************************\n\n}});\n\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Script Module\n\nFirebug.Script = extend(Firebug.Module,\n{\n    getPanel: function()\n    {\n        return Firebug.chrome ? Firebug.chrome.getPanel("Script") : null;\n    },\n\n    selectSourceCode: function(index)\n    {\n        this.getPanel().selectSourceCode(index);\n    }\n});\n\nFirebug.registerModule(Firebug.Script);\n\n\n// ************************************************************************************************\n// Script Panel\n\nfunction ScriptPanel(){};\n\nScriptPanel.prototype = extend(Firebug.Panel,\n{\n    name: "Script",\n    title: "Script",\n\n    selectIndex: 0, // index of the current selectNode\'s option\n    sourceIndex: -1, // index of the script node, based in doc.getElementsByTagName("script")\n\n    options: {\n        hasToolButtons: true\n    },\n\n    create: function()\n    {\n        Firebug.Panel.create.apply(this, arguments);\n\n        this.onChangeSelect = bind(this.onChangeSelect, this);\n\n        var doc = Firebug.browser.document;\n        var scripts = doc.getElementsByTagName("script");\n        var selectNode = this.selectNode = createElement("select");\n\n        for(var i=0, script; script=scripts[i]; i++)\n        {\n            // Don\'t show Firebug Lite source code in the list of options\n            if (Firebug.ignoreFirebugElements && script.getAttribute("firebugIgnore"))\n                continue;\n\n            var fileName = getFileName(script.src) || getFileName(doc.location.href);\n            var option = createElement("option", {value:i});\n\n            option.appendChild(Firebug.chrome.document.createTextNode(fileName));\n            selectNode.appendChild(option);\n        };\n\n        this.toolButtonsNode.appendChild(selectNode);\n    },\n\n    initialize: function()\n    {\n        // we must render the code first, so the persistent state can be restore\n        this.selectSourceCode(this.selectIndex);\n\n        Firebug.Panel.initialize.apply(this, arguments);\n\n        addEvent(this.selectNode, "change", this.onChangeSelect);\n    },\n\n    shutdown: function()\n    {\n        removeEvent(this.selectNode, "change", this.onChangeSelect);\n\n        Firebug.Panel.shutdown.apply(this, arguments);\n    },\n\n    detach: function(oldChrome, newChrome)\n    {\n        Firebug.Panel.detach.apply(this, arguments);\n\n        var oldPanel = oldChrome.getPanel("Script");\n        var index = oldPanel.selectIndex;\n\n        this.selectNode.selectedIndex = index;\n        this.selectIndex = index;\n        this.sourceIndex = -1;\n    },\n\n    onChangeSelect: function(event)\n    {\n        var select = this.selectNode;\n\n        this.selectIndex = select.selectedIndex;\n\n        var option = select.options[select.selectedIndex];\n        if (!option)\n            return;\n\n        var selectedSourceIndex = parseInt(option.value);\n\n        this.renderSourceCode(selectedSourceIndex);\n    },\n\n    selectSourceCode: function(index)\n    {\n        var select = this.selectNode;\n        select.selectedIndex = index;\n\n        var option = select.options[index];\n        if (!option)\n            return;\n\n        var selectedSourceIndex = parseInt(option.value);\n\n        this.renderSourceCode(selectedSourceIndex);\n    },\n\n    renderSourceCode: function(index)\n    {\n        if (this.sourceIndex != index)\n        {\n            var renderProcess = function renderProcess(src)\n            {\n                var html = [],\n                    hl = 0;\n\n                src = isIE && !isExternal ?\n                        src+\'\\n\' :  // IE put an extra line when reading source of local resources\n                        \'\\n\'+src;\n\n                // find the number of lines of code\n                src = src.replace(/\\n\\r|\\r\\n/g, "\\n");\n                var match = src.match(/[\\n]/g);\n                var lines=match ? match.length : 0;\n\n                // render the full source code + line numbers html\n                html[hl++] = \'<div><div class="sourceBox" style="left:\';\n                html[hl++] = 35 + 7*(lines+\'\').length;\n                html[hl++] = \'px;"><pre class="sourceCode">\';\n                html[hl++] = escapeHTML(src);\n                html[hl++] = \'</pre></div><div class="lineNo">\';\n\n                // render the line number divs\n                for(var l=1, lines; l<=lines; l++)\n                {\n                    html[hl++] = \'<div line="\';\n                    html[hl++] = l;\n                    html[hl++] = \'">\';\n                    html[hl++] = l;\n                    html[hl++] = \'</div>\';\n                }\n\n                html[hl++] = \'</div></div>\';\n\n                updatePanel(html);\n            };\n\n            var updatePanel = function(html)\n            {\n                self.panelNode.innerHTML = html.join("");\n\n                // IE needs this timeout, otherwise the panel won\'t scroll\n                setTimeout(function(){\n                    self.synchronizeUI();\n                },0);\n            };\n\n            var onFailure = function()\n            {\n                FirebugReps.Warning.tag.replace({object: "AccessRestricted"}, self.panelNode);\n            };\n\n            var self = this;\n\n            var doc = Firebug.browser.document;\n            var script = doc.getElementsByTagName("script")[index];\n            var url = getScriptURL(script);\n            var isExternal = url && url != doc.location.href;\n\n            try\n            {\n                if (Firebug.disableResourceFetching)\n                {\n                    renderProcess(Firebug.Lite.Proxy.fetchResourceDisabledMessage);\n                }\n                else if (isExternal)\n                {\n                    Ajax.request({url: url, onSuccess: renderProcess, onFailure: onFailure});\n                }\n                else\n                {\n                    var src = script.innerHTML;\n                    renderProcess(src);\n                }\n            }\n            catch(e)\n            {\n                onFailure();\n            }\n\n            this.sourceIndex = index;\n        }\n    }\n});\n\nFirebug.registerPanel(ScriptPanel);\n\n\n// ************************************************************************************************\n\n\nvar getScriptURL = function getScriptURL(script)\n{\n    var reFile = /([^\\/\\?#]+)(#.+)?$/;\n    var rePath = /^(.*\\/)/;\n    var reProtocol = /^\\w+:\\/\\//;\n    var path = null;\n    var doc = Firebug.browser.document;\n\n    var file = reFile.exec(script.src);\n\n    if (file)\n    {\n        var fileName = file[1];\n        var fileOptions = file[2];\n\n        // absolute path\n        if (reProtocol.test(script.src)) {\n            path = rePath.exec(script.src)[1];\n\n        }\n        // relative path\n        else\n        {\n            var r = rePath.exec(script.src);\n            var src = r ? r[1] : script.src;\n            var backDir = /^((?:\\.\\.\\/)+)(.*)/.exec(src);\n            var reLastDir = /^(.*\\/)[^\\/]+\\/$/;\n            path = rePath.exec(doc.location.href)[1];\n\n            // "../some/path"\n            if (backDir)\n            {\n                var j = backDir[1].length/3;\n                var p;\n                while (j-- > 0)\n                    path = reLastDir.exec(path)[1];\n\n                path += backDir[2];\n            }\n\n            else if(src.indexOf("/") != -1)\n            {\n                // "./some/path"\n                if(/^\\.\\/./.test(src))\n                {\n                    path += src.substring(2);\n                }\n                // "/some/path"\n                else if(/^\\/./.test(src))\n                {\n                    var domain = /^(\\w+:\\/\\/[^\\/]+)/.exec(path);\n                    path = domain[1] + src;\n                }\n                // "some/path"\n                else\n                {\n                    path += src;\n                }\n            }\n        }\n    }\n\n    var m = path && path.match(/([^\\/]+)\\/$/) || null;\n\n    if (path && m)\n    {\n        return path + fileName;\n    }\n};\n\nvar getFileName = function getFileName(path)\n{\n    if (!path) return "";\n\n    var match = path && path.match(/[^\\/]+(\\?.*)?(#.*)?$/);\n\n    return match && match[0] || path;\n};\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar ElementCache = Firebug.Lite.Cache.Element;\n\nvar insertSliceSize = 18;\nvar insertInterval = 40;\n\nvar ignoreVars =\n{\n    "__firebug__": 1,\n    "eval": 1,\n\n    // We are forced to ignore Java-related variables, because\n    // trying to access them causes browser freeze\n    "java": 1,\n    "sun": 1,\n    "Packages": 1,\n    "JavaArray": 1,\n    "JavaMember": 1,\n    "JavaObject": 1,\n    "JavaClass": 1,\n    "JavaPackage": 1,\n    "_firebug": 1,\n    "_FirebugConsole": 1,\n    "_FirebugCommandLine": 1\n};\n\nif (Firebug.ignoreFirebugElements)\n    ignoreVars[Firebug.Lite.Cache.ID] = 1;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvar memberPanelRep =\n    isIE6 ?\n    {"class": "memberLabel $member.type\\\\Label", href: "javacript:void(0)"}\n    :\n    {"class": "memberLabel $member.type\\\\Label"};\n\nvar RowTag =\n    TR({"class": "memberRow $member.open $member.type\\\\Row", $hasChildren: "$member.hasChildren", role : \'presentation\',\n        level: "$member.level"},\n        TD({"class": "memberLabelCell", style: "padding-left: $member.indent\\\\px", role : \'presentation\'},\n            A(memberPanelRep,\n                SPAN({}, "$member.name")\n            )\n        ),\n        TD({"class": "memberValueCell", role : \'presentation\'},\n            TAG("$member.tag", {object: "$member.value"})\n        )\n    );\n\nvar WatchRowTag =\n    TR({"class": "watchNewRow", level: 0},\n        TD({"class": "watchEditCell", colspan: 2},\n            DIV({"class": "watchEditBox a11yFocusNoTab", role: "button", \'tabindex\' : \'0\',\n                \'aria-label\' : $STR(\'press enter to add new watch expression\')},\n                    $STR("NewWatch")\n            )\n        )\n    );\n\nvar SizerRow =\n    TR({role : \'presentation\'},\n        TD({width: "30%"}),\n        TD({width: "70%"})\n    );\n\nvar domTableClass = isIElt8 ? "domTable domTableIE" : "domTable";\nvar DirTablePlate = domplate(Firebug.Rep,\n{\n    tag:\n        TABLE({"class": domTableClass, cellpadding: 0, cellspacing: 0, onclick: "$onClick", role :"tree"},\n            TBODY({role: \'presentation\'},\n                SizerRow,\n                FOR("member", "$object|memberIterator", RowTag)\n            )\n        ),\n\n    watchTag:\n        TABLE({"class": domTableClass, cellpadding: 0, cellspacing: 0,\n               _toggles: "$toggles", _domPanel: "$domPanel", onclick: "$onClick", role : \'tree\'},\n            TBODY({role : \'presentation\'},\n                SizerRow,\n                WatchRowTag\n            )\n        ),\n\n    tableTag:\n        TABLE({"class": domTableClass, cellpadding: 0, cellspacing: 0,\n            _toggles: "$toggles", _domPanel: "$domPanel", onclick: "$onClick", role : \'tree\'},\n            TBODY({role : \'presentation\'},\n                SizerRow\n            )\n        ),\n\n    rowTag:\n        FOR("member", "$members", RowTag),\n\n    memberIterator: function(object, level)\n    {\n        return getMembers(object, level);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onClick: function(event)\n    {\n        if (!isLeftClick(event))\n            return;\n\n        var target = event.target || event.srcElement;\n\n        var row = getAncestorByClass(target, "memberRow");\n        var label = getAncestorByClass(target, "memberLabel");\n        if (label && hasClass(row, "hasChildren"))\n        {\n            var row = label.parentNode.parentNode;\n            this.toggleRow(row);\n        }\n        else\n        {\n            var object = Firebug.getRepObject(target);\n            if (typeof(object) == "function")\n            {\n                Firebug.chrome.select(object, "script");\n                cancelEvent(event);\n            }\n            else if (event.detail == 2 && !object)\n            {\n                var panel = row.parentNode.parentNode.domPanel;\n                if (panel)\n                {\n                    var rowValue = panel.getRowPropertyValue(row);\n                    if (typeof(rowValue) == "boolean")\n                        panel.setPropertyValue(row, !rowValue);\n                    else\n                        panel.editProperty(row);\n\n                    cancelEvent(event);\n                }\n            }\n        }\n\n        return false;\n    },\n\n    toggleRow: function(row)\n    {\n        var level = parseInt(row.getAttribute("level"));\n        var toggles = row.parentNode.parentNode.toggles;\n\n        if (hasClass(row, "opened"))\n        {\n            removeClass(row, "opened");\n\n            if (toggles)\n            {\n                var path = getPath(row);\n\n                // Remove the path from the toggle tree\n                for (var i = 0; i < path.length; ++i)\n                {\n                    if (i == path.length-1)\n                        delete toggles[path[i]];\n                    else\n                        toggles = toggles[path[i]];\n                }\n            }\n\n            var rowTag = this.rowTag;\n            var tbody = row.parentNode;\n\n            setTimeout(function()\n            {\n                for (var firstRow = row.nextSibling; firstRow; firstRow = row.nextSibling)\n                {\n                    if (parseInt(firstRow.getAttribute("level")) <= level)\n                        break;\n\n                    tbody.removeChild(firstRow);\n                }\n            }, row.insertTimeout ? row.insertTimeout : 0);\n        }\n        else\n        {\n            setClass(row, "opened");\n\n            if (toggles)\n            {\n                var path = getPath(row);\n\n                // Mark the path in the toggle tree\n                for (var i = 0; i < path.length; ++i)\n                {\n                    var name = path[i];\n                    if (toggles.hasOwnProperty(name))\n                        toggles = toggles[name];\n                    else\n                        toggles = toggles[name] = {};\n                }\n            }\n\n            var value = row.lastChild.firstChild.repObject;\n            var members = getMembers(value, level+1);\n\n            var rowTag = this.rowTag;\n            var lastRow = row;\n\n            var delay = 0;\n            //var setSize = members.length;\n            //var rowCount = 1;\n            while (members.length)\n            {\n                with({slice: members.splice(0, insertSliceSize), isLast: !members.length})\n                {\n                    setTimeout(function()\n                    {\n                        if (lastRow.parentNode)\n                        {\n                            var result = rowTag.insertRows({members: slice}, lastRow);\n                            lastRow = result[1];\n                            //dispatch([Firebug.A11yModel], \'onMemberRowSliceAdded\', [null, result, rowCount, setSize]);\n                            //rowCount += insertSliceSize;\n                        }\n                        if (isLast)\n                            row.removeAttribute("insertTimeout");\n                    }, delay);\n                }\n\n                delay += insertInterval;\n            }\n\n            row.insertTimeout = delay;\n        }\n    }\n});\n\n\n\n// ************************************************************************************************\n\nFirebug.DOMBasePanel = function() {};\n\nFirebug.DOMBasePanel.prototype = extend(Firebug.Panel,\n{\n    tag: DirTablePlate.tableTag,\n\n    getRealObject: function(object)\n    {\n        // TODO: Move this to some global location\n        // TODO: Unwrapping should be centralized rather than sprinkling it around ad hoc.\n        // TODO: We might be able to make this check more authoritative with QueryInterface.\n        if (!object) return object;\n        if (object.wrappedJSObject) return object.wrappedJSObject;\n        return object;\n    },\n\n    rebuild: function(update, scrollTop)\n    {\n        //dispatch([Firebug.A11yModel], \'onBeforeDomUpdateSelection\', [this]);\n        var members = getMembers(this.selection);\n        expandMembers(members, this.toggles, 0, 0);\n\n        this.showMembers(members, update, scrollTop);\n\n        //TODO: xxxpedro statusbar\n        if (!this.parentPanel)\n            updateStatusBar(this);\n    },\n\n    showMembers: function(members, update, scrollTop)\n    {\n        // If we are still in the midst of inserting rows, cancel all pending\n        // insertions here - this is a big speedup when stepping in the debugger\n        if (this.timeouts)\n        {\n            for (var i = 0; i < this.timeouts.length; ++i)\n                this.context.clearTimeout(this.timeouts[i]);\n            delete this.timeouts;\n        }\n\n        if (!members.length)\n            return this.showEmptyMembers();\n\n        var panelNode = this.panelNode;\n        var priorScrollTop = scrollTop == undefined ? panelNode.scrollTop : scrollTop;\n\n        // If we are asked to "update" the current view, then build the new table\n        // offscreen and swap it in when it\'s done\n        var offscreen = update && panelNode.firstChild;\n        var dest = offscreen ? panelNode.ownerDocument : panelNode;\n\n        var table = this.tag.replace({domPanel: this, toggles: this.toggles}, dest);\n        var tbody = table.lastChild;\n        var rowTag = DirTablePlate.rowTag;\n\n        // Insert the first slice immediately\n        //var slice = members.splice(0, insertSliceSize);\n        //var result = rowTag.insertRows({members: slice}, tbody.lastChild);\n\n        //var setSize = members.length;\n        //var rowCount = 1;\n\n        var panel = this;\n        var result;\n\n        //dispatch([Firebug.A11yModel], \'onMemberRowSliceAdded\', [panel, result, rowCount, setSize]);\n        var timeouts = [];\n\n        var delay = 0;\n\n        // enable to measure rendering performance\n        var renderStart = new Date().getTime();\n        while (members.length)\n        {\n            with({slice: members.splice(0, insertSliceSize), isLast: !members.length})\n            {\n                timeouts.push(this.context.setTimeout(function()\n                {\n                    // TODO: xxxpedro can this be a timing error related to the\n                    // "iteration number" approach insted of "duration time"?\n                    // avoid error in IE8\n                    if (!tbody.lastChild) return;\n\n                    result = rowTag.insertRows({members: slice}, tbody.lastChild);\n\n                    //rowCount += insertSliceSize;\n                    //dispatch([Firebug.A11yModel], \'onMemberRowSliceAdded\', [panel, result, rowCount, setSize]);\n\n                    if ((panelNode.scrollHeight+panelNode.offsetHeight) >= priorScrollTop)\n                        panelNode.scrollTop = priorScrollTop;\n\n\n                    // enable to measure rendering performance\n                    //if (isLast) alert(new Date().getTime() - renderStart + "ms");\n\n\n                }, delay));\n\n                delay += insertInterval;\n            }\n        }\n\n        if (offscreen)\n        {\n            timeouts.push(this.context.setTimeout(function()\n            {\n                if (panelNode.firstChild)\n                    panelNode.replaceChild(table, panelNode.firstChild);\n                else\n                    panelNode.appendChild(table);\n\n                // Scroll back to where we were before\n                panelNode.scrollTop = priorScrollTop;\n            }, delay));\n        }\n        else\n        {\n            timeouts.push(this.context.setTimeout(function()\n            {\n                panelNode.scrollTop = scrollTop == undefined ? 0 : scrollTop;\n            }, delay));\n        }\n        this.timeouts = timeouts;\n    },\n\n    /*\n    // new\n    showMembers: function(members, update, scrollTop)\n    {\n        // If we are still in the midst of inserting rows, cancel all pending\n        // insertions here - this is a big speedup when stepping in the debugger\n        if (this.timeouts)\n        {\n            for (var i = 0; i < this.timeouts.length; ++i)\n                this.context.clearTimeout(this.timeouts[i]);\n            delete this.timeouts;\n        }\n\n        if (!members.length)\n            return this.showEmptyMembers();\n\n        var panelNode = this.panelNode;\n        var priorScrollTop = scrollTop == undefined ? panelNode.scrollTop : scrollTop;\n\n        // If we are asked to "update" the current view, then build the new table\n        // offscreen and swap it in when it\'s done\n        var offscreen = update && panelNode.firstChild;\n        var dest = offscreen ? panelNode.ownerDocument : panelNode;\n\n        var table = this.tag.replace({domPanel: this, toggles: this.toggles}, dest);\n        var tbody = table.lastChild;\n        var rowTag = DirTablePlate.rowTag;\n\n        // Insert the first slice immediately\n        //var slice = members.splice(0, insertSliceSize);\n        //var result = rowTag.insertRows({members: slice}, tbody.lastChild);\n\n        //var setSize = members.length;\n        //var rowCount = 1;\n\n        var panel = this;\n        var result;\n\n        //dispatch([Firebug.A11yModel], \'onMemberRowSliceAdded\', [panel, result, rowCount, setSize]);\n        var timeouts = [];\n\n        var delay = 0;\n        var _insertSliceSize = insertSliceSize;\n        var _insertInterval = insertInterval;\n\n        // enable to measure rendering performance\n        var renderStart = new Date().getTime();\n        var lastSkip = renderStart, now;\n\n        while (members.length)\n        {\n            with({slice: members.splice(0, _insertSliceSize), isLast: !members.length})\n            {\n                var _tbody = tbody;\n                var _rowTag = rowTag;\n                var _panelNode = panelNode;\n                var _priorScrollTop = priorScrollTop;\n\n                timeouts.push(this.context.setTimeout(function()\n                {\n                    // TODO: xxxpedro can this be a timing error related to the\n                    // "iteration number" approach insted of "duration time"?\n                    // avoid error in IE8\n                    if (!_tbody.lastChild) return;\n\n                    result = _rowTag.insertRows({members: slice}, _tbody.lastChild);\n\n                    //rowCount += _insertSliceSize;\n                    //dispatch([Firebug.A11yModel], \'onMemberRowSliceAdded\', [panel, result, rowCount, setSize]);\n\n                    if ((_panelNode.scrollHeight + _panelNode.offsetHeight) >= _priorScrollTop)\n                        _panelNode.scrollTop = _priorScrollTop;\n\n\n                    // enable to measure rendering performance\n                    //alert("gap: " + (new Date().getTime() - lastSkip));\n                    //lastSkip = new Date().getTime();\n\n                    //if (isLast) alert("new: " + (new Date().getTime() - renderStart) + "ms");\n\n                }, delay));\n\n                delay += _insertInterval;\n            }\n        }\n\n        if (offscreen)\n        {\n            timeouts.push(this.context.setTimeout(function()\n            {\n                if (panelNode.firstChild)\n                    panelNode.replaceChild(table, panelNode.firstChild);\n                else\n                    panelNode.appendChild(table);\n\n                // Scroll back to where we were before\n                panelNode.scrollTop = priorScrollTop;\n            }, delay));\n        }\n        else\n        {\n            timeouts.push(this.context.setTimeout(function()\n            {\n                panelNode.scrollTop = scrollTop == undefined ? 0 : scrollTop;\n            }, delay));\n        }\n        this.timeouts = timeouts;\n    },\n    /**/\n\n    showEmptyMembers: function()\n    {\n        FirebugReps.Warning.tag.replace({object: "NoMembersWarning"}, this.panelNode);\n    },\n\n    findPathObject: function(object)\n    {\n        var pathIndex = -1;\n        for (var i = 0; i < this.objectPath.length; ++i)\n        {\n            // IE needs === instead of == or otherwise some objects will\n            // be considered equal to different objects, returning the\n            // wrong index of the objectPath array\n            if (this.getPathObject(i) === object)\n                return i;\n        }\n\n        return -1;\n    },\n\n    getPathObject: function(index)\n    {\n        var object = this.objectPath[index];\n\n        if (object instanceof Property)\n            return object.getObject();\n        else\n            return object;\n    },\n\n    getRowObject: function(row)\n    {\n        var object = getRowOwnerObject(row);\n        return object ? object : this.selection;\n    },\n\n    getRowPropertyValue: function(row)\n    {\n        var object = this.getRowObject(row);\n        object = this.getRealObject(object);\n        if (object)\n        {\n            var propName = getRowName(row);\n\n            if (object instanceof jsdIStackFrame)\n                return Firebug.Debugger.evaluate(propName, this.context);\n            else\n                return object[propName];\n        }\n    },\n    /*\n    copyProperty: function(row)\n    {\n        var value = this.getRowPropertyValue(row);\n        copyToClipboard(value);\n    },\n\n    editProperty: function(row, editValue)\n    {\n        if (hasClass(row, "watchNewRow"))\n        {\n            if (this.context.stopped)\n                Firebug.Editor.startEditing(row, "");\n            else if (Firebug.Console.isAlwaysEnabled())  // not stopped in debugger, need command line\n            {\n                if (Firebug.CommandLine.onCommandLineFocus())\n                    Firebug.Editor.startEditing(row, "");\n                else\n                    row.innerHTML = $STR("warning.Command line blocked?");\n            }\n            else\n                row.innerHTML = $STR("warning.Console must be enabled");\n        }\n        else if (hasClass(row, "watchRow"))\n            Firebug.Editor.startEditing(row, getRowName(row));\n        else\n        {\n            var object = this.getRowObject(row);\n            this.context.thisValue = object;\n\n            if (!editValue)\n            {\n                var propValue = this.getRowPropertyValue(row);\n\n                var type = typeof(propValue);\n                if (type == "undefined" || type == "number" || type == "boolean")\n                    editValue = propValue;\n                else if (type == "string")\n                    editValue = "\\"" + escapeJS(propValue) + "\\"";\n                else if (propValue == null)\n                    editValue = "null";\n                else if (object instanceof Window || object instanceof jsdIStackFrame)\n                    editValue = getRowName(row);\n                else\n                    editValue = "this." + getRowName(row);\n            }\n\n\n            Firebug.Editor.startEditing(row, editValue);\n        }\n    },\n\n    deleteProperty: function(row)\n    {\n        if (hasClass(row, "watchRow"))\n            this.deleteWatch(row);\n        else\n        {\n            var object = getRowOwnerObject(row);\n            if (!object)\n                object = this.selection;\n            object = this.getRealObject(object);\n\n            if (object)\n            {\n                var name = getRowName(row);\n                try\n                {\n                    delete object[name];\n                }\n                catch (exc)\n                {\n                    return;\n                }\n\n                this.rebuild(true);\n                this.markChange();\n            }\n        }\n    },\n\n    setPropertyValue: function(row, value)  // value must be string\n    {\n        if(FBTrace.DBG_DOM)\n        {\n            FBTrace.sysout("row: "+row);\n            FBTrace.sysout("value: "+value+" type "+typeof(value), value);\n        }\n\n        var name = getRowName(row);\n        if (name == "this")\n            return;\n\n        var object = this.getRowObject(row);\n        object = this.getRealObject(object);\n        if (object && !(object instanceof jsdIStackFrame))\n        {\n             // unwrappedJSObject.property = unwrappedJSObject\n             Firebug.CommandLine.evaluate(value, this.context, object, this.context.getGlobalScope(),\n                 function success(result, context)\n                 {\n                     if (FBTrace.DBG_DOM)\n                         FBTrace.sysout("setPropertyValue evaluate success object["+name+"]="+result+" type "+typeof(result), result);\n                     object[name] = result;\n                 },\n                 function failed(exc, context)\n                 {\n                     try\n                     {\n                         if (FBTrace.DBG_DOM)\n                              FBTrace.sysout("setPropertyValue evaluate failed with exc:"+exc+" object["+name+"]="+value+" type "+typeof(value), exc);\n                         // If the value doesn\'t parse, then just store it as a string.  Some users will\n                         // not realize they\'re supposed to enter a JavaScript expression and just type\n                         // literal text\n                         object[name] = String(value);  // unwrappedJSobject.property = string\n                     }\n                     catch (exc)\n                     {\n                         return;\n                     }\n                  }\n             );\n        }\n        else if (this.context.stopped)\n        {\n            try\n            {\n                Firebug.CommandLine.evaluate(name+"="+value, this.context);\n            }\n            catch (exc)\n            {\n                try\n                {\n                    // See catch block above...\n                    object[name] = String(value); // unwrappedJSobject.property = string\n                }\n                catch (exc)\n                {\n                    return;\n                }\n            }\n        }\n\n        this.rebuild(true);\n        this.markChange();\n    },\n\n    highlightRow: function(row)\n    {\n        if (this.highlightedRow)\n            cancelClassTimed(this.highlightedRow, "jumpHighlight", this.context);\n\n        this.highlightedRow = row;\n\n        if (row)\n            setClassTimed(row, "jumpHighlight", this.context);\n    },/**/\n\n    onMouseMove: function(event)\n    {\n        var target = event.srcElement || event.target;\n\n        var object = getAncestorByClass(target, "objectLink-element");\n        object = object ? object.repObject : null;\n\n        if(object && instanceOf(object, "Element") && object.nodeType == 1)\n        {\n            if(object != lastHighlightedObject)\n            {\n                Firebug.Inspector.drawBoxModel(object);\n                object = lastHighlightedObject;\n            }\n        }\n        else\n            Firebug.Inspector.hideBoxModel();\n\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    create: function()\n    {\n        // TODO: xxxpedro\n        this.context = Firebug.browser;\n\n        this.objectPath = [];\n        this.propertyPath = [];\n        this.viewPath = [];\n        this.pathIndex = -1;\n        this.toggles = {};\n\n        Firebug.Panel.create.apply(this, arguments);\n\n        this.panelNode.style.padding = "0 1px";\n    },\n\n    initialize: function(){\n        Firebug.Panel.initialize.apply(this, arguments);\n\n        addEvent(this.panelNode, "mousemove", this.onMouseMove);\n    },\n\n    shutdown: function()\n    {\n        removeEvent(this.panelNode, "mousemove", this.onMouseMove);\n\n        Firebug.Panel.shutdown.apply(this, arguments);\n    },\n\n    /*\n    destroy: function(state)\n    {\n        var view = this.viewPath[this.pathIndex];\n        if (view && this.panelNode.scrollTop)\n            view.scrollTop = this.panelNode.scrollTop;\n\n        if (this.pathIndex)\n            state.pathIndex = this.pathIndex;\n        if (this.viewPath)\n            state.viewPath = this.viewPath;\n        if (this.propertyPath)\n            state.propertyPath = this.propertyPath;\n\n        if (this.propertyPath.length > 0 && !this.propertyPath[1])\n            state.firstSelection = persistObject(this.getPathObject(1), this.context);\n\n        Firebug.Panel.destroy.apply(this, arguments);\n    },\n    /**/\n\n    ishow: function(state)\n    {\n        if (this.context.loaded && !this.selection)\n        {\n            if (!state)\n            {\n                this.select(null);\n                return;\n            }\n            if (state.viewPath)\n                this.viewPath = state.viewPath;\n            if (state.propertyPath)\n                this.propertyPath = state.propertyPath;\n\n            var defaultObject = this.getDefaultSelection(this.context);\n            var selectObject = defaultObject;\n\n            if (state.firstSelection)\n            {\n                var restored = state.firstSelection(this.context);\n                if (restored)\n                {\n                    selectObject = restored;\n                    this.objectPath = [defaultObject, restored];\n                }\n                else\n                    this.objectPath = [defaultObject];\n            }\n            else\n                this.objectPath = [defaultObject];\n\n            if (this.propertyPath.length > 1)\n            {\n                for (var i = 1; i < this.propertyPath.length; ++i)\n                {\n                    var name = this.propertyPath[i];\n                    if (!name)\n                        continue;\n\n                    var object = selectObject;\n                    try\n                    {\n                        selectObject = object[name];\n                    }\n                    catch (exc)\n                    {\n                        selectObject = null;\n                    }\n\n                    if (selectObject)\n                    {\n                        this.objectPath.push(new Property(object, name));\n                    }\n                    else\n                    {\n                        // If we can\'t access a property, just stop\n                        this.viewPath.splice(i);\n                        this.propertyPath.splice(i);\n                        this.objectPath.splice(i);\n                        selectObject = this.getPathObject(this.objectPath.length-1);\n                        break;\n                    }\n                }\n            }\n\n            var selection = state.pathIndex <= this.objectPath.length-1\n                ? this.getPathObject(state.pathIndex)\n                : this.getPathObject(this.objectPath.length-1);\n\n            this.select(selection);\n        }\n    },\n    /*\n    hide: function()\n    {\n        var view = this.viewPath[this.pathIndex];\n        if (view && this.panelNode.scrollTop)\n            view.scrollTop = this.panelNode.scrollTop;\n    },\n    /**/\n\n    supportsObject: function(object)\n    {\n        if (object == null)\n            return 1000;\n\n        if (typeof(object) == "undefined")\n            return 1000;\n        else if (object instanceof SourceLink)\n            return 0;\n        else\n            return 1; // just agree to support everything but not agressively.\n    },\n\n    refresh: function()\n    {\n        this.rebuild(true);\n    },\n\n    updateSelection: function(object)\n    {\n        var previousIndex = this.pathIndex;\n        var previousView = previousIndex == -1 ? null : this.viewPath[previousIndex];\n\n        var newPath = this.pathToAppend;\n        delete this.pathToAppend;\n\n        var pathIndex = this.findPathObject(object);\n        if (newPath || pathIndex == -1)\n        {\n            this.toggles = {};\n\n            if (newPath)\n            {\n                // Remove everything after the point where we are inserting, so we\n                // essentially replace it with the new path\n                if (previousView)\n                {\n                    if (this.panelNode.scrollTop)\n                        previousView.scrollTop = this.panelNode.scrollTop;\n\n                    var start = previousIndex + 1,\n                        // Opera needs the length argument in splice(), otherwise\n                        // it will consider that only one element should be removed\n                        length = this.objectPath.length - start;\n\n                    this.objectPath.splice(start, length);\n                    this.propertyPath.splice(start, length);\n                    this.viewPath.splice(start, length);\n                }\n\n                var value = this.getPathObject(previousIndex);\n                if (!value)\n                {\n                    if (FBTrace.DBG_ERRORS)\n                        FBTrace.sysout("dom.updateSelection no pathObject for "+previousIndex+"\\n");\n                    return;\n                }\n\n                for (var i = 0, length = newPath.length; i < length; ++i)\n                {\n                    var name = newPath[i];\n                    var object = value;\n                    try\n                    {\n                        value = value[name];\n                    }\n                    catch(exc)\n                    {\n                        if (FBTrace.DBG_ERRORS)\n                                FBTrace.sysout("dom.updateSelection FAILS at path_i="+i+" for name:"+name+"\\n");\n                        return;\n                    }\n\n                    ++this.pathIndex;\n                    this.objectPath.push(new Property(object, name));\n                    this.propertyPath.push(name);\n                    this.viewPath.push({toggles: this.toggles, scrollTop: 0});\n                }\n            }\n            else\n            {\n                this.toggles = {};\n\n                var win = Firebug.browser.window;\n                //var win = this.context.getGlobalScope();\n                if (object === win)\n                {\n                    this.pathIndex = 0;\n                    this.objectPath = [win];\n                    this.propertyPath = [null];\n                    this.viewPath = [{toggles: this.toggles, scrollTop: 0}];\n                }\n                else\n                {\n                    this.pathIndex = 1;\n                    this.objectPath = [win, object];\n                    this.propertyPath = [null, null];\n                    this.viewPath = [\n                        {toggles: {}, scrollTop: 0},\n                        {toggles: this.toggles, scrollTop: 0}\n                    ];\n                }\n            }\n\n            this.panelNode.scrollTop = 0;\n            this.rebuild();\n        }\n        else\n        {\n            this.pathIndex = pathIndex;\n\n            var view = this.viewPath[pathIndex];\n            this.toggles = view.toggles;\n\n            // Persist the current scroll location\n            if (previousView && this.panelNode.scrollTop)\n                previousView.scrollTop = this.panelNode.scrollTop;\n\n            this.rebuild(false, view.scrollTop);\n        }\n    },\n\n    getObjectPath: function(object)\n    {\n        return this.objectPath;\n    },\n\n    getDefaultSelection: function()\n    {\n        return Firebug.browser.window;\n        //return this.context.getGlobalScope();\n    }/*,\n\n    updateOption: function(name, value)\n    {\n        const optionMap = {showUserProps: 1, showUserFuncs: 1, showDOMProps: 1,\n            showDOMFuncs: 1, showDOMConstants: 1};\n        if ( optionMap.hasOwnProperty(name) )\n            this.rebuild(true);\n    },\n\n    getOptionsMenuItems: function()\n    {\n        return [\n            optionMenu("ShowUserProps", "showUserProps"),\n            optionMenu("ShowUserFuncs", "showUserFuncs"),\n            optionMenu("ShowDOMProps", "showDOMProps"),\n            optionMenu("ShowDOMFuncs", "showDOMFuncs"),\n            optionMenu("ShowDOMConstants", "showDOMConstants"),\n            "-",\n            {label: "Refresh", command: bindFixed(this.rebuild, this, true) }\n        ];\n    },\n\n    getContextMenuItems: function(object, target)\n    {\n        var row = getAncestorByClass(target, "memberRow");\n\n        var items = [];\n\n        if (row)\n        {\n            var rowName = getRowName(row);\n            var rowObject = this.getRowObject(row);\n            var rowValue = this.getRowPropertyValue(row);\n\n            var isWatch = hasClass(row, "watchRow");\n            var isStackFrame = rowObject instanceof jsdIStackFrame;\n\n            if (typeof(rowValue) == "string" || typeof(rowValue) == "number")\n            {\n                // Functions already have a copy item in their context menu\n                items.push(\n                    "-",\n                    {label: "CopyValue",\n                        command: bindFixed(this.copyProperty, this, row) }\n                );\n            }\n\n            items.push(\n                "-",\n                {label: isWatch ? "EditWatch" : (isStackFrame ? "EditVariable" : "EditProperty"),\n                    command: bindFixed(this.editProperty, this, row) }\n            );\n\n            if (isWatch || (!isStackFrame && !isDOMMember(rowObject, rowName)))\n            {\n                items.push(\n                    {label: isWatch ? "DeleteWatch" : "DeleteProperty",\n                        command: bindFixed(this.deleteProperty, this, row) }\n                );\n            }\n        }\n\n        items.push(\n            "-",\n            {label: "Refresh", command: bindFixed(this.rebuild, this, true) }\n        );\n\n        return items;\n    },\n\n    getEditor: function(target, value)\n    {\n        if (!this.editor)\n            this.editor = new DOMEditor(this.document);\n\n        return this.editor;\n    }/**/\n});\n\n// ************************************************************************************************\n\n// TODO: xxxpedro statusbar\nvar updateStatusBar = function(panel)\n{\n    var path = panel.propertyPath;\n    var index = panel.pathIndex;\n\n    var r = [];\n\n    for (var i=0, l=path.length; i<l; i++)\n    {\n        r.push(i==index ? \'<a class="fbHover fbButton fbBtnSelected" \' : \'<a class="fbHover fbButton" \');\n        r.push(\'pathIndex=\');\n        r.push(i);\n\n        if(isIE6)\n            r.push(\' href="javascript:void(0)"\');\n\n        r.push(\'>\');\n        r.push(i==0 ? "window" : path[i] || "Object");\n        r.push(\'</a>\');\n\n        if(i < l-1)\n            r.push(\'<span class="fbStatusSeparator">&gt;</span>\');\n    }\n    panel.statusBarNode.innerHTML = r.join("");\n};\n\n\nvar DOMMainPanel = Firebug.DOMPanel = function () {};\n\nFirebug.DOMPanel.DirTable = DirTablePlate;\n\nDOMMainPanel.prototype = extend(Firebug.DOMBasePanel.prototype,\n{\n    onClickStatusBar: function(event)\n    {\n        var target = event.srcElement || event.target;\n        var element = getAncestorByClass(target, "fbHover");\n\n        if(element)\n        {\n            var pathIndex = element.getAttribute("pathIndex");\n\n            if(pathIndex)\n            {\n                this.select(this.getPathObject(pathIndex));\n            }\n        }\n    },\n\n    selectRow: function(row, target)\n    {\n        if (!target)\n            target = row.lastChild.firstChild;\n\n        if (!target || !target.repObject)\n            return;\n\n        this.pathToAppend = getPath(row);\n\n        // If the object is inside an array, look up its index\n        var valueBox = row.lastChild.firstChild;\n        if (hasClass(valueBox, "objectBox-array"))\n        {\n            var arrayIndex = FirebugReps.Arr.getItemIndex(target);\n            this.pathToAppend.push(arrayIndex);\n        }\n\n        // Make sure we get a fresh status path for the object, since otherwise\n        // it might find the object in the existing path and not refresh it\n        //Firebug.chrome.clearStatusPath();\n\n        this.select(target.repObject, true);\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onClick: function(event)\n    {\n        var target = event.srcElement || event.target;\n        var repNode = Firebug.getRepNode(target);\n        if (repNode)\n        {\n            var row = getAncestorByClass(target, "memberRow");\n            if (row)\n            {\n                this.selectRow(row, repNode);\n                cancelEvent(event);\n            }\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    name: "DOM",\n    title: "DOM",\n    searchable: true,\n    statusSeparator: ">",\n\n    options: {\n        hasToolButtons: true,\n        hasStatusBar: true\n    },\n\n    create: function()\n    {\n        Firebug.DOMBasePanel.prototype.create.apply(this, arguments);\n\n        this.onClick = bind(this.onClick, this);\n\n        //TODO: xxxpedro\n        this.onClickStatusBar = bind(this.onClickStatusBar, this);\n\n        this.panelNode.style.padding = "0 1px";\n    },\n\n    initialize: function(oldPanelNode)\n    {\n        //this.panelNode.addEventListener("click", this.onClick, false);\n        //dispatch([Firebug.A11yModel], \'onInitializeNode\', [this, \'console\']);\n\n        Firebug.DOMBasePanel.prototype.initialize.apply(this, arguments);\n\n        addEvent(this.panelNode, "click", this.onClick);\n\n        // TODO: xxxpedro dom\n        this.ishow();\n\n        //TODO: xxxpedro\n        addEvent(this.statusBarNode, "click", this.onClickStatusBar);\n    },\n\n    shutdown: function()\n    {\n        //this.panelNode.removeEventListener("click", this.onClick, false);\n        //dispatch([Firebug.A11yModel], \'onDestroyNode\', [this, \'console\']);\n\n        removeEvent(this.panelNode, "click", this.onClick);\n\n        Firebug.DOMBasePanel.prototype.shutdown.apply(this, arguments);\n    }/*,\n\n    search: function(text, reverse)\n    {\n        if (!text)\n        {\n            delete this.currentSearch;\n            this.highlightRow(null);\n            return false;\n        }\n\n        var row;\n        if (this.currentSearch && text == this.currentSearch.text)\n            row = this.currentSearch.findNext(true, undefined, reverse, Firebug.searchCaseSensitive);\n        else\n        {\n            function findRow(node) { return getAncestorByClass(node, "memberRow"); }\n            this.currentSearch = new TextSearch(this.panelNode, findRow);\n            row = this.currentSearch.find(text, reverse, Firebug.searchCaseSensitive);\n        }\n\n        if (row)\n        {\n            var sel = this.document.defaultView.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(this.currentSearch.range);\n\n            scrollIntoCenterView(row, this.panelNode);\n\n            this.highlightRow(row);\n            dispatch([Firebug.A11yModel], \'onDomSearchMatchFound\', [this, text, row]);\n            return true;\n        }\n        else\n        {\n            dispatch([Firebug.A11yModel], \'onDomSearchMatchFound\', [this, text, null]);\n            return false;\n        }\n    }/**/\n});\n\nFirebug.registerPanel(DOMMainPanel);\n\n\n// ************************************************************************************************\n\n\n\n// ************************************************************************************************\n// Local Helpers\n\nvar getMembers = function getMembers(object, level)  // we expect object to be user-level object wrapped in security blanket\n{\n    if (!level)\n        level = 0;\n\n    var ordinals = [], userProps = [], userClasses = [], userFuncs = [],\n        domProps = [], domFuncs = [], domConstants = [];\n\n    try\n    {\n        var domMembers = getDOMMembers(object);\n        //var domMembers = {}; // TODO: xxxpedro\n        //var domConstantMap = {};  // TODO: xxxpedro\n\n        if (object.wrappedJSObject)\n            var insecureObject = object.wrappedJSObject;\n        else\n            var insecureObject = object;\n\n        // IE function prototype is not listed in (for..in)\n        if (isIE && isFunction(object))\n            addMember("user", userProps, "prototype", object.prototype, level);\n\n        for (var name in insecureObject)  // enumeration is safe\n        {\n            if (ignoreVars[name] == 1)  // javascript.options.strict says ignoreVars is undefined.\n                continue;\n\n            var val;\n            try\n            {\n                val = insecureObject[name];  // getter is safe\n            }\n            catch (exc)\n            {\n                // Sometimes we get exceptions trying to access certain members\n                if (FBTrace.DBG_ERRORS && FBTrace.DBG_DOM)\n                    FBTrace.sysout("dom.getMembers cannot access "+name, exc);\n            }\n\n            var ordinal = parseInt(name);\n            if (ordinal || ordinal == 0)\n            {\n                addMember("ordinal", ordinals, name, val, level);\n            }\n            else if (isFunction(val))\n            {\n                if (isClassFunction(val) && !(name in domMembers))\n                    addMember("userClass", userClasses, name, val, level);\n                else if (name in domMembers)\n                    addMember("domFunction", domFuncs, name, val, level, domMembers[name]);\n                else\n                    addMember("userFunction", userFuncs, name, val, level);\n            }\n            else\n            {\n                //TODO: xxxpedro\n                /*\n                var getterFunction = insecureObject.__lookupGetter__(name),\n                    setterFunction = insecureObject.__lookupSetter__(name),\n                    prefix = "";\n\n                if(getterFunction && !setterFunction)\n                    prefix = "get ";\n                /**/\n\n                var prefix = "";\n\n                if (name in domMembers && !(name in domConstantMap))\n                    addMember("dom", domProps, (prefix+name), val, level, domMembers[name]);\n                else if (name in domConstantMap)\n                    addMember("dom", domConstants, (prefix+name), val, level);\n                else\n                    addMember("user", userProps, (prefix+name), val, level);\n            }\n        }\n    }\n    catch (exc)\n    {\n        // Sometimes we get exceptions just from trying to iterate the members\n        // of certain objects, like StorageList, but don\'t let that gum up the works\n        throw exc;\n        if (FBTrace.DBG_ERRORS && FBTrace.DBG_DOM)\n            FBTrace.sysout("dom.getMembers FAILS: ", exc);\n        //throw exc;\n    }\n\n    function sortName(a, b) { return a.name > b.name ? 1 : -1; }\n    function sortOrder(a, b) { return a.order > b.order ? 1 : -1; }\n\n    var members = [];\n\n    members.push.apply(members, ordinals);\n\n    Firebug.showUserProps = true; // TODO: xxxpedro\n    Firebug.showUserFuncs = true; // TODO: xxxpedro\n    Firebug.showDOMProps = true;\n    Firebug.showDOMFuncs = true;\n    Firebug.showDOMConstants = true;\n\n    if (Firebug.showUserProps)\n    {\n        userProps.sort(sortName);\n        members.push.apply(members, userProps);\n    }\n\n    if (Firebug.showUserFuncs)\n    {\n        userClasses.sort(sortName);\n        members.push.apply(members, userClasses);\n\n        userFuncs.sort(sortName);\n        members.push.apply(members, userFuncs);\n    }\n\n    if (Firebug.showDOMProps)\n    {\n        domProps.sort(sortName);\n        members.push.apply(members, domProps);\n    }\n\n    if (Firebug.showDOMFuncs)\n    {\n        domFuncs.sort(sortName);\n        members.push.apply(members, domFuncs);\n    }\n\n    if (Firebug.showDOMConstants)\n        members.push.apply(members, domConstants);\n\n    return members;\n};\n\nfunction expandMembers(members, toggles, offset, level)  // recursion starts with offset=0, level=0\n{\n    var expanded = 0;\n    for (var i = offset; i < members.length; ++i)\n    {\n        var member = members[i];\n        if (member.level > level)\n            break;\n\n        if ( toggles.hasOwnProperty(member.name) )\n        {\n            member.open = "opened";  // member.level <= level && member.name in toggles.\n\n            var newMembers = getMembers(member.value, level+1);  // sets newMembers.level to level+1\n\n            var args = [i+1, 0];\n            args.push.apply(args, newMembers);\n            members.splice.apply(members, args);\n\n            /*\n            if (FBTrace.DBG_DOM)\n            {\n                FBTrace.sysout("expandMembers member.name", member.name);\n                FBTrace.sysout("expandMembers toggles", toggles);\n                FBTrace.sysout("expandMembers toggles[member.name]", toggles[member.name]);\n                FBTrace.sysout("dom.expandedMembers level: "+level+" member", member);\n            }\n            /**/\n\n            expanded += newMembers.length;\n            i += newMembers.length + expandMembers(members, toggles[member.name], i+1, level+1);\n        }\n    }\n\n    return expanded;\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\nfunction isClassFunction(fn)\n{\n    try\n    {\n        for (var name in fn.prototype)\n            return true;\n    } catch (exc) {}\n    return false;\n}\n\n// FIXME: xxxpedro This function is already defined in Lib. If we keep this definition here, it\n// will crash IE9 when not running the IE Developer Tool with JavaScript Debugging enabled!!!\n// Check if this function is in fact defined in Firebug for Firefox. If so, we should remove\n// this from here. The only difference of this function is the IE hack to show up the prototype\n// of functions, but Firebug no longer shows the prototype for simple functions.\n//var hasProperties = function hasProperties(ob)\n//{\n//    try\n//    {\n//        for (var name in ob)\n//            return true;\n//    } catch (exc) {}\n//\n//    // IE function prototype is not listed in (for..in)\n//    if (isFunction(ob)) return true;\n//\n//    return false;\n//};\n\nFBL.ErrorCopy = function(message)\n{\n    this.message = message;\n};\n\nvar addMember = function addMember(type, props, name, value, level, order)\n{\n    var rep = Firebug.getRep(value);    // do this first in case a call to instanceof reveals contents\n    var tag = rep.shortTag ? rep.shortTag : rep.tag;\n\n    var ErrorCopy = function(){}; //TODO: xxxpedro\n\n    var valueType = typeof(value);\n    var hasChildren = hasProperties(value) && !(value instanceof ErrorCopy) &&\n        (isFunction(value) || (valueType == "object" && value != null)\n        || (valueType == "string" && value.length > Firebug.stringCropLength));\n\n    props.push({\n        name: name,\n        value: value,\n        type: type,\n        rowClass: "memberRow-"+type,\n        open: "",\n        order: order,\n        level: level,\n        indent: level*16,\n        hasChildren: hasChildren,\n        tag: tag\n    });\n};\n\nvar getWatchRowIndex = function getWatchRowIndex(row)\n{\n    var index = -1;\n    for (; row && hasClass(row, "watchRow"); row = row.previousSibling)\n        ++index;\n    return index;\n};\n\nvar getRowName = function getRowName(row)\n{\n    var node = row.firstChild;\n    return node.textContent ? node.textContent : node.innerText;\n};\n\nvar getRowValue = function getRowValue(row)\n{\n    return row.lastChild.firstChild.repObject;\n};\n\nvar getRowOwnerObject = function getRowOwnerObject(row)\n{\n    var parentRow = getParentRow(row);\n    if (parentRow)\n        return getRowValue(parentRow);\n};\n\nvar getParentRow = function getParentRow(row)\n{\n    var level = parseInt(row.getAttribute("level"))-1;\n    for (row = row.previousSibling; row; row = row.previousSibling)\n    {\n        if (parseInt(row.getAttribute("level")) == level)\n            return row;\n    }\n};\n\nvar getPath = function getPath(row)\n{\n    var name = getRowName(row);\n    var path = [name];\n\n    var level = parseInt(row.getAttribute("level"))-1;\n    for (row = row.previousSibling; row; row = row.previousSibling)\n    {\n        if (parseInt(row.getAttribute("level")) == level)\n        {\n            var name = getRowName(row);\n            path.splice(0, 0, name);\n\n            --level;\n        }\n    }\n\n    return path;\n};\n\n// ************************************************************************************************\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n// ************************************************************************************************\n// DOM Module\n\nFirebug.DOM = extend(Firebug.Module,\n{\n    getPanel: function()\n    {\n        return Firebug.chrome ? Firebug.chrome.getPanel("DOM") : null;\n    }\n});\n\nFirebug.registerModule(Firebug.DOM);\n\n\n// ************************************************************************************************\n// DOM Panel\n\nvar lastHighlightedObject;\n\nfunction DOMSidePanel(){};\n\nDOMSidePanel.prototype = extend(Firebug.DOMBasePanel.prototype,\n{\n    selectRow: function(row, target)\n    {\n        if (!target)\n            target = row.lastChild.firstChild;\n\n        if (!target || !target.repObject)\n            return;\n\n        this.pathToAppend = getPath(row);\n\n        // If the object is inside an array, look up its index\n        var valueBox = row.lastChild.firstChild;\n        if (hasClass(valueBox, "objectBox-array"))\n        {\n            var arrayIndex = FirebugReps.Arr.getItemIndex(target);\n            this.pathToAppend.push(arrayIndex);\n        }\n\n        // Make sure we get a fresh status path for the object, since otherwise\n        // it might find the object in the existing path and not refresh it\n        //Firebug.chrome.clearStatusPath();\n\n        var object = target.repObject;\n\n        if (instanceOf(object, "Element"))\n        {\n            Firebug.HTML.selectTreeNode(ElementCache(object));\n        }\n        else\n        {\n            Firebug.chrome.selectPanel("DOM");\n            Firebug.chrome.getPanel("DOM").select(object, true);\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n    onClick: function(event)\n    {\n        /*\n        var target = event.srcElement || event.target;\n\n        var object = getAncestorByClass(target, "objectLink");\n        object = object ? object.repObject : null;\n\n        if(!object) return;\n\n        if (instanceOf(object, "Element"))\n        {\n            Firebug.HTML.selectTreeNode(ElementCache(object));\n        }\n        else\n        {\n            Firebug.chrome.selectPanel("DOM");\n            Firebug.chrome.getPanel("DOM").select(object, true);\n        }\n        /**/\n\n\n        var target = event.srcElement || event.target;\n        var repNode = Firebug.getRepNode(target);\n        if (repNode)\n        {\n            var row = getAncestorByClass(target, "memberRow");\n            if (row)\n            {\n                this.selectRow(row, repNode);\n                cancelEvent(event);\n            }\n        }\n        /**/\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // extends Panel\n\n    name: "DOMSidePanel",\n    parentPanel: "HTML",\n    title: "DOM",\n\n    options: {\n        hasToolButtons: true\n    },\n\n    isInitialized: false,\n\n    create: function()\n    {\n        Firebug.DOMBasePanel.prototype.create.apply(this, arguments);\n\n        this.onClick = bind(this.onClick, this);\n    },\n\n    initialize: function(){\n        Firebug.DOMBasePanel.prototype.initialize.apply(this, arguments);\n\n        addEvent(this.panelNode, "click", this.onClick);\n\n        // TODO: xxxpedro css2\n        var selection = ElementCache.get(Firebug.context.persistedState.selectedHTMLElementId);\n        if (selection)\n            this.select(selection, true);\n    },\n\n    shutdown: function()\n    {\n        removeEvent(this.panelNode, "click", this.onClick);\n\n        Firebug.DOMBasePanel.prototype.shutdown.apply(this, arguments);\n    },\n\n    reattach: function(oldChrome)\n    {\n        //this.isInitialized = oldChrome.getPanel("DOM").isInitialized;\n        this.toggles = oldChrome.getPanel("DOMSidePanel").toggles;\n    }\n\n});\n\nFirebug.registerPanel(DOMSidePanel);\n\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.FBTrace = {};\n\n(function() {\n// ************************************************************************************************\n\nvar traceOptions = {\n    DBG_TIMESTAMP: 1,\n    DBG_INITIALIZE: 1,\n    DBG_CHROME: 1,\n    DBG_ERRORS: 1,\n    DBG_DISPATCH: 1,\n    DBG_CSS: 1\n};\n\nthis.module = null;\n\nthis.initialize = function()\n{\n    if (!this.messageQueue)\n        this.messageQueue = [];\n\n    for (var name in traceOptions)\n        this[name] = traceOptions[name];\n};\n\n// ************************************************************************************************\n// FBTrace API\n\nthis.sysout = function()\n{\n    return this.logFormatted(arguments, "");\n};\n\nthis.dumpProperties = function(title, object)\n{\n    return this.logFormatted("dumpProperties() not supported.", "warning");\n};\n\nthis.dumpStack = function()\n{\n    return this.logFormatted("dumpStack() not supported.", "warning");\n};\n\nthis.flush = function(module)\n{\n    this.module = module;\n\n    var queue = this.messageQueue;\n    this.messageQueue = [];\n\n    for (var i = 0; i < queue.length; ++i)\n        this.writeMessage(queue[i][0], queue[i][1], queue[i][2]);\n};\n\nthis.getPanel = function()\n{\n    return this.module ? this.module.getPanel() : null;\n};\n\n//*************************************************************************************************\n\nthis.logFormatted = function(objects, className)\n{\n    var html = this.DBG_TIMESTAMP ? [getTimestamp(), " | "] : [];\n    var length = objects.length;\n\n    for (var i = 0; i < length; ++i)\n    {\n        appendText(" ", html);\n\n        var object = objects[i];\n\n        if (i == 0)\n        {\n            html.push("<b>");\n            appendText(object, html);\n            html.push("</b>");\n        }\n        else\n            appendText(object, html);\n    }\n\n    return this.logRow(html, className);\n};\n\nthis.logRow = function(message, className)\n{\n    var panel = this.getPanel();\n\n    if (panel && panel.panelNode)\n        this.writeMessage(message, className);\n    else\n    {\n        this.messageQueue.push([message, className]);\n    }\n\n    return this.LOG_COMMAND;\n};\n\nthis.writeMessage = function(message, className)\n{\n    var container = this.getPanel().containerNode;\n    var isScrolledToBottom =\n        container.scrollTop + container.offsetHeight >= container.scrollHeight;\n\n    this.writeRow.call(this, message, className);\n\n    if (isScrolledToBottom)\n        container.scrollTop = container.scrollHeight - container.offsetHeight;\n};\n\nthis.appendRow = function(row)\n{\n    var container = this.getPanel().panelNode;\n    container.appendChild(row);\n};\n\nthis.writeRow = function(message, className)\n{\n    var row = this.getPanel().panelNode.ownerDocument.createElement("div");\n    row.className = "logRow" + (className ? " logRow-"+className : "");\n    row.innerHTML = message.join("");\n    this.appendRow(row);\n};\n\n//*************************************************************************************************\n\nfunction appendText(object, html)\n{\n    html.push(escapeHTML(objectToString(object)));\n};\n\nfunction getTimestamp()\n{\n    var now = new Date();\n    var ms = "" + (now.getMilliseconds() / 1000).toFixed(3);\n    ms = ms.substr(2);\n\n    return now.toLocaleTimeString() + "." + ms;\n};\n\n//*************************************************************************************************\n\nvar HTMLtoEntity =\n{\n    "<": "&lt;",\n    ">": "&gt;",\n    "&": "&amp;",\n    "\'": "&#39;",\n    \'"\': "&quot;"\n};\n\nfunction replaceChars(ch)\n{\n    return HTMLtoEntity[ch];\n};\n\nfunction escapeHTML(value)\n{\n    return (value+"").replace(/[<>&"\']/g, replaceChars);\n};\n\n//*************************************************************************************************\n\nfunction objectToString(object)\n{\n    try\n    {\n        return object+"";\n    }\n    catch (exc)\n    {\n        return null;\n    }\n};\n\n// ************************************************************************************************\n}).apply(FBL.FBTrace);\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// If application isn\'t in trace mode, the FBTrace panel won\'t be loaded\nif (!Env.Options.enableTrace) return;\n\n// ************************************************************************************************\n// FBTrace Module\n\nFirebug.Trace = extend(Firebug.Module,\n{\n    getPanel: function()\n    {\n        return Firebug.chrome ? Firebug.chrome.getPanel("Trace") : null;\n    },\n\n    clear: function()\n    {\n        this.getPanel().panelNode.innerHTML = "";\n    }\n});\n\nFirebug.registerModule(Firebug.Trace);\n\n\n// ************************************************************************************************\n// FBTrace Panel\n\nfunction TracePanel(){};\n\nTracePanel.prototype = extend(Firebug.Panel,\n{\n    name: "Trace",\n    title: "Trace",\n\n    options: {\n        hasToolButtons: true,\n        innerHTMLSync: true\n    },\n\n    create: function(){\n        Firebug.Panel.create.apply(this, arguments);\n\n        this.clearButton = new Button({\n            caption: "Clear",\n            title: "Clear FBTrace logs",\n            owner: Firebug.Trace,\n            onClick: Firebug.Trace.clear\n        });\n    },\n\n    initialize: function(){\n        Firebug.Panel.initialize.apply(this, arguments);\n\n        this.clearButton.initialize();\n    },\n\n    shutdown: function()\n    {\n        this.clearButton.shutdown();\n\n        Firebug.Panel.shutdown.apply(this, arguments);\n    }\n\n});\n\nFirebug.registerPanel(TracePanel);\n\n// ************************************************************************************************\n}});\n\n/* See license.txt for terms of usage */\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\n// ************************************************************************************************\n// Globals\n\nvar modules = [];\nvar panelTypes = [];\nvar panelTypeMap = {};\n\nvar parentPanelMap = {};\n\n\nvar registerModule = Firebug.registerModule;\nvar registerPanel = Firebug.registerPanel;\n\n// ************************************************************************************************\nappend(Firebug,\n{\n    extend: function(fn)\n    {\n        if (Firebug.chrome && Firebug.chrome.addPanel)\n        {\n            var namespace = ns(fn);\n            fn.call(namespace, FBL);\n        }\n        else\n        {\n            setTimeout(function(){Firebug.extend(fn);},100);\n        }\n    },\n\n    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    // Registration\n\n    registerModule: function()\n    {\n        registerModule.apply(Firebug, arguments);\n\n        modules.push.apply(modules, arguments);\n\n        dispatch(modules, "initialize", []);\n\n        if (FBTrace.DBG_INITIALIZE) FBTrace.sysout("Firebug.registerModule");\n    },\n\n    registerPanel: function()\n    {\n        registerPanel.apply(Firebug, arguments);\n\n        panelTypes.push.apply(panelTypes, arguments);\n\n        for (var i = 0, panelType; panelType = arguments[i]; ++i)\n        {\n            // TODO: xxxpedro investigate why Dev Panel throws an error\n            if (panelType.prototype.name == "Dev") continue;\n\n            panelTypeMap[panelType.prototype.name] = arguments[i];\n\n            var parentPanelName = panelType.prototype.parentPanel;\n            if (parentPanelName)\n            {\n                parentPanelMap[parentPanelName] = 1;\n            }\n            else\n            {\n                var panelName = panelType.prototype.name;\n                var chrome = Firebug.chrome;\n                chrome.addPanel(panelName);\n\n                // tab click handler\n                var onTabClick = function onTabClick()\n                {\n                    chrome.selectPanel(panelName);\n                    return false;\n                };\n\n                chrome.addController([chrome.panelMap[panelName].tabNode, "mousedown", onTabClick]);\n            }\n        }\n\n        if (FBTrace.DBG_INITIALIZE)\n            for (var i = 0; i < arguments.length; ++i)\n                FBTrace.sysout("Firebug.registerPanel", arguments[i].prototype.name);\n    }\n\n});\n\n\n\n\n// ************************************************************************************************\n}});\n\nFBL.ns(function() { with (FBL) {\n// ************************************************************************************************\n\nFirebugChrome.Skin =\n{\n    CSS: \'.obscured{left:-999999px !important;}.collapsed{display:none;}[collapsed="true"]{display:none;}#fbCSS{padding:0 !important;}.cssPropDisable{float:left;display:block;width:2em;cursor:default;}.infoTip{z-index:2147483647;position:fixed;padding:2px 3px;border:1px solid #CBE087;background:LightYellow;font-family:Monaco,monospace;color:#000000;display:none;white-space:nowrap;pointer-events:none;}.infoTip[active="true"]{display:block;}.infoTipLoading{width:16px;height:16px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/loading_16.gif) no-repeat;}.infoTipImageBox{font-size:11px;min-width:100px;text-align:center;}.infoTipCaption{font-size:11px;font:Monaco,monospace;}.infoTipLoading > .infoTipImage,.infoTipLoading > .infoTipCaption{display:none;}h1.groupHeader{padding:2px 4px;margin:0 0 4px 0;border-top:1px solid #CCCCCC;border-bottom:1px solid #CCCCCC;background:#eee url(https://getfirebug.com/releases/lite/latest/skin/xp/group.gif) repeat-x;font-size:11px;font-weight:bold;_position:relative;}.inlineEditor,.fixedWidthEditor{z-index:2147483647;position:absolute;display:none;}.inlineEditor{margin-left:-6px;margin-top:-3px;}.textEditorInner,.fixedWidthEditor{margin:0 0 0 0 !important;padding:0;border:none !important;font:inherit;text-decoration:inherit;background-color:#FFFFFF;}.fixedWidthEditor{border-top:1px solid #888888 !important;border-bottom:1px solid #888888 !important;}.textEditorInner{position:relative;top:-7px;left:-5px;outline:none;resize:none;}.textEditorInner1{padding-left:11px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorBorders.png) repeat-y;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorBorders.gif) repeat-y;_overflow:hidden;}.textEditorInner2{position:relative;padding-right:2px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorBorders.png) repeat-y 100% 0;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorBorders.gif) repeat-y 100% 0;_position:fixed;}.textEditorTop1{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.png) no-repeat 100% 0;margin-left:11px;height:10px;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.gif) no-repeat 100% 0;_overflow:hidden;}.textEditorTop2{position:relative;left:-11px;width:11px;height:10px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.png) no-repeat;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.gif) no-repeat;}.textEditorBottom1{position:relative;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.png) no-repeat 100% 100%;margin-left:11px;height:12px;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.gif) no-repeat 100% 100%;}.textEditorBottom2{position:relative;left:-11px;width:11px;height:12px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.png) no-repeat 0 100%;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/textEditorCorners.gif) no-repeat 0 100%;}.panelNode-css{overflow-x:hidden;}.cssSheet > .insertBefore{height:1.5em;}.cssRule{position:relative;margin:0;padding:1em 0 0 6px;font-family:Monaco,monospace;color:#000000;}.cssRule:first-child{padding-top:6px;}.cssElementRuleContainer{position:relative;}.cssHead{padding-right:150px;}.cssProp{}.cssPropName{color:DarkGreen;}.cssPropValue{margin-left:8px;color:DarkBlue;}.cssOverridden span{text-decoration:line-through;}.cssInheritedRule{}.cssInheritLabel{margin-right:0.5em;font-weight:bold;}.cssRule .objectLink-sourceLink{top:0;}.cssProp.editGroup:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/disable.png) no-repeat 2px 1px;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/disable.gif) no-repeat 2px 1px;}.cssProp.editGroup.editing{background:none;}.cssProp.disabledStyle{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/disableHover.png) no-repeat 2px 1px;_background:url(https://getfirebug.com/releases/lite/latest/skin/xp/disableHover.gif) no-repeat 2px 1px;opacity:1;color:#CCCCCC;}.disabledStyle .cssPropName,.disabledStyle .cssPropValue{color:#CCCCCC;}.cssPropValue.editing + .cssSemi,.inlineExpander + .cssSemi{display:none;}.cssPropValue.editing{white-space:nowrap;}.stylePropName{font-weight:bold;padding:0 4px 4px 4px;width:50%;}.stylePropValue{width:50%;}.panelNode-net{overflow-x:hidden;}.netTable{width:100%;}.hideCategory-undefined .category-undefined,.hideCategory-html .category-html,.hideCategory-css .category-css,.hideCategory-js .category-js,.hideCategory-image .category-image,.hideCategory-xhr .category-xhr,.hideCategory-flash .category-flash,.hideCategory-txt .category-txt,.hideCategory-bin .category-bin{display:none;}.netHeadRow{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/group.gif) repeat-x #FFFFFF;}.netHeadCol{border-bottom:1px solid #CCCCCC;padding:2px 4px 2px 18px;font-weight:bold;}.netHeadLabel{white-space:nowrap;overflow:hidden;}.netHeaderRow{height:16px;}.netHeaderCell{cursor:pointer;-moz-user-select:none;border-bottom:1px solid #9C9C9C;padding:0 !important;font-weight:bold;background:#BBBBBB url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/tableHeader.gif) repeat-x;white-space:nowrap;}.netHeaderRow > .netHeaderCell:first-child > .netHeaderCellBox{padding:2px 14px 2px 18px;}.netHeaderCellBox{padding:2px 14px 2px 10px;border-left:1px solid #D9D9D9;border-right:1px solid #9C9C9C;}.netHeaderCell:hover:active{background:#959595 url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/tableHeaderActive.gif) repeat-x;}.netHeaderSorted{background:#7D93B2 url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/tableHeaderSorted.gif) repeat-x;}.netHeaderSorted > .netHeaderCellBox{border-right-color:#6B7C93;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/arrowDown.png) no-repeat right;}.netHeaderSorted.sortedAscending > .netHeaderCellBox{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/arrowUp.png);}.netHeaderSorted:hover:active{background:#536B90 url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/tableHeaderSortedActive.gif) repeat-x;}.panelNode-net .netRowHeader{display:block;}.netRowHeader{cursor:pointer;display:none;height:15px;margin-right:0 !important;}.netRow .netRowHeader{background-position:5px 1px;}.netRow[breakpoint="true"] .netRowHeader{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/breakpoint.png);}.netRow[breakpoint="true"][disabledBreakpoint="true"] .netRowHeader{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/breakpointDisabled.png);}.netRow.category-xhr:hover .netRowHeader{background-color:#F6F6F6;}#netBreakpointBar{max-width:38px;}#netHrefCol > .netHeaderCellBox{border-left:0px;}.netRow .netRowHeader{width:3px;}.netInfoRow .netRowHeader{display:table-cell;}.netTable[hiddenCols~=netHrefCol] TD[id="netHrefCol"],.netTable[hiddenCols~=netHrefCol] TD.netHrefCol,.netTable[hiddenCols~=netStatusCol] TD[id="netStatusCol"],.netTable[hiddenCols~=netStatusCol] TD.netStatusCol,.netTable[hiddenCols~=netDomainCol] TD[id="netDomainCol"],.netTable[hiddenCols~=netDomainCol] TD.netDomainCol,.netTable[hiddenCols~=netSizeCol] TD[id="netSizeCol"],.netTable[hiddenCols~=netSizeCol] TD.netSizeCol,.netTable[hiddenCols~=netTimeCol] TD[id="netTimeCol"],.netTable[hiddenCols~=netTimeCol] TD.netTimeCol{display:none;}.netRow{background:LightYellow;}.netRow.loaded{background:#FFFFFF;}.netRow.loaded:hover{background:#EFEFEF;}.netCol{padding:0;vertical-align:top;border-bottom:1px solid #EFEFEF;white-space:nowrap;height:17px;}.netLabel{width:100%;}.netStatusCol{padding-left:10px;color:rgb(128,128,128);}.responseError > .netStatusCol{color:red;}.netDomainCol{padding-left:5px;}.netSizeCol{text-align:right;padding-right:10px;}.netHrefLabel{-moz-box-sizing:padding-box;overflow:hidden;z-index:10;position:absolute;padding-left:18px;padding-top:1px;max-width:15%;font-weight:bold;}.netFullHrefLabel{display:none;-moz-user-select:none;padding-right:10px;padding-bottom:3px;max-width:100%;background:#FFFFFF;z-index:200;}.netHrefCol:hover > .netFullHrefLabel{display:block;}.netRow.loaded:hover .netCol > .netFullHrefLabel{background-color:#EFEFEF;}.useA11y .a11yShowFullLabel{display:block;background-image:none !important;border:1px solid #CBE087;background-color:LightYellow;font-family:Monaco,monospace;color:#000000;font-size:10px;z-index:2147483647;}.netSizeLabel{padding-left:6px;}.netStatusLabel,.netDomainLabel,.netSizeLabel,.netBar{padding:1px 0 2px 0 !important;}.responseError{color:red;}.hasHeaders .netHrefLabel:hover{cursor:pointer;color:blue;text-decoration:underline;}.netLoadingIcon{position:absolute;border:0;margin-left:14px;width:16px;height:16px;background:transparent no-repeat 0 0;background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/loading_16.gif);display:inline-block;}.loaded .netLoadingIcon{display:none;}.netBar,.netSummaryBar{position:relative;border-right:50px solid transparent;}.netResolvingBar{position:absolute;left:0;top:0;bottom:0;background:#FFFFFF url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarResolving.gif) repeat-x;z-index:60;}.netConnectingBar{position:absolute;left:0;top:0;bottom:0;background:#FFFFFF url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarConnecting.gif) repeat-x;z-index:50;}.netBlockingBar{position:absolute;left:0;top:0;bottom:0;background:#FFFFFF url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarWaiting.gif) repeat-x;z-index:40;}.netSendingBar{position:absolute;left:0;top:0;bottom:0;background:#FFFFFF url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarSending.gif) repeat-x;z-index:30;}.netWaitingBar{position:absolute;left:0;top:0;bottom:0;background:#FFFFFF url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarResponded.gif) repeat-x;z-index:20;min-width:1px;}.netReceivingBar{position:absolute;left:0;top:0;bottom:0;background:#38D63B url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarLoading.gif) repeat-x;z-index:10;}.netWindowLoadBar,.netContentLoadBar{position:absolute;left:0;top:0;bottom:0;width:1px;background-color:red;z-index:70;opacity:0.5;display:none;margin-bottom:-1px;}.netContentLoadBar{background-color:Blue;}.netTimeLabel{-moz-box-sizing:padding-box;position:absolute;top:1px;left:100%;padding-left:6px;color:#444444;min-width:16px;}.loaded .netReceivingBar,.loaded.netReceivingBar{background:#B6B6B6 url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarLoaded.gif) repeat-x;border-color:#B6B6B6;}.fromCache .netReceivingBar,.fromCache.netReceivingBar{background:#D6D6D6 url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/netBarCached.gif) repeat-x;border-color:#D6D6D6;}.netSummaryRow .netTimeLabel,.loaded .netTimeLabel{background:transparent;}.timeInfoTip{width:150px; height:40px}.timeInfoTipBar,.timeInfoTipEventBar{position:relative;display:block;margin:0;opacity:1;height:15px;width:4px;}.timeInfoTipEventBar{width:1px !important;}.timeInfoTipCell.startTime{padding-right:8px;}.timeInfoTipCell.elapsedTime{text-align:right;padding-right:8px;}.sizeInfoLabelCol{font-weight:bold;padding-right:10px;font-family:Lucida Grande,Tahoma,sans-serif;font-size:11px;}.sizeInfoSizeCol{font-weight:bold;}.sizeInfoDetailCol{color:gray;text-align:right;}.sizeInfoDescCol{font-style:italic;}.netSummaryRow .netReceivingBar{background:#BBBBBB;border:none;}.netSummaryLabel{color:#222222;}.netSummaryRow{background:#BBBBBB !important;font-weight:bold;}.netSummaryRow .netBar{border-right-color:#BBBBBB;}.netSummaryRow > .netCol{border-top:1px solid #999999;border-bottom:2px solid;-moz-border-bottom-colors:#EFEFEF #999999;padding-top:1px;padding-bottom:2px;}.netSummaryRow > .netHrefCol:hover{background:transparent !important;}.netCountLabel{padding-left:18px;}.netTotalSizeCol{text-align:right;padding-right:10px;}.netTotalTimeCol{text-align:right;}.netCacheSizeLabel{position:absolute;z-index:1000;left:0;top:0;}.netLimitRow{background:rgb(255,255,225) !important;font-weight:normal;color:black;font-weight:normal;}.netLimitLabel{padding-left:18px;}.netLimitRow > .netCol{border-bottom:2px solid;-moz-border-bottom-colors:#EFEFEF #999999;vertical-align:middle !important;padding-top:2px;padding-bottom:2px;}.netLimitButton{font-size:11px;padding-top:1px;padding-bottom:1px;}.netInfoCol{border-top:1px solid #EEEEEE;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/group.gif) repeat-x #FFFFFF;}.netInfoBody{margin:10px 0 4px 10px;}.netInfoTabs{position:relative;padding-left:17px;}.netInfoTab{position:relative;top:-3px;margin-top:10px;padding:4px 6px;border:1px solid transparent;border-bottom:none;_border:none;font-weight:bold;color:#565656;cursor:pointer;}.netInfoTabSelected{cursor:default !important;border:1px solid #D7D7D7 !important;border-bottom:none !important;-moz-border-radius:4px 4px 0 0;-webkit-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0;background-color:#FFFFFF;}.logRow-netInfo.error .netInfoTitle{color:red;}.logRow-netInfo.loading .netInfoResponseText{font-style:italic;color:#888888;}.loading .netInfoResponseHeadersTitle{display:none;}.netInfoResponseSizeLimit{font-family:Lucida Grande,Tahoma,sans-serif;padding-top:10px;font-size:11px;}.netInfoText{display:none;margin:0;border:1px solid #D7D7D7;border-right:none;padding:8px;background-color:#FFFFFF;font-family:Monaco,monospace;white-space:pre-wrap;}.netInfoTextSelected{display:block;}.netInfoParamName{padding-right:10px;font-family:Lucida Grande,Tahoma,sans-serif;font-weight:bold;vertical-align:top;text-align:right;white-space:nowrap;}.netInfoPostText .netInfoParamName{width:1px;}.netInfoParamValue{width:100%;}.netInfoHeadersText,.netInfoPostText,.netInfoPutText{padding-top:0;}.netInfoHeadersGroup,.netInfoPostParams,.netInfoPostSource{margin-bottom:4px;border-bottom:1px solid #D7D7D7;padding-top:8px;padding-bottom:2px;font-family:Lucida Grande,Tahoma,sans-serif;font-weight:bold;color:#565656;}.netInfoPostParamsTable,.netInfoPostPartsTable,.netInfoPostJSONTable,.netInfoPostXMLTable,.netInfoPostSourceTable{margin-bottom:10px;width:100%;}.netInfoPostContentType{color:#bdbdbd;padding-left:50px;font-weight:normal;}.netInfoHtmlPreview{border:0;width:100%;height:100%;}.netHeadersViewSource{color:#bdbdbd;margin-left:200px;font-weight:normal;}.netHeadersViewSource:hover{color:blue;cursor:pointer;}.netActivationRow,.netPageSeparatorRow{background:rgb(229,229,229) !important;font-weight:normal;color:black;}.netActivationLabel{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/chrome://firebug/skin/infoIcon.png) no-repeat 3px 2px;padding-left:22px;}.netPageSeparatorRow{height:5px !important;}.netPageSeparatorLabel{padding-left:22px;height:5px !important;}.netPageRow{background-color:rgb(255,255,255);}.netPageRow:hover{background:#EFEFEF;}.netPageLabel{padding:1px 0 2px 18px !important;font-weight:bold;}.netActivationRow > .netCol{border-bottom:2px solid;-moz-border-bottom-colors:#EFEFEF #999999;padding-top:2px;padding-bottom:3px;}.twisty,.logRow-errorMessage > .hasTwisty > .errorTitle,.logRow-log > .objectBox-array.hasTwisty,.logRow-spy .spyHead .spyTitle,.logGroup > .logRow,.memberRow.hasChildren > .memberLabelCell > .memberLabel,.hasHeaders .netHrefLabel,.netPageRow > .netCol > .netPageTitle{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/tree_open.gif);background-repeat:no-repeat;background-position:2px 2px;min-height:12px;}.logRow-errorMessage > .hasTwisty.opened > .errorTitle,.logRow-log > .objectBox-array.hasTwisty.opened,.logRow-spy.opened .spyHead .spyTitle,.logGroup.opened > .logRow,.memberRow.hasChildren.opened > .memberLabelCell > .memberLabel,.nodeBox.highlightOpen > .nodeLabel > .twisty,.nodeBox.open > .nodeLabel > .twisty,.netRow.opened > .netCol > .netHrefLabel,.netPageRow.opened > .netCol > .netPageTitle{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/tree_close.gif);}.twisty{background-position:4px 4px;}* html .logRow-spy .spyHead .spyTitle,* html .logGroup .logGroupLabel,* html .hasChildren .memberLabelCell .memberLabel,* html .hasHeaders .netHrefLabel{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/tree_open.gif);background-repeat:no-repeat;background-position:2px 2px;}* html .opened .spyHead .spyTitle,* html .opened .logGroupLabel,* html .opened .memberLabelCell .memberLabel{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/tree_close.gif);background-repeat:no-repeat;background-position:2px 2px;}.panelNode-console{overflow-x:hidden;}.objectLink{text-decoration:none;}.objectLink:hover{cursor:pointer;text-decoration:underline;}.logRow{position:relative;margin:0;border-bottom:1px solid #D7D7D7;padding:2px 4px 1px 6px;background-color:#FFFFFF;overflow:hidden !important;}.useA11y .logRow:focus{border-bottom:1px solid #000000 !important;outline:none !important;background-color:#FFFFAD !important;}.useA11y .logRow:focus a.objectLink-sourceLink{background-color:#FFFFAD;}.useA11y .a11yFocus:focus,.useA11y .objectBox:focus{outline:2px solid #FF9933;background-color:#FFFFAD;}.useA11y .objectBox-null:focus,.useA11y .objectBox-undefined:focus{background-color:#888888 !important;}.useA11y .logGroup.opened > .logRow{border-bottom:1px solid #ffffff;}.logGroup{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/group.gif) repeat-x #FFFFFF;padding:0 !important;border:none !important;}.logGroupBody{display:none;margin-left:16px;border-left:1px solid #D7D7D7;border-top:1px solid #D7D7D7;background:#FFFFFF;}.logGroup > .logRow{background-color:transparent !important;font-weight:bold;}.logGroup.opened > .logRow{border-bottom:none;}.logGroup.opened > .logGroupBody{display:block;}.logRow-command > .objectBox-text{font-family:Monaco,monospace;color:#0000FF;white-space:pre-wrap;}.logRow-info,.logRow-warn,.logRow-error,.logRow-assert,.logRow-warningMessage,.logRow-errorMessage{padding-left:22px;background-repeat:no-repeat;background-position:4px 2px;}.logRow-assert,.logRow-warningMessage,.logRow-errorMessage{padding-top:0;padding-bottom:0;}.logRow-info,.logRow-info .objectLink-sourceLink{background-color:#FFFFFF;}.logRow-warn,.logRow-warningMessage,.logRow-warn .objectLink-sourceLink,.logRow-warningMessage .objectLink-sourceLink{background-color:cyan;}.logRow-error,.logRow-assert,.logRow-errorMessage,.logRow-error .objectLink-sourceLink,.logRow-errorMessage .objectLink-sourceLink{background-color:LightYellow;}.logRow-error,.logRow-assert,.logRow-errorMessage{color:#FF0000;}.logRow-info{}.logRow-warn,.logRow-warningMessage{}.logRow-error,.logRow-assert,.logRow-errorMessage{}.objectBox-string,.objectBox-text,.objectBox-number,.objectLink-element,.objectLink-textNode,.objectLink-function,.objectBox-stackTrace,.objectLink-profile{font-family:Monaco,monospace;}.objectBox-string,.objectBox-text,.objectLink-textNode{white-space:pre-wrap;}.objectBox-number,.objectLink-styleRule,.objectLink-element,.objectLink-textNode{color:#000088;}.objectBox-string{color:#FF0000;}.objectLink-function,.objectBox-stackTrace,.objectLink-profile{color:DarkGreen;}.objectBox-null,.objectBox-undefined{padding:0 2px;border:1px solid #666666;background-color:#888888;color:#FFFFFF;}.objectBox-exception{padding:0 2px 0 18px;color:red;}.objectLink-sourceLink{position:absolute;right:4px;top:2px;padding-left:8px;font-family:Lucida Grande,sans-serif;font-weight:bold;color:#0000FF;}.errorTitle{margin-top:0px;margin-bottom:1px;padding-top:2px;padding-bottom:2px;}.errorTrace{margin-left:17px;}.errorSourceBox{margin:2px 0;}.errorSource-none{display:none;}.errorSource-syntax > .errorBreak{visibility:hidden;}.errorSource{cursor:pointer;font-family:Monaco,monospace;color:DarkGreen;}.errorSource:hover{text-decoration:underline;}.errorBreak{cursor:pointer;display:none;margin:0 6px 0 0;width:13px;height:14px;vertical-align:bottom;opacity:0.1;}.hasBreakSwitch .errorBreak{display:inline;}.breakForError .errorBreak{opacity:1;}.assertDescription{margin:0;}.logRow-profile > .logRow > .objectBox-text{font-family:Lucida Grande,Tahoma,sans-serif;color:#000000;}.logRow-profile > .logRow > .objectBox-text:last-child{color:#555555;font-style:italic;}.logRow-profile.opened > .logRow{padding-bottom:4px;}.profilerRunning > .logRow{padding-left:22px !important;}.profileSizer{width:100%;overflow-x:auto;overflow-y:scroll;}.profileTable{border-bottom:1px solid #D7D7D7;padding:0 0 4px 0;}.profileTable tr[odd="1"]{background-color:#F5F5F5;vertical-align:middle;}.profileTable a{vertical-align:middle;}.profileTable td{padding:1px 4px 0 4px;}.headerCell{cursor:pointer;-moz-user-select:none;border-bottom:1px solid #9C9C9C;padding:0 !important;font-weight:bold;}.headerCellBox{padding:2px 4px;border-left:1px solid #D9D9D9;border-right:1px solid #9C9C9C;}.headerCell:hover:active{}.headerSorted{}.headerSorted > .headerCellBox{border-right-color:#6B7C93;}.headerSorted.sortedAscending > .headerCellBox{}.headerSorted:hover:active{}.linkCell{text-align:right;}.linkCell > .objectLink-sourceLink{position:static;}.logRow-stackTrace{padding-top:0;background:#f8f8f8;}.logRow-stackTrace > .objectBox-stackFrame{position:relative;padding-top:2px;}.objectLink-object{font-family:Lucida Grande,sans-serif;font-weight:bold;color:DarkGreen;white-space:pre-wrap;}.objectProp-object{color:DarkGreen;}.objectProps{color:#000;font-weight:normal;}.objectPropName{color:#777;}.objectProps .objectProp-string{color:#f55;}.objectProps .objectProp-number{color:#55a;}.objectProps .objectProp-object{color:#585;}.selectorTag,.selectorId,.selectorClass{font-family:Monaco,monospace;font-weight:normal;}.selectorTag{color:#0000FF;}.selectorId{color:DarkBlue;}.selectorClass{color:red;}.selectorHidden > .selectorTag{color:#5F82D9;}.selectorHidden > .selectorId{color:#888888;}.selectorHidden > .selectorClass{color:#D86060;}.selectorValue{font-family:Lucida Grande,sans-serif;font-style:italic;color:#555555;}.panelNode.searching .logRow{display:none;}.logRow.matched{display:block !important;}.logRow.matching{position:absolute;left:-1000px;top:-1000px;max-width:0;max-height:0;overflow:hidden;}.objectLeftBrace,.objectRightBrace,.objectEqual,.objectComma,.arrayLeftBracket,.arrayRightBracket,.arrayComma{font-family:Monaco,monospace;}.objectLeftBrace,.objectRightBrace,.arrayLeftBracket,.arrayRightBracket{font-weight:bold;}.objectLeftBrace,.arrayLeftBracket{margin-right:4px;}.objectRightBrace,.arrayRightBracket{margin-left:4px;}.logRow-dir{padding:0;}.logRow-errorMessage .hasTwisty .errorTitle,.logRow-spy .spyHead .spyTitle,.logGroup .logRow{cursor:pointer;padding-left:18px;background-repeat:no-repeat;background-position:3px 3px;}.logRow-errorMessage > .hasTwisty > .errorTitle{background-position:2px 3px;}.logRow-errorMessage > .hasTwisty > .errorTitle:hover,.logRow-spy .spyHead .spyTitle:hover,.logGroup > .logRow:hover{text-decoration:underline;}.logRow-spy{padding:0 !important;}.logRow-spy,.logRow-spy .objectLink-sourceLink{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/group.gif) repeat-x #FFFFFF;padding-right:4px;right:0;}.logRow-spy.opened{padding-bottom:4px;border-bottom:none;}.spyTitle{color:#000000;font-weight:bold;-moz-box-sizing:padding-box;overflow:hidden;z-index:100;padding-left:18px;}.spyCol{padding:0;white-space:nowrap;height:16px;}.spyTitleCol:hover > .objectLink-sourceLink,.spyTitleCol:hover > .spyTime,.spyTitleCol:hover > .spyStatus,.spyTitleCol:hover > .spyTitle{display:none;}.spyFullTitle{display:none;-moz-user-select:none;max-width:100%;background-color:Transparent;}.spyTitleCol:hover > .spyFullTitle{display:block;}.spyStatus{padding-left:10px;color:rgb(128,128,128);}.spyTime{margin-left:4px;margin-right:4px;color:rgb(128,128,128);}.spyIcon{margin-right:4px;margin-left:4px;width:16px;height:16px;vertical-align:middle;background:transparent no-repeat 0 0;display:none;}.loading .spyHead .spyRow .spyIcon{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/loading_16.gif);display:block;}.logRow-spy.loaded:not(.error) .spyHead .spyRow .spyIcon{width:0;margin:0;}.logRow-spy.error .spyHead .spyRow .spyIcon{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/errorIcon-sm.png);display:block;background-position:2px 2px;}.logRow-spy .spyHead .netInfoBody{display:none;}.logRow-spy.opened .spyHead .netInfoBody{margin-top:10px;display:block;}.logRow-spy.error .spyTitle,.logRow-spy.error .spyStatus,.logRow-spy.error .spyTime{color:red;}.logRow-spy.loading .spyResponseText{font-style:italic;color:#888888;}.caption{font-family:Lucida Grande,Tahoma,sans-serif;font-weight:bold;color:#444444;}.warning{padding:10px;font-family:Lucida Grande,Tahoma,sans-serif;font-weight:bold;color:#888888;}.panelNode-dom{overflow-x:hidden !important;}.domTable{font-size:1em;width:100%;table-layout:fixed;background:#fff;}.domTableIE{width:auto;}.memberLabelCell{padding:2px 0 2px 0;vertical-align:top;}.memberValueCell{padding:1px 0 1px 5px;display:block;overflow:hidden;}.memberLabel{display:block;cursor:default;-moz-user-select:none;overflow:hidden;padding-left:18px;background-color:#FFFFFF;text-decoration:none;}.memberRow.hasChildren .memberLabelCell .memberLabel:hover{cursor:pointer;color:blue;text-decoration:underline;}.userLabel{color:#000000;font-weight:bold;}.userClassLabel{color:#E90000;font-weight:bold;}.userFunctionLabel{color:#025E2A;font-weight:bold;}.domLabel{color:#000000;}.domFunctionLabel{color:#025E2A;}.ordinalLabel{color:SlateBlue;font-weight:bold;}.scopesRow{padding:2px 18px;background-color:LightYellow;border-bottom:5px solid #BEBEBE;color:#666666;}.scopesLabel{background-color:LightYellow;}.watchEditCell{padding:2px 18px;background-color:LightYellow;border-bottom:1px solid #BEBEBE;color:#666666;}.editor-watchNewRow,.editor-memberRow{font-family:Monaco,monospace !important;}.editor-memberRow{padding:1px 0 !important;}.editor-watchRow{padding-bottom:0 !important;}.watchRow > .memberLabelCell{font-family:Monaco,monospace;padding-top:1px;padding-bottom:1px;}.watchRow > .memberLabelCell > .memberLabel{background-color:transparent;}.watchRow > .memberValueCell{padding-top:2px;padding-bottom:2px;}.watchRow > .memberLabelCell,.watchRow > .memberValueCell{background-color:#F5F5F5;border-bottom:1px solid #BEBEBE;}.watchToolbox{z-index:2147483647;position:absolute;right:0;padding:1px 2px;}#fbConsole{overflow-x:hidden !important;}#fbCSS{font:1em Monaco,monospace;padding:0 7px;}#fbstylesheetButtons select,#fbScriptButtons select{font:11px Lucida Grande,Tahoma,sans-serif;margin-top:1px;padding-left:3px;background:#fafafa;border:1px inset #fff;width:220px;outline:none;}.Selector{margin-top:10px}.CSSItem{margin-left:4%}.CSSText{padding-left:20px;}.CSSProperty{color:#005500;}.CSSValue{padding-left:5px; color:#000088;}#fbHTMLStatusBar{display:inline;}.fbToolbarButtons{display:none;}.fbStatusSeparator{display:block;float:left;padding-top:4px;}#fbStatusBarBox{display:none;}#fbToolbarContent{display:block;position:absolute;_position:absolute;top:0;padding-top:4px;height:23px;clip:rect(0,2048px,27px,0);}.fbTabMenuTarget{display:none !important;float:left;width:10px;height:10px;margin-top:6px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuTarget.png);}.fbTabMenuTarget:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuTargetHover.png);}.fbShadow{float:left;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/shadowAlpha.png) no-repeat bottom right !important;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/shadow2.gif) no-repeat bottom right;margin:10px 0 0 10px !important;margin:10px 0 0 5px;}.fbShadowContent{display:block;position:relative;background-color:#fff;border:1px solid #a9a9a9;top:-6px;left:-6px;}.fbMenu{display:none;position:absolute;font-size:11px;line-height:13px;z-index:2147483647;}.fbMenuContent{padding:2px;}.fbMenuSeparator{display:block;position:relative;padding:1px 18px 0;text-decoration:none;color:#000;cursor:default;background:#ACA899;margin:4px 0;}.fbMenuOption{display:block;position:relative;padding:2px 18px;text-decoration:none;color:#000;cursor:default;}.fbMenuOption:hover{color:#fff;background:#316AC5;}.fbMenuGroup{background:transparent url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuPin.png) no-repeat right 0;}.fbMenuGroup:hover{background:#316AC5 url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuPin.png) no-repeat right -17px;}.fbMenuGroupSelected{color:#fff;background:#316AC5 url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuPin.png) no-repeat right -17px;}.fbMenuChecked{background:transparent url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuCheckbox.png) no-repeat 4px 0;}.fbMenuChecked:hover{background:#316AC5 url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuCheckbox.png) no-repeat 4px -17px;}.fbMenuRadioSelected{background:transparent url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuRadio.png) no-repeat 4px 0;}.fbMenuRadioSelected:hover{background:#316AC5 url(https://getfirebug.com/releases/lite/latest/skin/xp/tabMenuRadio.png) no-repeat 4px -17px;}.fbMenuShortcut{padding-right:85px;}.fbMenuShortcutKey{position:absolute;right:0;top:2px;width:77px;}#fbFirebugMenu{top:22px;left:0;}.fbMenuDisabled{color:#ACA899 !important;}#fbFirebugSettingsMenu{left:245px;top:99px;}#fbConsoleMenu{top:42px;left:48px;}.fbIconButton{display:block;}.fbIconButton{display:block;}.fbIconButton{display:block;float:left;height:20px;width:20px;color:#000;margin-right:2px;text-decoration:none;cursor:default;}.fbIconButton:hover{position:relative;top:-1px;left:-1px;margin-right:0;_margin-right:1px;color:#333;border:1px solid #fff;border-bottom:1px solid #bbb;border-right:1px solid #bbb;}.fbIconPressed{position:relative;margin-right:0;_margin-right:1px;top:0 !important;left:0 !important;height:19px;color:#333 !important;border:1px solid #bbb !important;border-bottom:1px solid #cfcfcf !important;border-right:1px solid #ddd !important;}#fbErrorPopup{position:absolute;right:0;bottom:0;height:19px;width:75px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #f1f2ee 0 0;z-index:999;}#fbErrorPopupContent{position:absolute;right:0;top:1px;height:18px;width:75px;_width:74px;border-left:1px solid #aca899;}#fbErrorIndicator{position:absolute;top:2px;right:5px;}.fbBtnInspectActive{background:#aaa;color:#fff !important;}.fbBody{margin:0;padding:0;overflow:hidden;font-family:Lucida Grande,Tahoma,sans-serif;font-size:11px;background:#fff;}.clear{clear:both;}#fbMiniChrome{display:none;right:0;height:27px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #f1f2ee 0 0;margin-left:1px;}#fbMiniContent{display:block;position:relative;left:-1px;right:0;top:1px;height:25px;border-left:1px solid #aca899;}#fbToolbarSearch{float:right;border:1px solid #ccc;margin:0 5px 0 0;background:#fff url(https://getfirebug.com/releases/lite/latest/skin/xp/search.png) no-repeat 4px 2px !important;background:#fff url(https://getfirebug.com/releases/lite/latest/skin/xp/search.gif) no-repeat 4px 2px;padding-left:20px;font-size:11px;}#fbToolbarErrors{float:right;margin:1px 4px 0 0;font-size:11px;}#fbLeftToolbarErrors{float:left;margin:7px 0px 0 5px;font-size:11px;}.fbErrors{padding-left:20px;height:14px;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/errorIcon.png) no-repeat !important;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/errorIcon.gif) no-repeat;color:#f00;font-weight:bold;}#fbMiniErrors{display:inline;display:none;float:right;margin:5px 2px 0 5px;}#fbMiniIcon{float:right;margin:3px 4px 0;height:20px;width:20px;float:right;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) 0 -135px;cursor:pointer;}#fbChrome{font-family:Lucida Grande,Tahoma,sans-serif;font-size:11px;position:absolute;_position:static;top:0;left:0;height:100%;width:100%;border-collapse:collapse;border-spacing:0;background:#fff;overflow:hidden;}#fbChrome > tbody > tr > td{padding:0;}#fbTop{height:49px;}#fbToolbar{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #f1f2ee 0 0;height:27px;font-size:11px;line-height:13px;}#fbPanelBarBox{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #dbd9c9 0 -27px;height:22px;}#fbContent{height:100%;vertical-align:top;}#fbBottom{height:18px;background:#fff;}#fbToolbarIcon{float:left;padding:0 5px 0;}#fbToolbarIcon a{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) 0 -135px;}#fbToolbarButtons{padding:0 2px 0 5px;}#fbToolbarButtons{padding:0 2px 0 5px;}.fbButton{text-decoration:none;display:block;float:left;color:#000;padding:4px 6px 4px 7px;cursor:default;}.fbButton:hover{color:#333;background:#f5f5ef url(https://getfirebug.com/releases/lite/latest/skin/xp/buttonBg.png);padding:3px 5px 3px 6px;border:1px solid #fff;border-bottom:1px solid #bbb;border-right:1px solid #bbb;}.fbBtnPressed{background:#e3e3db url(https://getfirebug.com/releases/lite/latest/skin/xp/buttonBgHover.png) !important;padding:3px 4px 2px 6px !important;margin:1px 0 0 1px !important;border:1px solid #ACA899 !important;border-color:#ACA899 #ECEBE3 #ECEBE3 #ACA899 !important;}#fbStatusBarBox{top:4px;cursor:default;}.fbToolbarSeparator{overflow:hidden;border:1px solid;border-color:transparent #fff transparent #777;_border-color:#eee #fff #eee #777;height:7px;margin:6px 3px;float:left;}.fbBtnSelected{font-weight:bold;}.fbStatusBar{color:#aca899;}.fbStatusBar a{text-decoration:none;color:black;}.fbStatusBar a:hover{color:blue;cursor:pointer;}#fbWindowButtons{position:absolute;white-space:nowrap;right:0;top:0;height:17px;width:48px;padding:5px;z-index:6;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #f1f2ee 0 0;}#fbPanelBar1{width:1024px; z-index:8;left:0;white-space:nowrap;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #dbd9c9 0 -27px;position:absolute;left:4px;}#fbPanelBar2Box{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #dbd9c9 0 -27px;position:absolute;height:22px;width:300px; z-index:9;right:0;}#fbPanelBar2{position:absolute;width:290px; height:22px;padding-left:4px;}.fbPanel{display:none;}#fbPanelBox1,#fbPanelBox2{max-height:inherit;height:100%;font-size:1em;}#fbPanelBox2{background:#fff;}#fbPanelBox2{width:300px;background:#fff;}#fbPanel2{margin-left:6px;background:#fff;}#fbLargeCommandLine{display:none;position:absolute;z-index:9;top:27px;right:0;width:294px;height:201px;border-width:0;margin:0;padding:2px 0 0 2px;resize:none;outline:none;font-size:11px;overflow:auto;border-top:1px solid #B9B7AF;_right:-1px;_border-left:1px solid #fff;}#fbLargeCommandButtons{display:none;background:#ECE9D8;bottom:0;right:0;width:294px;height:21px;padding-top:1px;position:fixed;border-top:1px solid #ACA899;z-index:9;}#fbSmallCommandLineIcon{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/down.png) no-repeat;position:absolute;right:2px;bottom:3px;z-index:99;}#fbSmallCommandLineIcon:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/downHover.png) no-repeat;}.hide{overflow:hidden !important;position:fixed !important;display:none !important;visibility:hidden !important;}#fbCommand{height:18px;}#fbCommandBox{position:fixed;_position:absolute;width:100%;height:18px;bottom:0;overflow:hidden;z-index:9;background:#fff;border:0;border-top:1px solid #ccc;}#fbCommandIcon{position:absolute;color:#00f;top:2px;left:6px;display:inline;font:11px Monaco,monospace;z-index:10;}#fbCommandLine{position:absolute;width:100%;top:0;left:0;border:0;margin:0;padding:2px 0 2px 32px;font:11px Monaco,monospace;z-index:9;outline:none;}#fbLargeCommandLineIcon{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/up.png) no-repeat;position:absolute;right:1px;bottom:1px;z-index:10;}#fbLargeCommandLineIcon:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/upHover.png) no-repeat;}div.fbFitHeight{overflow:auto;position:relative;}.fbSmallButton{overflow:hidden;width:16px;height:16px;display:block;text-decoration:none;cursor:default;}#fbWindowButtons .fbSmallButton{float:right;}#fbWindow_btClose{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/min.png);}#fbWindow_btClose:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/minHover.png);}#fbWindow_btDetach{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/detach.png);}#fbWindow_btDetach:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/detachHover.png);}#fbWindow_btDeactivate{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/off.png);}#fbWindow_btDeactivate:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/offHover.png);}.fbTab{text-decoration:none;display:none;float:left;width:auto;float:left;cursor:default;font-family:Lucida Grande,Tahoma,sans-serif;font-size:11px;line-height:13px;font-weight:bold;height:22px;color:#565656;}.fbPanelBar span{float:left;}.fbPanelBar .fbTabL,.fbPanelBar .fbTabR{height:22px;width:8px;}.fbPanelBar .fbTabText{padding:4px 1px 0;}a.fbTab:hover{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) 0 -73px;}a.fbTab:hover .fbTabL{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) -16px -96px;}a.fbTab:hover .fbTabR{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) -24px -96px;}.fbSelectedTab{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) #f1f2ee 0 -50px !important;color:#000;}.fbSelectedTab .fbTabL{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) 0 -96px !important;}.fbSelectedTab .fbTabR{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/sprite.png) -8px -96px !important;}#fbHSplitter{position:fixed;_position:absolute;left:0;top:0;width:100%;height:5px;overflow:hidden;cursor:n-resize !important;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/pixel_transparent.gif);z-index:9;}#fbHSplitter.fbOnMovingHSplitter{height:100%;z-index:100;}.fbVSplitter{background:#ece9d8;color:#000;border:1px solid #716f64;border-width:0 1px;border-left-color:#aca899;width:4px;cursor:e-resize;overflow:hidden;right:294px;text-decoration:none;z-index:10;position:absolute;height:100%;top:27px;}div.lineNo{font:1em/1.4545em Monaco,monospace;position:relative;float:left;top:0;left:0;margin:0 5px 0 0;padding:0 5px 0 10px;background:#eee;color:#888;border-right:1px solid #ccc;text-align:right;}.sourceBox{position:absolute;}.sourceCode{font:1em Monaco,monospace;overflow:hidden;white-space:pre;display:inline;}.nodeControl{margin-top:3px;margin-left:-14px;float:left;width:9px;height:9px;overflow:hidden;cursor:default;background:url(https://getfirebug.com/releases/lite/latest/skin/xp/tree_open.gif);_float:none;_display:inline;_position:absolute;}div.nodeMaximized{background:url(https://getfirebug.com/releases/lite/latest/skin/xp/tree_close.gif);}div.objectBox-element{padding:1px 3px;}.objectBox-selector{cursor:default;}.selectedElement{background:highlight;color:#fff !important;}.selectedElement span{color:#fff !important;}* html .selectedElement{position:relative;}@media screen and (-webkit-min-device-pixel-ratio:0){.selectedElement{background:#316AC5;color:#fff !important;}}.logRow *{font-size:1em;}.logRow{position:relative;border-bottom:1px solid #D7D7D7;padding:2px 4px 1px 6px;zbackground-color:#FFFFFF;}.logRow-command{font-family:Monaco,monospace;color:blue;}.objectBox-string,.objectBox-text,.objectBox-number,.objectBox-function,.objectLink-element,.objectLink-textNode,.objectLink-function,.objectBox-stackTrace,.objectLink-profile{font-family:Monaco,monospace;}.objectBox-null{padding:0 2px;border:1px solid #666666;background-color:#888888;color:#FFFFFF;}.objectBox-string{color:red;}.objectBox-number{color:#000088;}.objectBox-function{color:DarkGreen;}.objectBox-object{color:DarkGreen;font-weight:bold;font-family:Lucida Grande,sans-serif;}.objectBox-array{color:#000;}.logRow-info,.logRow-error,.logRow-warn{background:#fff no-repeat 2px 2px;padding-left:20px;padding-bottom:3px;}.logRow-info{background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/infoIcon.png) !important;background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/infoIcon.gif);}.logRow-warn{background-color:cyan;background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/warningIcon.png) !important;background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/warningIcon.gif);}.logRow-error{background-color:LightYellow;background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/errorIcon.png) !important;background-image:url(https://getfirebug.com/releases/lite/latest/skin/xp/errorIcon.gif);color:#f00;}.errorMessage{vertical-align:top;color:#f00;}.objectBox-sourceLink{position:absolute;right:4px;top:2px;padding-left:8px;font-family:Lucida Grande,sans-serif;font-weight:bold;color:#0000FF;}.selectorTag,.selectorId,.selectorClass{font-family:Monaco,monospace;font-weight:normal;}.selectorTag{color:#0000FF;}.selectorId{color:DarkBlue;}.selectorClass{color:red;}.objectBox-element{font-family:Monaco,monospace;color:#000088;}.nodeChildren{padding-left:26px;}.nodeTag{color:blue;cursor:pointer;}.nodeValue{color:#FF0000;font-weight:normal;}.nodeText,.nodeComment{margin:0 2px;vertical-align:top;}.nodeText{color:#333333;font-family:Monaco,monospace;}.nodeComment{color:DarkGreen;}.nodeHidden,.nodeHidden *{color:#888888;}.nodeHidden .nodeTag{color:#5F82D9;}.nodeHidden .nodeValue{color:#D86060;}.selectedElement .nodeHidden,.selectedElement .nodeHidden *{color:SkyBlue !important;}.log-object{}.property{position:relative;clear:both;height:15px;}.propertyNameCell{vertical-align:top;float:left;width:28%;position:absolute;left:0;z-index:0;}.propertyValueCell{float:right;width:68%;background:#fff;position:absolute;padding-left:5px;display:table-cell;right:0;z-index:1;}.propertyName{font-weight:bold;}.FirebugPopup{height:100% !important;}.FirebugPopup #fbWindowButtons{display:none !important;}.FirebugPopup #fbHSplitter{display:none !important;}\',\n    HTML: \'<table id="fbChrome" cellpadding="0" cellspacing="0" border="0"><tbody><tr><td id="fbTop" colspan="2"><div id="fbWindowButtons"><a id="fbWindow_btDeactivate" class="fbSmallButton fbHover" title="Deactivate Firebug for this web page">&nbsp;</a><a id="fbWindow_btDetach" class="fbSmallButton fbHover" title="Open Firebug in popup window">&nbsp;</a><a id="fbWindow_btClose" class="fbSmallButton fbHover" title="Minimize Firebug">&nbsp;</a></div><div id="fbToolbar"><div id="fbToolbarContent"><span id="fbToolbarIcon"><a id="fbFirebugButton" class="fbIconButton" class="fbHover" target="_blank">&nbsp;</a></span><span id="fbToolbarButtons"><span id="fbFixedButtons"><a id="fbChrome_btInspect" class="fbButton fbHover" title="Click an element in the page to inspect">Inspect</a></span><span id="fbConsoleButtons" class="fbToolbarButtons"><a id="fbConsole_btClear" class="fbButton fbHover" title="Clear the console">Clear</a></span></span><span id="fbStatusBarBox"><span class="fbToolbarSeparator"></span></span></div></div><div id="fbPanelBarBox"><div id="fbPanelBar1" class="fbPanelBar"><a id="fbConsoleTab" class="fbTab fbHover"><span class="fbTabL"></span><span class="fbTabText">Console</span><span class="fbTabMenuTarget"></span><span class="fbTabR"></span></a><a id="fbHTMLTab" class="fbTab fbHover"><span class="fbTabL"></span><span class="fbTabText">HTML</span><span class="fbTabR"></span></a><a class="fbTab fbHover"><span class="fbTabL"></span><span class="fbTabText">CSS</span><span class="fbTabR"></span></a><a class="fbTab fbHover"><span class="fbTabL"></span><span class="fbTabText">Script</span><span class="fbTabR"></span></a><a class="fbTab fbHover"><span class="fbTabL"></span><span class="fbTabText">DOM</span><span class="fbTabR"></span></a></div><div id="fbPanelBar2Box" class="hide"><div id="fbPanelBar2" class="fbPanelBar"></div></div></div><div id="fbHSplitter">&nbsp;</div></td></tr><tr id="fbContent"><td id="fbPanelBox1"><div id="fbPanel1" class="fbFitHeight"><div id="fbConsole" class="fbPanel"></div><div id="fbHTML" class="fbPanel"></div></div></td><td id="fbPanelBox2" class="hide"><div id="fbVSplitter" class="fbVSplitter">&nbsp;</div><div id="fbPanel2" class="fbFitHeight"><div id="fbHTML_Style" class="fbPanel"></div><div id="fbHTML_Layout" class="fbPanel"></div><div id="fbHTML_DOM" class="fbPanel"></div></div><textarea id="fbLargeCommandLine" class="fbFitHeight"></textarea><div id="fbLargeCommandButtons"><a id="fbCommand_btRun" class="fbButton fbHover">Run</a><a id="fbCommand_btClear" class="fbButton fbHover">Clear</a><a id="fbSmallCommandLineIcon" class="fbSmallButton fbHover"></a></div></td></tr><tr id="fbBottom" class="hide"><td id="fbCommand" colspan="2"><div id="fbCommandBox"><div id="fbCommandIcon">&gt;&gt;&gt;</div><input id="fbCommandLine" name="fbCommandLine" type="text"/><a id="fbLargeCommandLineIcon" class="fbSmallButton fbHover"></a></div></td></tr></tbody></table><span id="fbMiniChrome"><span id="fbMiniContent"><span id="fbMiniIcon" title="Open Firebug Lite"></span><span id="fbMiniErrors" class="fbErrors"></span></span></span>\'\n};\n\n// ************************************************************************************************\n}});\n\n// ************************************************************************************************\nFBL.initialize();\n// ************************************************************************************************\n\n})();',
                    language: 'javascript',
                    size: 960048,
                    tokens: 90531,
                    lastModified: '2025-07-02T12:28:22.883Z',
                  },
                ],
              },
            ],
          },
          {
            name: 'json-js',
            path: 'vendor/json-js',
            type: 'directory',
            children: [
              {
                name: 'json2.js',
                path: 'vendor/json-js/json2.js',
                type: 'file',
                content:
                  "/*\n    json2.js\n    2015-05-03\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse. This file is provides the ES5 JSON capability to ES3 systems.\n    If a project might run on IE8 or earlier, then this file should be included.\n    This file does nothing on ES5 systems.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 \n                            ? '0' + n \n                            : n;\n                    }\n\n                    return this.getUTCFullYear()   + '-' +\n                         f(this.getUTCMonth() + 1) + '-' +\n                         f(this.getUTCDate())      + 'T' +\n                         f(this.getUTCHours())     + ':' +\n                         f(this.getUTCMinutes())   + ':' +\n                         f(this.getUTCSeconds())   + 'Z';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date \n                    ? 'Date(' + this[key] + ')' \n                    : value;\n            });\n            // text is '[\"Date(---current time---)\"]'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n                var d;\n                if (typeof value === 'string' &&\n                        value.slice(0, 5) === 'Date(' &&\n                        value.slice(-1) === ')') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint \n    eval, for, this \n*/\n\n/*property\n    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== 'object') {\n    JSON = {};\n}\n\n(function () {\n    'use strict';\n    \n    var rx_one = /^[\\],:{}\\s]*$/,\n        rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n        rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n        rx_four = /(?:^|:|,)(?:\\s*\\[)+/g,\n        rx_escapable = /[\\\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 \n            ? '0' + n \n            : n;\n    }\n    \n    function this_value() {\n        return this.valueOf();\n    }\n\n    if (typeof Date.prototype.toJSON !== 'function') {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear() + '-' +\n                        f(this.getUTCMonth() + 1) + '-' +\n                        f(this.getUTCDate()) + 'T' +\n                        f(this.getUTCHours()) + ':' +\n                        f(this.getUTCMinutes()) + ':' +\n                        f(this.getUTCSeconds()) + 'Z'\n                : null;\n        };\n\n        Boolean.prototype.toJSON = this_value;\n        Number.prototype.toJSON = this_value;\n        String.prototype.toJSON = this_value;\n    }\n\n    var gap,\n        indent,\n        meta,\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        rx_escapable.lastIndex = 0;\n        return rx_escapable.test(string) \n            ? '\"' + string.replace(rx_escapable, function (a) {\n                var c = meta[a];\n                return typeof c === 'string'\n                    ? c\n                    : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + '\"' \n            : '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) \n                ? String(value) \n                : 'null';\n\n        case 'boolean':\n        case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n        case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? '[]'\n                    : gap\n                        ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\n                        : '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === 'string') {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap \n                                    ? ': ' \n                                    : ':'\n                            ) + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap \n                                    ? ': ' \n                                    : ':'\n                            ) + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? '{}'\n                : gap\n                    ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\n                    : '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== 'function') {\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"': '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        };\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = '';\n            indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === 'number') {\n                for (i = 0; i < space; i += 1) {\n                    indent += ' ';\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === 'string') {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== 'function' &&\n                    (typeof replacer !== 'object' ||\n                    typeof replacer.length !== 'number')) {\n                throw new Error('JSON.stringify');\n            }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n            return str('', {'': value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== 'function') {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === 'object') {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            rx_dangerous.lastIndex = 0;\n            if (rx_dangerous.test(text)) {\n                text = text.replace(rx_dangerous, function (a) {\n                    return '\\\\u' +\n                            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\n// because they can cause invocation, and '=' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n            if (\n                rx_one.test(\n                    text\n                        .replace(rx_two, '@')\n                        .replace(rx_three, ']')\n                        .replace(rx_four, '')\n                )\n            ) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval('(' + text + ')');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === 'function'\n                    ? walk({'': j}, '')\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError('JSON.parse');\n        };\n    }\n}());\n",
                language: 'javascript',
                size: 18423,
                tokens: 2259,
                lastModified: '2025-07-02T12:28:22.883Z',
              },
            ],
          },
          {
            name: 'underscore',
            path: 'vendor/underscore',
            type: 'directory',
            children: [
              {
                name: 'test',
                path: 'vendor/underscore/test',
                type: 'directory',
                children: [
                  {
                    name: 'arrays.js',
                    path: 'vendor/underscore/test/arrays.js',
                    type: 'file',
                    content:
                      "(function() {\n  var _ = typeof require == 'function' ? require('..') : window._;\n\n  QUnit.module('Arrays');\n\n  QUnit.test('first', function(assert) {\n    assert.equal(_.first([1, 2, 3]), 1, 'can pull out the first element of an array');\n    assert.equal(_([1, 2, 3]).first(), 1, 'can perform OO-style \"first()\"');\n    assert.deepEqual(_.first([1, 2, 3], 0), [], 'returns an empty array when n <= 0 (0 case)');\n    assert.deepEqual(_.first([1, 2, 3], -1), [], 'returns an empty array when n <= 0 (negative case)');\n    assert.deepEqual(_.first([1, 2, 3], 2), [1, 2], 'can fetch the first n elements');\n    assert.deepEqual(_.first([1, 2, 3], 5), [1, 2, 3], 'returns the whole array if n > length');\n    var result = (function(){ return _.first(arguments); }(4, 3, 2, 1));\n    assert.equal(result, 4, 'works on an arguments object');\n    result = _.map([[1, 2, 3], [1, 2, 3]], _.first);\n    assert.deepEqual(result, [1, 1], 'works well with _.map');\n    assert.equal(_.first(null), void 0, 'returns undefined when called on null');\n\n    Array.prototype[0] = 'boo';\n    assert.equal(_.first([]), void 0, 'return undefined when called on a empty array');\n    delete Array.prototype[0];\n  });\n\n  QUnit.test('head', function(assert) {\n    assert.strictEqual(_.head, _.first, 'is an alias for first');\n  });\n\n  QUnit.test('take', function(assert) {\n    assert.strictEqual(_.take, _.first, 'is an alias for first');\n  });\n\n  QUnit.test('rest', function(assert) {\n    var numbers = [1, 2, 3, 4];\n    assert.deepEqual(_.rest(numbers), [2, 3, 4], 'fetches all but the first element');\n    assert.deepEqual(_.rest(numbers, 0), [1, 2, 3, 4], 'returns the whole array when index is 0');\n    assert.deepEqual(_.rest(numbers, 2), [3, 4], 'returns elements starting at the given index');\n    var result = (function(){ return _(arguments).rest(); }(1, 2, 3, 4));\n    assert.deepEqual(result, [2, 3, 4], 'works on an arguments object');\n    result = _.map([[1, 2, 3], [1, 2, 3]], _.rest);\n    assert.deepEqual(_.flatten(result), [2, 3, 2, 3], 'works well with _.map');\n  });\n\n  QUnit.test('tail', function(assert) {\n    assert.strictEqual(_.tail, _.rest, 'is an alias for rest');\n  });\n\n  QUnit.test('drop', function(assert) {\n    assert.strictEqual(_.drop, _.rest, 'is an alias for rest');\n  });\n\n  QUnit.test('initial', function(assert) {\n    assert.deepEqual(_.initial([1, 2, 3, 4, 5]), [1, 2, 3, 4], 'returns all but the last element');\n    assert.deepEqual(_.initial([1, 2, 3, 4], 2), [1, 2], 'returns all but the last n elements');\n    assert.deepEqual(_.initial([1, 2, 3, 4], 6), [], 'returns an empty array when n > length');\n    var result = (function(){ return _(arguments).initial(); }(1, 2, 3, 4));\n    assert.deepEqual(result, [1, 2, 3], 'works on an arguments object');\n    result = _.map([[1, 2, 3], [1, 2, 3]], _.initial);\n    assert.deepEqual(_.flatten(result), [1, 2, 1, 2], 'works well with _.map');\n  });\n\n  QUnit.test('last', function(assert) {\n    assert.equal(_.last([1, 2, 3]), 3, 'can pull out the last element of an array');\n    assert.equal(_([1, 2, 3]).last(), 3, 'can perform OO-style \"last()\"');\n    assert.deepEqual(_.last([1, 2, 3], 0), [], 'returns an empty array when n <= 0 (0 case)');\n    assert.deepEqual(_.last([1, 2, 3], -1), [], 'returns an empty array when n <= 0 (negative case)');\n    assert.deepEqual(_.last([1, 2, 3], 2), [2, 3], 'can fetch the last n elements');\n    assert.deepEqual(_.last([1, 2, 3], 5), [1, 2, 3], 'returns the whole array if n > length');\n    var result = (function(){ return _(arguments).last(); }(1, 2, 3, 4));\n    assert.equal(result, 4, 'works on an arguments object');\n    result = _.map([[1, 2, 3], [1, 2, 3]], _.last);\n    assert.deepEqual(result, [3, 3], 'works well with _.map');\n    assert.equal(_.last(null), void 0, 'returns undefined when called on null');\n\n    var arr = [];\n    arr[-1] = 'boo';\n    assert.equal(_.last(arr), void 0, 'return undefined when called on a empty array');\n  });\n\n  QUnit.test('compact', function(assert) {\n    assert.deepEqual(_.compact([1, false, null, 0, '', void 0, NaN, 2]), [1, 2], 'removes all falsy values');\n    var result = (function(){ return _.compact(arguments); }(0, 1, false, 2, false, 3));\n    assert.deepEqual(result, [1, 2, 3], 'works on an arguments object');\n    result = _.map([[1, false, false], [false, false, 3]], _.compact);\n    assert.deepEqual(result, [[1], [3]], 'works well with _.map');\n  });\n\n  QUnit.test('flatten', function(assert) {\n    assert.deepEqual(_.flatten(null), [], 'supports null');\n    assert.deepEqual(_.flatten(void 0), [], 'supports undefined');\n\n    assert.deepEqual(_.flatten([[], [[]], []]), [], 'supports empty arrays');\n    assert.deepEqual(_.flatten([[], [[]], []], true), [[]], 'can shallowly flatten empty arrays');\n\n    var list = [1, [2], [3, [[[4]]]]];\n    assert.deepEqual(_.flatten(list), [1, 2, 3, 4], 'can flatten nested arrays');\n    assert.deepEqual(_.flatten(list, true), [1, 2, 3, [[[4]]]], 'can shallowly flatten nested arrays');\n    var result = (function(){ return _.flatten(arguments); }(1, [2], [3, [[[4]]]]));\n    assert.deepEqual(result, [1, 2, 3, 4], 'works on an arguments object');\n    list = [[1], [2], [3], [[4]]];\n    assert.deepEqual(_.flatten(list, true), [1, 2, 3, [4]], 'can shallowly flatten arrays containing only other arrays');\n\n    assert.equal(_.flatten([_.range(10), _.range(10), 5, 1, 3], true).length, 23, 'can flatten medium length arrays');\n    assert.equal(_.flatten([_.range(10), _.range(10), 5, 1, 3]).length, 23, 'can shallowly flatten medium length arrays');\n    assert.equal(_.flatten([new Array(1000000), _.range(56000), 5, 1, 3]).length, 1056003, 'can handle massive arrays');\n    assert.equal(_.flatten([new Array(1000000), _.range(56000), 5, 1, 3], true).length, 1056003, 'can handle massive arrays in shallow mode');\n\n    var x = _.range(100000);\n    for (var i = 0; i < 1000; i++) x = [x];\n    assert.deepEqual(_.flatten(x), _.range(100000), 'can handle very deep arrays');\n    assert.deepEqual(_.flatten(x, true), x[0], 'can handle very deep arrays in shallow mode');\n  });\n\n  QUnit.test('without', function(assert) {\n    var list = [1, 2, 1, 0, 3, 1, 4];\n    assert.deepEqual(_.without(list, 0, 1), [2, 3, 4], 'removes all instances of the given values');\n    var result = (function(){ return _.without(arguments, 0, 1); }(1, 2, 1, 0, 3, 1, 4));\n    assert.deepEqual(result, [2, 3, 4], 'works on an arguments object');\n\n    list = [{one: 1}, {two: 2}];\n    assert.deepEqual(_.without(list, {one: 1}), list, 'compares objects by reference (value case)');\n    assert.deepEqual(_.without(list, list[0]), [{two: 2}], 'compares objects by reference (reference case)');\n  });\n\n  QUnit.test('sortedIndex', function(assert) {\n    var numbers = [10, 20, 30, 40, 50];\n    var indexFor35 = _.sortedIndex(numbers, 35);\n    assert.equal(indexFor35, 3, 'finds the index at which a value should be inserted to retain order');\n    var indexFor30 = _.sortedIndex(numbers, 30);\n    assert.equal(indexFor30, 2, 'finds the smallest index at which a value could be inserted to retain order');\n\n    var objects = [{x: 10}, {x: 20}, {x: 30}, {x: 40}];\n    var iterator = function(obj){ return obj.x; };\n    assert.strictEqual(_.sortedIndex(objects, {x: 25}, iterator), 2, 'uses the result of `iterator` for order comparisons');\n    assert.strictEqual(_.sortedIndex(objects, {x: 35}, 'x'), 3, 'when `iterator` is a string, uses that key for order comparisons');\n\n    var context = {1: 2, 2: 3, 3: 4};\n    iterator = function(obj){ return this[obj]; };\n    assert.strictEqual(_.sortedIndex([1, 3], 2, iterator, context), 1, 'can execute its iterator in the given context');\n\n    var values = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287,\n        1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647];\n    var largeArray = Array(Math.pow(2, 32) - 1);\n    var length = values.length;\n    // Sparsely populate `array`\n    while (length--) {\n      largeArray[values[length]] = values[length];\n    }\n    assert.equal(_.sortedIndex(largeArray, 2147483648), 2147483648, 'works with large indexes');\n  });\n\n  QUnit.test('uniq', function(assert) {\n    var list = [1, 2, 1, 3, 1, 4];\n    assert.deepEqual(_.uniq(list), [1, 2, 3, 4], 'can find the unique values of an unsorted array');\n    list = [1, 1, 1, 2, 2, 3];\n    assert.deepEqual(_.uniq(list, true), [1, 2, 3], 'can find the unique values of a sorted array faster');\n\n    list = [{name: 'Moe'}, {name: 'Curly'}, {name: 'Larry'}, {name: 'Curly'}];\n    var expected = [{name: 'Moe'}, {name: 'Curly'}, {name: 'Larry'}];\n    var iterator = function(stooge) { return stooge.name; };\n    assert.deepEqual(_.uniq(list, false, iterator), expected, 'uses the result of `iterator` for uniqueness comparisons (unsorted case)');\n    assert.deepEqual(_.uniq(list, iterator), expected, '`sorted` argument defaults to false when omitted');\n    assert.deepEqual(_.uniq(list, 'name'), expected, 'when `iterator` is a string, uses that key for comparisons (unsorted case)');\n\n    list = [{score: 8}, {score: 10}, {score: 10}];\n    expected = [{score: 8}, {score: 10}];\n    iterator = function(item) { return item.score; };\n    assert.deepEqual(_.uniq(list, true, iterator), expected, 'uses the result of `iterator` for uniqueness comparisons (sorted case)');\n    assert.deepEqual(_.uniq(list, true, 'score'), expected, 'when `iterator` is a string, uses that key for comparisons (sorted case)');\n\n    assert.deepEqual(_.uniq([{0: 1}, {0: 1}, {0: 1}, {0: 2}], 0), [{0: 1}, {0: 2}], 'can use falsey pluck like iterator');\n\n    var result = (function(){ return _.uniq(arguments); }(1, 2, 1, 3, 1, 4));\n    assert.deepEqual(result, [1, 2, 3, 4], 'works on an arguments object');\n\n    var a = {}, b = {}, c = {};\n    assert.deepEqual(_.uniq([a, b, a, b, c]), [a, b, c], 'works on values that can be tested for equivalency but not ordered');\n\n    assert.deepEqual(_.uniq(null), [], 'returns an empty array when `array` is not iterable');\n\n    var context = {};\n    list = [3];\n    _.uniq(list, function(value, index, array) {\n      assert.strictEqual(this, context, 'executes its iterator in the given context');\n      assert.strictEqual(value, 3, 'passes its iterator the value');\n      assert.strictEqual(index, 0, 'passes its iterator the index');\n      assert.strictEqual(array, list, 'passes its iterator the entire array');\n    }, context);\n\n  });\n\n  QUnit.test('unique', function(assert) {\n    assert.strictEqual(_.unique, _.uniq, 'is an alias for uniq');\n  });\n\n  QUnit.test('intersection', function(assert) {\n    var stooges = ['moe', 'curly', 'larry'], leaders = ['moe', 'groucho'];\n    assert.deepEqual(_.intersection(stooges, leaders), ['moe'], 'can find the set intersection of two arrays');\n    assert.deepEqual(_(stooges).intersection(leaders), ['moe'], 'can perform an OO-style intersection');\n    var result = (function(){ return _.intersection(arguments, leaders); }('moe', 'curly', 'larry'));\n    assert.deepEqual(result, ['moe'], 'works on an arguments object');\n    var theSixStooges = ['moe', 'moe', 'curly', 'curly', 'larry', 'larry'];\n    assert.deepEqual(_.intersection(theSixStooges, leaders), ['moe'], 'returns a duplicate-free array');\n    result = _.intersection([2, 4, 3, 1], [1, 2, 3]);\n    assert.deepEqual(result, [2, 3, 1], 'preserves the order of the first array');\n    result = _.intersection(null, [1, 2, 3]);\n    assert.deepEqual(result, [], 'returns an empty array when passed null as the first argument');\n    result = _.intersection([1, 2, 3], null);\n    assert.deepEqual(result, [], 'returns an empty array when passed null as an argument beyond the first');\n  });\n\n  QUnit.test('union', function(assert) {\n    var result = _.union([1, 2, 3], [2, 30, 1], [1, 40]);\n    assert.deepEqual(result, [1, 2, 3, 30, 40], 'can find the union of a list of arrays');\n\n    result = _([1, 2, 3]).union([2, 30, 1], [1, 40]);\n    assert.deepEqual(result, [1, 2, 3, 30, 40], 'can perform an OO-style union');\n\n    result = _.union([1, 2, 3], [2, 30, 1], [1, 40, [1]]);\n    assert.deepEqual(result, [1, 2, 3, 30, 40, [1]], 'can find the union of a list of nested arrays');\n\n    result = _.union([10, 20], [1, 30, 10], [0, 40]);\n    assert.deepEqual(result, [10, 20, 1, 30, 0, 40], 'orders values by their first encounter');\n\n    result = (function(){ return _.union(arguments, [2, 30, 1], [1, 40]); }(1, 2, 3));\n    assert.deepEqual(result, [1, 2, 3, 30, 40], 'works on an arguments object');\n\n    assert.deepEqual(_.union([1, 2, 3], 4), [1, 2, 3], 'restricts the union to arrays only');\n  });\n\n  QUnit.test('difference', function(assert) {\n    var result = _.difference([1, 2, 3], [2, 30, 40]);\n    assert.deepEqual(result, [1, 3], 'can find the difference of two arrays');\n\n    result = _([1, 2, 3]).difference([2, 30, 40]);\n    assert.deepEqual(result, [1, 3], 'can perform an OO-style difference');\n\n    result = _.difference([1, 2, 3, 4], [2, 30, 40], [1, 11, 111]);\n    assert.deepEqual(result, [3, 4], 'can find the difference of three arrays');\n\n    result = _.difference([8, 9, 3, 1], [3, 8]);\n    assert.deepEqual(result, [9, 1], 'preserves the order of the first array');\n\n    result = (function(){ return _.difference(arguments, [2, 30, 40]); }(1, 2, 3));\n    assert.deepEqual(result, [1, 3], 'works on an arguments object');\n\n    result = _.difference([1, 2, 3], 1);\n    assert.deepEqual(result, [1, 2, 3], 'restrict the difference to arrays only');\n  });\n\n  QUnit.test('zip', function(assert) {\n    var names = ['moe', 'larry', 'curly'], ages = [30, 40, 50], leaders = [true];\n    assert.deepEqual(_.zip(names, ages, leaders), [\n      ['moe', 30, true],\n      ['larry', 40, void 0],\n      ['curly', 50, void 0]\n    ], 'zipped together arrays of different lengths');\n\n    var stooges = _.zip(['moe', 30, 'stooge 1'], ['larry', 40, 'stooge 2'], ['curly', 50, 'stooge 3']);\n    assert.deepEqual(stooges, [['moe', 'larry', 'curly'], [30, 40, 50], ['stooge 1', 'stooge 2', 'stooge 3']], 'zipped pairs');\n\n    // In the case of different lengths of the tuples, undefined values\n    // should be used as placeholder\n    stooges = _.zip(['moe', 30], ['larry', 40], ['curly', 50, 'extra data']);\n    assert.deepEqual(stooges, [['moe', 'larry', 'curly'], [30, 40, 50], [void 0, void 0, 'extra data']], 'zipped pairs with empties');\n\n    var empty = _.zip([]);\n    assert.deepEqual(empty, [], 'unzipped empty');\n\n    assert.deepEqual(_.zip(null), [], 'handles null');\n    assert.deepEqual(_.zip(), [], '_.zip() returns []');\n  });\n\n  QUnit.test('unzip', function(assert) {\n    assert.deepEqual(_.unzip(null), [], 'handles null');\n\n    assert.deepEqual(_.unzip([['a', 'b'], [1, 2]]), [['a', 1], ['b', 2]]);\n\n    // complements zip\n    var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n    assert.deepEqual(_.unzip(zipped), [['fred', 'barney'], [30, 40], [true, false]]);\n\n    zipped = _.zip(['moe', 30], ['larry', 40], ['curly', 50, 'extra data']);\n    assert.deepEqual(_.unzip(zipped), [['moe', 30, void 0], ['larry', 40, void 0], ['curly', 50, 'extra data']], 'Uses length of largest array');\n  });\n\n  QUnit.test('object', function(assert) {\n    var result = _.object(['moe', 'larry', 'curly'], [30, 40, 50]);\n    var shouldBe = {moe: 30, larry: 40, curly: 50};\n    assert.deepEqual(result, shouldBe, 'two arrays zipped together into an object');\n\n    result = _.object([['one', 1], ['two', 2], ['three', 3]]);\n    shouldBe = {one: 1, two: 2, three: 3};\n    assert.deepEqual(result, shouldBe, 'an array of pairs zipped together into an object');\n\n    var stooges = {moe: 30, larry: 40, curly: 50};\n    assert.deepEqual(_.object(_.pairs(stooges)), stooges, 'an object converted to pairs and back to an object');\n\n    assert.deepEqual(_.object(null), {}, 'handles nulls');\n  });\n\n  QUnit.test('indexOf', function(assert) {\n    var numbers = [1, 2, 3];\n    assert.equal(_.indexOf(numbers, 2), 1, 'can compute indexOf');\n    var result = (function(){ return _.indexOf(arguments, 2); }(1, 2, 3));\n    assert.equal(result, 1, 'works on an arguments object');\n\n    _.each([null, void 0, [], false], function(val) {\n      var msg = 'Handles: ' + (_.isArray(val) ? '[]' : val);\n      assert.equal(_.indexOf(val, 2), -1, msg);\n      assert.equal(_.indexOf(val, 2, -1), -1, msg);\n      assert.equal(_.indexOf(val, 2, -20), -1, msg);\n      assert.equal(_.indexOf(val, 2, 15), -1, msg);\n    });\n\n    var num = 35;\n    numbers = [10, 20, 30, 40, 50];\n    var index = _.indexOf(numbers, num, true);\n    assert.equal(index, -1, '35 is not in the list');\n\n    numbers = [10, 20, 30, 40, 50]; num = 40;\n    index = _.indexOf(numbers, num, true);\n    assert.equal(index, 3, '40 is in the list');\n\n    numbers = [1, 40, 40, 40, 40, 40, 40, 40, 50, 60, 70]; num = 40;\n    assert.equal(_.indexOf(numbers, num, true), 1, '40 is in the list');\n    assert.equal(_.indexOf(numbers, 6, true), -1, '6 isnt in the list');\n    assert.equal(_.indexOf([1, 2, 5, 4, 6, 7], 5, true), -1, 'sorted indexOf doesn\\'t uses binary search');\n    assert.ok(_.every(['1', [], {}, null], function() {\n      return _.indexOf(numbers, num, {}) === 1;\n    }), 'non-nums as fromIndex make indexOf assume sorted');\n\n    numbers = [1, 2, 3, 1, 2, 3, 1, 2, 3];\n    index = _.indexOf(numbers, 2, 5);\n    assert.equal(index, 7, 'supports the fromIndex argument');\n\n    index = _.indexOf([,,, 0], void 0);\n    assert.equal(index, 0, 'treats sparse arrays as if they were dense');\n\n    var array = [1, 2, 3, 1, 2, 3];\n    assert.strictEqual(_.indexOf(array, 1, -3), 3, 'neg `fromIndex` starts at the right index');\n    assert.strictEqual(_.indexOf(array, 1, -2), -1, 'neg `fromIndex` starts at the right index');\n    assert.strictEqual(_.indexOf(array, 2, -3), 4);\n    _.each([-6, -8, -Infinity], function(fromIndex) {\n      assert.strictEqual(_.indexOf(array, 1, fromIndex), 0);\n    });\n    assert.strictEqual(_.indexOf([1, 2, 3], 1, true), 0);\n\n    index = _.indexOf([], void 0, true);\n    assert.equal(index, -1, 'empty array with truthy `isSorted` returns -1');\n  });\n\n  QUnit.test('indexOf with NaN', function(assert) {\n    assert.strictEqual(_.indexOf([1, 2, NaN, NaN], NaN), 2, 'Expected [1, 2, NaN] to contain NaN');\n    assert.strictEqual(_.indexOf([1, 2, Infinity], NaN), -1, 'Expected [1, 2, NaN] to contain NaN');\n\n    assert.strictEqual(_.indexOf([1, 2, NaN, NaN], NaN, 1), 2, 'startIndex does not affect result');\n    assert.strictEqual(_.indexOf([1, 2, NaN, NaN], NaN, -2), 2, 'startIndex does not affect result');\n\n    (function() {\n      assert.strictEqual(_.indexOf(arguments, NaN), 2, 'Expected arguments [1, 2, NaN] to contain NaN');\n    }(1, 2, NaN, NaN));\n  });\n\n  QUnit.test('indexOf with +- 0', function(assert) {\n    _.each([-0, +0], function(val) {\n      assert.strictEqual(_.indexOf([1, 2, val, val], val), 2);\n      assert.strictEqual(_.indexOf([1, 2, val, val], -val), 2);\n    });\n  });\n\n  QUnit.test('lastIndexOf', function(assert) {\n    var numbers = [1, 0, 1];\n    var falsey = [void 0, '', 0, false, NaN, null, void 0];\n    assert.equal(_.lastIndexOf(numbers, 1), 2);\n\n    numbers = [1, 0, 1, 0, 0, 1, 0, 0, 0];\n    numbers.lastIndexOf = null;\n    assert.equal(_.lastIndexOf(numbers, 1), 5, 'can compute lastIndexOf, even without the native function');\n    assert.equal(_.lastIndexOf(numbers, 0), 8, 'lastIndexOf the other element');\n    var result = (function(){ return _.lastIndexOf(arguments, 1); }(1, 0, 1, 0, 0, 1, 0, 0, 0));\n    assert.equal(result, 5, 'works on an arguments object');\n\n    _.each([null, void 0, [], false], function(val) {\n      var msg = 'Handles: ' + (_.isArray(val) ? '[]' : val);\n      assert.equal(_.lastIndexOf(val, 2), -1, msg);\n      assert.equal(_.lastIndexOf(val, 2, -1), -1, msg);\n      assert.equal(_.lastIndexOf(val, 2, -20), -1, msg);\n      assert.equal(_.lastIndexOf(val, 2, 15), -1, msg);\n    });\n\n    numbers = [1, 2, 3, 1, 2, 3, 1, 2, 3];\n    var index = _.lastIndexOf(numbers, 2, 2);\n    assert.equal(index, 1, 'supports the fromIndex argument');\n\n    var array = [1, 2, 3, 1, 2, 3];\n\n    assert.strictEqual(_.lastIndexOf(array, 1, 0), 0, 'starts at the correct from idx');\n    assert.strictEqual(_.lastIndexOf(array, 3), 5, 'should return the index of the last matched value');\n    assert.strictEqual(_.lastIndexOf(array, 4), -1, 'should return `-1` for an unmatched value');\n\n    assert.strictEqual(_.lastIndexOf(array, 1, 2), 0, 'should work with a positive `fromIndex`');\n\n    _.each([6, 8, Math.pow(2, 32), Infinity], function(fromIndex) {\n      assert.strictEqual(_.lastIndexOf(array, void 0, fromIndex), -1);\n      assert.strictEqual(_.lastIndexOf(array, 1, fromIndex), 3);\n      assert.strictEqual(_.lastIndexOf(array, '', fromIndex), -1);\n    });\n\n    var expected = _.map(falsey, function(value) {\n      return typeof value == 'number' ? -1 : 5;\n    });\n\n    var actual = _.map(falsey, function(fromIndex) {\n      return _.lastIndexOf(array, 3, fromIndex);\n    });\n\n    assert.deepEqual(actual, expected, 'should treat falsey `fromIndex` values, except `0` and `NaN`, as `array.length`');\n    assert.strictEqual(_.lastIndexOf(array, 3, '1'), 5, 'should treat non-number `fromIndex` values as `array.length`');\n    assert.strictEqual(_.lastIndexOf(array, 3, true), 5, 'should treat non-number `fromIndex` values as `array.length`');\n\n    assert.strictEqual(_.lastIndexOf(array, 2, -3), 1, 'should work with a negative `fromIndex`');\n    assert.strictEqual(_.lastIndexOf(array, 1, -3), 3, 'neg `fromIndex` starts at the right index');\n\n    assert.deepEqual(_.map([-6, -8, -Infinity], function(fromIndex) {\n      return _.lastIndexOf(array, 1, fromIndex);\n    }), [0, -1, -1]);\n  });\n\n  QUnit.test('lastIndexOf with NaN', function(assert) {\n    assert.strictEqual(_.lastIndexOf([1, 2, NaN, NaN], NaN), 3, 'Expected [1, 2, NaN] to contain NaN');\n    assert.strictEqual(_.lastIndexOf([1, 2, Infinity], NaN), -1, 'Expected [1, 2, NaN] to contain NaN');\n\n    assert.strictEqual(_.lastIndexOf([1, 2, NaN, NaN], NaN, 2), 2, 'fromIndex does not affect result');\n    assert.strictEqual(_.lastIndexOf([1, 2, NaN, NaN], NaN, -2), 2, 'fromIndex does not affect result');\n\n    (function() {\n      assert.strictEqual(_.lastIndexOf(arguments, NaN), 3, 'Expected arguments [1, 2, NaN] to contain NaN');\n    }(1, 2, NaN, NaN));\n  });\n\n  QUnit.test('lastIndexOf with +- 0', function(assert) {\n    _.each([-0, +0], function(val) {\n      assert.strictEqual(_.lastIndexOf([1, 2, val, val], val), 3);\n      assert.strictEqual(_.lastIndexOf([1, 2, val, val], -val), 3);\n      assert.strictEqual(_.lastIndexOf([-1, 1, 2], -val), -1);\n    });\n  });\n\n  QUnit.test('findIndex', function(assert) {\n    var objects = [\n      {a: 0, b: 0},\n      {a: 1, b: 1},\n      {a: 2, b: 2},\n      {a: 0, b: 0}\n    ];\n\n    assert.equal(_.findIndex(objects, function(obj) {\n      return obj.a === 0;\n    }), 0);\n\n    assert.equal(_.findIndex(objects, function(obj) {\n      return obj.b * obj.a === 4;\n    }), 2);\n\n    assert.equal(_.findIndex(objects, 'a'), 1, 'Uses lookupIterator');\n\n    assert.equal(_.findIndex(objects, function(obj) {\n      return obj.b * obj.a === 5;\n    }), -1);\n\n    assert.equal(_.findIndex(null, _.noop), -1);\n    assert.strictEqual(_.findIndex(objects, function(a) {\n      return a.foo === null;\n    }), -1);\n    _.findIndex([{a: 1}], function(a, key, obj) {\n      assert.equal(key, 0);\n      assert.deepEqual(obj, [{a: 1}]);\n      assert.strictEqual(this, objects, 'called with context');\n    }, objects);\n\n    var sparse = [];\n    sparse[20] = {a: 2, b: 2};\n    assert.equal(_.findIndex(sparse, function(obj) {\n      return obj && obj.b * obj.a === 4;\n    }), 20, 'Works with sparse arrays');\n\n    var array = [1, 2, 3, 4];\n    array.match = 55;\n    assert.strictEqual(_.findIndex(array, function(x) { return x === 55; }), -1, 'doesn\\'t match array-likes keys');\n  });\n\n  QUnit.test('findLastIndex', function(assert) {\n    var objects = [\n      {a: 0, b: 0},\n      {a: 1, b: 1},\n      {a: 2, b: 2},\n      {a: 0, b: 0}\n    ];\n\n    assert.equal(_.findLastIndex(objects, function(obj) {\n      return obj.a === 0;\n    }), 3);\n\n    assert.equal(_.findLastIndex(objects, function(obj) {\n      return obj.b * obj.a === 4;\n    }), 2);\n\n    assert.equal(_.findLastIndex(objects, 'a'), 2, 'Uses lookupIterator');\n\n    assert.equal(_.findLastIndex(objects, function(obj) {\n      return obj.b * obj.a === 5;\n    }), -1);\n\n    assert.equal(_.findLastIndex(null, _.noop), -1);\n    assert.strictEqual(_.findLastIndex(objects, function(a) {\n      return a.foo === null;\n    }), -1);\n    _.findLastIndex([{a: 1}], function(a, key, obj) {\n      assert.equal(key, 0);\n      assert.deepEqual(obj, [{a: 1}]);\n      assert.strictEqual(this, objects, 'called with context');\n    }, objects);\n\n    var sparse = [];\n    sparse[20] = {a: 2, b: 2};\n    assert.equal(_.findLastIndex(sparse, function(obj) {\n      return obj && obj.b * obj.a === 4;\n    }), 20, 'Works with sparse arrays');\n\n    var array = [1, 2, 3, 4];\n    array.match = 55;\n    assert.strictEqual(_.findLastIndex(array, function(x) { return x === 55; }), -1, 'doesn\\'t match array-likes keys');\n  });\n\n  QUnit.test('range', function(assert) {\n    assert.deepEqual(_.range(0), [], 'range with 0 as a first argument generates an empty array');\n    assert.deepEqual(_.range(4), [0, 1, 2, 3], 'range with a single positive argument generates an array of elements 0,1,2,...,n-1');\n    assert.deepEqual(_.range(5, 8), [5, 6, 7], 'range with two arguments a &amp; b, a&lt;b generates an array of elements a,a+1,a+2,...,b-2,b-1');\n    assert.deepEqual(_.range(3, 10, 3), [3, 6, 9], 'range with three arguments a &amp; b &amp; c, c &lt; b-a, a &lt; b generates an array of elements a,a+c,a+2c,...,b - (multiplier of a) &lt; c');\n    assert.deepEqual(_.range(3, 10, 15), [3], 'range with three arguments a &amp; b &amp; c, c &gt; b-a, a &lt; b generates an array with a single element, equal to a');\n    assert.deepEqual(_.range(12, 7, -2), [12, 10, 8], 'range with three arguments a &amp; b &amp; c, a &gt; b, c &lt; 0 generates an array of elements a,a-c,a-2c and ends with the number not less than b');\n    assert.deepEqual(_.range(0, -10, -1), [0, -1, -2, -3, -4, -5, -6, -7, -8, -9], 'final example in the Python docs');\n    assert.strictEqual(1 / _.range(-0, 1)[0], -Infinity, 'should preserve -0');\n    assert.deepEqual(_.range(8, 5), [8, 7, 6], 'negative range generates descending array');\n    assert.deepEqual(_.range(-3), [0, -1, -2], 'negative range generates descending array');\n  });\n\n  QUnit.test('chunk', function(assert) {\n    assert.deepEqual(_.chunk([], 2), [], 'chunk for empty array returns an empty array');\n\n    assert.deepEqual(_.chunk([1, 2, 3], 0), [], 'chunk into parts of 0 elements returns empty array');\n    assert.deepEqual(_.chunk([1, 2, 3], -1), [], 'chunk into parts of negative amount of elements returns an empty array');\n    assert.deepEqual(_.chunk([1, 2, 3]), [], 'defaults to empty array (chunk size 0)');\n\n    assert.deepEqual(_.chunk([1, 2, 3], 1), [[1], [2], [3]], 'chunk into parts of 1 elements returns original array');\n\n    assert.deepEqual(_.chunk([1, 2, 3], 3), [[1, 2, 3]], 'chunk into parts of current array length elements returns the original array');\n    assert.deepEqual(_.chunk([1, 2, 3], 5), [[1, 2, 3]], 'chunk into parts of more then current array length elements returns the original array');\n\n    assert.deepEqual(_.chunk([10, 20, 30, 40, 50, 60, 70], 2), [[10, 20], [30, 40], [50, 60], [70]], 'chunk into parts of less then current array length elements');\n    assert.deepEqual(_.chunk([10, 20, 30, 40, 50, 60, 70], 3), [[10, 20, 30], [40, 50, 60], [70]], 'chunk into parts of less then current array length elements');\n  });\n}());\n",
                    language: 'javascript',
                    size: 27711,
                    tokens: 4053,
                    lastModified: '2025-07-02T12:28:22.884Z',
                  },
                  {
                    name: 'chaining.js',
                    path: 'vendor/underscore/test/chaining.js',
                    type: 'file',
                    content:
                      "(function() {\n  var _ = typeof require == 'function' ? require('..') : window._;\n\n  QUnit.module('Chaining');\n\n  QUnit.test('map/flatten/reduce', function(assert) {\n    var lyrics = [\n      'I\\'m a lumberjack and I\\'m okay',\n      'I sleep all night and I work all day',\n      'He\\'s a lumberjack and he\\'s okay',\n      'He sleeps all night and he works all day'\n    ];\n    var counts = _(lyrics).chain()\n      .map(function(line) { return line.split(''); })\n      .flatten()\n      .reduce(function(hash, l) {\n        hash[l] = hash[l] || 0;\n        hash[l]++;\n        return hash;\n      }, {})\n      .value();\n    assert.equal(counts.a, 16, 'counted all the letters in the song');\n    assert.equal(counts.e, 10, 'counted all the letters in the song');\n  });\n\n  QUnit.test('select/reject/sortBy', function(assert) {\n    var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    numbers = _(numbers).chain().select(function(n) {\n      return n % 2 === 0;\n    }).reject(function(n) {\n      return n % 4 === 0;\n    }).sortBy(function(n) {\n      return -n;\n    }).value();\n    assert.deepEqual(numbers, [10, 6, 2], 'filtered and reversed the numbers');\n  });\n\n  QUnit.test('select/reject/sortBy in functional style', function(assert) {\n    var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    numbers = _.chain(numbers).select(function(n) {\n      return n % 2 === 0;\n    }).reject(function(n) {\n      return n % 4 === 0;\n    }).sortBy(function(n) {\n      return -n;\n    }).value();\n    assert.deepEqual(numbers, [10, 6, 2], 'filtered and reversed the numbers');\n  });\n\n  QUnit.test('reverse/concat/unshift/pop/map', function(assert) {\n    var numbers = [1, 2, 3, 4, 5];\n    numbers = _(numbers).chain()\n      .reverse()\n      .concat([5, 5, 5])\n      .unshift(17)\n      .pop()\n      .map(function(n){ return n * 2; })\n      .value();\n    assert.deepEqual(numbers, [34, 10, 8, 6, 4, 2, 10, 10], 'can chain together array functions.');\n  });\n\n  QUnit.test('splice', function(assert) {\n    var instance = _([1, 2, 3, 4, 5]).chain();\n    assert.deepEqual(instance.splice(1, 3).value(), [1, 5]);\n    assert.deepEqual(instance.splice(1, 0).value(), [1, 5]);\n    assert.deepEqual(instance.splice(1, 1).value(), [1]);\n    assert.deepEqual(instance.splice(0, 1).value(), [], '#397 Can create empty array');\n  });\n\n  QUnit.test('shift', function(assert) {\n    var instance = _([1, 2, 3]).chain();\n    assert.deepEqual(instance.shift().value(), [2, 3]);\n    assert.deepEqual(instance.shift().value(), [3]);\n    assert.deepEqual(instance.shift().value(), [], '#397 Can create empty array');\n  });\n\n  QUnit.test('pop', function(assert) {\n    var instance = _([1, 2, 3]).chain();\n    assert.deepEqual(instance.pop().value(), [1, 2]);\n    assert.deepEqual(instance.pop().value(), [1]);\n    assert.deepEqual(instance.pop().value(), [], '#397 Can create empty array');\n  });\n\n  QUnit.test('chaining works in small stages', function(assert) {\n    var o = _([1, 2, 3, 4]).chain();\n    assert.deepEqual(o.filter(function(i) { return i < 3; }).value(), [1, 2]);\n    assert.deepEqual(o.filter(function(i) { return i > 2; }).value(), [3, 4]);\n  });\n\n  QUnit.test('#1562: Engine proxies for chained functions', function(assert) {\n    var wrapped = _(512);\n    assert.strictEqual(wrapped.toJSON(), 512);\n    assert.strictEqual(wrapped.valueOf(), 512);\n    assert.strictEqual(+wrapped, 512);\n    assert.strictEqual(wrapped.toString(), '512');\n    assert.strictEqual('' + wrapped, '512');\n  });\n\n}());\n",
                    language: 'javascript',
                    size: 3462,
                    tokens: 481,
                    lastModified: '2025-07-02T12:28:22.884Z',
                  },
                  {
                    name: 'collections.js',
                    path: 'vendor/underscore/test/collections.js',
                    type: 'file',
                    content:
                      "(function() {\n  var _ = typeof require == 'function' ? require('..') : window._;\n\n  QUnit.module('Collections');\n\n  QUnit.test('each', function(assert) {\n    _.each([1, 2, 3], function(num, i) {\n      assert.equal(num, i + 1, 'each iterators provide value and iteration count');\n    });\n\n    var answers = [];\n    _.each([1, 2, 3], function(num){ answers.push(num * this.multiplier); }, {multiplier: 5});\n    assert.deepEqual(answers, [5, 10, 15], 'context object property accessed');\n\n    answers = [];\n    _.each([1, 2, 3], function(num){ answers.push(num); });\n    assert.deepEqual(answers, [1, 2, 3], 'can iterate a simple array');\n\n    answers = [];\n    var obj = {one: 1, two: 2, three: 3};\n    obj.constructor.prototype.four = 4;\n    _.each(obj, function(value, key){ answers.push(key); });\n    assert.deepEqual(answers, ['one', 'two', 'three'], 'iterating over objects works, and ignores the object prototype.');\n    delete obj.constructor.prototype.four;\n\n    // ensure the each function is JITed\n    _(1000).times(function() { _.each([], function(){}); });\n    var count = 0;\n    obj = {1: 'foo', 2: 'bar', 3: 'baz'};\n    _.each(obj, function(){ count++; });\n    assert.equal(count, 3, 'the fun should be called only 3 times');\n\n    var answer = null;\n    _.each([1, 2, 3], function(num, index, arr){ if (_.include(arr, num)) answer = true; });\n    assert.ok(answer, 'can reference the original collection from inside the iterator');\n\n    answers = 0;\n    _.each(null, function(){ ++answers; });\n    assert.equal(answers, 0, 'handles a null properly');\n\n    _.each(false, function(){});\n\n    var a = [1, 2, 3];\n    assert.strictEqual(_.each(a, function(){}), a);\n    assert.strictEqual(_.each(null, function(){}), null);\n  });\n\n  QUnit.test('forEach', function(assert) {\n    assert.strictEqual(_.forEach, _.each, 'is an alias for each');\n  });\n\n  QUnit.test('lookupIterator with contexts', function(assert) {\n    _.each([true, false, 'yes', '', 0, 1, {}], function(context) {\n      _.each([1], function() {\n        assert.equal(this, context);\n      }, context);\n    });\n  });\n\n  QUnit.test('Iterating objects with sketchy length properties', function(assert) {\n    var functions = [\n      'each', 'map', 'filter', 'find',\n      'some', 'every', 'max', 'min',\n      'groupBy', 'countBy', 'partition', 'indexBy'\n    ];\n    var reducers = ['reduce', 'reduceRight'];\n\n    var tricks = [\n      {length: '5'},\n      {length: {valueOf: _.constant(5)}},\n      {length: Math.pow(2, 53) + 1},\n      {length: Math.pow(2, 53)},\n      {length: null},\n      {length: -2},\n      {length: new Number(15)}\n    ];\n\n    assert.expect(tricks.length * (functions.length + reducers.length + 4));\n\n    _.each(tricks, function(trick) {\n      var length = trick.length;\n      assert.strictEqual(_.size(trick), 1, 'size on obj with length: ' + length);\n      assert.deepEqual(_.toArray(trick), [length], 'toArray on obj with length: ' + length);\n      assert.deepEqual(_.shuffle(trick), [length], 'shuffle on obj with length: ' + length);\n      assert.deepEqual(_.sample(trick), length, 'sample on obj with length: ' + length);\n\n\n      _.each(functions, function(method) {\n        _[method](trick, function(val, key) {\n          assert.strictEqual(key, 'length', method + ': ran with length = ' + val);\n        });\n      });\n\n      _.each(reducers, function(method) {\n        assert.strictEqual(_[method](trick), trick.length, method);\n      });\n    });\n  });\n\n  QUnit.test('Resistant to collection length and properties changing while iterating', function(assert) {\n\n    var collection = [\n      'each', 'map', 'filter', 'find',\n      'some', 'every', 'max', 'min', 'reject',\n      'groupBy', 'countBy', 'partition', 'indexBy',\n      'reduce', 'reduceRight'\n    ];\n    var array = [\n      'findIndex', 'findLastIndex'\n    ];\n    var object = [\n      'mapObject', 'findKey', 'pick', 'omit'\n    ];\n\n    _.each(collection.concat(array), function(method) {\n      var sparseArray = [1, 2, 3];\n      sparseArray.length = 100;\n      var answers = 0;\n      _[method](sparseArray, function(){\n        ++answers;\n        return method === 'every' ? true : null;\n      }, {});\n      assert.equal(answers, 100, method + ' enumerates [0, length)');\n\n      var growingCollection = [1, 2, 3], count = 0;\n      _[method](growingCollection, function() {\n        if (count < 10) growingCollection.push(count++);\n        return method === 'every' ? true : null;\n      }, {});\n      assert.equal(count, 3, method + ' is resistant to length changes');\n    });\n\n    _.each(collection.concat(object), function(method) {\n      var changingObject = {0: 0, 1: 1}, count = 0;\n      _[method](changingObject, function(val) {\n        if (count < 10) changingObject[++count] = val + 1;\n        return method === 'every' ? true : null;\n      }, {});\n\n      assert.equal(count, 2, method + ' is resistant to property changes');\n    });\n  });\n\n  QUnit.test('map', function(assert) {\n    var doubled = _.map([1, 2, 3], function(num){ return num * 2; });\n    assert.deepEqual(doubled, [2, 4, 6], 'doubled numbers');\n\n    var tripled = _.map([1, 2, 3], function(num){ return num * this.multiplier; }, {multiplier: 3});\n    assert.deepEqual(tripled, [3, 6, 9], 'tripled numbers with context');\n\n    doubled = _([1, 2, 3]).map(function(num){ return num * 2; });\n    assert.deepEqual(doubled, [2, 4, 6], 'OO-style doubled numbers');\n\n    var ids = _.map({length: 2, 0: {id: '1'}, 1: {id: '2'}}, function(n){\n      return n.id;\n    });\n    assert.deepEqual(ids, ['1', '2'], 'Can use collection methods on Array-likes.');\n\n    assert.deepEqual(_.map(null, _.noop), [], 'handles a null properly');\n\n    assert.deepEqual(_.map([1], function() {\n      return this.length;\n    }, [5]), [1], 'called with context');\n\n    // Passing a property name like _.pluck.\n    var people = [{name: 'moe', age: 30}, {name: 'curly', age: 50}];\n    assert.deepEqual(_.map(people, 'name'), ['moe', 'curly'], 'predicate string map to object properties');\n  });\n\n  QUnit.test('collect', function(assert) {\n    assert.strictEqual(_.collect, _.map, 'is an alias for map');\n  });\n\n  QUnit.test('reduce', function(assert) {\n    var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);\n    assert.equal(sum, 6, 'can sum up an array');\n\n    var context = {multiplier: 3};\n    sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num * this.multiplier; }, 0, context);\n    assert.equal(sum, 18, 'can reduce with a context object');\n\n    sum = _([1, 2, 3]).reduce(function(memo, num){ return memo + num; }, 0);\n    assert.equal(sum, 6, 'OO-style reduce');\n\n    sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; });\n    assert.equal(sum, 6, 'default initial value');\n\n    var prod = _.reduce([1, 2, 3, 4], function(memo, num){ return memo * num; });\n    assert.equal(prod, 24, 'can reduce via multiplication');\n\n    assert.strictEqual(_.reduce(null, _.noop, 138), 138, 'handles a null (with initial value) properly');\n    assert.equal(_.reduce([], _.noop, void 0), void 0, 'undefined can be passed as a special case');\n    assert.equal(_.reduce([_], _.noop), _, 'collection of length one with no initial value returns the first item');\n    assert.equal(_.reduce([], _.noop), void 0, 'returns undefined when collection is empty and no initial value');\n  });\n\n  QUnit.test('foldl', function(assert) {\n    assert.strictEqual(_.foldl, _.reduce, 'is an alias for reduce');\n  });\n\n  QUnit.test('inject', function(assert) {\n    assert.strictEqual(_.inject, _.reduce, 'is an alias for reduce');\n  });\n\n  QUnit.test('reduceRight', function(assert) {\n    var list = _.reduceRight(['foo', 'bar', 'baz'], function(memo, str){ return memo + str; }, '');\n    assert.equal(list, 'bazbarfoo', 'can perform right folds');\n\n    list = _.reduceRight(['foo', 'bar', 'baz'], function(memo, str){ return memo + str; });\n    assert.equal(list, 'bazbarfoo', 'default initial value');\n\n    var sum = _.reduceRight({a: 1, b: 2, c: 3}, function(memo, num){ return memo + num; });\n    assert.equal(sum, 6, 'default initial value on object');\n\n    assert.strictEqual(_.reduceRight(null, _.noop, 138), 138, 'handles a null (with initial value) properly');\n    assert.equal(_.reduceRight([_], _.noop), _, 'collection of length one with no initial value returns the first item');\n\n    assert.equal(_.reduceRight([], _.noop, void 0), void 0, 'undefined can be passed as a special case');\n    assert.equal(_.reduceRight([], _.noop), void 0, 'returns undefined when collection is empty and no initial value');\n\n    // Assert that the correct arguments are being passed.\n\n    var args,\n        init = {},\n        object = {a: 1, b: 2},\n        lastKey = _.keys(object).pop();\n\n    var expected = lastKey === 'a'\n      ? [init, 1, 'a', object]\n      : [init, 2, 'b', object];\n\n    _.reduceRight(object, function() {\n      if (!args) args = _.toArray(arguments);\n    }, init);\n\n    assert.deepEqual(args, expected);\n\n    // And again, with numeric keys.\n\n    object = {2: 'a', 1: 'b'};\n    lastKey = _.keys(object).pop();\n    args = null;\n\n    expected = lastKey === '2'\n      ? [init, 'a', '2', object]\n      : [init, 'b', '1', object];\n\n    _.reduceRight(object, function() {\n      if (!args) args = _.toArray(arguments);\n    }, init);\n\n    assert.deepEqual(args, expected);\n  });\n\n  QUnit.test('foldr', function(assert) {\n    assert.strictEqual(_.foldr, _.reduceRight, 'is an alias for reduceRight');\n  });\n\n  QUnit.test('find', function(assert) {\n    var array = [1, 2, 3, 4];\n    assert.strictEqual(_.find(array, function(n) { return n > 2; }), 3, 'should return first found `value`');\n    assert.strictEqual(_.find(array, function() { return false; }), void 0, 'should return `undefined` if `value` is not found');\n\n    array.dontmatch = 55;\n    assert.strictEqual(_.find(array, function(x) { return x === 55; }), void 0, 'iterates array-likes correctly');\n\n    // Matching an object like _.findWhere.\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}, {a: 2, b: 4}];\n    assert.deepEqual(_.find(list, {a: 1}), {a: 1, b: 2}, 'can be used as findWhere');\n    assert.deepEqual(_.find(list, {b: 4}), {a: 1, b: 4});\n    assert.notOk(_.find(list, {c: 1}), 'undefined when not found');\n    assert.notOk(_.find([], {c: 1}), 'undefined when searching empty list');\n\n    var result = _.find([1, 2, 3], function(num){ return num * 2 === 4; });\n    assert.equal(result, 2, 'found the first \"2\" and broke the loop');\n\n    var obj = {\n      a: {x: 1, z: 3},\n      b: {x: 2, z: 2},\n      c: {x: 3, z: 4},\n      d: {x: 4, z: 1}\n    };\n\n    assert.deepEqual(_.find(obj, {x: 2}), {x: 2, z: 2}, 'works on objects');\n    assert.deepEqual(_.find(obj, {x: 2, z: 1}), void 0);\n    assert.deepEqual(_.find(obj, function(x) {\n      return x.x === 4;\n    }), {x: 4, z: 1});\n\n    _.findIndex([{a: 1}], function(a, key, o) {\n      assert.equal(key, 0);\n      assert.deepEqual(o, [{a: 1}]);\n      assert.strictEqual(this, _, 'called with context');\n    }, _);\n  });\n\n  QUnit.test('detect', function(assert) {\n    assert.strictEqual(_.detect, _.find, 'is an alias for find');\n  });\n\n  QUnit.test('filter', function(assert) {\n    var evenArray = [1, 2, 3, 4, 5, 6];\n    var evenObject = {one: 1, two: 2, three: 3};\n    var isEven = function(num){ return num % 2 === 0; };\n\n    assert.deepEqual(_.filter(evenArray, isEven), [2, 4, 6]);\n    assert.deepEqual(_.filter(evenObject, isEven), [2], 'can filter objects');\n    assert.deepEqual(_.filter([{}, evenObject, []], 'two'), [evenObject], 'predicate string map to object properties');\n\n    _.filter([1], function() {\n      assert.equal(this, evenObject, 'given context');\n    }, evenObject);\n\n    // Can be used like _.where.\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}];\n    assert.deepEqual(_.filter(list, {a: 1}), [{a: 1, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}]);\n    assert.deepEqual(_.filter(list, {b: 2}), [{a: 1, b: 2}, {a: 2, b: 2}]);\n    assert.deepEqual(_.filter(list, {}), list, 'Empty object accepts all items');\n    assert.deepEqual(_(list).filter({}), list, 'OO-filter');\n  });\n\n  QUnit.test('select', function(assert) {\n    assert.strictEqual(_.select, _.filter, 'is an alias for filter');\n  });\n\n  QUnit.test('reject', function(assert) {\n    var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 === 0; });\n    assert.deepEqual(odds, [1, 3, 5], 'rejected each even number');\n\n    var context = 'obj';\n\n    var evens = _.reject([1, 2, 3, 4, 5, 6], function(num){\n      assert.equal(context, 'obj');\n      return num % 2 !== 0;\n    }, context);\n    assert.deepEqual(evens, [2, 4, 6], 'rejected each odd number');\n\n    assert.deepEqual(_.reject([odds, {one: 1, two: 2, three: 3}], 'two'), [odds], 'predicate string map to object properties');\n\n    // Can be used like _.where.\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}];\n    assert.deepEqual(_.reject(list, {a: 1}), [{a: 2, b: 2}]);\n    assert.deepEqual(_.reject(list, {b: 2}), [{a: 1, b: 3}, {a: 1, b: 4}]);\n    assert.deepEqual(_.reject(list, {}), [], 'Returns empty list given empty object');\n    assert.deepEqual(_.reject(list, []), [], 'Returns empty list given empty array');\n  });\n\n  QUnit.test('every', function(assert) {\n    assert.ok(_.every([], _.identity), 'the empty set');\n    assert.ok(_.every([true, true, true], _.identity), 'every true values');\n    assert.notOk(_.every([true, false, true], _.identity), 'one false value');\n    assert.ok(_.every([0, 10, 28], function(num){ return num % 2 === 0; }), 'even numbers');\n    assert.notOk(_.every([0, 11, 28], function(num){ return num % 2 === 0; }), 'an odd number');\n    assert.strictEqual(_.every([1], _.identity), true, 'cast to boolean - true');\n    assert.strictEqual(_.every([0], _.identity), false, 'cast to boolean - false');\n    assert.notOk(_.every([void 0, void 0, void 0], _.identity), 'works with arrays of undefined');\n\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}];\n    assert.notOk(_.every(list, {a: 1, b: 2}), 'Can be called with object');\n    assert.ok(_.every(list, 'a'), 'String mapped to object property');\n\n    list = [{a: 1, b: 2}, {a: 2, b: 2, c: true}];\n    assert.ok(_.every(list, {b: 2}), 'Can be called with object');\n    assert.notOk(_.every(list, 'c'), 'String mapped to object property');\n\n    assert.ok(_.every({a: 1, b: 2, c: 3, d: 4}, _.isNumber), 'takes objects');\n    assert.notOk(_.every({a: 1, b: 2, c: 3, d: 4}, _.isObject), 'takes objects');\n    assert.ok(_.every(['a', 'b', 'c', 'd'], _.hasOwnProperty, {a: 1, b: 2, c: 3, d: 4}), 'context works');\n    assert.notOk(_.every(['a', 'b', 'c', 'd', 'f'], _.hasOwnProperty, {a: 1, b: 2, c: 3, d: 4}), 'context works');\n  });\n\n  QUnit.test('all', function(assert) {\n    assert.strictEqual(_.all, _.every, 'is an alias for every');\n  });\n\n  QUnit.test('some', function(assert) {\n    assert.notOk(_.some([]), 'the empty set');\n    assert.notOk(_.some([false, false, false]), 'all false values');\n    assert.ok(_.some([false, false, true]), 'one true value');\n    assert.ok(_.some([null, 0, 'yes', false]), 'a string');\n    assert.notOk(_.some([null, 0, '', false]), 'falsy values');\n    assert.notOk(_.some([1, 11, 29], function(num){ return num % 2 === 0; }), 'all odd numbers');\n    assert.ok(_.some([1, 10, 29], function(num){ return num % 2 === 0; }), 'an even number');\n    assert.strictEqual(_.some([1], _.identity), true, 'cast to boolean - true');\n    assert.strictEqual(_.some([0], _.identity), false, 'cast to boolean - false');\n    assert.ok(_.some([false, false, true]));\n\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}];\n    assert.notOk(_.some(list, {a: 5, b: 2}), 'Can be called with object');\n    assert.ok(_.some(list, 'a'), 'String mapped to object property');\n\n    list = [{a: 1, b: 2}, {a: 2, b: 2, c: true}];\n    assert.ok(_.some(list, {b: 2}), 'Can be called with object');\n    assert.notOk(_.some(list, 'd'), 'String mapped to object property');\n\n    assert.ok(_.some({a: '1', b: '2', c: '3', d: '4', e: 6}, _.isNumber), 'takes objects');\n    assert.notOk(_.some({a: 1, b: 2, c: 3, d: 4}, _.isObject), 'takes objects');\n    assert.ok(_.some(['a', 'b', 'c', 'd'], _.hasOwnProperty, {a: 1, b: 2, c: 3, d: 4}), 'context works');\n    assert.notOk(_.some(['x', 'y', 'z'], _.hasOwnProperty, {a: 1, b: 2, c: 3, d: 4}), 'context works');\n  });\n\n  QUnit.test('any', function(assert) {\n    assert.strictEqual(_.any, _.some, 'is an alias for some');\n  });\n\n  QUnit.test('includes', function(assert) {\n    _.each([null, void 0, 0, 1, NaN, {}, []], function(val) {\n      assert.strictEqual(_.includes(val, 'hasOwnProperty'), false);\n    });\n    assert.strictEqual(_.includes([1, 2, 3], 2), true, 'two is in the array');\n    assert.notOk(_.includes([1, 3, 9], 2), 'two is not in the array');\n\n    assert.strictEqual(_.includes([5, 4, 3, 2, 1], 5, true), true, 'doesn\\'t delegate to binary search');\n\n    assert.strictEqual(_.includes({moe: 1, larry: 3, curly: 9}, 3), true, '_.includes on objects checks their values');\n    assert.ok(_([1, 2, 3]).includes(2), 'OO-style includes');\n\n    var numbers = [1, 2, 3, 1, 2, 3, 1, 2, 3];\n    assert.strictEqual(_.includes(numbers, 1, 1), true, 'takes a fromIndex');\n    assert.strictEqual(_.includes(numbers, 1, -1), false, 'takes a fromIndex');\n    assert.strictEqual(_.includes(numbers, 1, -2), false, 'takes a fromIndex');\n    assert.strictEqual(_.includes(numbers, 1, -3), true, 'takes a fromIndex');\n    assert.strictEqual(_.includes(numbers, 1, 6), true, 'takes a fromIndex');\n    assert.strictEqual(_.includes(numbers, 1, 7), false, 'takes a fromIndex');\n\n    assert.ok(_.every([1, 2, 3], _.partial(_.includes, numbers)), 'fromIndex is guarded');\n  });\n\n  QUnit.test('include', function(assert) {\n    assert.strictEqual(_.include, _.includes, 'is an alias for includes');\n  });\n\n  QUnit.test('contains', function(assert) {\n    assert.strictEqual(_.contains, _.includes, 'is an alias for includes');\n\n  });\n\n  QUnit.test('includes with NaN', function(assert) {\n    assert.strictEqual(_.includes([1, 2, NaN, NaN], NaN), true, 'Expected [1, 2, NaN] to contain NaN');\n    assert.strictEqual(_.includes([1, 2, Infinity], NaN), false, 'Expected [1, 2, NaN] to contain NaN');\n  });\n\n  QUnit.test('includes with +- 0', function(assert) {\n    _.each([-0, +0], function(val) {\n      assert.strictEqual(_.includes([1, 2, val, val], val), true);\n      assert.strictEqual(_.includes([1, 2, val, val], -val), true);\n      assert.strictEqual(_.includes([-1, 1, 2], -val), false);\n    });\n  });\n\n\n  QUnit.test('invoke', function(assert) {\n    assert.expect(5);\n    var list = [[5, 1, 7], [3, 2, 1]];\n    var result = _.invoke(list, 'sort');\n    assert.deepEqual(result[0], [1, 5, 7], 'first array sorted');\n    assert.deepEqual(result[1], [1, 2, 3], 'second array sorted');\n\n    _.invoke([{\n      method: function() {\n        assert.deepEqual(_.toArray(arguments), [1, 2, 3], 'called with arguments');\n      }\n    }], 'method', 1, 2, 3);\n\n    assert.deepEqual(_.invoke([{a: null}, {}, {a: _.constant(1)}], 'a'), [null, void 0, 1], 'handles null & undefined');\n\n    assert.raises(function() {\n      _.invoke([{a: 1}], 'a');\n    }, TypeError, 'throws for non-functions');\n  });\n\n  QUnit.test('invoke w/ function reference', function(assert) {\n    var list = [[5, 1, 7], [3, 2, 1]];\n    var result = _.invoke(list, Array.prototype.sort);\n    assert.deepEqual(result[0], [1, 5, 7], 'first array sorted');\n    assert.deepEqual(result[1], [1, 2, 3], 'second array sorted');\n\n    assert.deepEqual(_.invoke([1, 2, 3], function(a) {\n      return a + this;\n    }, 5), [6, 7, 8], 'receives params from invoke');\n  });\n\n  // Relevant when using ClojureScript\n  QUnit.test('invoke when strings have a call method', function(assert) {\n    String.prototype.call = function() {\n      return 42;\n    };\n    var list = [[5, 1, 7], [3, 2, 1]];\n    var s = 'foo';\n    assert.equal(s.call(), 42, 'call function exists');\n    var result = _.invoke(list, 'sort');\n    assert.deepEqual(result[0], [1, 5, 7], 'first array sorted');\n    assert.deepEqual(result[1], [1, 2, 3], 'second array sorted');\n    delete String.prototype.call;\n    assert.equal(s.call, void 0, 'call function removed');\n  });\n\n  QUnit.test('pluck', function(assert) {\n    var people = [{name: 'moe', age: 30}, {name: 'curly', age: 50}];\n    assert.deepEqual(_.pluck(people, 'name'), ['moe', 'curly'], 'pulls names out of objects');\n    assert.deepEqual(_.pluck(people, 'address'), [void 0, void 0], 'missing properties are returned as undefined');\n    //compat: most flexible handling of edge cases\n    assert.deepEqual(_.pluck([{'[object Object]': 1}], {}), [1]);\n  });\n\n  QUnit.test('where', function(assert) {\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}];\n    var result = _.where(list, {a: 1});\n    assert.equal(result.length, 3);\n    assert.equal(result[result.length - 1].b, 4);\n    result = _.where(list, {b: 2});\n    assert.equal(result.length, 2);\n    assert.equal(result[0].a, 1);\n    result = _.where(list, {});\n    assert.equal(result.length, list.length);\n\n    function test() {}\n    test.map = _.map;\n    assert.deepEqual(_.where([_, {a: 1, b: 2}, _], test), [_, _], 'checks properties given function');\n  });\n\n  QUnit.test('findWhere', function(assert) {\n    var list = [{a: 1, b: 2}, {a: 2, b: 2}, {a: 1, b: 3}, {a: 1, b: 4}, {a: 2, b: 4}];\n    var result = _.findWhere(list, {a: 1});\n    assert.deepEqual(result, {a: 1, b: 2});\n    result = _.findWhere(list, {b: 4});\n    assert.deepEqual(result, {a: 1, b: 4});\n\n    result = _.findWhere(list, {c: 1});\n    assert.ok(_.isUndefined(result), 'undefined when not found');\n\n    result = _.findWhere([], {c: 1});\n    assert.ok(_.isUndefined(result), 'undefined when searching empty list');\n\n    function test() {}\n    test.map = _.map;\n    assert.equal(_.findWhere([_, {a: 1, b: 2}, _], test), _, 'checks properties given function');\n\n    function TestClass() {\n      this.y = 5;\n      this.x = 'foo';\n    }\n    var expect = {c: 1, x: 'foo', y: 5};\n    assert.deepEqual(_.findWhere([{y: 5, b: 6}, expect], new TestClass()), expect, 'uses class instance properties');\n  });\n\n  QUnit.test('max', function(assert) {\n    assert.equal(-Infinity, _.max(null), 'can handle null/undefined');\n    assert.equal(-Infinity, _.max(void 0), 'can handle null/undefined');\n    assert.equal(-Infinity, _.max(null, _.identity), 'can handle null/undefined');\n\n    assert.equal(_.max([1, 2, 3]), 3, 'can perform a regular Math.max');\n\n    var neg = _.max([1, 2, 3], function(num){ return -num; });\n    assert.equal(neg, 1, 'can perform a computation-based max');\n\n    assert.equal(-Infinity, _.max({}), 'Maximum value of an empty object');\n    assert.equal(-Infinity, _.max([]), 'Maximum value of an empty array');\n    assert.equal(_.max({a: 'a'}), -Infinity, 'Maximum value of a non-numeric collection');\n\n    assert.equal(_.max(_.range(1, 300000)), 299999, 'Maximum value of a too-big array');\n\n    assert.equal(_.max([1, 2, 3, 'test']), 3, 'Finds correct max in array starting with num and containing a NaN');\n    assert.equal(_.max(['test', 1, 2, 3]), 3, 'Finds correct max in array starting with NaN');\n\n    assert.equal(_.max([1, 2, 3, null]), 3, 'Finds correct max in array starting with num and containing a `null`');\n    assert.equal(_.max([null, 1, 2, 3]), 3, 'Finds correct max in array starting with a `null`');\n\n    assert.equal(_.max([1, 2, 3, '']), 3, 'Finds correct max in array starting with num and containing an empty string');\n    assert.equal(_.max(['', 1, 2, 3]), 3, 'Finds correct max in array starting with an empty string');\n\n    assert.equal(_.max([1, 2, 3, false]), 3, 'Finds correct max in array starting with num and containing a false');\n    assert.equal(_.max([false, 1, 2, 3]), 3, 'Finds correct max in array starting with a false');\n\n    assert.equal(_.max([0, 1, 2, 3, 4]), 4, 'Finds correct max in array containing a zero');\n    assert.equal(_.max([-3, -2, -1, 0]), 0, 'Finds correct max in array containing negative numbers');\n\n    assert.deepEqual(_.map([[1, 2, 3], [4, 5, 6]], _.max), [3, 6], 'Finds correct max in array when mapping through multiple arrays');\n\n    var a = {x: -Infinity};\n    var b = {x: -Infinity};\n    var iterator = function(o){ return o.x; };\n    assert.equal(_.max([a, b], iterator), a, 'Respects iterator return value of -Infinity');\n\n    assert.deepEqual(_.max([{a: 1}, {a: 0, b: 3}, {a: 4}, {a: 2}], 'a'), {a: 4}, 'String keys use property iterator');\n\n    assert.deepEqual(_.max([0, 2], function(c){ return c * this.x; }, {x: 1}), 2, 'Iterator context');\n    assert.deepEqual(_.max([[1], [2, 3], [-1, 4], [5]], 0), [5], 'Lookup falsy iterator');\n    assert.deepEqual(_.max([{0: 1}, {0: 2}, {0: -1}, {a: 1}], 0), {0: 2}, 'Lookup falsy iterator');\n  });\n\n  QUnit.test('min', function(assert) {\n    assert.equal(_.min(null), Infinity, 'can handle null/undefined');\n    assert.equal(_.min(void 0), Infinity, 'can handle null/undefined');\n    assert.equal(_.min(null, _.identity), Infinity, 'can handle null/undefined');\n\n    assert.equal(_.min([1, 2, 3]), 1, 'can perform a regular Math.min');\n\n    var neg = _.min([1, 2, 3], function(num){ return -num; });\n    assert.equal(neg, 3, 'can perform a computation-based min');\n\n    assert.equal(_.min({}), Infinity, 'Minimum value of an empty object');\n    assert.equal(_.min([]), Infinity, 'Minimum value of an empty array');\n    assert.equal(_.min({a: 'a'}), Infinity, 'Minimum value of a non-numeric collection');\n\n    assert.deepEqual(_.map([[1, 2, 3], [4, 5, 6]], _.min), [1, 4], 'Finds correct min in array when mapping through multiple arrays');\n\n    var now = new Date(9999999999);\n    var then = new Date(0);\n    assert.equal(_.min([now, then]), then);\n\n    assert.equal(_.min(_.range(1, 300000)), 1, 'Minimum value of a too-big array');\n\n    assert.equal(_.min([1, 2, 3, 'test']), 1, 'Finds correct min in array starting with num and containing a NaN');\n    assert.equal(_.min(['test', 1, 2, 3]), 1, 'Finds correct min in array starting with NaN');\n\n    assert.equal(_.min([1, 2, 3, null]), 1, 'Finds correct min in array starting with num and containing a `null`');\n    assert.equal(_.min([null, 1, 2, 3]), 1, 'Finds correct min in array starting with a `null`');\n\n    assert.equal(_.min([0, 1, 2, 3, 4]), 0, 'Finds correct min in array containing a zero');\n    assert.equal(_.min([-3, -2, -1, 0]), -3, 'Finds correct min in array containing negative numbers');\n\n    var a = {x: Infinity};\n    var b = {x: Infinity};\n    var iterator = function(o){ return o.x; };\n    assert.equal(_.min([a, b], iterator), a, 'Respects iterator return value of Infinity');\n\n    assert.deepEqual(_.min([{a: 1}, {a: 0, b: 3}, {a: 4}, {a: 2}], 'a'), {a: 0, b: 3}, 'String keys use property iterator');\n\n    assert.deepEqual(_.min([0, 2], function(c){ return c * this.x; }, {x: -1}), 2, 'Iterator context');\n    assert.deepEqual(_.min([[1], [2, 3], [-1, 4], [5]], 0), [-1, 4], 'Lookup falsy iterator');\n    assert.deepEqual(_.min([{0: 1}, {0: 2}, {0: -1}, {a: 1}], 0), {0: -1}, 'Lookup falsy iterator');\n  });\n\n  QUnit.test('sortBy', function(assert) {\n    var people = [{name: 'curly', age: 50}, {name: 'moe', age: 30}];\n    people = _.sortBy(people, function(person){ return person.age; });\n    assert.deepEqual(_.pluck(people, 'name'), ['moe', 'curly'], 'stooges sorted by age');\n\n    var list = [void 0, 4, 1, void 0, 3, 2];\n    assert.deepEqual(_.sortBy(list, _.identity), [1, 2, 3, 4, void 0, void 0], 'sortBy with undefined values');\n\n    list = ['one', 'two', 'three', 'four', 'five'];\n    var sorted = _.sortBy(list, 'length');\n    assert.deepEqual(sorted, ['one', 'two', 'four', 'five', 'three'], 'sorted by length');\n\n    function Pair(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    var stableArray = [\n      new Pair(1, 1), new Pair(1, 2),\n      new Pair(1, 3), new Pair(1, 4),\n      new Pair(1, 5), new Pair(1, 6),\n      new Pair(2, 1), new Pair(2, 2),\n      new Pair(2, 3), new Pair(2, 4),\n      new Pair(2, 5), new Pair(2, 6),\n      new Pair(void 0, 1), new Pair(void 0, 2),\n      new Pair(void 0, 3), new Pair(void 0, 4),\n      new Pair(void 0, 5), new Pair(void 0, 6)\n    ];\n\n    var stableObject = _.object('abcdefghijklmnopqr'.split(''), stableArray);\n\n    var actual = _.sortBy(stableArray, function(pair) {\n      return pair.x;\n    });\n\n    assert.deepEqual(actual, stableArray, 'sortBy should be stable for arrays');\n    assert.deepEqual(_.sortBy(stableArray, 'x'), stableArray, 'sortBy accepts property string');\n\n    actual = _.sortBy(stableObject, function(pair) {\n      return pair.x;\n    });\n\n    assert.deepEqual(actual, stableArray, 'sortBy should be stable for objects');\n\n    list = ['q', 'w', 'e', 'r', 't', 'y'];\n    assert.deepEqual(_.sortBy(list), ['e', 'q', 'r', 't', 'w', 'y'], 'uses _.identity if iterator is not specified');\n  });\n\n  QUnit.test('groupBy', function(assert) {\n    var parity = _.groupBy([1, 2, 3, 4, 5, 6], function(num){ return num % 2; });\n    assert.ok('0' in parity && '1' in parity, 'created a group for each value');\n    assert.deepEqual(parity[0], [2, 4, 6], 'put each even number in the right group');\n\n    var list = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];\n    var grouped = _.groupBy(list, 'length');\n    assert.deepEqual(grouped['3'], ['one', 'two', 'six', 'ten']);\n    assert.deepEqual(grouped['4'], ['four', 'five', 'nine']);\n    assert.deepEqual(grouped['5'], ['three', 'seven', 'eight']);\n\n    var context = {};\n    _.groupBy([{}], function(){ assert.strictEqual(this, context); }, context);\n\n    grouped = _.groupBy([4.2, 6.1, 6.4], function(num) {\n      return Math.floor(num) > 4 ? 'hasOwnProperty' : 'constructor';\n    });\n    assert.equal(grouped.constructor.length, 1);\n    assert.equal(grouped.hasOwnProperty.length, 2);\n\n    var array = [{}];\n    _.groupBy(array, function(value, index, obj){ assert.strictEqual(obj, array); });\n\n    array = [1, 2, 1, 2, 3];\n    grouped = _.groupBy(array);\n    assert.equal(grouped['1'].length, 2);\n    assert.equal(grouped['3'].length, 1);\n\n    var matrix = [\n      [1, 2],\n      [1, 3],\n      [2, 3]\n    ];\n    assert.deepEqual(_.groupBy(matrix, 0), {1: [[1, 2], [1, 3]], 2: [[2, 3]]});\n    assert.deepEqual(_.groupBy(matrix, 1), {2: [[1, 2]], 3: [[1, 3], [2, 3]]});\n  });\n\n  QUnit.test('indexBy', function(assert) {\n    var parity = _.indexBy([1, 2, 3, 4, 5], function(num){ return num % 2 === 0; });\n    assert.equal(parity['true'], 4);\n    assert.equal(parity['false'], 5);\n\n    var list = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];\n    var grouped = _.indexBy(list, 'length');\n    assert.equal(grouped['3'], 'ten');\n    assert.equal(grouped['4'], 'nine');\n    assert.equal(grouped['5'], 'eight');\n\n    var array = [1, 2, 1, 2, 3];\n    grouped = _.indexBy(array);\n    assert.equal(grouped['1'], 1);\n    assert.equal(grouped['2'], 2);\n    assert.equal(grouped['3'], 3);\n  });\n\n  QUnit.test('countBy', function(assert) {\n    var parity = _.countBy([1, 2, 3, 4, 5], function(num){ return num % 2 === 0; });\n    assert.equal(parity['true'], 2);\n    assert.equal(parity['false'], 3);\n\n    var list = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];\n    var grouped = _.countBy(list, 'length');\n    assert.equal(grouped['3'], 4);\n    assert.equal(grouped['4'], 3);\n    assert.equal(grouped['5'], 3);\n\n    var context = {};\n    _.countBy([{}], function(){ assert.strictEqual(this, context); }, context);\n\n    grouped = _.countBy([4.2, 6.1, 6.4], function(num) {\n      return Math.floor(num) > 4 ? 'hasOwnProperty' : 'constructor';\n    });\n    assert.equal(grouped.constructor, 1);\n    assert.equal(grouped.hasOwnProperty, 2);\n\n    var array = [{}];\n    _.countBy(array, function(value, index, obj){ assert.strictEqual(obj, array); });\n\n    array = [1, 2, 1, 2, 3];\n    grouped = _.countBy(array);\n    assert.equal(grouped['1'], 2);\n    assert.equal(grouped['3'], 1);\n  });\n\n  QUnit.test('shuffle', function(assert) {\n    assert.deepEqual(_.shuffle([1]), [1], 'behaves correctly on size 1 arrays');\n    var numbers = _.range(20);\n    var shuffled = _.shuffle(numbers);\n    assert.notDeepEqual(numbers, shuffled, 'does change the order'); // Chance of false negative: 1 in ~2.4*10^18\n    assert.notStrictEqual(numbers, shuffled, 'original object is unmodified');\n    assert.deepEqual(numbers, _.sortBy(shuffled), 'contains the same members before and after shuffle');\n\n    shuffled = _.shuffle({a: 1, b: 2, c: 3, d: 4});\n    assert.equal(shuffled.length, 4);\n    assert.deepEqual(shuffled.sort(), [1, 2, 3, 4], 'works on objects');\n  });\n\n  QUnit.test('sample', function(assert) {\n    assert.strictEqual(_.sample([1]), 1, 'behaves correctly when no second parameter is given');\n    assert.deepEqual(_.sample([1, 2, 3], -2), [], 'behaves correctly on negative n');\n    var numbers = _.range(10);\n    var allSampled = _.sample(numbers, 10).sort();\n    assert.deepEqual(allSampled, numbers, 'contains the same members before and after sample');\n    allSampled = _.sample(numbers, 20).sort();\n    assert.deepEqual(allSampled, numbers, 'also works when sampling more objects than are present');\n    assert.ok(_.contains(numbers, _.sample(numbers)), 'sampling a single element returns something from the array');\n    assert.strictEqual(_.sample([]), void 0, 'sampling empty array with no number returns undefined');\n    assert.notStrictEqual(_.sample([], 5), [], 'sampling empty array with a number returns an empty array');\n    assert.notStrictEqual(_.sample([1, 2, 3], 0), [], 'sampling an array with 0 picks returns an empty array');\n    assert.deepEqual(_.sample([1, 2], -1), [], 'sampling a negative number of picks returns an empty array');\n    assert.ok(_.contains([1, 2, 3], _.sample({a: 1, b: 2, c: 3})), 'sample one value from an object');\n    var partialSample = _.sample(_.range(1000), 10);\n    var partialSampleSorted = partialSample.sort();\n    assert.notDeepEqual(partialSampleSorted, _.range(10), 'samples from the whole array, not just the beginning');\n  });\n\n  QUnit.test('toArray', function(assert) {\n    assert.notOk(_.isArray(arguments), 'arguments object is not an array');\n    assert.ok(_.isArray(_.toArray(arguments)), 'arguments object converted into array');\n    var a = [1, 2, 3];\n    assert.notStrictEqual(_.toArray(a), a, 'array is cloned');\n    assert.deepEqual(_.toArray(a), [1, 2, 3], 'cloned array contains same elements');\n\n    var numbers = _.toArray({one: 1, two: 2, three: 3});\n    assert.deepEqual(numbers, [1, 2, 3], 'object flattened into array');\n\n    var hearts = '\\uD83D\\uDC95';\n    var pair = hearts.split('');\n    var expected = [pair[0], hearts, '&', hearts, pair[1]];\n    assert.deepEqual(_.toArray(expected.join('')), expected, 'maintains astral characters');\n    assert.deepEqual(_.toArray(''), [], 'empty string into empty array');\n\n    if (typeof document != 'undefined') {\n      // test in IE < 9\n      var actual;\n      try {\n        actual = _.toArray(document.childNodes);\n      } catch (e) { /* ignored */ }\n      assert.deepEqual(actual, _.map(document.childNodes, _.identity), 'works on NodeList');\n    }\n  });\n\n  QUnit.test('size', function(assert) {\n    assert.equal(_.size({one: 1, two: 2, three: 3}), 3, 'can compute the size of an object');\n    assert.equal(_.size([1, 2, 3]), 3, 'can compute the size of an array');\n    assert.equal(_.size({length: 3, 0: 0, 1: 0, 2: 0}), 3, 'can compute the size of Array-likes');\n\n    var func = function() {\n      return _.size(arguments);\n    };\n\n    assert.equal(func(1, 2, 3, 4), 4, 'can test the size of the arguments object');\n\n    assert.equal(_.size('hello'), 5, 'can compute the size of a string literal');\n    assert.equal(_.size(new String('hello')), 5, 'can compute the size of string object');\n\n    assert.equal(_.size(null), 0, 'handles nulls');\n    assert.equal(_.size(0), 0, 'handles numbers');\n  });\n\n  QUnit.test('partition', function(assert) {\n    var list = [0, 1, 2, 3, 4, 5];\n    assert.deepEqual(_.partition(list, function(x) { return x < 4; }), [[0, 1, 2, 3], [4, 5]], 'handles bool return values');\n    assert.deepEqual(_.partition(list, function(x) { return x & 1; }), [[1, 3, 5], [0, 2, 4]], 'handles 0 and 1 return values');\n    assert.deepEqual(_.partition(list, function(x) { return x - 3; }), [[0, 1, 2, 4, 5], [3]], 'handles other numeric return values');\n    assert.deepEqual(_.partition(list, function(x) { return x > 1 ? null : true; }), [[0, 1], [2, 3, 4, 5]], 'handles null return values');\n    assert.deepEqual(_.partition(list, function(x) { if (x < 2) return true; }), [[0, 1], [2, 3, 4, 5]], 'handles undefined return values');\n    assert.deepEqual(_.partition({a: 1, b: 2, c: 3}, function(x) { return x > 1; }), [[2, 3], [1]], 'handles objects');\n\n    assert.deepEqual(_.partition(list, function(x, index) { return index % 2; }), [[1, 3, 5], [0, 2, 4]], 'can reference the array index');\n    assert.deepEqual(_.partition(list, function(x, index, arr) { return x === arr.length - 1; }), [[5], [0, 1, 2, 3, 4]], 'can reference the collection');\n\n    // Default iterator\n    assert.deepEqual(_.partition([1, false, true, '']), [[1, true], [false, '']], 'Default iterator');\n    assert.deepEqual(_.partition([{x: 1}, {x: 0}, {x: 1}], 'x'), [[{x: 1}, {x: 1}], [{x: 0}]], 'Takes a string');\n\n    // Context\n    var predicate = function(x){ return x === this.x; };\n    assert.deepEqual(_.partition([1, 2, 3], predicate, {x: 2}), [[2], [1, 3]], 'partition takes a context argument');\n\n    assert.deepEqual(_.partition([{a: 1}, {b: 2}, {a: 1, b: 2}], {a: 1}), [[{a: 1}, {a: 1, b: 2}], [{b: 2}]], 'predicate can be object');\n\n    var object = {a: 1};\n    _.partition(object, function(val, key, obj) {\n      assert.equal(val, 1);\n      assert.equal(key, 'a');\n      assert.equal(obj, object);\n      assert.equal(this, predicate);\n    }, predicate);\n  });\n\n  if (typeof document != 'undefined') {\n    QUnit.test('Can use various collection methods on NodeLists', function(assert) {\n      var parent = document.createElement('div');\n      parent.innerHTML = '<span id=id1></span>textnode<span id=id2></span>';\n\n      var elementChildren = _.filter(parent.childNodes, _.isElement);\n      assert.equal(elementChildren.length, 2);\n\n      assert.deepEqual(_.map(elementChildren, 'id'), ['id1', 'id2']);\n      assert.deepEqual(_.map(parent.childNodes, 'nodeType'), [1, 3, 1]);\n\n      assert.notOk(_.every(parent.childNodes, _.isElement));\n      assert.ok(_.some(parent.childNodes, _.isElement));\n\n      function compareNode(node) {\n        return _.isElement(node) ? node.id.charAt(2) : void 0;\n      }\n      assert.equal(_.max(parent.childNodes, compareNode), _.last(parent.childNodes));\n      assert.equal(_.min(parent.childNodes, compareNode), _.first(parent.childNodes));\n    });\n  }\n\n}());\n",
                    language: 'javascript',
                    size: 38786,
                    tokens: 5513,
                    lastModified: '2025-07-02T12:28:22.884Z',
                  },
                  {
                    name: 'cross-document.js',
                    path: 'vendor/underscore/test/cross-document.js',
                    type: 'file',
                    content:
                      "(function() {\n  if (typeof document == 'undefined') return;\n\n  var _ = typeof require == 'function' ? require('..') : window._;\n\n  QUnit.module('Cross Document');\n  /* global iObject, iElement, iArguments, iFunction, iArray, iError, iString, iNumber, iBoolean, iDate, iRegExp, iNaN, iNull, iUndefined, ActiveXObject */\n\n  // Setup remote variables for iFrame tests.\n  var iframe = document.createElement('iframe');\n  iframe.frameBorder = iframe.height = iframe.width = 0;\n  document.body.appendChild(iframe);\n  var iDoc = (iDoc = iframe.contentDocument || iframe.contentWindow).document || iDoc;\n  iDoc.write(\n    [\n      '<script>',\n      'parent.iElement = document.createElement(\"div\");',\n      'parent.iArguments = (function(){ return arguments; })(1, 2, 3);',\n      'parent.iArray = [1, 2, 3];',\n      'parent.iString = new String(\"hello\");',\n      'parent.iNumber = new Number(100);',\n      'parent.iFunction = (function(){});',\n      'parent.iDate = new Date();',\n      'parent.iRegExp = /hi/;',\n      'parent.iNaN = NaN;',\n      'parent.iNull = null;',\n      'parent.iBoolean = new Boolean(false);',\n      'parent.iUndefined = undefined;',\n      'parent.iObject = {};',\n      'parent.iError = new Error();',\n      '</script>'\n    ].join('\\n')\n  );\n  iDoc.close();\n\n  QUnit.test('isEqual', function(assert) {\n\n    assert.notOk(_.isEqual(iNumber, 101));\n    assert.ok(_.isEqual(iNumber, 100));\n\n    // Objects from another frame.\n    assert.ok(_.isEqual({}, iObject), 'Objects with equivalent members created in different documents are equal');\n\n    // Array from another frame.\n    assert.ok(_.isEqual([1, 2, 3], iArray), 'Arrays with equivalent elements created in different documents are equal');\n  });\n\n  QUnit.test('isEmpty', function(assert) {\n    assert.notOk(_([iNumber]).isEmpty(), '[1] is not empty');\n    assert.notOk(_.isEmpty(iArray), '[] is empty');\n    assert.ok(_.isEmpty(iObject), '{} is empty');\n  });\n\n  QUnit.test('isElement', function(assert) {\n    assert.notOk(_.isElement('div'), 'strings are not dom elements');\n    assert.ok(_.isElement(document.body), 'the body tag is a DOM element');\n    assert.ok(_.isElement(iElement), 'even from another frame');\n  });\n\n  QUnit.test('isArguments', function(assert) {\n    assert.ok(_.isArguments(iArguments), 'even from another frame');\n  });\n\n  QUnit.test('isObject', function(assert) {\n    assert.ok(_.isObject(iElement), 'even from another frame');\n    assert.ok(_.isObject(iFunction), 'even from another frame');\n  });\n\n  QUnit.test('isArray', function(assert) {\n    assert.ok(_.isArray(iArray), 'even from another frame');\n  });\n\n  QUnit.test('isString', function(assert) {\n    assert.ok(_.isString(iString), 'even from another frame');\n  });\n\n  QUnit.test('isNumber', function(assert) {\n    assert.ok(_.isNumber(iNumber), 'even from another frame');\n  });\n\n  QUnit.test('isBoolean', function(assert) {\n    assert.ok(_.isBoolean(iBoolean), 'even from another frame');\n  });\n\n  QUnit.test('isFunction', function(assert) {\n    assert.ok(_.isFunction(iFunction), 'even from another frame');\n  });\n\n  QUnit.test('isDate', function(assert) {\n    assert.ok(_.isDate(iDate), 'even from another frame');\n  });\n\n  QUnit.test('isRegExp', function(assert) {\n    assert.ok(_.isRegExp(iRegExp), 'even from another frame');\n  });\n\n  QUnit.test('isNaN', function(assert) {\n    assert.ok(_.isNaN(iNaN), 'even from another frame');\n  });\n\n  QUnit.test('isNull', function(assert) {\n    assert.ok(_.isNull(iNull), 'even from another frame');\n  });\n\n  QUnit.test('isUndefined', function(assert) {\n    assert.ok(_.isUndefined(iUndefined), 'even from another frame');\n  });\n\n  QUnit.test('isError', function(assert) {\n    assert.ok(_.isError(iError), 'even from another frame');\n  });\n\n  if (typeof ActiveXObject != 'undefined') {\n    QUnit.test('IE host objects', function(assert) {\n      var xml = new ActiveXObject('Msxml2.DOMDocument.3.0');\n      assert.notOk(_.isNumber(xml));\n      assert.notOk(_.isBoolean(xml));\n      assert.notOk(_.isNaN(xml));\n      assert.notOk(_.isFunction(xml));\n      assert.notOk(_.isNull(xml));\n      assert.notOk(_.isUndefined(xml));\n    });\n\n    QUnit.test('#1621 IE 11 compat mode DOM elements are not functions', function(assert) {\n      var fn = function() {};\n      var xml = new ActiveXObject('Msxml2.DOMDocument.3.0');\n      var div = document.createElement('div');\n\n      // JIT the function\n      var count = 200;\n      while (count--) {\n        _.isFunction(fn);\n      }\n\n      assert.equal(_.isFunction(xml), false);\n      assert.equal(_.isFunction(div), false);\n      assert.equal(_.isFunction(fn), true);\n    });\n  }\n\n}());\n",
                    language: 'javascript',
                    size: 4623,
                    tokens: 549,
                    lastModified: '2025-07-02T12:28:22.885Z',
                  },
                  {
                    name: 'functions.js',
                    path: 'vendor/underscore/test/functions.js',
                    type: 'file',
                    content:
                      "(function() {\n  var _ = typeof require == 'function' ? require('..') : window._;\n\n  QUnit.module('Functions');\n  QUnit.config.asyncRetries = 3;\n\n  QUnit.test('bind', function(assert) {\n    var context = {name: 'moe'};\n    var func = function(arg) { return 'name: ' + (this.name || arg); };\n    var bound = _.bind(func, context);\n    assert.equal(bound(), 'name: moe', 'can bind a function to a context');\n\n    bound = _(func).bind(context);\n    assert.equal(bound(), 'name: moe', 'can do OO-style binding');\n\n    bound = _.bind(func, null, 'curly');\n    var result = bound();\n    // Work around a PhantomJS bug when applying a function with null|undefined.\n    assert.ok(result === 'name: curly' || result === 'name: ' + window.name, 'can bind without specifying a context');\n\n    func = function(salutation, name) { return salutation + ': ' + name; };\n    func = _.bind(func, this, 'hello');\n    assert.equal(func('moe'), 'hello: moe', 'the function was partially applied in advance');\n\n    func = _.bind(func, this, 'curly');\n    assert.equal(func(), 'hello: curly', 'the function was completely applied in advance');\n\n    func = function(salutation, firstname, lastname) { return salutation + ': ' + firstname + ' ' + lastname; };\n    func = _.bind(func, this, 'hello', 'moe', 'curly');\n    assert.equal(func(), 'hello: moe curly', 'the function was partially applied in advance and can accept multiple arguments');\n\n    func = function(ctx, message) { assert.equal(this, ctx, message); };\n    _.bind(func, 0, 0, 'can bind a function to `0`')();\n    _.bind(func, '', '', 'can bind a function to an empty string')();\n    _.bind(func, false, false, 'can bind a function to `false`')();\n\n    // These tests are only meaningful when using a browser without a native bind function\n    // To test this with a modern browser, set underscore's nativeBind to undefined\n    var F = function() { return this; };\n    var boundf = _.bind(F, {hello: 'moe curly'});\n    var Boundf = boundf; // make eslint happy.\n    var newBoundf = new Boundf();\n    assert.equal(newBoundf.hello, void 0, 'function should not be bound to the context, to comply with ECMAScript 5');\n    assert.equal(boundf().hello, 'moe curly', \"When called without the new operator, it's OK to be bound to the context\");\n    assert.ok(newBoundf instanceof F, 'a bound instance is an instance of the original function');\n\n    assert.raises(function() { _.bind('notafunction'); }, TypeError, 'throws an error when binding to a non-function');\n  });\n\n  QUnit.test('partial', function(assert) {\n    var obj = {name: 'moe'};\n    var func = function() { return this.name + ' ' + _.toArray(arguments).join(' '); };\n\n    obj.func = _.partial(func, 'a', 'b');\n    assert.equal(obj.func('c', 'd'), 'moe a b c d', 'can partially apply');\n\n    obj.func = _.partial(func, _, 'b', _, 'd');\n    assert.equal(obj.func('a', 'c'), 'moe a b c d', 'can partially apply with placeholders');\n\n    func = _.partial(function() { return arguments.length; }, _, 'b', _, 'd');\n    assert.equal(func('a', 'c', 'e'), 5, 'accepts more arguments than the number of placeholders');\n    assert.equal(func('a'), 4, 'accepts fewer arguments than the number of placeholders');\n\n    func = _.partial(function() { return typeof arguments[2]; }, _, 'b', _, 'd');\n    assert.equal(func('a'), 'undefined', 'unfilled placeholders are undefined');\n\n    // passes context\n    function MyWidget(name, options) {\n      this.name = name;\n      this.options = options;\n    }\n    MyWidget.prototype.get = function() {\n      return this.name;\n    };\n    var MyWidgetWithCoolOpts = _.partial(MyWidget, _, {a: 1});\n    var widget = new MyWidgetWithCoolOpts('foo');\n    assert.ok(widget instanceof MyWidget, 'Can partially bind a constructor');\n    assert.equal(widget.get(), 'foo', 'keeps prototype');\n    assert.deepEqual(widget.options, {a: 1});\n\n    _.partial.placeholder = obj;\n    func = _.partial(function() { return arguments.length; }, obj, 'b', obj, 'd');\n    assert.equal(func('a'), 4, 'allows the placeholder to be swapped out');\n\n    _.partial.placeholder = {};\n    func = _.partial(function() { return arguments.length; }, obj, 'b', obj, 'd');\n    assert.equal(func('a'), 5, 'swapping the placeholder preserves previously bound arguments');\n\n    _.partial.placeholder = _;\n  });\n\n  QUnit.test('bindAll', function(assert) {\n    var curly = {name: 'curly'};\n    var moe = {\n      name: 'moe',\n      getName: function() { return 'name: ' + this.name; },\n      sayHi: function() { return 'hi: ' + this.name; }\n    };\n    curly.getName = moe.getName;\n    _.bindAll(moe, 'getName', 'sayHi');\n    curly.sayHi = moe.sayHi;\n    assert.equal(curly.getName(), 'name: curly', 'unbound function is bound to current object');\n    assert.equal(curly.sayHi(), 'hi: moe', 'bound function is still bound to original object');\n\n    curly = {name: 'curly'};\n    moe = {\n      name: 'moe',\n      getName: function() { return 'name: ' + this.name; },\n      sayHi: function() { return 'hi: ' + this.name; },\n      sayLast: function() { return this.sayHi(_.last(arguments)); }\n    };\n\n    assert.raises(function() { _.bindAll(moe); }, Error, 'throws an error for bindAll with no functions named');\n    assert.raises(function() { _.bindAll(moe, 'sayBye'); }, TypeError, 'throws an error for bindAll if the given key is undefined');\n    assert.raises(function() { _.bindAll(moe, 'name'); }, TypeError, 'throws an error for bindAll if the given key is not a function');\n\n    _.bindAll(moe, 'sayHi', 'sayLast');\n    curly.sayHi = moe.sayHi;\n    assert.equal(curly.sayHi(), 'hi: moe');\n\n    var sayLast = moe.sayLast;\n    assert.equal(sayLast(1, 2, 3, 4, 5, 6, 7, 'Tom'), 'hi: moe', 'createCallback works with any number of arguments');\n\n    _.bindAll(moe, ['getName']);\n    var getName = moe.getName;\n    assert.equal(getName(), 'name: moe', 'flattens arguments into a single list');\n  });\n\n  QUnit.test('memoize', function(assert) {\n    var fib = function(n) {\n      return n < 2 ? n : fib(n - 1) + fib(n - 2);\n    };\n    assert.equal(fib(10), 55, 'a memoized version of fibonacci produces identical results');\n    fib = _.memoize(fib); // Redefine `fib` for memoization\n    assert.equal(fib(10), 55, 'a memoized version of fibonacci produces identical results');\n\n    var o = function(str) {\n      return str;\n    };\n    var fastO = _.memoize(o);\n    assert.equal(o('toString'), 'toString', 'checks hasOwnProperty');\n    assert.equal(fastO('toString'), 'toString', 'checks hasOwnProperty');\n\n    // Expose the cache.\n    var upper = _.memoize(function(s) {\n      return s.toUpperCase();\n    });\n    assert.equal(upper('foo'), 'FOO');\n    assert.equal(upper('bar'), 'BAR');\n    assert.deepEqual(upper.cache, {foo: 'FOO', bar: 'BAR'});\n    upper.cache = {foo: 'BAR', bar: 'FOO'};\n    assert.equal(upper('foo'), 'BAR');\n    assert.equal(upper('bar'), 'FOO');\n\n    var hashed = _.memoize(function(key) {\n      //https://github.com/jashkenas/underscore/pull/1679#discussion_r13736209\n      assert.ok(/[a-z]+/.test(key), 'hasher doesn\\'t change keys');\n      return key;\n    }, function(key) {\n      return key.toUpperCase();\n    });\n    hashed('yep');\n    assert.deepEqual(hashed.cache, {YEP: 'yep'}, 'takes a hasher');\n\n    // Test that the hash function can be used to swizzle the key.\n    var objCacher = _.memoize(function(value, key) {\n      return {key: key, value: value};\n    }, function(value, key) {\n      return key;\n    });\n    var myObj = objCacher('a', 'alpha');\n    var myObjAlias = objCacher('b', 'alpha');\n    assert.notStrictEqual(myObj, void 0, 'object is created if second argument used as key');\n    assert.strictEqual(myObj, myObjAlias, 'object is cached if second argument used as key');\n    assert.strictEqual(myObj.value, 'a', 'object is not modified if second argument used as key');\n  });\n\n  QUnit.test('delay', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var delayed = false;\n    _.delay(function(){ delayed = true; }, 100);\n    setTimeout(function(){ assert.notOk(delayed, \"didn't delay the function quite yet\"); }, 50);\n    setTimeout(function(){ assert.ok(delayed, 'delayed the function'); done(); }, 150);\n  });\n\n  QUnit.test('defer', function(assert) {\n    assert.expect(1);\n    var done = assert.async();\n    var deferred = false;\n    _.defer(function(bool){ deferred = bool; }, true);\n    _.delay(function(){ assert.ok(deferred, 'deferred the function'); done(); }, 50);\n  });\n\n  QUnit.test('throttle', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 32);\n    throttledIncr(); throttledIncr();\n\n    assert.equal(counter, 1, 'incr was called immediately');\n    _.delay(function(){ assert.equal(counter, 2, 'incr was throttled'); done(); }, 64);\n  });\n\n  QUnit.test('throttle arguments', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var value = 0;\n    var update = function(val){ value = val; };\n    var throttledUpdate = _.throttle(update, 32);\n    throttledUpdate(1); throttledUpdate(2);\n    _.delay(function(){ throttledUpdate(3); }, 64);\n    assert.equal(value, 1, 'updated to latest value');\n    _.delay(function(){ assert.equal(value, 3, 'updated to latest value'); done(); }, 96);\n  });\n\n  QUnit.test('throttle once', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ return ++counter; };\n    var throttledIncr = _.throttle(incr, 32);\n    var result = throttledIncr();\n    _.delay(function(){\n      assert.equal(result, 1, 'throttled functions return their value');\n      assert.equal(counter, 1, 'incr was called once'); done();\n    }, 64);\n  });\n\n  QUnit.test('throttle twice', function(assert) {\n    assert.expect(1);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 32);\n    throttledIncr(); throttledIncr();\n    _.delay(function(){ assert.equal(counter, 2, 'incr was called twice'); done(); }, 64);\n  });\n\n  QUnit.test('more throttling', function(assert) {\n    assert.expect(3);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 30);\n    throttledIncr(); throttledIncr();\n    assert.equal(counter, 1);\n    _.delay(function(){\n      assert.equal(counter, 2);\n      throttledIncr();\n      assert.equal(counter, 3);\n      done();\n    }, 85);\n  });\n\n  QUnit.test('throttle repeatedly with results', function(assert) {\n    assert.expect(6);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ return ++counter; };\n    var throttledIncr = _.throttle(incr, 100);\n    var results = [];\n    var saveResult = function() { results.push(throttledIncr()); };\n    saveResult(); saveResult();\n    _.delay(saveResult, 50);\n    _.delay(saveResult, 150);\n    _.delay(saveResult, 160);\n    _.delay(saveResult, 230);\n    _.delay(function() {\n      assert.equal(results[0], 1, 'incr was called once');\n      assert.equal(results[1], 1, 'incr was throttled');\n      assert.equal(results[2], 1, 'incr was throttled');\n      assert.equal(results[3], 2, 'incr was called twice');\n      assert.equal(results[4], 2, 'incr was throttled');\n      assert.equal(results[5], 3, 'incr was called trailing');\n      done();\n    }, 300);\n  });\n\n  QUnit.test('throttle triggers trailing call when invoked repeatedly', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var limit = 48;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 32);\n\n    var stamp = new Date;\n    while (new Date - stamp < limit) {\n      throttledIncr();\n    }\n    var lastCount = counter;\n    assert.ok(counter > 1);\n\n    _.delay(function() {\n      assert.ok(counter > lastCount);\n      done();\n    }, 96);\n  });\n\n  QUnit.test('throttle does not trigger leading call when leading is set to false', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 60, {leading: false});\n\n    throttledIncr(); throttledIncr();\n    assert.equal(counter, 0);\n\n    _.delay(function() {\n      assert.equal(counter, 1);\n      done();\n    }, 96);\n  });\n\n  QUnit.test('more throttle does not trigger leading call when leading is set to false', function(assert) {\n    assert.expect(3);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 100, {leading: false});\n\n    throttledIncr();\n    _.delay(throttledIncr, 50);\n    _.delay(throttledIncr, 60);\n    _.delay(throttledIncr, 200);\n    assert.equal(counter, 0);\n\n    _.delay(function() {\n      assert.equal(counter, 1);\n    }, 250);\n\n    _.delay(function() {\n      assert.equal(counter, 2);\n      done();\n    }, 350);\n  });\n\n  QUnit.test('one more throttle with leading: false test', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 100, {leading: false});\n\n    var time = new Date;\n    while (new Date - time < 350) throttledIncr();\n    assert.ok(counter <= 3);\n\n    _.delay(function() {\n      assert.ok(counter <= 4);\n      done();\n    }, 200);\n  });\n\n  QUnit.test('throttle does not trigger trailing call when trailing is set to false', function(assert) {\n    assert.expect(4);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 60, {trailing: false});\n\n    throttledIncr(); throttledIncr(); throttledIncr();\n    assert.equal(counter, 1);\n\n    _.delay(function() {\n      assert.equal(counter, 1);\n\n      throttledIncr(); throttledIncr();\n      assert.equal(counter, 2);\n\n      _.delay(function() {\n        assert.equal(counter, 2);\n        done();\n      }, 96);\n    }, 96);\n  });\n\n  QUnit.test('throttle continues to function after system time is set backwards', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 100);\n    var origNowFunc = _.now;\n\n    throttledIncr();\n    assert.equal(counter, 1);\n    _.now = function() {\n      return new Date(2013, 0, 1, 1, 1, 1);\n    };\n\n    _.delay(function() {\n      throttledIncr();\n      assert.equal(counter, 2);\n      done();\n      _.now = origNowFunc;\n    }, 200);\n  });\n\n  QUnit.test('throttle re-entrant', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var sequence = [\n      ['b1', 'b2'],\n      ['c1', 'c2']\n    ];\n    var value = '';\n    var throttledAppend;\n    var append = function(arg){\n      value += this + arg;\n      var args = sequence.pop();\n      if (args) {\n        throttledAppend.call(args[0], args[1]);\n      }\n    };\n    throttledAppend = _.throttle(append, 32);\n    throttledAppend.call('a1', 'a2');\n    assert.equal(value, 'a1a2');\n    _.delay(function(){\n      assert.equal(value, 'a1a2c1c2b1b2', 'append was throttled successfully');\n      done();\n    }, 100);\n  });\n\n  QUnit.test('throttle cancel', function(assert) {\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 32);\n    throttledIncr();\n    throttledIncr.cancel();\n    throttledIncr();\n    throttledIncr();\n\n    assert.equal(counter, 2, 'incr was called immediately');\n    _.delay(function(){ assert.equal(counter, 3, 'incr was throttled'); done(); }, 64);\n  });\n\n  QUnit.test('throttle cancel with leading: false', function(assert) {\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var throttledIncr = _.throttle(incr, 32, {leading: false});\n    throttledIncr();\n    throttledIncr.cancel();\n\n    assert.equal(counter, 0, 'incr was throttled');\n    _.delay(function(){ assert.equal(counter, 0, 'incr was throttled'); done(); }, 64);\n  });\n\n  QUnit.test('debounce', function(assert) {\n    assert.expect(1);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var debouncedIncr = _.debounce(incr, 32);\n    debouncedIncr(); debouncedIncr();\n    _.delay(debouncedIncr, 16);\n    _.delay(function(){ assert.equal(counter, 1, 'incr was debounced'); done(); }, 96);\n  });\n\n  QUnit.test('debounce cancel', function(assert) {\n    assert.expect(1);\n    var done = assert.async();\n    var counter = 0;\n    var incr = function(){ counter++; };\n    var debouncedIncr = _.debounce(incr, 32);\n    debouncedIncr();\n    debouncedIncr.cancel();\n    _.delay(function(){ assert.equal(counter, 0, 'incr was not called'); done(); }, 96);\n  });\n\n  QUnit.test('debounce asap', function(assert) {\n    assert.expect(6);\n    var done = assert.async();\n    var a, b, c;\n    var counter = 0;\n    var incr = function(){ return ++counter; };\n    var debouncedIncr = _.debounce(incr, 64, true);\n    a = debouncedIncr();\n    b = debouncedIncr();\n    assert.equal(a, 1);\n    assert.equal(b, 1);\n    assert.equal(counter, 1, 'incr was called immediately');\n    _.delay(debouncedIncr, 16);\n    _.delay(debouncedIncr, 32);\n    _.delay(debouncedIncr, 48);\n    _.delay(function(){\n      assert.equal(counter, 1, 'incr was debounced');\n      c = debouncedIncr();\n      assert.equal(c, 2);\n      assert.equal(counter, 2, 'incr was called again');\n      done();\n    }, 128);\n  });\n\n  QUnit.test('debounce asap cancel', function(assert) {\n    assert.expect(4);\n    var done = assert.async();\n    var a, b;\n    var counter = 0;\n    var incr = function(){ return ++counter; };\n    var debouncedIncr = _.debounce(incr, 64, true);\n    a = debouncedIncr();\n    debouncedIncr.cancel();\n    b = debouncedIncr();\n    assert.equal(a, 1);\n    assert.equal(b, 2);\n    assert.equal(counter, 2, 'incr was called immediately');\n    _.delay(debouncedIncr, 16);\n    _.delay(debouncedIncr, 32);\n    _.delay(debouncedIncr, 48);\n    _.delay(function(){ assert.equal(counter, 2, 'incr was debounced'); done(); }, 128);\n  });\n\n  QUnit.test('debounce asap recursively', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var debouncedIncr = _.debounce(function(){\n      counter++;\n      if (counter < 10) debouncedIncr();\n    }, 32, true);\n    debouncedIncr();\n    assert.equal(counter, 1, 'incr was called immediately');\n    _.delay(function(){ assert.equal(counter, 1, 'incr was debounced'); done(); }, 96);\n  });\n\n  QUnit.test('debounce after system time is set backwards', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var counter = 0;\n    var origNowFunc = _.now;\n    var debouncedIncr = _.debounce(function(){\n      counter++;\n    }, 100, true);\n\n    debouncedIncr();\n    assert.equal(counter, 1, 'incr was called immediately');\n\n    _.now = function() {\n      return new Date(2013, 0, 1, 1, 1, 1);\n    };\n\n    _.delay(function() {\n      debouncedIncr();\n      assert.equal(counter, 2, 'incr was debounced successfully');\n      done();\n      _.now = origNowFunc;\n    }, 200);\n  });\n\n  QUnit.test('debounce re-entrant', function(assert) {\n    assert.expect(2);\n    var done = assert.async();\n    var sequence = [\n      ['b1', 'b2']\n    ];\n    var value = '';\n    var debouncedAppend;\n    var append = function(arg){\n      value += this + arg;\n      var args = sequence.pop();\n      if (args) {\n        debouncedAppend.call(args[0], args[1]);\n      }\n    };\n    debouncedAppend = _.debounce(append, 32);\n    debouncedAppend.call('a1', 'a2');\n    assert.equal(value, '');\n    _.delay(function(){\n      assert.equal(value, 'a1a2b1b2', 'append was debounced successfully');\n      done();\n    }, 100);\n  });\n\n  QUnit.test('once', function(assert) {\n    var num = 0;\n    var increment = _.once(function(){ return ++num; });\n    increment();\n    increment();\n    assert.equal(num, 1);\n\n    assert.equal(increment(), 1, 'stores a memo to the last value');\n  });\n\n  QUnit.test('Recursive onced function.', function(assert) {\n    assert.expect(1);\n    var f = _.once(function(){\n      assert.ok(true);\n      f();\n    });\n    f();\n  });\n\n  QUnit.test('wrap', function(assert) {\n    var greet = function(name){ return 'hi: ' + name; };\n    var backwards = _.wrap(greet, function(func, name){ return func(name) + ' ' + name.split('').reverse().join(''); });\n    assert.equal(backwards('moe'), 'hi: moe eom', 'wrapped the salutation function');\n\n    var inner = function(){ return 'Hello '; };\n    var obj = {name: 'Moe'};\n    obj.hi = _.wrap(inner, function(fn){ return fn() + this.name; });\n    assert.equal(obj.hi(), 'Hello Moe');\n\n    var noop = function(){};\n    var wrapped = _.wrap(noop, function(){ return Array.prototype.slice.call(arguments, 0); });\n    var ret = wrapped(['whats', 'your'], 'vector', 'victor');\n    assert.deepEqual(ret, [noop, ['whats', 'your'], 'vector', 'victor']);\n  });\n\n  QUnit.test('negate', function(assert) {\n    var isOdd = function(n){ return n & 1; };\n    assert.equal(_.negate(isOdd)(2), true, 'should return the complement of the given function');\n    assert.equal(_.negate(isOdd)(3), false, 'should return the complement of the given function');\n  });\n\n  QUnit.test('compose', function(assert) {\n    var greet = function(name){ return 'hi: ' + name; };\n    var exclaim = function(sentence){ return sentence + '!'; };\n    var composed = _.compose(exclaim, greet);\n    assert.equal(composed('moe'), 'hi: moe!', 'can compose a function that takes another');\n\n    composed = _.compose(greet, exclaim);\n    assert.equal(composed('moe'), 'hi: moe!', 'in this case, the functions are also commutative');\n\n    // f(g(h(x, y, z)))\n    function h(x, y, z) {\n      assert.equal(arguments.length, 3, 'First function called with multiple args');\n      return z * y;\n    }\n    function g(x) {\n      assert.equal(arguments.length, 1, 'Composed function is called with 1 argument');\n      return x;\n    }\n    function f(x) {\n      assert.equal(arguments.length, 1, 'Composed function is called with 1 argument');\n      return x * 2;\n    }\n    composed = _.compose(f, g, h);\n    assert.equal(composed(1, 2, 3), 12);\n  });\n\n  QUnit.test('after', function(assert) {\n    var testAfter = function(afterAmount, timesCalled) {\n      var afterCalled = 0;\n      var after = _.after(afterAmount, function() {\n        afterCalled++;\n      });\n      while (timesCalled--) after();\n      return afterCalled;\n    };\n\n    assert.equal(testAfter(5, 5), 1, 'after(N) should fire after being called N times');\n    assert.equal(testAfter(5, 4), 0, 'after(N) should not fire unless called N times');\n    assert.equal(testAfter(0, 0), 0, 'after(0) should not fire immediately');\n    assert.equal(testAfter(0, 1), 1, 'after(0) should fire when first invoked');\n  });\n\n  QUnit.test('before', function(assert) {\n    var testBefore = function(beforeAmount, timesCalled) {\n      var beforeCalled = 0;\n      var before = _.before(beforeAmount, function() { beforeCalled++; });\n      while (timesCalled--) before();\n      return beforeCalled;\n    };\n\n    assert.equal(testBefore(5, 5), 4, 'before(N) should not fire after being called N times');\n    assert.equal(testBefore(5, 4), 4, 'before(N) should fire before being called N times');\n    assert.equal(testBefore(0, 0), 0, 'before(0) should not fire immediately');\n    assert.equal(testBefore(0, 1), 0, 'before(0) should not fire when first invoked');\n\n    var context = {num: 0};\n    var increment = _.before(3, function(){ return ++this.num; });\n    _.times(10, increment, context);\n    assert.equal(increment(), 2, 'stores a memo to the last value');\n    assert.equal(context.num, 2, 'provides context');\n  });\n\n  QUnit.test('iteratee', function(assert) {\n    var identity = _.iteratee();\n    assert.equal(identity, _.identity, '_.iteratee is exposed as an external function.');\n\n    function fn() {\n      return arguments;\n    }\n    _.each([_.iteratee(fn), _.iteratee(fn, {})], function(cb) {\n      assert.equal(cb().length, 0);\n      assert.deepEqual(_.toArray(cb(1, 2, 3)), _.range(1, 4));\n      assert.deepEqual(_.toArray(cb(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)), _.range(1, 11));\n    });\n\n    // Test custom iteratee\n    var builtinIteratee = _.iteratee;\n    _.iteratee = function(value) {\n      // RegEx values return a function that returns the number of matches\n      if (_.isRegExp(value)) return function(obj) {\n        return (obj.match(value) || []).length;\n      };\n      return value;\n    };\n\n    var collection = ['foo', 'bar', 'bbiz'];\n\n    // Test all methods that claim to be transformed through `_.iteratee`\n    assert.deepEqual(_.countBy(collection, /b/g), {0: 1, 1: 1, 2: 1});\n    assert.equal(_.every(collection, /b/g), false);\n    assert.deepEqual(_.filter(collection, /b/g), ['bar', 'bbiz']);\n    assert.equal(_.find(collection, /b/g), 'bar');\n    assert.equal(_.findIndex(collection, /b/g), 1);\n    assert.equal(_.findKey(collection, /b/g), 1);\n    assert.equal(_.findLastIndex(collection, /b/g), 2);\n    assert.deepEqual(_.groupBy(collection, /b/g), {0: ['foo'], 1: ['bar'], 2: ['bbiz']});\n    assert.deepEqual(_.indexBy(collection, /b/g), {0: 'foo', 1: 'bar', 2: 'bbiz'});\n    assert.deepEqual(_.map(collection, /b/g), [0, 1, 2]);\n    assert.equal(_.max(collection, /b/g), 'bbiz');\n    assert.equal(_.min(collection, /b/g), 'foo');\n    assert.deepEqual(_.partition(collection, /b/g), [['bar', 'bbiz'], ['foo']]);\n    assert.deepEqual(_.reject(collection, /b/g), ['foo']);\n    assert.equal(_.some(collection, /b/g), true);\n    assert.deepEqual(_.sortBy(collection, /b/g), ['foo', 'bar', 'bbiz']);\n    assert.equal(_.sortedIndex(collection, 'blah', /b/g), 1);\n    assert.deepEqual(_.uniq(collection, /b/g), ['foo', 'bar', 'bbiz']);\n\n    var objCollection = {a: 'foo', b: 'bar', c: 'bbiz'};\n    assert.deepEqual(_.mapObject(objCollection, /b/g), {a: 0, b: 1, c: 2});\n\n    // Restore the builtin iteratee\n    _.iteratee = builtinIteratee;\n  });\n\n  QUnit.test('restArgs', function(assert) {\n    assert.expect(10);\n    _.restArgs(function(a, args) {\n      assert.strictEqual(a, 1);\n      assert.deepEqual(args, [2, 3], 'collects rest arguments into an array');\n    })(1, 2, 3);\n\n    _.restArgs(function(a, args) {\n      assert.strictEqual(a, void 0);\n      assert.deepEqual(args, [], 'passes empty array if there are not enough arguments');\n    })();\n\n    _.restArgs(function(a, b, c, args) {\n      assert.strictEqual(arguments.length, 4);\n      assert.deepEqual(args, [4, 5], 'works on functions with many named parameters');\n    })(1, 2, 3, 4, 5);\n\n    var obj = {};\n    _.restArgs(function() {\n      assert.strictEqual(this, obj, 'invokes function with this context');\n    }).call(obj);\n\n    _.restArgs(function(array, iteratee, context) {\n      assert.deepEqual(array, [1, 2, 3, 4], 'startIndex can be used manually specify index of rest parameter');\n      assert.strictEqual(iteratee, void 0);\n      assert.strictEqual(context, void 0);\n    }, 0)(1, 2, 3, 4);\n  });\n\n}());\n",
                    language: 'javascript',
                    size: 27053,
                    tokens: 3500,
                    lastModified: '2025-07-02T12:28:22.885Z',
                  },
                  {
                    name: 'objects.js',
                    path: 'vendor/underscore/test/objects.js',
                    type: 'file',
                    content:
                      "(function() {\n  var _ = typeof require == 'function' ? require('..') : window._;\n\n  QUnit.module('Objects');\n\n  var testElement = typeof document === 'object' ? document.createElement('div') : void 0;\n\n  QUnit.test('keys', function(assert) {\n    assert.deepEqual(_.keys({one: 1, two: 2}), ['one', 'two'], 'can extract the keys from an object');\n    // the test above is not safe because it relies on for-in enumeration order\n    var a = []; a[1] = 0;\n    assert.deepEqual(_.keys(a), ['1'], 'is not fooled by sparse arrays; see issue #95');\n    assert.deepEqual(_.keys(null), []);\n    assert.deepEqual(_.keys(void 0), []);\n    assert.deepEqual(_.keys(1), []);\n    assert.deepEqual(_.keys('a'), []);\n    assert.deepEqual(_.keys(true), []);\n\n    // keys that may be missed if the implementation isn't careful\n    var trouble = {\n      constructor: Object,\n      valueOf: _.noop,\n      hasOwnProperty: null,\n      toString: 5,\n      toLocaleString: void 0,\n      propertyIsEnumerable: /a/,\n      isPrototypeOf: this,\n      __defineGetter__: Boolean,\n      __defineSetter__: {},\n      __lookupSetter__: false,\n      __lookupGetter__: []\n    };\n    var troubleKeys = ['constructor', 'valueOf', 'hasOwnProperty', 'toString', 'toLocaleString', 'propertyIsEnumerable',\n                  'isPrototypeOf', '__defineGetter__', '__defineSetter__', '__lookupSetter__', '__lookupGetter__'].sort();\n    assert.deepEqual(_.keys(trouble).sort(), troubleKeys, 'matches non-enumerable properties');\n  });\n\n  QUnit.test('allKeys', function(assert) {\n    assert.deepEqual(_.allKeys({one: 1, two: 2}), ['one', 'two'], 'can extract the allKeys from an object');\n    // the test above is not safe because it relies on for-in enumeration order\n    var a = []; a[1] = 0;\n    assert.deepEqual(_.allKeys(a), ['1'], 'is not fooled by sparse arrays; see issue #95');\n\n    a.a = a;\n    assert.deepEqual(_.allKeys(a), ['1', 'a'], 'is not fooled by sparse arrays with additional properties');\n\n    _.each([null, void 0, 1, 'a', true, NaN, {}, [], new Number(5), new Date(0)], function(val) {\n      assert.deepEqual(_.allKeys(val), []);\n    });\n\n    // allKeys that may be missed if the implementation isn't careful\n    var trouble = {\n      constructor: Object,\n      valueOf: _.noop,\n      hasOwnProperty: null,\n      toString: 5,\n      toLocaleString: void 0,\n      propertyIsEnumerable: /a/,\n      isPrototypeOf: this\n    };\n    var troubleKeys = ['constructor', 'valueOf', 'hasOwnProperty', 'toString', 'toLocaleString', 'propertyIsEnumerable',\n                  'isPrototypeOf'].sort();\n    assert.deepEqual(_.allKeys(trouble).sort(), troubleKeys, 'matches non-enumerable properties');\n\n    function A() {}\n    A.prototype.foo = 'foo';\n    var b = new A();\n    b.bar = 'bar';\n    assert.deepEqual(_.allKeys(b).sort(), ['bar', 'foo'], 'should include inherited keys');\n\n    function y() {}\n    y.x = 'z';\n    assert.deepEqual(_.allKeys(y), ['x'], 'should get keys from constructor');\n  });\n\n  QUnit.test('values', function(assert) {\n    assert.deepEqual(_.values({one: 1, two: 2}), [1, 2], 'can extract the values from an object');\n    assert.deepEqual(_.values({one: 1, two: 2, length: 3}), [1, 2, 3], '... even when one of them is \"length\"');\n  });\n\n  QUnit.test('pairs', function(assert) {\n    assert.deepEqual(_.pairs({one: 1, two: 2}), [['one', 1], ['two', 2]], 'can convert an object into pairs');\n    assert.deepEqual(_.pairs({one: 1, two: 2, length: 3}), [['one', 1], ['two', 2], ['length', 3]], '... even when one of them is \"length\"');\n  });\n\n  QUnit.test('invert', function(assert) {\n    var obj = {first: 'Moe', second: 'Larry', third: 'Curly'};\n    assert.deepEqual(_.keys(_.invert(obj)), ['Moe', 'Larry', 'Curly'], 'can invert an object');\n    assert.deepEqual(_.invert(_.invert(obj)), obj, 'two inverts gets you back where you started');\n\n    obj = {length: 3};\n    assert.equal(_.invert(obj)['3'], 'length', 'can invert an object with \"length\"');\n  });\n\n  QUnit.test('functions', function(assert) {\n    var obj = {a: 'dash', b: _.map, c: /yo/, d: _.reduce};\n    assert.deepEqual(['b', 'd'], _.functions(obj), 'can grab the function names of any passed-in object');\n\n    var Animal = function(){};\n    Animal.prototype.run = function(){};\n    assert.deepEqual(_.functions(new Animal), ['run'], 'also looks up functions on the prototype');\n  });\n\n  QUnit.test('methods', function(assert) {\n    assert.strictEqual(_.methods, _.functions, 'is an alias for functions');\n  });\n\n  QUnit.test('extend', function(assert) {\n    var result;\n    assert.equal(_.extend({}, {a: 'b'}).a, 'b', 'can extend an object with the attributes of another');\n    assert.equal(_.extend({a: 'x'}, {a: 'b'}).a, 'b', 'properties in source override destination');\n    assert.equal(_.extend({x: 'x'}, {a: 'b'}).x, 'x', \"properties not in source don't get overriden\");\n    result = _.extend({x: 'x'}, {a: 'a'}, {b: 'b'});\n    assert.deepEqual(result, {x: 'x', a: 'a', b: 'b'}, 'can extend from multiple source objects');\n    result = _.extend({x: 'x'}, {a: 'a', x: 2}, {a: 'b'});\n    assert.deepEqual(result, {x: 2, a: 'b'}, 'extending from multiple source objects last property trumps');\n    result = _.extend({}, {a: void 0, b: null});\n    assert.deepEqual(_.keys(result), ['a', 'b'], 'extend copies undefined values');\n\n    var F = function() {};\n    F.prototype = {a: 'b'};\n    var subObj = new F();\n    subObj.c = 'd';\n    assert.deepEqual(_.extend({}, subObj), {a: 'b', c: 'd'}, 'extend copies all properties from source');\n    _.extend(subObj, {});\n    assert.notOk(subObj.hasOwnProperty('a'), \"extend does not convert destination object's 'in' properties to 'own' properties\");\n\n    try {\n      result = {};\n      _.extend(result, null, void 0, {a: 1});\n    } catch (e) { /* ignored */ }\n\n    assert.equal(result.a, 1, 'should not error on `null` or `undefined` sources');\n\n    assert.strictEqual(_.extend(null, {a: 1}), null, 'extending null results in null');\n    assert.strictEqual(_.extend(void 0, {a: 1}), void 0, 'extending undefined results in undefined');\n  });\n\n  QUnit.test('extendOwn', function(assert) {\n    var result;\n    assert.equal(_.extendOwn({}, {a: 'b'}).a, 'b', 'can extend an object with the attributes of another');\n    assert.equal(_.extendOwn({a: 'x'}, {a: 'b'}).a, 'b', 'properties in source override destination');\n    assert.equal(_.extendOwn({x: 'x'}, {a: 'b'}).x, 'x', \"properties not in source don't get overriden\");\n    result = _.extendOwn({x: 'x'}, {a: 'a'}, {b: 'b'});\n    assert.deepEqual(result, {x: 'x', a: 'a', b: 'b'}, 'can extend from multiple source objects');\n    result = _.extendOwn({x: 'x'}, {a: 'a', x: 2}, {a: 'b'});\n    assert.deepEqual(result, {x: 2, a: 'b'}, 'extending from multiple source objects last property trumps');\n    assert.deepEqual(_.extendOwn({}, {a: void 0, b: null}), {a: void 0, b: null}, 'copies undefined values');\n\n    var F = function() {};\n    F.prototype = {a: 'b'};\n    var subObj = new F();\n    subObj.c = 'd';\n    assert.deepEqual(_.extendOwn({}, subObj), {c: 'd'}, 'copies own properties from source');\n\n    result = {};\n    assert.deepEqual(_.extendOwn(result, null, void 0, {a: 1}), {a: 1}, 'should not error on `null` or `undefined` sources');\n\n    _.each(['a', 5, null, false], function(val) {\n      assert.strictEqual(_.extendOwn(val, {a: 1}), val, 'extending non-objects results in returning the non-object value');\n    });\n\n    assert.strictEqual(_.extendOwn(void 0, {a: 1}), void 0, 'extending undefined results in undefined');\n\n    result = _.extendOwn({a: 1, 0: 2, 1: '5', length: 6}, {0: 1, 1: 2, length: 2});\n    assert.deepEqual(result, {a: 1, 0: 1, 1: 2, length: 2}, 'should treat array-like objects like normal objects');\n  });\n\n  QUnit.test('assign', function(assert) {\n    assert.strictEqual(_.assign, _.extendOwn, 'is an alias for extendOwn');\n  });\n\n  QUnit.test('pick', function(assert) {\n    var result;\n    result = _.pick({a: 1, b: 2, c: 3}, 'a', 'c');\n    assert.deepEqual(result, {a: 1, c: 3}, 'can restrict properties to those named');\n    result = _.pick({a: 1, b: 2, c: 3}, ['b', 'c']);\n    assert.deepEqual(result, {b: 2, c: 3}, 'can restrict properties to those named in an array');\n    result = _.pick({a: 1, b: 2, c: 3}, ['a'], 'b');\n    assert.deepEqual(result, {a: 1, b: 2}, 'can restrict properties to those named in mixed args');\n    result = _.pick(['a', 'b'], 1);\n    assert.deepEqual(result, {1: 'b'}, 'can pick numeric properties');\n\n    _.each([null, void 0], function(val) {\n      assert.deepEqual(_.pick(val, 'hasOwnProperty'), {}, 'Called with null/undefined');\n      assert.deepEqual(_.pick(val, _.constant(true)), {});\n    });\n    assert.deepEqual(_.pick(5, 'toString', 'b'), {toString: Number.prototype.toString}, 'can iterate primitives');\n\n    var data = {a: 1, b: 2, c: 3};\n    var callback = function(value, key, object) {\n      assert.strictEqual(key, {1: 'a', 2: 'b', 3: 'c'}[value]);\n      assert.strictEqual(object, data);\n      return value !== this.value;\n    };\n    result = _.pick(data, callback, {value: 2});\n    assert.deepEqual(result, {a: 1, c: 3}, 'can accept a predicate and context');\n\n    var Obj = function(){};\n    Obj.prototype = {a: 1, b: 2, c: 3};\n    var instance = new Obj();\n    assert.deepEqual(_.pick(instance, 'a', 'c'), {a: 1, c: 3}, 'include prototype props');\n\n    assert.deepEqual(_.pick(data, function(val, key) {\n      return this[key] === 3 && this === instance;\n    }, instance), {c: 3}, 'function is given context');\n\n    assert.notOk(_.has(_.pick({}, 'foo'), 'foo'), 'does not set own property if property not in object');\n    _.pick(data, function(value, key, obj) {\n      assert.equal(obj, data, 'passes same object as third parameter of iteratee');\n    });\n  });\n\n  QUnit.test('omit', function(assert) {\n    var result;\n    result = _.omit({a: 1, b: 2, c: 3}, 'b');\n    assert.deepEqual(result, {a: 1, c: 3}, 'can omit a single named property');\n    result = _.omit({a: 1, b: 2, c: 3}, 'a', 'c');\n    assert.deepEqual(result, {b: 2}, 'can omit several named properties');\n    result = _.omit({a: 1, b: 2, c: 3}, ['b', 'c']);\n    assert.deepEqual(result, {a: 1}, 'can omit properties named in an array');\n    result = _.omit(['a', 'b'], 0);\n    assert.deepEqual(result, {1: 'b'}, 'can omit numeric properties');\n\n    assert.deepEqual(_.omit(null, 'a', 'b'), {}, 'non objects return empty object');\n    assert.deepEqual(_.omit(void 0, 'toString'), {}, 'null/undefined return empty object');\n    assert.deepEqual(_.omit(5, 'toString', 'b'), {}, 'returns empty object for primitives');\n\n    var data = {a: 1, b: 2, c: 3};\n    var callback = function(value, key, object) {\n      assert.strictEqual(key, {1: 'a', 2: 'b', 3: 'c'}[value]);\n      assert.strictEqual(object, data);\n      return value !== this.value;\n    };\n    result = _.omit(data, callback, {value: 2});\n    assert.deepEqual(result, {b: 2}, 'can accept a predicate');\n\n    var Obj = function(){};\n    Obj.prototype = {a: 1, b: 2, c: 3};\n    var instance = new Obj();\n    assert.deepEqual(_.omit(instance, 'b'), {a: 1, c: 3}, 'include prototype props');\n\n    assert.deepEqual(_.omit(data, function(val, key) {\n      return this[key] === 3 && this === instance;\n    }, instance), {a: 1, b: 2}, 'function is given context');\n  });\n\n  QUnit.test('defaults', function(assert) {\n    var options = {zero: 0, one: 1, empty: '', nan: NaN, nothing: null};\n\n    _.defaults(options, {zero: 1, one: 10, twenty: 20, nothing: 'str'});\n    assert.equal(options.zero, 0, 'value exists');\n    assert.equal(options.one, 1, 'value exists');\n    assert.equal(options.twenty, 20, 'default applied');\n    assert.equal(options.nothing, null, \"null isn't overridden\");\n\n    _.defaults(options, {empty: 'full'}, {nan: 'nan'}, {word: 'word'}, {word: 'dog'});\n    assert.equal(options.empty, '', 'value exists');\n    assert.ok(_.isNaN(options.nan), \"NaN isn't overridden\");\n    assert.equal(options.word, 'word', 'new value is added, first one wins');\n\n    try {\n      options = {};\n      _.defaults(options, null, void 0, {a: 1});\n    } catch (e) { /* ignored */ }\n\n    assert.equal(options.a, 1, 'should not error on `null` or `undefined` sources');\n\n    assert.deepEqual(_.defaults(null, {a: 1}), {a: 1}, 'defaults skips nulls');\n    assert.deepEqual(_.defaults(void 0, {a: 1}), {a: 1}, 'defaults skips undefined');\n  });\n\n  QUnit.test('clone', function(assert) {\n    var moe = {name: 'moe', lucky: [13, 27, 34]};\n    var clone = _.clone(moe);\n    assert.equal(clone.name, 'moe', 'the clone as the attributes of the original');\n\n    clone.name = 'curly';\n    assert.ok(clone.name === 'curly' && moe.name === 'moe', 'clones can change shallow attributes without affecting the original');\n\n    clone.lucky.push(101);\n    assert.equal(_.last(moe.lucky), 101, 'changes to deep attributes are shared with the original');\n\n    assert.equal(_.clone(void 0), void 0, 'non objects should not be changed by clone');\n    assert.equal(_.clone(1), 1, 'non objects should not be changed by clone');\n    assert.equal(_.clone(null), null, 'non objects should not be changed by clone');\n  });\n\n  QUnit.test('create', function(assert) {\n    var Parent = function() {};\n    Parent.prototype = {foo: function() {}, bar: 2};\n\n    _.each(['foo', null, void 0, 1], function(val) {\n      assert.deepEqual(_.create(val), {}, 'should return empty object when a non-object is provided');\n    });\n\n    assert.ok(_.create([]) instanceof Array, 'should return new instance of array when array is provided');\n\n    var Child = function() {};\n    Child.prototype = _.create(Parent.prototype);\n    assert.ok(new Child instanceof Parent, 'object should inherit prototype');\n\n    var func = function() {};\n    Child.prototype = _.create(Parent.prototype, {func: func});\n    assert.strictEqual(Child.prototype.func, func, 'properties should be added to object');\n\n    Child.prototype = _.create(Parent.prototype, {constructor: Child});\n    assert.strictEqual(Child.prototype.constructor, Child);\n\n    Child.prototype.foo = 'foo';\n    var created = _.create(Child.prototype, new Child);\n    assert.notOk(created.hasOwnProperty('foo'), 'should only add own properties');\n  });\n\n  QUnit.test('isEqual', function(assert) {\n    function First() {\n      this.value = 1;\n    }\n    First.prototype.value = 1;\n    function Second() {\n      this.value = 1;\n    }\n    Second.prototype.value = 2;\n\n    // Basic equality and identity comparisons.\n    assert.ok(_.isEqual(null, null), '`null` is equal to `null`');\n    assert.ok(_.isEqual(), '`undefined` is equal to `undefined`');\n\n    assert.notOk(_.isEqual(0, -0), '`0` is not equal to `-0`');\n    assert.notOk(_.isEqual(-0, 0), 'Commutative equality is implemented for `0` and `-0`');\n    assert.notOk(_.isEqual(null, void 0), '`null` is not equal to `undefined`');\n    assert.notOk(_.isEqual(void 0, null), 'Commutative equality is implemented for `null` and `undefined`');\n\n    // String object and primitive comparisons.\n    assert.ok(_.isEqual('Curly', 'Curly'), 'Identical string primitives are equal');\n    assert.ok(_.isEqual(new String('Curly'), new String('Curly')), 'String objects with identical primitive values are equal');\n    assert.ok(_.isEqual(new String('Curly'), 'Curly'), 'String primitives and their corresponding object wrappers are equal');\n    assert.ok(_.isEqual('Curly', new String('Curly')), 'Commutative equality is implemented for string objects and primitives');\n\n    assert.notOk(_.isEqual('Curly', 'Larry'), 'String primitives with different values are not equal');\n    assert.notOk(_.isEqual(new String('Curly'), new String('Larry')), 'String objects with different primitive values are not equal');\n    assert.notOk(_.isEqual(new String('Curly'), {toString: function(){ return 'Curly'; }}), 'String objects and objects with a custom `toString` method are not equal');\n\n    // Number object and primitive comparisons.\n    assert.ok(_.isEqual(75, 75), 'Identical number primitives are equal');\n    assert.ok(_.isEqual(new Number(75), new Number(75)), 'Number objects with identical primitive values are equal');\n    assert.ok(_.isEqual(75, new Number(75)), 'Number primitives and their corresponding object wrappers are equal');\n    assert.ok(_.isEqual(new Number(75), 75), 'Commutative equality is implemented for number objects and primitives');\n    assert.notOk(_.isEqual(new Number(0), -0), '`new Number(0)` and `-0` are not equal');\n    assert.notOk(_.isEqual(0, new Number(-0)), 'Commutative equality is implemented for `new Number(0)` and `-0`');\n\n    assert.notOk(_.isEqual(new Number(75), new Number(63)), 'Number objects with different primitive values are not equal');\n    assert.notOk(_.isEqual(new Number(63), {valueOf: function(){ return 63; }}), 'Number objects and objects with a `valueOf` method are not equal');\n\n    // Comparisons involving `NaN`.\n    assert.ok(_.isEqual(NaN, NaN), '`NaN` is equal to `NaN`');\n    assert.ok(_.isEqual(new Number(NaN), NaN), 'Object(`NaN`) is equal to `NaN`');\n    assert.notOk(_.isEqual(61, NaN), 'A number primitive is not equal to `NaN`');\n    assert.notOk(_.isEqual(new Number(79), NaN), 'A number object is not equal to `NaN`');\n    assert.notOk(_.isEqual(Infinity, NaN), '`Infinity` is not equal to `NaN`');\n\n    // Boolean object and primitive comparisons.\n    assert.ok(_.isEqual(true, true), 'Identical boolean primitives are equal');\n    assert.ok(_.isEqual(new Boolean, new Boolean), 'Boolean objects with identical primitive values are equal');\n    assert.ok(_.isEqual(true, new Boolean(true)), 'Boolean primitives and their corresponding object wrappers are equal');\n    assert.ok(_.isEqual(new Boolean(true), true), 'Commutative equality is implemented for booleans');\n    assert.notOk(_.isEqual(new Boolean(true), new Boolean), 'Boolean objects with different primitive values are not equal');\n\n    // Common type coercions.\n    assert.notOk(_.isEqual(new Boolean(false), true), '`new Boolean(false)` is not equal to `true`');\n    assert.notOk(_.isEqual('75', 75), 'String and number primitives with like values are not equal');\n    assert.notOk(_.isEqual(new Number(63), new String(63)), 'String and number objects with like values are not equal');\n    assert.notOk(_.isEqual(75, '75'), 'Commutative equality is implemented for like string and number values');\n    assert.notOk(_.isEqual(0, ''), 'Number and string primitives with like values are not equal');\n    assert.notOk(_.isEqual(1, true), 'Number and boolean primitives with like values are not equal');\n    assert.notOk(_.isEqual(new Boolean(false), new Number(0)), 'Boolean and number objects with like values are not equal');\n    assert.notOk(_.isEqual(false, new String('')), 'Boolean primitives and string objects with like values are not equal');\n    assert.notOk(_.isEqual(12564504e5, new Date(2009, 9, 25)), 'Dates and their corresponding numeric primitive values are not equal');\n\n    // Dates.\n    assert.ok(_.isEqual(new Date(2009, 9, 25), new Date(2009, 9, 25)), 'Date objects referencing identical times are equal');\n    assert.notOk(_.isEqual(new Date(2009, 9, 25), new Date(2009, 11, 13)), 'Date objects referencing different times are not equal');\n    assert.notOk(_.isEqual(new Date(2009, 11, 13), {\n      getTime: function(){\n        return 12606876e5;\n      }\n    }), 'Date objects and objects with a `getTime` method are not equal');\n    assert.notOk(_.isEqual(new Date('Curly'), new Date('Curly')), 'Invalid dates are not equal');\n\n    // Functions.\n    assert.notOk(_.isEqual(First, Second), 'Different functions with identical bodies and source code representations are not equal');\n\n    // RegExps.\n    assert.ok(_.isEqual(/(?:)/gim, /(?:)/gim), 'RegExps with equivalent patterns and flags are equal');\n    assert.ok(_.isEqual(/(?:)/gi, /(?:)/ig), 'Flag order is not significant');\n    assert.notOk(_.isEqual(/(?:)/g, /(?:)/gi), 'RegExps with equivalent patterns and different flags are not equal');\n    assert.notOk(_.isEqual(/Moe/gim, /Curly/gim), 'RegExps with different patterns and equivalent flags are not equal');\n    assert.notOk(_.isEqual(/(?:)/gi, /(?:)/g), 'Commutative equality is implemented for RegExps');\n    assert.notOk(_.isEqual(/Curly/g, {source: 'Larry', global: true, ignoreCase: false, multiline: false}), 'RegExps and RegExp-like objects are not equal');\n\n    // Empty arrays, array-like objects, and object literals.\n    assert.ok(_.isEqual({}, {}), 'Empty object literals are equal');\n    assert.ok(_.isEqual([], []), 'Empty array literals are equal');\n    assert.ok(_.isEqual([{}], [{}]), 'Empty nested arrays and objects are equal');\n    assert.notOk(_.isEqual({length: 0}, []), 'Array-like objects and arrays are not equal.');\n    assert.notOk(_.isEqual([], {length: 0}), 'Commutative equality is implemented for array-like objects');\n\n    assert.notOk(_.isEqual({}, []), 'Object literals and array literals are not equal');\n    assert.notOk(_.isEqual([], {}), 'Commutative equality is implemented for objects and arrays');\n\n    // Arrays with primitive and object values.\n    assert.ok(_.isEqual([1, 'Larry', true], [1, 'Larry', true]), 'Arrays containing identical primitives are equal');\n    assert.ok(_.isEqual([/Moe/g, new Date(2009, 9, 25)], [/Moe/g, new Date(2009, 9, 25)]), 'Arrays containing equivalent elements are equal');\n\n    // Multi-dimensional arrays.\n    var a = [new Number(47), false, 'Larry', /Moe/, new Date(2009, 11, 13), ['running', 'biking', new String('programming')], {a: 47}];\n    var b = [new Number(47), false, 'Larry', /Moe/, new Date(2009, 11, 13), ['running', 'biking', new String('programming')], {a: 47}];\n    assert.ok(_.isEqual(a, b), 'Arrays containing nested arrays and objects are recursively compared');\n\n    // Overwrite the methods defined in ES 5.1 section 15.4.4.\n    a.forEach = a.map = a.filter = a.every = a.indexOf = a.lastIndexOf = a.some = a.reduce = a.reduceRight = null;\n    b.join = b.pop = b.reverse = b.shift = b.slice = b.splice = b.concat = b.sort = b.unshift = null;\n\n    // Array elements and properties.\n    assert.ok(_.isEqual(a, b), 'Arrays containing equivalent elements and different non-numeric properties are equal');\n    a.push('White Rocks');\n    assert.notOk(_.isEqual(a, b), 'Arrays of different lengths are not equal');\n    a.push('East Boulder');\n    b.push('Gunbarrel Ranch', 'Teller Farm');\n    assert.notOk(_.isEqual(a, b), 'Arrays of identical lengths containing different elements are not equal');\n\n    // Sparse arrays.\n    assert.ok(_.isEqual(Array(3), Array(3)), 'Sparse arrays of identical lengths are equal');\n    assert.notOk(_.isEqual(Array(3), Array(6)), 'Sparse arrays of different lengths are not equal when both are empty');\n\n    var sparse = [];\n    sparse[1] = 5;\n    assert.ok(_.isEqual(sparse, [void 0, 5]), 'Handles sparse arrays as dense');\n\n    // Simple objects.\n    assert.ok(_.isEqual({a: 'Curly', b: 1, c: true}, {a: 'Curly', b: 1, c: true}), 'Objects containing identical primitives are equal');\n    assert.ok(_.isEqual({a: /Curly/g, b: new Date(2009, 11, 13)}, {a: /Curly/g, b: new Date(2009, 11, 13)}), 'Objects containing equivalent members are equal');\n    assert.notOk(_.isEqual({a: 63, b: 75}, {a: 61, b: 55}), 'Objects of identical sizes with different values are not equal');\n    assert.notOk(_.isEqual({a: 63, b: 75}, {a: 61, c: 55}), 'Objects of identical sizes with different property names are not equal');\n    assert.notOk(_.isEqual({a: 1, b: 2}, {a: 1}), 'Objects of different sizes are not equal');\n    assert.notOk(_.isEqual({a: 1}, {a: 1, b: 2}), 'Commutative equality is implemented for objects');\n    assert.notOk(_.isEqual({x: 1, y: void 0}, {x: 1, z: 2}), 'Objects with identical keys and different values are not equivalent');\n\n    // `A` contains nested objects and arrays.\n    a = {\n      name: new String('Moe Howard'),\n      age: new Number(77),\n      stooge: true,\n      hobbies: ['acting'],\n      film: {\n        name: 'Sing a Song of Six Pants',\n        release: new Date(1947, 9, 30),\n        stars: [new String('Larry Fine'), 'Shemp Howard'],\n        minutes: new Number(16),\n        seconds: 54\n      }\n    };\n\n    // `B` contains equivalent nested objects and arrays.\n    b = {\n      name: new String('Moe Howard'),\n      age: new Number(77),\n      stooge: true,\n      hobbies: ['acting'],\n      film: {\n        name: 'Sing a Song of Six Pants',\n        release: new Date(1947, 9, 30),\n        stars: [new String('Larry Fine'), 'Shemp Howard'],\n        minutes: new Number(16),\n        seconds: 54\n      }\n    };\n    assert.ok(_.isEqual(a, b), 'Objects with nested equivalent members are recursively compared');\n\n    // Instances.\n    assert.ok(_.isEqual(new First, new First), 'Object instances are equal');\n    assert.notOk(_.isEqual(new First, new Second), 'Objects with different constructors and identical own properties are not equal');\n    assert.notOk(_.isEqual({value: 1}, new First), 'Object instances and objects sharing equivalent properties are not equal');\n    assert.notOk(_.isEqual({value: 2}, new Second), 'The prototype chain of objects should not be examined');\n\n    // Circular Arrays.\n    (a = []).push(a);\n    (b = []).push(b);\n    assert.ok(_.isEqual(a, b), 'Arrays containing circular references are equal');\n    a.push(new String('Larry'));\n    b.push(new String('Larry'));\n    assert.ok(_.isEqual(a, b), 'Arrays containing circular references and equivalent properties are equal');\n    a.push('Shemp');\n    b.push('Curly');\n    assert.notOk(_.isEqual(a, b), 'Arrays containing circular references and different properties are not equal');\n\n    // More circular arrays #767.\n    a = ['everything is checked but', 'this', 'is not'];\n    a[1] = a;\n    b = ['everything is checked but', ['this', 'array'], 'is not'];\n    assert.notOk(_.isEqual(a, b), 'Comparison of circular references with non-circular references are not equal');\n\n    // Circular Objects.\n    a = {abc: null};\n    b = {abc: null};\n    a.abc = a;\n    b.abc = b;\n    assert.ok(_.isEqual(a, b), 'Objects containing circular references are equal');\n    a.def = 75;\n    b.def = 75;\n    assert.ok(_.isEqual(a, b), 'Objects containing circular references and equivalent properties are equal');\n    a.def = new Number(75);\n    b.def = new Number(63);\n    assert.notOk(_.isEqual(a, b), 'Objects containing circular references and different properties are not equal');\n\n    // More circular objects #767.\n    a = {everything: 'is checked', but: 'this', is: 'not'};\n    a.but = a;\n    b = {everything: 'is checked', but: {that: 'object'}, is: 'not'};\n    assert.notOk(_.isEqual(a, b), 'Comparison of circular references with non-circular object references are not equal');\n\n    // Cyclic Structures.\n    a = [{abc: null}];\n    b = [{abc: null}];\n    (a[0].abc = a).push(a);\n    (b[0].abc = b).push(b);\n    assert.ok(_.isEqual(a, b), 'Cyclic structures are equal');\n    a[0].def = 'Larry';\n    b[0].def = 'Larry';\n    assert.ok(_.isEqual(a, b), 'Cyclic structures containing equivalent properties are equal');\n    a[0].def = new String('Larry');\n    b[0].def = new String('Curly');\n    assert.notOk(_.isEqual(a, b), 'Cyclic structures containing different properties are not equal');\n\n    // Complex Circular References.\n    a = {foo: {b: {foo: {c: {foo: null}}}}};\n    b = {foo: {b: {foo: {c: {foo: null}}}}};\n    a.foo.b.foo.c.foo = a;\n    b.foo.b.foo.c.foo = b;\n    assert.ok(_.isEqual(a, b), 'Cyclic structures with nested and identically-named properties are equal');\n\n    // Chaining.\n    assert.notOk(_.isEqual(_({x: 1, y: void 0}).chain(), _({x: 1, z: 2}).chain()), 'Chained objects containing different values are not equal');\n\n    a = _({x: 1, y: 2}).chain();\n    b = _({x: 1, y: 2}).chain();\n    assert.equal(_.isEqual(a.isEqual(b), _(true)), true, '`isEqual` can be chained');\n\n    // Objects without a `constructor` property\n    if (Object.create) {\n      a = Object.create(null, {x: {value: 1, enumerable: true}});\n      b = {x: 1};\n      assert.ok(_.isEqual(a, b), 'Handles objects without a constructor (e.g. from Object.create');\n    }\n\n    function Foo() { this.a = 1; }\n    Foo.prototype.constructor = null;\n\n    var other = {a: 1};\n    assert.strictEqual(_.isEqual(new Foo, other), false, 'Objects from different constructors are not equal');\n\n\n    // Tricky object cases val comparisions\n    assert.equal(_.isEqual([0], [-0]), false);\n    assert.equal(_.isEqual({a: 0}, {a: -0}), false);\n    assert.equal(_.isEqual([NaN], [NaN]), true);\n    assert.equal(_.isEqual({a: NaN}, {a: NaN}), true);\n\n    if (typeof Symbol !== 'undefined') {\n      var symbol = Symbol('x');\n      assert.strictEqual(_.isEqual(symbol, symbol), true, 'A symbol is equal to itself');\n      assert.strictEqual(_.isEqual(symbol, Object(symbol)), true, 'Even when wrapped in Object()');\n      assert.strictEqual(_.isEqual(symbol, null), false, 'Different types are not equal');\n    }\n\n  });\n\n  QUnit.test('isEmpty', function(assert) {\n    assert.notOk(_([1]).isEmpty(), '[1] is not empty');\n    assert.ok(_.isEmpty([]), '[] is empty');\n    assert.notOk(_.isEmpty({one: 1}), '{one: 1} is not empty');\n    assert.ok(_.isEmpty({}), '{} is empty');\n    assert.ok(_.isEmpty(new RegExp('')), 'objects with prototype properties are empty');\n    assert.ok(_.isEmpty(null), 'null is empty');\n    assert.ok(_.isEmpty(), 'undefined is empty');\n    assert.ok(_.isEmpty(''), 'the empty string is empty');\n    assert.notOk(_.isEmpty('moe'), 'but other strings are not');\n\n    var obj = {one: 1};\n    delete obj.one;\n    assert.ok(_.isEmpty(obj), 'deleting all the keys from an object empties it');\n\n    var args = function(){ return arguments; };\n    assert.ok(_.isEmpty(args()), 'empty arguments object is empty');\n    assert.notOk(_.isEmpty(args('')), 'non-empty arguments object is not empty');\n\n    // covers collecting non-enumerable properties in IE < 9\n    var nonEnumProp = {toString: 5};\n    assert.notOk(_.isEmpty(nonEnumProp), 'non-enumerable property is not empty');\n  });\n\n  if (typeof document === 'object') {\n    QUnit.test('isElement', function(assert) {\n      assert.notOk(_.isElement('div'), 'strings are not dom elements');\n      assert.ok(_.isElement(testElement), 'an element is a DOM element');\n    });\n  }\n\n  QUnit.test('isArguments', function(assert) {\n    var args = (function(){ return arguments; }(1, 2, 3));\n    assert.notOk(_.isArguments('string'), 'a string is not an arguments object');\n    assert.notOk(_.isArguments(_.isArguments), 'a function is not an arguments object');\n    assert.ok(_.isArguments(args), 'but the arguments object is an arguments object');\n    assert.notOk(_.isArguments(_.toArray(args)), 'but not when it\\'s converted into an array');\n    assert.notOk(_.isArguments([1, 2, 3]), 'and not vanilla arrays.');\n  });\n\n  QUnit.test('isObject', function(assert) {\n    assert.ok(_.isObject(arguments), 'the arguments object is object');\n    assert.ok(_.isObject([1, 2, 3]), 'and arrays');\n    if (testElement) {\n      assert.ok(_.isObject(testElement), 'and DOM element');\n    }\n    assert.ok(_.isObject(function() {}), 'and functions');\n    assert.notOk(_.isObject(null), 'but not null');\n    assert.notOk(_.isObject(void 0), 'and not undefined');\n    assert.notOk(_.isObject('string'), 'and not string');\n    assert.notOk(_.isObject(12), 'and not number');\n    assert.notOk(_.isObject(true), 'and not boolean');\n    assert.ok(_.isObject(new String('string')), 'but new String()');\n  });\n\n  QUnit.test('isArray', function(assert) {\n    assert.notOk(_.isArray(void 0), 'undefined vars are not arrays');\n    assert.notOk(_.isArray(arguments), 'the arguments object is not an array');\n    assert.ok(_.isArray([1, 2, 3]), 'but arrays are');\n  });\n\n  QUnit.test('isString', function(assert) {\n    var obj = new String('I am a string object');\n    if (testElement) {\n      assert.notOk(_.isString(testElement), 'an element is not a string');\n    }\n    assert.ok(_.isString([1, 2, 3].join(', ')), 'but strings are');\n    assert.strictEqual(_.isString('I am a string literal'), true, 'string literals are');\n    assert.ok(_.isString(obj), 'so are String objects');\n    assert.strictEqual(_.isString(1), false);\n  });\n\n  QUnit.test('isSymbol', function(assert) {\n    assert.notOk(_.isSymbol(0), 'numbers are not symbols');\n    assert.notOk(_.isSymbol(''), 'strings are not symbols');\n    assert.notOk(_.isSymbol(_.isSymbol), 'functions are not symbols');\n    if (typeof Symbol === 'function') {\n      assert.ok(_.isSymbol(Symbol()), 'symbols are symbols');\n      assert.ok(_.isSymbol(Symbol('description')), 'described symbols are symbols');\n      assert.ok(_.isSymbol(Object(Symbol())), 'boxed symbols are symbols');\n    }\n  });\n\n  QUnit.test('isNumber', function(assert) {\n    assert.notOk(_.isNumber('string'), 'a string is not a number');\n    assert.notOk(_.isNumber(arguments), 'the arguments object is not a number');\n    assert.notOk(_.isNumber(void 0), 'undefined is not a number');\n    assert.ok(_.isNumber(3 * 4 - 7 / 10), 'but numbers are');\n    assert.ok(_.isNumber(NaN), 'NaN *is* a number');\n    assert.ok(_.isNumber(Infinity), 'Infinity is a number');\n    assert.notOk(_.isNumber('1'), 'numeric strings are not numbers');\n  });\n\n  QUnit.test('isBoolean', function(assert) {\n    assert.notOk(_.isBoolean(2), 'a number is not a boolean');\n    assert.notOk(_.isBoolean('string'), 'a string is not a boolean');\n    assert.notOk(_.isBoolean('false'), 'the string \"false\" is not a boolean');\n    assert.notOk(_.isBoolean('true'), 'the string \"true\" is not a boolean');\n    assert.notOk(_.isBoolean(arguments), 'the arguments object is not a boolean');\n    assert.notOk(_.isBoolean(void 0), 'undefined is not a boolean');\n    assert.notOk(_.isBoolean(NaN), 'NaN is not a boolean');\n    assert.notOk(_.isBoolean(null), 'null is not a boolean');\n    assert.ok(_.isBoolean(true), 'but true is');\n    assert.ok(_.isBoolean(false), 'and so is false');\n  });\n\n  QUnit.test('isMap', function(assert) {\n    assert.notOk(_.isMap('string'), 'a string is not a map');\n    assert.notOk(_.isMap(2), 'a number is not a map');\n    assert.notOk(_.isMap({}), 'an object is not a map');\n    assert.notOk(_.isMap(false), 'a boolean is not a map');\n    assert.notOk(_.isMap(void 0), 'undefined is not a map');\n    assert.notOk(_.isMap([1, 2, 3]), 'an array is not a map');\n    if (typeof Set === 'function') {\n      assert.notOk(_.isMap(new Set()), 'a set is not a map');\n    }\n    if (typeof WeakSet === 'function') {\n      assert.notOk(_.isMap(new WeakSet()), 'a weakset is not a map');\n    }\n    if (typeof WeakMap === 'function') {\n      assert.notOk(_.isMap(new WeakMap()), 'a weakmap is not a map');\n    }\n    if (typeof Map === 'function') {\n      var keyString = 'a string';\n      var obj = new Map();\n      obj.set(keyString, 'value');\n      assert.ok(_.isMap(obj), 'but a map is');\n    }\n  });\n\n  QUnit.test('isWeakMap', function(assert) {\n    assert.notOk(_.isWeakMap('string'), 'a string is not a weakmap');\n    assert.notOk(_.isWeakMap(2), 'a number is not a weakmap');\n    assert.notOk(_.isWeakMap({}), 'an object is not a weakmap');\n    assert.notOk(_.isWeakMap(false), 'a boolean is not a weakmap');\n    assert.notOk(_.isWeakMap(void 0), 'undefined is not a weakmap');\n    assert.notOk(_.isWeakMap([1, 2, 3]), 'an array is not a weakmap');\n    if (typeof Set === 'function') {\n      assert.notOk(_.isWeakMap(new Set()), 'a set is not a weakmap');\n    }\n    if (typeof WeakSet === 'function') {\n      assert.notOk(_.isWeakMap(new WeakSet()), 'a weakset is not a weakmap');\n    }\n    if (typeof Map === 'function') {\n      assert.notOk(_.isWeakMap(new Map()), 'a map is not a weakmap');\n    }\n    if (typeof WeakMap === 'function') {\n      var keyObj = {}, obj = new WeakMap();\n      obj.set(keyObj, 'value');\n      assert.ok(_.isWeakMap(obj), 'but a weakmap is');\n    }\n  });\n\n  QUnit.test('isSet', function(assert) {\n    assert.notOk(_.isSet('string'), 'a string is not a set');\n    assert.notOk(_.isSet(2), 'a number is not a set');\n    assert.notOk(_.isSet({}), 'an object is not a set');\n    assert.notOk(_.isSet(false), 'a boolean is not a set');\n    assert.notOk(_.isSet(void 0), 'undefined is not a set');\n    assert.notOk(_.isSet([1, 2, 3]), 'an array is not a set');\n    if (typeof Map === 'function') {\n      assert.notOk(_.isSet(new Map()), 'a map is not a set');\n    }\n    if (typeof WeakMap === 'function') {\n      assert.notOk(_.isSet(new WeakMap()), 'a weakmap is not a set');\n    }\n    if (typeof WeakSet === 'function') {\n      assert.notOk(_.isSet(new WeakSet()), 'a weakset is not a set');\n    }\n    if (typeof Set === 'function') {\n      var obj = new Set();\n      obj.add(1).add('string').add(false).add({});\n      assert.ok(_.isSet(obj), 'but a set is');\n    }\n  });\n\n  QUnit.test('isWeakSet', function(assert) {\n\n    assert.notOk(_.isWeakSet('string'), 'a string is not a weakset');\n    assert.notOk(_.isWeakSet(2), 'a number is not a weakset');\n    assert.notOk(_.isWeakSet({}), 'an object is not a weakset');\n    assert.notOk(_.isWeakSet(false), 'a boolean is not a weakset');\n    assert.notOk(_.isWeakSet(void 0), 'undefined is not a weakset');\n    assert.notOk(_.isWeakSet([1, 2, 3]), 'an array is not a weakset');\n    if (typeof Map === 'function') {\n      assert.notOk(_.isWeakSet(new Map()), 'a map is not a weakset');\n    }\n    if (typeof WeakMap === 'function') {\n      assert.notOk(_.isWeakSet(new WeakMap()), 'a weakmap is not a weakset');\n    }\n    if (typeof Set === 'function') {\n      assert.notOk(_.isWeakSet(new Set()), 'a set is not a weakset');\n    }\n    if (typeof WeakSet === 'function') {\n      var obj = new WeakSet();\n      obj.add({x: 1}, {y: 'string'}).add({y: 'string'}).add({z: [1, 2, 3]});\n      assert.ok(_.isWeakSet(obj), 'but a weakset is');\n    }\n  });\n\n  QUnit.test('isFunction', function(assert) {\n    assert.notOk(_.isFunction(void 0), 'undefined vars are not functions');\n    assert.notOk(_.isFunction([1, 2, 3]), 'arrays are not functions');\n    assert.notOk(_.isFunction('moe'), 'strings are not functions');\n    assert.ok(_.isFunction(_.isFunction), 'but functions are');\n    assert.ok(_.isFunction(function(){}), 'even anonymous ones');\n\n    if (testElement) {\n      assert.notOk(_.isFunction(testElement), 'elements are not functions');\n    }\n\n    var nodelist = typeof document != 'undefined' && document.childNodes;\n    if (nodelist) {\n      assert.notOk(_.isFunction(nodelist));\n    }\n  });\n\n  if (typeof Int8Array !== 'undefined') {\n    QUnit.test('#1929 Typed Array constructors are functions', function(assert) {\n      _.chain(['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array'])\n      .map(_.propertyOf(typeof GLOBAL != 'undefined' ? GLOBAL : window))\n      .compact()\n      .each(function(TypedArray) {\n        // PhantomJS reports `typeof UInt8Array == 'object'` and doesn't report toString TypeArray\n        // as a function\n        assert.strictEqual(_.isFunction(TypedArray), Object.prototype.toString.call(TypedArray) === '[object Function]');\n      });\n    });\n  }\n\n  QUnit.test('isDate', function(assert) {\n    assert.notOk(_.isDate(100), 'numbers are not dates');\n    assert.notOk(_.isDate({}), 'objects are not dates');\n    assert.ok(_.isDate(new Date()), 'but dates are');\n  });\n\n  QUnit.test('isRegExp', function(assert) {\n    assert.notOk(_.isRegExp(_.identity), 'functions are not RegExps');\n    assert.ok(_.isRegExp(/identity/), 'but RegExps are');\n  });\n\n  QUnit.test('isFinite', function(assert) {\n    assert.notOk(_.isFinite(void 0), 'undefined is not finite');\n    assert.notOk(_.isFinite(null), 'null is not finite');\n    assert.notOk(_.isFinite(NaN), 'NaN is not finite');\n    assert.notOk(_.isFinite(Infinity), 'Infinity is not finite');\n    assert.notOk(_.isFinite(-Infinity), '-Infinity is not finite');\n    assert.ok(_.isFinite('12'), 'Numeric strings are numbers');\n    assert.notOk(_.isFinite('1a'), 'Non numeric strings are not numbers');\n    assert.notOk(_.isFinite(''), 'Empty strings are not numbers');\n    var obj = new Number(5);\n    assert.ok(_.isFinite(obj), 'Number instances can be finite');\n    assert.ok(_.isFinite(0), '0 is finite');\n    assert.ok(_.isFinite(123), 'Ints are finite');\n    assert.ok(_.isFinite(-12.44), 'Floats are finite');\n    if (typeof Symbol === 'function') {\n      assert.notOk(_.isFinite(Symbol()), 'symbols are not numbers');\n      assert.notOk(_.isFinite(Symbol('description')), 'described symbols are not numbers');\n      assert.notOk(_.isFinite(Object(Symbol())), 'boxed symbols are not numbers');\n    }\n  });\n\n  QUnit.test('isNaN', function(assert) {\n    assert.notOk(_.isNaN(void 0), 'undefined is not NaN');\n    assert.notOk(_.isNaN(null), 'null is not NaN');\n    assert.notOk(_.isNaN(0), '0 is not NaN');\n    assert.notOk(_.isNaN(new Number(0)), 'wrapped 0 is not NaN');\n    assert.ok(_.isNaN(NaN), 'but NaN is');\n    assert.ok(_.isNaN(new Number(NaN)), 'wrapped NaN is still NaN');\n    if (typeof Symbol !== 'undefined'){\n      assert.notOk(_.isNaN(Symbol()), 'symbol is not NaN');\n    }\n  });\n\n  QUnit.test('isNull', function(assert) {\n    assert.notOk(_.isNull(void 0), 'undefined is not null');\n    assert.notOk(_.isNull(NaN), 'NaN is not null');\n    assert.ok(_.isNull(null), 'but null is');\n  });\n\n  QUnit.test('isUndefined', function(assert) {\n    assert.notOk(_.isUndefined(1), 'numbers are defined');\n    assert.notOk(_.isUndefined(null), 'null is defined');\n    assert.notOk(_.isUndefined(false), 'false is defined');\n    assert.notOk(_.isUndefined(NaN), 'NaN is defined');\n    assert.ok(_.isUndefined(), 'nothing is undefined');\n    assert.ok(_.isUndefined(void 0), 'undefined is undefined');\n  });\n\n  QUnit.test('isError', function(assert) {\n    assert.notOk(_.isError(1), 'numbers are not Errors');\n    assert.notOk(_.isError(null), 'null is not an Error');\n    assert.notOk(_.isError(Error), 'functions are not Errors');\n    assert.ok(_.isError(new Error()), 'Errors are Errors');\n    assert.ok(_.isError(new EvalError()), 'EvalErrors are Errors');\n    assert.ok(_.isError(new RangeError()), 'RangeErrors are Errors');\n    assert.ok(_.isError(new ReferenceError()), 'ReferenceErrors are Errors');\n    assert.ok(_.isError(new SyntaxError()), 'SyntaxErrors are Errors');\n    assert.ok(_.isError(new TypeError()), 'TypeErrors are Errors');\n    assert.ok(_.isError(new URIError()), 'URIErrors are Errors');\n  });\n\n  QUnit.test('tap', function(assert) {\n    var intercepted = null;\n    var interceptor = function(obj) { intercepted = obj; };\n    var returned = _.tap(1, interceptor);\n    assert.equal(intercepted, 1, 'passes tapped object to interceptor');\n    assert.equal(returned, 1, 'returns tapped object');\n\n    returned = _([1, 2, 3]).chain().\n      map(function(n){ return n * 2; }).\n      max().\n      tap(interceptor).\n      value();\n    assert.equal(returned, 6, 'can use tapped objects in a chain');\n    assert.equal(intercepted, returned, 'can use tapped objects in a chain');\n  });\n\n  QUnit.test('has', function(assert) {\n    var obj = {foo: 'bar', func: function(){}};\n    assert.ok(_.has(obj, 'foo'), 'has() checks that the object has a property.');\n    assert.notOk(_.has(obj, 'baz'), \"has() returns false if the object doesn't have the property.\");\n    assert.ok(_.has(obj, 'func'), 'has() works for functions too.');\n    obj.hasOwnProperty = null;\n    assert.ok(_.has(obj, 'foo'), 'has() works even when the hasOwnProperty method is deleted.');\n    var child = {};\n    child.prototype = obj;\n    assert.notOk(_.has(child, 'foo'), 'has() does not check the prototype chain for a property.');\n    assert.strictEqual(_.has(null, 'foo'), false, 'has() returns false for null');\n    assert.strictEqual(_.has(void 0, 'foo'), false, 'has() returns false for undefined');\n  });\n\n  QUnit.test('isMatch', function(assert) {\n    var moe = {name: 'Moe Howard', hair: true};\n    var curly = {name: 'Curly Howard', hair: false};\n\n    assert.equal(_.isMatch(moe, {hair: true}), true, 'Returns a boolean');\n    assert.equal(_.isMatch(curly, {hair: true}), false, 'Returns a boolean');\n\n    assert.equal(_.isMatch(5, {__x__: void 0}), false, 'can match undefined props on primitives');\n    assert.equal(_.isMatch({__x__: void 0}, {__x__: void 0}), true, 'can match undefined props');\n\n    assert.equal(_.isMatch(null, {}), true, 'Empty spec called with null object returns true');\n    assert.equal(_.isMatch(null, {a: 1}), false, 'Non-empty spec called with null object returns false');\n\n    _.each([null, void 0], function(item) { assert.strictEqual(_.isMatch(item, null), true, 'null matches null'); });\n    _.each([null, void 0], function(item) { assert.strictEqual(_.isMatch(item, null), true, 'null matches {}'); });\n    assert.strictEqual(_.isMatch({b: 1}, {a: void 0}), false, 'handles undefined values (1683)');\n\n    _.each([true, 5, NaN, null, void 0], function(item) {\n      assert.strictEqual(_.isMatch({a: 1}, item), true, 'treats primitives as empty');\n    });\n\n    function Prototest() {}\n    Prototest.prototype.x = 1;\n    var specObj = new Prototest;\n    assert.equal(_.isMatch({x: 2}, specObj), true, 'spec is restricted to own properties');\n\n    specObj.y = 5;\n    assert.equal(_.isMatch({x: 1, y: 5}, specObj), true);\n    assert.equal(_.isMatch({x: 1, y: 4}, specObj), false);\n\n    assert.ok(_.isMatch(specObj, {x: 1, y: 5}), 'inherited and own properties are checked on the test object');\n\n    Prototest.x = 5;\n    assert.ok(_.isMatch({x: 5, y: 1}, Prototest), 'spec can be a function');\n\n    //null edge cases\n    var oCon = {constructor: Object};\n    assert.deepEqual(_.map([null, void 0, 5, {}], _.partial(_.isMatch, _, oCon)), [false, false, false, true], 'doesnt falsey match constructor on undefined/null');\n  });\n\n  QUnit.test('matcher', function(assert) {\n    var moe = {name: 'Moe Howard', hair: true};\n    var curly = {name: 'Curly Howard', hair: false};\n    var stooges = [moe, curly];\n\n    assert.equal(_.matcher({hair: true})(moe), true, 'Returns a boolean');\n    assert.equal(_.matcher({hair: true})(curly), false, 'Returns a boolean');\n\n    assert.equal(_.matcher({__x__: void 0})(5), false, 'can match undefined props on primitives');\n    assert.equal(_.matcher({__x__: void 0})({__x__: void 0}), true, 'can match undefined props');\n\n    assert.equal(_.matcher({})(null), true, 'Empty spec called with null object returns true');\n    assert.equal(_.matcher({a: 1})(null), false, 'Non-empty spec called with null object returns false');\n\n    assert.strictEqual(_.find(stooges, _.matcher({hair: false})), curly, 'returns a predicate that can be used by finding functions.');\n    assert.strictEqual(_.find(stooges, _.matcher(moe)), moe, 'can be used to locate an object exists in a collection.');\n    assert.deepEqual(_.filter([null, void 0], _.matcher({a: 1})), [], 'Do not throw on null values.');\n\n    assert.deepEqual(_.filter([null, void 0], _.matcher(null)), [null, void 0], 'null matches null');\n    assert.deepEqual(_.filter([null, void 0], _.matcher({})), [null, void 0], 'null matches {}');\n    assert.deepEqual(_.filter([{b: 1}], _.matcher({a: void 0})), [], 'handles undefined values (1683)');\n\n    _.each([true, 5, NaN, null, void 0], function(item) {\n      assert.equal(_.matcher(item)({a: 1}), true, 'treats primitives as empty');\n    });\n\n    function Prototest() {}\n    Prototest.prototype.x = 1;\n    var specObj = new Prototest;\n    var protospec = _.matcher(specObj);\n    assert.equal(protospec({x: 2}), true, 'spec is restricted to own properties');\n\n    specObj.y = 5;\n    protospec = _.matcher(specObj);\n    assert.equal(protospec({x: 1, y: 5}), true);\n    assert.equal(protospec({x: 1, y: 4}), false);\n\n    assert.ok(_.matcher({x: 1, y: 5})(specObj), 'inherited and own properties are checked on the test object');\n\n    Prototest.x = 5;\n    assert.ok(_.matcher(Prototest)({x: 5, y: 1}), 'spec can be a function');\n\n    // #1729\n    var o = {b: 1};\n    var m = _.matcher(o);\n\n    assert.equal(m({b: 1}), true);\n    o.b = 2;\n    o.a = 1;\n    assert.equal(m({b: 1}), true, 'changing spec object doesnt change matches result');\n\n\n    //null edge cases\n    var oCon = _.matcher({constructor: Object});\n    assert.deepEqual(_.map([null, void 0, 5, {}], oCon), [false, false, false, true], 'doesnt falsey match constructor on undefined/null');\n  });\n\n  QUnit.test('matches', function(assert) {\n    assert.strictEqual(_.matches, _.matcher, 'is an alias for matcher');\n  });\n\n  QUnit.test('findKey', function(assert) {\n    var objects = {\n      a: {a: 0, b: 0},\n      b: {a: 1, b: 1},\n      c: {a: 2, b: 2}\n    };\n\n    assert.equal(_.findKey(objects, function(obj) {\n      return obj.a === 0;\n    }), 'a');\n\n    assert.equal(_.findKey(objects, function(obj) {\n      return obj.b * obj.a === 4;\n    }), 'c');\n\n    assert.equal(_.findKey(objects, 'a'), 'b', 'Uses lookupIterator');\n\n    assert.equal(_.findKey(objects, function(obj) {\n      return obj.b * obj.a === 5;\n    }), void 0);\n\n    assert.strictEqual(_.findKey([1, 2, 3, 4, 5, 6], function(obj) {\n      return obj === 3;\n    }), '2', 'Keys are strings');\n\n    assert.strictEqual(_.findKey(objects, function(a) {\n      return a.foo === null;\n    }), void 0);\n\n    _.findKey({a: {a: 1}}, function(a, key, obj) {\n      assert.equal(key, 'a');\n      assert.deepEqual(obj, {a: {a: 1}});\n      assert.strictEqual(this, objects, 'called with context');\n    }, objects);\n\n    var array = [1, 2, 3, 4];\n    array.match = 55;\n    assert.strictEqual(_.findKey(array, function(x) { return x === 55; }), 'match', 'matches array-likes keys');\n  });\n\n\n  QUnit.test('mapObject', function(assert) {\n    var obj = {a: 1, b: 2};\n    var objects = {\n      a: {a: 0, b: 0},\n      b: {a: 1, b: 1},\n      c: {a: 2, b: 2}\n    };\n\n    assert.deepEqual(_.mapObject(obj, function(val) {\n      return val * 2;\n    }), {a: 2, b: 4}, 'simple objects');\n\n    assert.deepEqual(_.mapObject(objects, function(val) {\n      return _.reduce(val, function(memo, v){\n        return memo + v;\n      }, 0);\n    }), {a: 0, b: 2, c: 4}, 'nested objects');\n\n    assert.deepEqual(_.mapObject(obj, function(val, key, o) {\n      return o[key] * 2;\n    }), {a: 2, b: 4}, 'correct keys');\n\n    assert.deepEqual(_.mapObject([1, 2], function(val) {\n      return val * 2;\n    }), {0: 2, 1: 4}, 'check behavior for arrays');\n\n    assert.deepEqual(_.mapObject(obj, function(val) {\n      return val * this.multiplier;\n    }, {multiplier: 3}), {a: 3, b: 6}, 'keep context');\n\n    assert.deepEqual(_.mapObject({a: 1}, function() {\n      return this.length;\n    }, [1, 2]), {a: 2}, 'called with context');\n\n    var ids = _.mapObject({length: 2, 0: {id: '1'}, 1: {id: '2'}}, function(n){\n      return n.id;\n    });\n    assert.deepEqual(ids, {length: void 0, 0: '1', 1: '2'}, 'Check with array-like objects');\n\n    // Passing a property name like _.pluck.\n    var people = {a: {name: 'moe', age: 30}, b: {name: 'curly', age: 50}};\n    assert.deepEqual(_.mapObject(people, 'name'), {a: 'moe', b: 'curly'}, 'predicate string map to object properties');\n\n    _.each([null, void 0, 1, 'abc', [], {}, void 0], function(val){\n      assert.deepEqual(_.mapObject(val, _.identity), {}, 'mapValue identity');\n    });\n\n    var Proto = function(){ this.a = 1; };\n    Proto.prototype.b = 1;\n    var protoObj = new Proto();\n    assert.deepEqual(_.mapObject(protoObj, _.identity), {a: 1}, 'ignore inherited values from prototypes');\n\n  });\n}());\n",
                    language: 'javascript',
                    size: 51223,
                    tokens: 7048,
                    lastModified: '2025-07-02T12:28:22.886Z',
                  },
                  {
                    name: 'utility.js',
                    path: 'vendor/underscore/test/utility.js',
                    type: 'file',
                    content:
                      "(function() {\n  var _ = typeof require == 'function' ? require('..') : window._;\n  var templateSettings;\n\n  QUnit.module('Utility', {\n\n    beforeEach: function() {\n      templateSettings = _.clone(_.templateSettings);\n    },\n\n    afterEach: function() {\n      _.templateSettings = templateSettings;\n    }\n\n  });\n\n  if (typeof this == 'object') {\n    QUnit.test('noConflict', function(assert) {\n      var underscore = _.noConflict();\n      assert.equal(underscore.identity(1), 1);\n      if (typeof require != 'function') {\n        assert.equal(this._, void 0, 'global underscore is removed');\n        this._ = underscore;\n      } else if (typeof global !== 'undefined') {\n        delete global._;\n      }\n    });\n  }\n\n  if (typeof require == 'function') {\n    QUnit.test('noConflict (node vm)', function(assert) {\n      assert.expect(2);\n      var done = assert.async();\n      var fs = require('fs');\n      var vm = require('vm');\n      var filename = __dirname + '/../underscore.js';\n      fs.readFile(filename, function(err, content){\n        var sandbox = vm.createScript(\n          content + 'this.underscore = this._.noConflict();',\n          filename\n        );\n        var context = {_: 'oldvalue'};\n        sandbox.runInNewContext(context);\n        assert.equal(context._, 'oldvalue');\n        assert.equal(context.underscore.VERSION, _.VERSION);\n\n        done();\n      });\n    });\n  }\n\n  QUnit.test('#750 - Return _ instance.', function(assert) {\n    assert.expect(2);\n    var instance = _([]);\n    assert.strictEqual(_(instance), instance);\n    assert.strictEqual(new _(instance), instance);\n  });\n\n  QUnit.test('identity', function(assert) {\n    var stooge = {name: 'moe'};\n    assert.equal(_.identity(stooge), stooge, 'stooge is the same as his identity');\n  });\n\n  QUnit.test('constant', function(assert) {\n    var stooge = {name: 'moe'};\n    assert.equal(_.constant(stooge)(), stooge, 'should create a function that returns stooge');\n  });\n\n  QUnit.test('noop', function(assert) {\n    assert.strictEqual(_.noop('curly', 'larry', 'moe'), void 0, 'should always return undefined');\n  });\n\n  QUnit.test('property', function(assert) {\n    var stooge = {name: 'moe'};\n    assert.equal(_.property('name')(stooge), 'moe', 'should return the property with the given name');\n    assert.equal(_.property('name')(null), void 0, 'should return undefined for null values');\n    assert.equal(_.property('name')(void 0), void 0, 'should return undefined for undefined values');\n  });\n\n  QUnit.test('propertyOf', function(assert) {\n    var stoogeRanks = _.propertyOf({curly: 2, moe: 1, larry: 3});\n    assert.equal(stoogeRanks('curly'), 2, 'should return the property with the given name');\n    assert.equal(stoogeRanks(null), void 0, 'should return undefined for null values');\n    assert.equal(stoogeRanks(void 0), void 0, 'should return undefined for undefined values');\n\n    function MoreStooges() { this.shemp = 87; }\n    MoreStooges.prototype = {curly: 2, moe: 1, larry: 3};\n    var moreStoogeRanks = _.propertyOf(new MoreStooges());\n    assert.equal(moreStoogeRanks('curly'), 2, 'should return properties from further up the prototype chain');\n\n    var nullPropertyOf = _.propertyOf(null);\n    assert.equal(nullPropertyOf('curly'), void 0, 'should return undefined when obj is null');\n\n    var undefPropertyOf = _.propertyOf(void 0);\n    assert.equal(undefPropertyOf('curly'), void 0, 'should return undefined when obj is undefined');\n  });\n\n  QUnit.test('random', function(assert) {\n    var array = _.range(1000);\n    var min = Math.pow(2, 31);\n    var max = Math.pow(2, 62);\n\n    assert.ok(_.every(array, function() {\n      return _.random(min, max) >= min;\n    }), 'should produce a random number greater than or equal to the minimum number');\n\n    assert.ok(_.some(array, function() {\n      return _.random(Number.MAX_VALUE) > 0;\n    }), 'should produce a random number when passed `Number.MAX_VALUE`');\n  });\n\n  QUnit.test('now', function(assert) {\n    var diff = _.now() - new Date().getTime();\n    assert.ok(diff <= 0 && diff > -5, 'Produces the correct time in milliseconds');//within 5ms\n  });\n\n  QUnit.test('uniqueId', function(assert) {\n    var ids = [], i = 0;\n    while (i++ < 100) ids.push(_.uniqueId());\n    assert.equal(_.uniq(ids).length, ids.length, 'can generate a globally-unique stream of ids');\n  });\n\n  QUnit.test('times', function(assert) {\n    var vals = [];\n    _.times(3, function(i) { vals.push(i); });\n    assert.deepEqual(vals, [0, 1, 2], 'is 0 indexed');\n    //\n    vals = [];\n    _(3).times(function(i) { vals.push(i); });\n    assert.deepEqual(vals, [0, 1, 2], 'works as a wrapper');\n    // collects return values\n    assert.deepEqual([0, 1, 2], _.times(3, function(i) { return i; }), 'collects return values');\n\n    assert.deepEqual(_.times(0, _.identity), []);\n    assert.deepEqual(_.times(-1, _.identity), []);\n    assert.deepEqual(_.times(parseFloat('-Infinity'), _.identity), []);\n  });\n\n  QUnit.test('mixin', function(assert) {\n    var ret = _.mixin({\n      myReverse: function(string) {\n        return string.split('').reverse().join('');\n      }\n    });\n    assert.equal(ret, _, 'returns the _ object to facilitate chaining');\n    assert.equal(_.myReverse('panacea'), 'aecanap', 'mixed in a function to _');\n    assert.equal(_('champ').myReverse(), 'pmahc', 'mixed in a function to the OOP wrapper');\n  });\n\n  QUnit.test('_.escape', function(assert) {\n    assert.equal(_.escape(null), '');\n  });\n\n  QUnit.test('_.unescape', function(assert) {\n    var string = 'Curly & Moe';\n    assert.equal(_.unescape(null), '');\n    assert.equal(_.unescape(_.escape(string)), string);\n    assert.equal(_.unescape(string), string, 'don\\'t unescape unnecessarily');\n  });\n\n  // Don't care what they escape them to just that they're escaped and can be unescaped\n  QUnit.test('_.escape & unescape', function(assert) {\n    // test & (&amp;) seperately obviously\n    var escapeCharacters = ['<', '>', '\"', '\\'', '`'];\n\n    _.each(escapeCharacters, function(escapeChar) {\n      var s = 'a ' + escapeChar + ' string escaped';\n      var e = _.escape(s);\n      assert.notEqual(s, e, escapeChar + ' is escaped');\n      assert.equal(s, _.unescape(e), escapeChar + ' can be unescaped');\n\n      s = 'a ' + escapeChar + escapeChar + escapeChar + 'some more string' + escapeChar;\n      e = _.escape(s);\n\n      assert.equal(e.indexOf(escapeChar), -1, 'can escape multiple occurances of ' + escapeChar);\n      assert.equal(_.unescape(e), s, 'multiple occurrences of ' + escapeChar + ' can be unescaped');\n    });\n\n    // handles multiple escape characters at once\n    var joiner = ' other stuff ';\n    var allEscaped = escapeCharacters.join(joiner);\n    allEscaped += allEscaped;\n    assert.ok(_.every(escapeCharacters, function(escapeChar) {\n      return allEscaped.indexOf(escapeChar) !== -1;\n    }), 'handles multiple characters');\n    assert.ok(allEscaped.indexOf(joiner) >= 0, 'can escape multiple escape characters at the same time');\n\n    // test & -> &amp;\n    var str = 'some string & another string & yet another';\n    var escaped = _.escape(str);\n\n    assert.notStrictEqual(escaped.indexOf('&'), -1, 'handles & aka &amp;');\n    assert.equal(_.unescape(str), str, 'can unescape &amp;');\n  });\n\n  QUnit.test('template', function(assert) {\n    var basicTemplate = _.template(\"<%= thing %> is gettin' on my noives!\");\n    var result = basicTemplate({thing: 'This'});\n    assert.equal(result, \"This is gettin' on my noives!\", 'can do basic attribute interpolation');\n\n    var sansSemicolonTemplate = _.template('A <% this %> B');\n    assert.equal(sansSemicolonTemplate(), 'A  B');\n\n    var backslashTemplate = _.template('<%= thing %> is \\\\ridanculous');\n    assert.equal(backslashTemplate({thing: 'This'}), 'This is \\\\ridanculous');\n\n    var escapeTemplate = _.template('<%= a ? \"checked=\\\\\"checked\\\\\"\" : \"\" %>');\n    assert.equal(escapeTemplate({a: true}), 'checked=\"checked\"', 'can handle slash escapes in interpolations.');\n\n    var fancyTemplate = _.template('<ul><% ' +\n    '  for (var key in people) { ' +\n    '%><li><%= people[key] %></li><% } %></ul>');\n    result = fancyTemplate({people: {moe: 'Moe', larry: 'Larry', curly: 'Curly'}});\n    assert.equal(result, '<ul><li>Moe</li><li>Larry</li><li>Curly</li></ul>', 'can run arbitrary javascript in templates');\n\n    var escapedCharsInJavascriptTemplate = _.template('<ul><% _.each(numbers.split(\"\\\\n\"), function(item) { %><li><%= item %></li><% }) %></ul>');\n    result = escapedCharsInJavascriptTemplate({numbers: 'one\\ntwo\\nthree\\nfour'});\n    assert.equal(result, '<ul><li>one</li><li>two</li><li>three</li><li>four</li></ul>', 'Can use escaped characters (e.g. \\\\n) in JavaScript');\n\n    var namespaceCollisionTemplate = _.template('<%= pageCount %> <%= thumbnails[pageCount] %> <% _.each(thumbnails, function(p) { %><div class=\"thumbnail\" rel=\"<%= p %>\"></div><% }); %>');\n    result = namespaceCollisionTemplate({\n      pageCount: 3,\n      thumbnails: {\n        1: 'p1-thumbnail.gif',\n        2: 'p2-thumbnail.gif',\n        3: 'p3-thumbnail.gif'\n      }\n    });\n    assert.equal(result, '3 p3-thumbnail.gif <div class=\"thumbnail\" rel=\"p1-thumbnail.gif\"></div><div class=\"thumbnail\" rel=\"p2-thumbnail.gif\"></div><div class=\"thumbnail\" rel=\"p3-thumbnail.gif\"></div>');\n\n    var noInterpolateTemplate = _.template('<div><p>Just some text. Hey, I know this is silly but it aids consistency.</p></div>');\n    result = noInterpolateTemplate();\n    assert.equal(result, '<div><p>Just some text. Hey, I know this is silly but it aids consistency.</p></div>');\n\n    var quoteTemplate = _.template(\"It's its, not it's\");\n    assert.equal(quoteTemplate({}), \"It's its, not it's\");\n\n    var quoteInStatementAndBody = _.template('<% ' +\n    \"  if(foo == 'bar'){ \" +\n    \"%>Statement quotes and 'quotes'.<% } %>\");\n    assert.equal(quoteInStatementAndBody({foo: 'bar'}), \"Statement quotes and 'quotes'.\");\n\n    var withNewlinesAndTabs = _.template('This\\n\\t\\tis: <%= x %>.\\n\\tok.\\nend.');\n    assert.equal(withNewlinesAndTabs({x: 'that'}), 'This\\n\\t\\tis: that.\\n\\tok.\\nend.');\n\n    var template = _.template('<i><%- value %></i>');\n    result = template({value: '<script>'});\n    assert.equal(result, '<i>&lt;script&gt;</i>');\n\n    var stooge = {\n      name: 'Moe',\n      template: _.template(\"I'm <%= this.name %>\")\n    };\n    assert.equal(stooge.template(), \"I'm Moe\");\n\n    template = _.template('\\n ' +\n    '  <%\\n ' +\n    '  // a comment\\n ' +\n    '  if (data) { data += 12345; }; %>\\n ' +\n    '  <li><%= data %></li>\\n '\n    );\n    assert.equal(template({data: 12345}).replace(/\\s/g, ''), '<li>24690</li>');\n\n    _.templateSettings = {\n      evaluate: /\\{\\{([\\s\\S]+?)\\}\\}/g,\n      interpolate: /\\{\\{=([\\s\\S]+?)\\}\\}/g\n    };\n\n    var custom = _.template('<ul>{{ for (var key in people) { }}<li>{{= people[key] }}</li>{{ } }}</ul>');\n    result = custom({people: {moe: 'Moe', larry: 'Larry', curly: 'Curly'}});\n    assert.equal(result, '<ul><li>Moe</li><li>Larry</li><li>Curly</li></ul>', 'can run arbitrary javascript in templates');\n\n    var customQuote = _.template(\"It's its, not it's\");\n    assert.equal(customQuote({}), \"It's its, not it's\");\n\n    quoteInStatementAndBody = _.template(\"{{ if(foo == 'bar'){ }}Statement quotes and 'quotes'.{{ } }}\");\n    assert.equal(quoteInStatementAndBody({foo: 'bar'}), \"Statement quotes and 'quotes'.\");\n\n    _.templateSettings = {\n      evaluate: /<\\?([\\s\\S]+?)\\?>/g,\n      interpolate: /<\\?=([\\s\\S]+?)\\?>/g\n    };\n\n    var customWithSpecialChars = _.template('<ul><? for (var key in people) { ?><li><?= people[key] ?></li><? } ?></ul>');\n    result = customWithSpecialChars({people: {moe: 'Moe', larry: 'Larry', curly: 'Curly'}});\n    assert.equal(result, '<ul><li>Moe</li><li>Larry</li><li>Curly</li></ul>', 'can run arbitrary javascript in templates');\n\n    var customWithSpecialCharsQuote = _.template(\"It's its, not it's\");\n    assert.equal(customWithSpecialCharsQuote({}), \"It's its, not it's\");\n\n    quoteInStatementAndBody = _.template(\"<? if(foo == 'bar'){ ?>Statement quotes and 'quotes'.<? } ?>\");\n    assert.equal(quoteInStatementAndBody({foo: 'bar'}), \"Statement quotes and 'quotes'.\");\n\n    _.templateSettings = {\n      interpolate: /\\{\\{(.+?)\\}\\}/g\n    };\n\n    var mustache = _.template('Hello {{planet}}!');\n    assert.equal(mustache({planet: 'World'}), 'Hello World!', 'can mimic mustache.js');\n\n    var templateWithNull = _.template('a null undefined {{planet}}');\n    assert.equal(templateWithNull({planet: 'world'}), 'a null undefined world', 'can handle missing escape and evaluate settings');\n  });\n\n  QUnit.test('_.template provides the generated function source, when a SyntaxError occurs', function(assert) {\n    var source;\n    try {\n      _.template('<b><%= if x %></b>');\n    } catch (ex) {\n      source = ex.source;\n    }\n    assert.ok(/__p/.test(source));\n  });\n\n  QUnit.test('_.template handles \\\\u2028 & \\\\u2029', function(assert) {\n    var tmpl = _.template('<p>\\u2028<%= \"\\\\u2028\\\\u2029\" %>\\u2029</p>');\n    assert.strictEqual(tmpl(), '<p>\\u2028\\u2028\\u2029\\u2029</p>');\n  });\n\n  QUnit.test('result calls functions and returns primitives', function(assert) {\n    var obj = {w: '', x: 'x', y: function(){ return this.x; }};\n    assert.strictEqual(_.result(obj, 'w'), '');\n    assert.strictEqual(_.result(obj, 'x'), 'x');\n    assert.strictEqual(_.result(obj, 'y'), 'x');\n    assert.strictEqual(_.result(obj, 'z'), void 0);\n    assert.strictEqual(_.result(null, 'x'), void 0);\n  });\n\n  QUnit.test('result returns a default value if object is null or undefined', function(assert) {\n    assert.strictEqual(_.result(null, 'b', 'default'), 'default');\n    assert.strictEqual(_.result(void 0, 'c', 'default'), 'default');\n    assert.strictEqual(_.result(''.match('missing'), 1, 'default'), 'default');\n  });\n\n  QUnit.test('result returns a default value if property of object is missing', function(assert) {\n    assert.strictEqual(_.result({d: null}, 'd', 'default'), null);\n    assert.strictEqual(_.result({e: false}, 'e', 'default'), false);\n  });\n\n  QUnit.test('result only returns the default value if the object does not have the property or is undefined', function(assert) {\n    assert.strictEqual(_.result({}, 'b', 'default'), 'default');\n    assert.strictEqual(_.result({d: void 0}, 'd', 'default'), 'default');\n  });\n\n  QUnit.test('result does not return the default if the property of an object is found in the prototype', function(assert) {\n    var Foo = function(){};\n    Foo.prototype.bar = 1;\n    assert.strictEqual(_.result(new Foo, 'bar', 2), 1);\n  });\n\n  QUnit.test('result does use the fallback when the result of invoking the property is undefined', function(assert) {\n    var obj = {a: function() {}};\n    assert.strictEqual(_.result(obj, 'a', 'failed'), void 0);\n  });\n\n  QUnit.test('result fallback can use a function', function(assert) {\n    var obj = {a: [1, 2, 3]};\n    assert.strictEqual(_.result(obj, 'b', _.constant(5)), 5);\n    assert.strictEqual(_.result(obj, 'b', function() {\n      return this.a;\n    }), obj.a, 'called with context');\n  });\n\n  QUnit.test('_.templateSettings.variable', function(assert) {\n    var s = '<%=data.x%>';\n    var data = {x: 'x'};\n    var tmp = _.template(s, {variable: 'data'});\n    assert.strictEqual(tmp(data), 'x');\n    _.templateSettings.variable = 'data';\n    assert.strictEqual(_.template(s)(data), 'x');\n  });\n\n  QUnit.test('#547 - _.templateSettings is unchanged by custom settings.', function(assert) {\n    assert.notOk(_.templateSettings.variable);\n    _.template('', {}, {variable: 'x'});\n    assert.notOk(_.templateSettings.variable);\n  });\n\n  QUnit.test('#556 - undefined template variables.', function(assert) {\n    var template = _.template('<%=x%>');\n    assert.strictEqual(template({x: null}), '');\n    assert.strictEqual(template({x: void 0}), '');\n\n    var templateEscaped = _.template('<%-x%>');\n    assert.strictEqual(templateEscaped({x: null}), '');\n    assert.strictEqual(templateEscaped({x: void 0}), '');\n\n    var templateWithProperty = _.template('<%=x.foo%>');\n    assert.strictEqual(templateWithProperty({x: {}}), '');\n    assert.strictEqual(templateWithProperty({x: {}}), '');\n\n    var templateWithPropertyEscaped = _.template('<%-x.foo%>');\n    assert.strictEqual(templateWithPropertyEscaped({x: {}}), '');\n    assert.strictEqual(templateWithPropertyEscaped({x: {}}), '');\n  });\n\n  QUnit.test('interpolate evaluates code only once.', function(assert) {\n    assert.expect(2);\n    var count = 0;\n    var template = _.template('<%= f() %>');\n    template({f: function(){ assert.notOk(count++); }});\n\n    var countEscaped = 0;\n    var templateEscaped = _.template('<%- f() %>');\n    templateEscaped({f: function(){ assert.notOk(countEscaped++); }});\n  });\n\n  QUnit.test('#746 - _.template settings are not modified.', function(assert) {\n    assert.expect(1);\n    var settings = {};\n    _.template('', null, settings);\n    assert.deepEqual(settings, {});\n  });\n\n  QUnit.test('#779 - delimeters are applied to unescaped text.', function(assert) {\n    assert.expect(1);\n    var template = _.template('<<\\nx\\n>>', null, {evaluate: /<<(.*?)>>/g});\n    assert.strictEqual(template(), '<<\\nx\\n>>');\n  });\n\n}());\n",
                    language: 'javascript',
                    size: 17135,
                    tokens: 2159,
                    lastModified: '2025-07-02T12:28:22.886Z',
                  },
                ],
              },
              {
                name: 'underscore-min.js',
                path: 'vendor/underscore/underscore-min.js',
                type: 'file',
                content:
                  '//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n(function(){function n(n){function t(t,r,e,u,i,o){for(;i>=0&&o>i;i+=n){var a=u?u[i]:i;e=r(e,t[a],a,t)}return e}return function(r,e,u,i){e=b(e,i,4);var o=!k(r)&&m.keys(r),a=(o||r).length,c=n>0?0:a-1;return arguments.length<3&&(u=r[o?o[c]:c],c+=n),t(r,e,u,o,c,a)}}function t(n){return function(t,r,e){r=x(r,e);for(var u=O(t),i=n>0?0:u-1;i>=0&&u>i;i+=n)if(r(t[i],i,t))return i;return-1}}function r(n,t,r){return function(e,u,i){var o=0,a=O(e);if("number"==typeof i)n>0?o=i>=0?i:Math.max(i+a,o):a=i>=0?Math.min(i+1,a):i+a+1;else if(r&&i&&a)return i=r(e,u),e[i]===u?i:-1;if(u!==u)return i=t(l.call(e,o,a),m.isNaN),i>=0?i+o:-1;for(i=n>0?o:a-1;i>=0&&a>i;i+=n)if(e[i]===u)return i;return-1}}function e(n,t){var r=I.length,e=n.constructor,u=m.isFunction(e)&&e.prototype||a,i="constructor";for(m.has(n,i)&&!m.contains(t,i)&&t.push(i);r--;)i=I[r],i in n&&n[i]!==u[i]&&!m.contains(t,i)&&t.push(i)}var u=this,i=u._,o=Array.prototype,a=Object.prototype,c=Function.prototype,f=o.push,l=o.slice,s=a.toString,p=a.hasOwnProperty,h=Array.isArray,v=Object.keys,g=c.bind,y=Object.create,d=function(){},m=function(n){return n instanceof m?n:this instanceof m?void(this._wrapped=n):new m(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=m),exports._=m):u._=m,m.VERSION="1.8.3";var b=function(n,t,r){if(t===void 0)return n;switch(null==r?3:r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)}}return function(){return n.apply(t,arguments)}},x=function(n,t,r){return null==n?m.identity:m.isFunction(n)?b(n,t,r):m.isObject(n)?m.matcher(n):m.property(n)};m.iteratee=function(n,t){return x(n,t,1/0)};var _=function(n,t){return function(r){var e=arguments.length;if(2>e||null==r)return r;for(var u=1;e>u;u++)for(var i=arguments[u],o=n(i),a=o.length,c=0;a>c;c++){var f=o[c];t&&r[f]!==void 0||(r[f]=i[f])}return r}},j=function(n){if(!m.isObject(n))return{};if(y)return y(n);d.prototype=n;var t=new d;return d.prototype=null,t},w=function(n){return function(t){return null==t?void 0:t[n]}},A=Math.pow(2,53)-1,O=w("length"),k=function(n){var t=O(n);return"number"==typeof t&&t>=0&&A>=t};m.each=m.forEach=function(n,t,r){t=b(t,r);var e,u;if(k(n))for(e=0,u=n.length;u>e;e++)t(n[e],e,n);else{var i=m.keys(n);for(e=0,u=i.length;u>e;e++)t(n[i[e]],i[e],n)}return n},m.map=m.collect=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=Array(u),o=0;u>o;o++){var a=e?e[o]:o;i[o]=t(n[a],a,n)}return i},m.reduce=m.foldl=m.inject=n(1),m.reduceRight=m.foldr=n(-1),m.find=m.detect=function(n,t,r){var e;return e=k(n)?m.findIndex(n,t,r):m.findKey(n,t,r),e!==void 0&&e!==-1?n[e]:void 0},m.filter=m.select=function(n,t,r){var e=[];return t=x(t,r),m.each(n,function(n,r,u){t(n,r,u)&&e.push(n)}),e},m.reject=function(n,t,r){return m.filter(n,m.negate(x(t)),r)},m.every=m.all=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(!t(n[o],o,n))return!1}return!0},m.some=m.any=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(t(n[o],o,n))return!0}return!1},m.contains=m.includes=m.include=function(n,t,r,e){return k(n)||(n=m.values(n)),("number"!=typeof r||e)&&(r=0),m.indexOf(n,t,r)>=0},m.invoke=function(n,t){var r=l.call(arguments,2),e=m.isFunction(t);return m.map(n,function(n){var u=e?t:n[t];return null==u?u:u.apply(n,r)})},m.pluck=function(n,t){return m.map(n,m.property(t))},m.where=function(n,t){return m.filter(n,m.matcher(t))},m.findWhere=function(n,t){return m.find(n,m.matcher(t))},m.max=function(n,t,r){var e,u,i=-1/0,o=-1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],e>i&&(i=e)}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(u>o||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},m.min=function(n,t,r){var e,u,i=1/0,o=1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],i>e&&(i=e)}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(o>u||1/0===u&&1/0===i)&&(i=n,o=u)});return i},m.shuffle=function(n){for(var t,r=k(n)?n:m.values(n),e=r.length,u=Array(e),i=0;e>i;i++)t=m.random(0,i),t!==i&&(u[i]=u[t]),u[t]=r[i];return u},m.sample=function(n,t,r){return null==t||r?(k(n)||(n=m.values(n)),n[m.random(n.length-1)]):m.shuffle(n).slice(0,Math.max(0,t))},m.sortBy=function(n,t,r){return t=x(t,r),m.pluck(m.map(n,function(n,r,e){return{value:n,index:r,criteria:t(n,r,e)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={};return r=x(r,e),m.each(t,function(e,i){var o=r(e,i,t);n(u,e,o)}),u}};m.groupBy=F(function(n,t,r){m.has(n,r)?n[r].push(t):n[r]=[t]}),m.indexBy=F(function(n,t,r){n[r]=t}),m.countBy=F(function(n,t,r){m.has(n,r)?n[r]++:n[r]=1}),m.toArray=function(n){return n?m.isArray(n)?l.call(n):k(n)?m.map(n,m.identity):m.values(n):[]},m.size=function(n){return null==n?0:k(n)?n.length:m.keys(n).length},m.partition=function(n,t,r){t=x(t,r);var e=[],u=[];return m.each(n,function(n,r,i){(t(n,r,i)?e:u).push(n)}),[e,u]},m.first=m.head=m.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:m.initial(n,n.length-t)},m.initial=function(n,t,r){return l.call(n,0,Math.max(0,n.length-(null==t||r?1:t)))},m.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:m.rest(n,Math.max(0,n.length-t))},m.rest=m.tail=m.drop=function(n,t,r){return l.call(n,null==t||r?1:t)},m.compact=function(n){return m.filter(n,m.identity)};var S=function(n,t,r,e){for(var u=[],i=0,o=e||0,a=O(n);a>o;o++){var c=n[o];if(k(c)&&(m.isArray(c)||m.isArguments(c))){t||(c=S(c,t,r));var f=0,l=c.length;for(u.length+=l;l>f;)u[i++]=c[f++]}else r||(u[i++]=c)}return u};m.flatten=function(n,t){return S(n,t,!1)},m.without=function(n){return m.difference(n,l.call(arguments,1))},m.uniq=m.unique=function(n,t,r,e){m.isBoolean(t)||(e=r,r=t,t=!1),null!=r&&(r=x(r,e));for(var u=[],i=[],o=0,a=O(n);a>o;o++){var c=n[o],f=r?r(c,o,n):c;t?(o&&i===f||u.push(c),i=f):r?m.contains(i,f)||(i.push(f),u.push(c)):m.contains(u,c)||u.push(c)}return u},m.union=function(){return m.uniq(S(arguments,!0,!0))},m.intersection=function(n){for(var t=[],r=arguments.length,e=0,u=O(n);u>e;e++){var i=n[e];if(!m.contains(t,i)){for(var o=1;r>o&&m.contains(arguments[o],i);o++);o===r&&t.push(i)}}return t},m.difference=function(n){var t=S(arguments,!0,!0,1);return m.filter(n,function(n){return!m.contains(t,n)})},m.zip=function(){return m.unzip(arguments)},m.unzip=function(n){for(var t=n&&m.max(n,O).length||0,r=Array(t),e=0;t>e;e++)r[e]=m.pluck(n,e);return r},m.object=function(n,t){for(var r={},e=0,u=O(n);u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},m.findIndex=t(1),m.findLastIndex=t(-1),m.sortedIndex=function(n,t,r,e){r=x(r,e,1);for(var u=r(t),i=0,o=O(n);o>i;){var a=Math.floor((i+o)/2);r(n[a])<u?i=a+1:o=a}return i},m.indexOf=r(1,m.findIndex,m.sortedIndex),m.lastIndexOf=r(-1,m.findLastIndex),m.range=function(n,t,r){null==t&&(t=n||0,n=0),r=r||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=Array(e),i=0;e>i;i++,n+=r)u[i]=n;return u};var E=function(n,t,r,e,u){if(!(e instanceof t))return n.apply(r,u);var i=j(n.prototype),o=n.apply(i,u);return m.isObject(o)?o:i};m.bind=function(n,t){if(g&&n.bind===g)return g.apply(n,l.call(arguments,1));if(!m.isFunction(n))throw new TypeError("Bind must be called on a function");var r=l.call(arguments,2),e=function(){return E(n,e,t,this,r.concat(l.call(arguments)))};return e},m.partial=function(n){var t=l.call(arguments,1),r=function(){for(var e=0,u=t.length,i=Array(u),o=0;u>o;o++)i[o]=t[o]===m?arguments[e++]:t[o];for(;e<arguments.length;)i.push(arguments[e++]);return E(n,r,this,this,i)};return r},m.bindAll=function(n){var t,r,e=arguments.length;if(1>=e)throw new Error("bindAll must be passed function names");for(t=1;e>t;t++)r=arguments[t],n[r]=m.bind(n[r],n);return n},m.memoize=function(n,t){var r=function(e){var u=r.cache,i=""+(t?t.apply(this,arguments):e);return m.has(u,i)||(u[i]=n.apply(this,arguments)),u[i]};return r.cache={},r},m.delay=function(n,t){var r=l.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},m.defer=m.partial(m.delay,m,1),m.throttle=function(n,t,r){var e,u,i,o=null,a=0;r||(r={});var c=function(){a=r.leading===!1?0:m.now(),o=null,i=n.apply(e,u),o||(e=u=null)};return function(){var f=m.now();a||r.leading!==!1||(a=f);var l=t-(f-a);return e=this,u=arguments,0>=l||l>t?(o&&(clearTimeout(o),o=null),a=f,i=n.apply(e,u),o||(e=u=null)):o||r.trailing===!1||(o=setTimeout(c,l)),i}},m.debounce=function(n,t,r){var e,u,i,o,a,c=function(){var f=m.now()-o;t>f&&f>=0?e=setTimeout(c,t-f):(e=null,r||(a=n.apply(i,u),e||(i=u=null)))};return function(){i=this,u=arguments,o=m.now();var f=r&&!e;return e||(e=setTimeout(c,t)),f&&(a=n.apply(i,u),i=u=null),a}},m.wrap=function(n,t){return m.partial(t,n)},m.negate=function(n){return function(){return!n.apply(this,arguments)}},m.compose=function(){var n=arguments,t=n.length-1;return function(){for(var r=t,e=n[t].apply(this,arguments);r--;)e=n[r].call(this,e);return e}},m.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},m.before=function(n,t){var r;return function(){return--n>0&&(r=t.apply(this,arguments)),1>=n&&(t=null),r}},m.once=m.partial(m.before,2);var M=!{toString:null}.propertyIsEnumerable("toString"),I=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"];m.keys=function(n){if(!m.isObject(n))return[];if(v)return v(n);var t=[];for(var r in n)m.has(n,r)&&t.push(r);return M&&e(n,t),t},m.allKeys=function(n){if(!m.isObject(n))return[];var t=[];for(var r in n)t.push(r);return M&&e(n,t),t},m.values=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},m.mapObject=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=u.length,o={},a=0;i>a;a++)e=u[a],o[e]=t(n[e],e,n);return o},m.pairs=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},m.invert=function(n){for(var t={},r=m.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},m.functions=m.methods=function(n){var t=[];for(var r in n)m.isFunction(n[r])&&t.push(r);return t.sort()},m.extend=_(m.allKeys),m.extendOwn=m.assign=_(m.keys),m.findKey=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=0,o=u.length;o>i;i++)if(e=u[i],t(n[e],e,n))return e},m.pick=function(n,t,r){var e,u,i={},o=n;if(null==o)return i;m.isFunction(t)?(u=m.allKeys(o),e=b(t,r)):(u=S(arguments,!1,!1,1),e=function(n,t,r){return t in r},o=Object(o));for(var a=0,c=u.length;c>a;a++){var f=u[a],l=o[f];e(l,f,o)&&(i[f]=l)}return i},m.omit=function(n,t,r){if(m.isFunction(t))t=m.negate(t);else{var e=m.map(S(arguments,!1,!1,1),String);t=function(n,t){return!m.contains(e,t)}}return m.pick(n,t,r)},m.defaults=_(m.allKeys,!0),m.create=function(n,t){var r=j(n);return t&&m.extendOwn(r,t),r},m.clone=function(n){return m.isObject(n)?m.isArray(n)?n.slice():m.extend({},n):n},m.tap=function(n,t){return t(n),n},m.isMatch=function(n,t){var r=m.keys(t),e=r.length;if(null==n)return!e;for(var u=Object(n),i=0;e>i;i++){var o=r[i];if(t[o]!==u[o]||!(o in u))return!1}return!0};var N=function(n,t,r,e){if(n===t)return 0!==n||1/n===1/t;if(null==n||null==t)return n===t;n instanceof m&&(n=n._wrapped),t instanceof m&&(t=t._wrapped);var u=s.call(n);if(u!==s.call(t))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+t;case"[object Number]":return+n!==+n?+t!==+t:0===+n?1/+n===1/t:+n===+t;case"[object Date]":case"[object Boolean]":return+n===+t}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof t)return!1;var o=n.constructor,a=t.constructor;if(o!==a&&!(m.isFunction(o)&&o instanceof o&&m.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in t)return!1}r=r||[],e=e||[];for(var c=r.length;c--;)if(r[c]===n)return e[c]===t;if(r.push(n),e.push(t),i){if(c=n.length,c!==t.length)return!1;for(;c--;)if(!N(n[c],t[c],r,e))return!1}else{var f,l=m.keys(n);if(c=l.length,m.keys(t).length!==c)return!1;for(;c--;)if(f=l[c],!m.has(t,f)||!N(n[f],t[f],r,e))return!1}return r.pop(),e.pop(),!0};m.isEqual=function(n,t){return N(n,t)},m.isEmpty=function(n){return null==n?!0:k(n)&&(m.isArray(n)||m.isString(n)||m.isArguments(n))?0===n.length:0===m.keys(n).length},m.isElement=function(n){return!(!n||1!==n.nodeType)},m.isArray=h||function(n){return"[object Array]"===s.call(n)},m.isObject=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},m.each(["Arguments","Function","String","Number","Date","RegExp","Error"],function(n){m["is"+n]=function(t){return s.call(t)==="[object "+n+"]"}}),m.isArguments(arguments)||(m.isArguments=function(n){return m.has(n,"callee")}),"function"!=typeof/./&&"object"!=typeof Int8Array&&(m.isFunction=function(n){return"function"==typeof n||!1}),m.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},m.isNaN=function(n){return m.isNumber(n)&&n!==+n},m.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"===s.call(n)},m.isNull=function(n){return null===n},m.isUndefined=function(n){return n===void 0},m.has=function(n,t){return null!=n&&p.call(n,t)},m.noConflict=function(){return u._=i,this},m.identity=function(n){return n},m.constant=function(n){return function(){return n}},m.noop=function(){},m.property=w,m.propertyOf=function(n){return null==n?function(){}:function(t){return n[t]}},m.matcher=m.matches=function(n){return n=m.extendOwn({},n),function(t){return m.isMatch(t,n)}},m.times=function(n,t,r){var e=Array(Math.max(0,n));t=b(t,r,1);for(var u=0;n>u;u++)e[u]=t(u);return e},m.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},m.now=Date.now||function(){return(new Date).getTime()};var B={"&":"&amp;","<":"&lt;",">":"&gt;",\'"\':"&quot;","\'":"&#x27;","`":"&#x60;"},T=m.invert(B),R=function(n){var t=function(t){return n[t]},r="(?:"+m.keys(n).join("|")+")",e=RegExp(r),u=RegExp(r,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};m.escape=R(B),m.unescape=R(T),m.result=function(n,t,r){var e=null==n?void 0:n[t];return e===void 0&&(e=r),m.isFunction(e)?e.call(n):e};var q=0;m.uniqueId=function(n){var t=++q+"";return n?n+t:t},m.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var K=/(.)^/,z={"\'":"\'","\\\\":"\\\\","\\r":"r","\\n":"n","\\u2028":"u2028","\\u2029":"u2029"},D=/\\\\|\'|\\r|\\n|\\u2028|\\u2029/g,L=function(n){return"\\\\"+z[n]};m.template=function(n,t,r){!t&&r&&(t=r),t=m.defaults({},t,m.templateSettings);var e=RegExp([(t.escape||K).source,(t.interpolate||K).source,(t.evaluate||K).source].join("|")+"|$","g"),u=0,i="__p+=\'";n.replace(e,function(t,r,e,o,a){return i+=n.slice(u,a).replace(D,L),u=a+t.length,r?i+="\'+\\n((__t=("+r+"))==null?\'\':_.escape(__t))+\\n\'":e?i+="\'+\\n((__t=("+e+"))==null?\'\':__t)+\\n\'":o&&(i+="\';\\n"+o+"\\n__p+=\'"),t}),i+="\';\\n",t.variable||(i="with(obj||{}){\\n"+i+"}\\n"),i="var __t,__p=\'\',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,\'\');};\\n"+i+"return __p;\\n";try{var o=new Function(t.variable||"obj","_",i)}catch(a){throw a.source=i,a}var c=function(n){return o.call(this,n,m)},f=t.variable||"obj";return c.source="function("+f+"){\\n"+i+"}",c},m.chain=function(n){var t=m(n);return t._chain=!0,t};var P=function(n,t){return n._chain?m(t).chain():t};m.mixin=function(n){m.each(m.functions(n),function(t){var r=m[t]=n[t];m.prototype[t]=function(){var n=[this._wrapped];return f.apply(n,arguments),P(this,r.apply(m,n))}})},m.mixin(m),m.each(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=o[n];m.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!==n&&"splice"!==n||0!==r.length||delete r[0],P(this,r)}}),m.each(["concat","join","slice"],function(n){var t=o[n];m.prototype[n]=function(){return P(this,t.apply(this._wrapped,arguments))}}),m.prototype.value=function(){return this._wrapped},m.prototype.valueOf=m.prototype.toJSON=m.prototype.value,m.prototype.toString=function(){return""+this._wrapped},"function"==typeof define&&define.amd&&define("underscore",[],function(){return m})}).call(this);\n//# sourceMappingURL=underscore-min.map',
                language: 'javascript',
                size: 16449,
                tokens: 3332,
                lastModified: '2025-07-02T12:28:22.886Z',
              },
              {
                name: 'underscore.js',
                path: 'vendor/underscore/underscore.js',
                type: 'file',
                content:
                  "//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-parameter case has been omitted only because no current consumers\n      // made use of it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n  // This accumulates the arguments passed into an array, after a given index.\n  var restArgs = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0);\n      var rest = Array(length);\n      for (var index = 0; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArgs(function(obj, method, args) {\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function(obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null || array.length < 1) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null || array.length < 1) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArgs(function(array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArgs(function(arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArgs(function(array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArgs(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Split an **array** into several arrays containing **count** or less elements\n  // of initial array.\n  _.chunk = function(array, count) {\n    if (count == null || count < 1) return [];\n\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArgs(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArgs(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArgs(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArgs(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArgs(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArgs(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArgs = restArgs;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArgs(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArgs(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, prop, fallback) {\n    var value = object == null ? void 0 : object[prop];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define == 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}());\n",
                language: 'javascript',
                size: 56125,
                tokens: 7685,
                lastModified: '2025-07-02T12:28:22.887Z',
              },
            ],
          },
        ],
      },
      {
        name: '.jscsrc',
        path: '.jscsrc',
        type: 'file',
        content:
          '{\n  "maxErrors": "2000",\n  "maximumLineLength": {\n    "value": 180,\n    "allExcept": ["comments", "functionSignature", "regex"]\n  },\n  "requireCurlyBraces": [\n    "if",\n    "else",\n    "for",\n    "while",\n    "do",\n    "try",\n    "catch"\n  ],\n  "requireOperatorBeforeLineBreak": [\n    "=",\n    "+",\n    "-",\n    "/",\n    "*",\n    "==",\n    "===",\n    "!=",\n    "!==",\n    ">",\n    ">=",\n    "<",\n    "<="\n  ],\n  "requireSpaceAfterKeywords": [\n    "if",\n    "else",\n    "for",\n    "while",\n    "do",\n    "switch",\n    "return",\n    "try",\n    "catch"\n  ],\n  "requireSpaceBeforeBinaryOperators": [\n    "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=",\n    "&=", "|=", "^=",\n\n    "+", "-", "*", "/", "%", "<<", ">>", ">>>", "&",\n    "|", "^", "&&", "||", "===", "==", ">=",\n    "<=", "<", ">", "!=", "!=="\n  ],\n  "requireSpacesInFunctionExpression": {\n    "beforeOpeningCurlyBrace": true\n  },\n  "requireCamelCaseOrUpperCaseIdentifiers": true,\n  "requireDotNotation": { "allExcept": ["keywords"] },\n  "requireEarlyReturn": true,\n  "requireLineFeedAtFileEnd": true,\n  "requireSemicolons": true,\n  "requireSpaceAfterBinaryOperators": true,\n  "requireSpacesInConditionalExpression": true,\n  "requireSpaceBeforeObjectValues": true,\n  "requireSpaceBeforeBlockStatements": true,\n  "requireSpacesInForStatement": true,\n\n  "validateIndentation": 2,\n  "validateParameterSeparator": ", ",\n  "validateQuoteMarks": { "mark": "\'", "escape": true },\n\n  "disallowSpacesInAnonymousFunctionExpression": {\n    "beforeOpeningRoundBrace": true\n  },\n  "disallowSpacesInFunctionDeclaration": {\n    "beforeOpeningRoundBrace": true\n  },\n  "disallowSpacesInFunctionExpression": {\n    "beforeOpeningRoundBrace": true\n  },\n  "disallowKeywords": ["with"],\n  "disallowMixedSpacesAndTabs": true,\n  "disallowMultipleLineBreaks": true,\n  "disallowNewlineBeforeBlockStatements": true,\n  "disallowSpaceAfterObjectKeys": true,\n  "disallowSpaceAfterPrefixUnaryOperators": true,\n  "disallowSpacesInCallExpression": true,\n  "disallowSpacesInsideArrayBrackets": true,\n  "disallowSpacesInsideParentheses": true,\n  "disallowTrailingWhitespace": true,\n  "disallowUnusedVariables": true,\n\n  "jsDoc": {\n    "checkRedundantAccess": true,\n    "checkTypes": true,\n    "requireNewlineAfterDescription": true,\n    "requireParamDescription": true,\n    "requireParamTypes": true,\n    "requireReturnTypes": true\n  }\n}\n',
        language: 'text',
        size: 2369,
        tokens: 141,
        lastModified: '2025-07-02T12:28:22.820Z',
      },
      {
        name: '.markdown-doctest-setup.js',
        path: '.markdown-doctest-setup.js',
        type: 'file',
        content:
          "'use strict';\n\ndelete global['__core-js_shared__'];\n\nconst _ = require('./lodash.js');\nconst globals = require('lodash-doc-globals');\n\nmodule.exports = {\n  'babel': false,\n  'globals': _.assign({ '_': _ }, globals)\n};\n",
        language: 'javascript',
        size: 218,
        tokens: 27,
        lastModified: '2025-07-02T12:28:22.821Z',
      },
      {
        name: '.travis.yml',
        path: '.travis.yml',
        type: 'file',
        content:
          'language: node_js\nsudo: false\nnode_js:\n  - 7\n\naddons:\n  jwt:\n    secure: OYhRpW+8A0Iik+9GmHwa45ZwXeBXw/6zh6I+1w2H9g/LqPRp+Nhq3f4FSpvrrfno8lO8W4h+7s6+JOzF8C8NxNda5UUygKjF9pUphgiQdqls3YZMJlC9zXVl7gQXAHi3nG1s8vWSpwpzYD9fqczE1FX9n0+R63qX3eB6C/LbPeI=\n\ncache:\n  directories:\n    - ~/.npm\n    - ~/.yarn-cache\n    - travis_phantomjs\n\nenv:\n  global:\n    - BIN=node ISTANBUL=false OPTION=""\n    - SAUCE_LABS=false SAUCE_USERNAME=lodash\n\n  matrix:\n    -\n    - BIN=phantomjs\n    - ISTANBUL=true\n    - SAUCE_LABS=true\n\nmatrix:\n  include:\n    - node_js: 6\n      env:\n\ngit:\n  depth: 10\n\nbranches:\n  only:\n    - master\n    - 4.17\n\nnotifications:\n  webhooks:\n    urls:\n      - https://webhooks.gitter.im/e/4aab6358b0e9aed0b628\n    on_success: change\n    on_failure: always\n\nbefore_install:\n  # Upgrade PhantomJS.\n  - |\n      export PHANTOMJS_VERSION=2.1.1\n      export PATH=$PWD/travis_phantomjs/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/bin:$PATH\n      if [ $(phantomjs --version) != $PHANTOMJS_VERSION ]; then\n        rm -rf $PWD/travis_phantomjs\n        mkdir -p $PWD/travis_phantomjs\n        wget https://github.com/Medium/phantomjs/releases/download/v$PHANTOMJS_VERSION/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2\n        tar -xvf phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C $PWD/travis_phantomjs\n      fi\n      phantomjs -v\n\n  # Use exact Node version.\n  - nvm use $TRAVIS_NODE_VERSION\n\n  # Setup package managers.\n  - npm set loglevel error\n  - npm set progress false\n  - npm i -g yarn@0.16.1\n  - yarn -V\n\n  # Remove code skipped on the coverage run.\n  - |\n      PATTERN[0]="|\\s*while\\s*\\([^)]+\\)\\s*\\{\\s*iteratee\\(index\\);\\s*\\}|"\n      PATTERN[1]="|\\bindex,\\s*iterable\\)\\s*===\\s*false\\)[^}]+?(break;)|"\n      PATTERN[2]="|\\bcase\\s+(?:dataView|promise|set|map|weakMap)CtorString:.+|g"\n      PATTERN[3]="|\\s*if\\s*\\(cache\\.size\\b[\\s\\S]+?\\}|"\n      PATTERN[4]="|\\s*if\\s*\\(\\!lodashFunc\\)\\s*\\{\\s*return;\\s*\\}|"\n      PATTERN[5]="|\\s*define\\([\\s\\S]+?\\);|"\n      PATTERN[6]="|\\s*root\\._\\s*=\\s*_;|"\n\n      if [ $ISTANBUL = true ]; then\n        set -e\n        for PTRN in ${PATTERN[@]}; do\n          node ./test/remove.js $PTRN ./lodash.js\n        done\n      fi\n\ninstall:\n  # Install packages.\n  - yarn\n\n  # Use lodash-cli from GitHub. Temporarily use a fork.\n  - git clone --depth=10 --branch=master git://github.com/bnjmnt4n/lodash-cli ./node_modules/lodash-cli\n  - cd ./node_modules/lodash-cli/; npm i --production; cd ../../\n  - mkdir -p ./node_modules/lodash-cli/node_modules/lodash; cd $_; cp ../../../../lodash.js ./lodash.js; cp ../../../../package.json ./package.json; cd ../../../../\n\nscript:\n  # Detect code coverage.\n  - |\n      if [ $ISTANBUL = true ]; then\n        istanbul cover -x "**/vendor/**" --report lcovonly ./test/test.js -- ./lodash.js\n        if [ $TRAVIS_SECURE_ENV_VARS = true ]; then\n          cat ./coverage/lcov.info | coveralls\n          cat ./coverage/coverage.json | codecov\n        fi\n      fi\n\n  # Test in Node.js and PhantomJS.\n  - |\n      if [ $ISTANBUL = false ]; then\n        node ./node_modules/lodash-cli/bin/lodash -o ./dist/lodash.js\n        node ./node_modules/lodash-cli/bin/lodash modularize exports=node -o ./\n        node ./node_modules/lodash-cli/bin/lodash -d -o ./lodash.js\n        if [ $SAUCE_LABS = false ]; then\n          cd ./test\n          $BIN $OPTION ./test.js ../lodash.js\n          if [ $TRAVIS_SECURE_ENV_VARS = true ]; then\n            $BIN $OPTION ./test.js ../dist/lodash.min.js\n          fi\n        fi\n      fi\n\n  # Test in Sauce Labs.\n  - |\n      if [ $SAUCE_LABS = true ]; then\n        node ./node_modules/lodash-cli/bin/lodash core -o ./dist/lodash.core.js\n        npm run build\n        $BIN ./test/saucelabs.js name="lodash tests"     runner="test/index.html?build=../dist/lodash.js&noglobals=true"     tags=development\n        $BIN ./test/saucelabs.js name="lodash tests"     runner="test/index.html?build=../dist/lodash.min.js&noglobals=true" tags=production\n        $BIN ./test/saucelabs.js name="lodash-fp tests"  runner="test/fp.html?noglobals=true"                                tags=development\n        $BIN ./test/saucelabs.js name="underscore tests" runner="test/underscore.html?build=../dist/lodash.js"               tags=development,underscore\n        $BIN ./test/saucelabs.js name="underscore tests" runner="test/underscore.html?build=../dist/lodash.min.js"           tags=production,underscore\n        $BIN ./test/saucelabs.js name="backbone tests"   runner="test/backbone.html?build=../dist/lodash.js"                 tags=development,backbone\n        $BIN ./test/saucelabs.js name="backbone tests"   runner="test/backbone.html?build=../dist/lodash.min.js"             tags=production,backbone\n        $BIN ./test/saucelabs.js name="backbone tests"   runner="test/backbone.html?build=../dist/lodash.core.js"            tags=development,backbone\n        $BIN ./test/saucelabs.js name="backbone tests"   runner="test/backbone.html?build=../dist/lodash.core.min.js"        tags=production,backbone\n      fi\n',
        language: 'yaml',
        size: 4983,
        tokens: 649,
        lastModified: '2025-07-02T12:28:22.821Z',
      },
      {
        name: 'lodash.js',
        path: 'lodash.js',
        type: 'file',
        content:
          "/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.21';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function',\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Used to validate the `validate` option in `_.template` variable.\n   *\n   * Forbids characters which could potentially change the meaning of the function argument definition:\n   * - \"(),\" (modification of function parameters)\n   * - \"=\" (default value)\n   * - \"[]{}\" (destructuring of function parameters)\n   * - \"/\" (beginning of a comment)\n   * - whitespace\n   */\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Throw an error if a forbidden character was found in `variable`, to prevent\n      // potential command injection attacks.\n      else if (reForbiddenIdentifierChars.test(variable)) {\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\n      }\n\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return baseTrim(string);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.slice(0, trimmedEndIndex(string) + 1);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n",
        language: 'javascript',
        size: 544098,
        tokens: 61499,
        lastModified: '2025-07-02T12:28:22.843Z',
      },
      {
        name: 'package.json',
        path: 'package.json',
        type: 'file',
        content:
          '{\n  "name": "lodash",\n  "version": "4.17.21",\n  "license": "MIT",\n  "private": true,\n  "main": "lodash.js",\n  "engines": {\n    "node": ">=4.0.0"\n  },\n  "scripts": {\n    "build": "npm run build:main && npm run build:fp",\n    "build:fp": "node lib/fp/build-dist.js",\n    "build:fp-modules": "node lib/fp/build-modules.js",\n    "build:main": "node lib/main/build-dist.js",\n    "build:main-modules": "node lib/main/build-modules.js",\n    "doc": "node lib/main/build-doc github && npm run test:doc",\n    "doc:fp": "node lib/fp/build-doc",\n    "doc:site": "node lib/main/build-doc site",\n    "doc:sitehtml": "optional-dev-dependency marky-markdown@^9.0.1 && npm run doc:site && node lib/main/build-site",\n    "pretest": "npm run build",\n    "style": "npm run style:main && npm run style:fp && npm run style:perf && npm run style:test",\n    "style:fp": "jscs fp/*.js lib/**/*.js",\n    "style:main": "jscs lodash.js",\n    "style:perf": "jscs perf/*.js perf/**/*.js",\n    "style:test": "jscs test/*.js test/**/*.js",\n    "test": "npm run test:main && npm run test:fp",\n    "test:doc": "markdown-doctest doc/*.md",\n    "test:fp": "node test/test-fp",\n    "test:main": "node test/test",\n    "validate": "npm run style && npm run test"\n  },\n  "devDependencies": {\n    "async": "^2.6.3",\n    "benchmark": "^2.1.3",\n    "chalk": "^1.1.3",\n    "cheerio": "^0.22.0",\n    "codecov.io": "~0.1.6",\n    "coveralls": "^2.11.15",\n    "curl-amd": "~0.8.12",\n    "docdown": "~0.7.2",\n    "dojo": "^1.15.0",\n    "ecstatic": "^2.2.2",\n    "fs-extra": "~1.0.0",\n    "glob": "^7.1.4",\n    "istanbul": "0.4.5",\n    "jquery": "^3.4.1",\n    "jscs": "^3.0.7",\n    "lodash": "4.17.20",\n    "lodash-doc-globals": "^0.1.1",\n    "markdown-doctest": "^0.9.1",\n    "optional-dev-dependency": "^2.0.0",\n    "platform": "^1.3.3",\n    "qunit-extras": "^3.0.0",\n    "qunitjs": "^2.1.0",\n    "request": "^2.88.0",\n    "requirejs": "^2.3.6",\n    "sauce-tunnel": "^2.5.0",\n    "uglify-js": "2.7.5",\n    "webpack": "^1.14.0"\n  },\n  "greenkeeper": {\n    "ignore": [\n      "lodash"\n    ]\n  }\n}\n',
        language: 'json',
        size: 2046,
        tokens: 310,
        lastModified: '2025-07-02T12:28:22.845Z',
      },
      {
        name: 'SECURITY.md',
        path: 'SECURITY.md',
        type: 'file',
        content:
          '# Security Policy\n\n## Supported versions\n\nThe following table describes the versions of this project that are currently\nsupported with security updates:\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 4.x   | :white_check_mark:   |\n| 3.x   | :x:                  |\n| 2.x   | :x:                  |\n| 1.x   | :x:                  |\n\n## Responsible disclosure security policy\n\nA responsible disclosure policy helps protect users of the project from publicly\ndisclosed security vulnerabilities without a fix by employing a process where\nvulnerabilities are first triaged in a private manner, and only publicly disclosed\nafter a reasonable time period that allows patching the vulnerability and provides\nan upgrade path for users.\n\nWe kindly ask you to refrain from malicious acts that put our users, the project,\nor any of the project’s team members at risk.\n\n## Reporting a security issue\n\nWe consider the security of Lodash a top priority. But no matter how much effort\nwe put into security, there can still be vulnerabilities present.\n\nIf you discover a security vulnerability, please report the security issue\ndirectly to the Lodash maintainers through the [Security tab](https://github.com/lodash/lodash/security) of the Lodash\nrepository.\n\nYour efforts to responsibly disclose your findings are sincerely appreciated.\n',
        language: 'markdown',
        size: 1344,
        tokens: 204,
        lastModified: '2025-07-02T12:28:22.824Z',
      },
    ],
  },
  metadata: {
    totalFiles: 71,
    totalSize: 3203402,
    totalTokens: 350952,
    fetchedAt: '2025-07-02T12:28:55.998Z',
    source: 'https://github.com/lodash/lodash',
    gitProvider: 'github',
    gitOwner: 'lodash',
    gitRepo: 'lodash',
    gitRef: 'main',
  },
};
